'use strict';

var crypto2 = require('crypto');
var jose = require('jose');
var fs19 = require('fs');
var eventemitter3 = require('eventemitter3');
var path2 = require('path');
var TurndownService = require('turndown');
var readability = require('@mozilla/readability');
var os2 = require('os');
var OpenAI3 = require('openai');
var Anthropic = require('@anthropic-ai/sdk');
var genai = require('@google/genai');
require('zod/v3');
var z4mini = require('zod/v4-mini');
var z = require('zod/v4');
var spawn = require('cross-spawn');
var process2 = require('process');
var stream = require('stream');
var fs18 = require('fs/promises');
var simpleIcons = require('simple-icons');
var child_process = require('child_process');
var util = require('util');
var cheerio = require('cheerio');
var vm = require('vm');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var crypto2__namespace = /*#__PURE__*/_interopNamespace(crypto2);
var fs19__namespace = /*#__PURE__*/_interopNamespace(fs19);
var path2__namespace = /*#__PURE__*/_interopNamespace(path2);
var TurndownService__default = /*#__PURE__*/_interopDefault(TurndownService);
var os2__namespace = /*#__PURE__*/_interopNamespace(os2);
var OpenAI3__default = /*#__PURE__*/_interopDefault(OpenAI3);
var Anthropic__default = /*#__PURE__*/_interopDefault(Anthropic);
var z4mini__namespace = /*#__PURE__*/_interopNamespace(z4mini);
var z__namespace = /*#__PURE__*/_interopNamespace(z);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var process2__default = /*#__PURE__*/_interopDefault(process2);
var fs18__namespace = /*#__PURE__*/_interopNamespace(fs18);
var simpleIcons__namespace = /*#__PURE__*/_interopNamespace(simpleIcons);
var vm__namespace = /*#__PURE__*/_interopNamespace(vm);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
function encrypt(text, password) {
  const salt = crypto2__namespace.randomBytes(SALT_LENGTH);
  const key = crypto2__namespace.pbkdf2Sync(password, salt, 1e5, KEY_LENGTH, "sha512");
  const iv = crypto2__namespace.randomBytes(IV_LENGTH);
  const cipher = crypto2__namespace.createCipheriv(ALGORITHM, key, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  const tag = cipher.getAuthTag();
  const result = Buffer.concat([salt, iv, tag, Buffer.from(encrypted, "hex")]);
  return result.toString("base64");
}
function decrypt(encryptedData, password) {
  const buffer = Buffer.from(encryptedData, "base64");
  const salt = buffer.subarray(0, SALT_LENGTH);
  const iv = buffer.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const tag = buffer.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  const encrypted = buffer.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  const key = crypto2__namespace.pbkdf2Sync(password, salt, 1e5, KEY_LENGTH, "sha512");
  const decipher = crypto2__namespace.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(tag);
  let decrypted = decipher.update(encrypted);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString("utf8");
}
function getEncryptionKey() {
  if (process.env.OAUTH_ENCRYPTION_KEY) {
    return process.env.OAUTH_ENCRYPTION_KEY;
  }
  if (!global.__oauthEncryptionKey) {
    global.__oauthEncryptionKey = crypto2__namespace.randomBytes(32).toString("hex");
    console.warn(
      "WARNING: Using auto-generated encryption key. Tokens will not persist across restarts. Set OAUTH_ENCRYPTION_KEY environment variable for production!"
    );
  }
  return global.__oauthEncryptionKey;
}
function generateEncryptionKey() {
  return crypto2__namespace.randomBytes(32).toString("hex");
}
var ALGORITHM, IV_LENGTH, SALT_LENGTH, TAG_LENGTH, KEY_LENGTH;
var init_encryption = __esm({
  "src/connectors/oauth/utils/encryption.ts"() {
    ALGORITHM = "aes-256-gcm";
    IV_LENGTH = 16;
    SALT_LENGTH = 64;
    TAG_LENGTH = 16;
    KEY_LENGTH = 32;
  }
});

// src/connectors/oauth/infrastructure/storage/MemoryStorage.ts
exports.MemoryStorage = void 0;
var init_MemoryStorage = __esm({
  "src/connectors/oauth/infrastructure/storage/MemoryStorage.ts"() {
    init_encryption();
    exports.MemoryStorage = class {
      tokens = /* @__PURE__ */ new Map();
      // Stores encrypted tokens
      async storeToken(key, token) {
        const encryptionKey = getEncryptionKey();
        const plaintext = JSON.stringify(token);
        const encrypted = encrypt(plaintext, encryptionKey);
        this.tokens.set(key, encrypted);
      }
      async getToken(key) {
        const encrypted = this.tokens.get(key);
        if (!encrypted) {
          return null;
        }
        try {
          const encryptionKey = getEncryptionKey();
          const decrypted = decrypt(encrypted, encryptionKey);
          return JSON.parse(decrypted);
        } catch (error) {
          console.error("Failed to decrypt token from memory:", error);
          this.tokens.delete(key);
          return null;
        }
      }
      async deleteToken(key) {
        this.tokens.delete(key);
      }
      async hasToken(key) {
        return this.tokens.has(key);
      }
      /**
       * Clear all tokens (useful for testing)
       */
      clearAll() {
        this.tokens.clear();
      }
      /**
       * Get number of stored tokens
       */
      size() {
        return this.tokens.size;
      }
    };
  }
});

// src/connectors/oauth/domain/TokenStore.ts
var TokenStore;
var init_TokenStore = __esm({
  "src/connectors/oauth/domain/TokenStore.ts"() {
    init_MemoryStorage();
    TokenStore = class {
      storage;
      baseStorageKey;
      constructor(storageKey = "default", storage) {
        this.baseStorageKey = storageKey;
        this.storage = storage || new exports.MemoryStorage();
      }
      /**
       * Get user-scoped storage key
       * For multi-user support, keys are scoped per user: "provider:userId"
       * For single-user (backward compatible), userId is omitted or "default"
       *
       * @param userId - User identifier (optional, defaults to single-user mode)
       * @returns Storage key scoped to user
       */
      getScopedKey(userId) {
        if (!userId || userId === "default") {
          return this.baseStorageKey;
        }
        return `${this.baseStorageKey}:${userId}`;
      }
      /**
       * Store token (encrypted by storage layer)
       * @param tokenResponse - Token response from OAuth provider
       * @param userId - Optional user identifier for multi-user support
       */
      async storeToken(tokenResponse, userId) {
        if (!tokenResponse.access_token) {
          throw new Error("OAuth response missing required access_token field");
        }
        if (typeof tokenResponse.access_token !== "string") {
          throw new Error("access_token must be a string");
        }
        if (tokenResponse.expires_in !== void 0 && tokenResponse.expires_in < 0) {
          throw new Error("expires_in must be positive");
        }
        const token = {
          access_token: tokenResponse.access_token,
          refresh_token: tokenResponse.refresh_token,
          expires_in: tokenResponse.expires_in || 3600,
          token_type: tokenResponse.token_type || "Bearer",
          scope: tokenResponse.scope,
          obtained_at: Date.now()
        };
        const key = this.getScopedKey(userId);
        await this.storage.storeToken(key, token);
      }
      /**
       * Get access token
       * @param userId - Optional user identifier for multi-user support
       */
      async getAccessToken(userId) {
        const key = this.getScopedKey(userId);
        const token = await this.storage.getToken(key);
        if (!token) {
          throw new Error(`No token stored for ${userId ? `user: ${userId}` : "default user"}`);
        }
        return token.access_token;
      }
      /**
       * Get refresh token
       * @param userId - Optional user identifier for multi-user support
       */
      async getRefreshToken(userId) {
        const key = this.getScopedKey(userId);
        const token = await this.storage.getToken(key);
        if (!token?.refresh_token) {
          throw new Error(`No refresh token available for ${userId ? `user: ${userId}` : "default user"}`);
        }
        return token.refresh_token;
      }
      /**
       * Check if has refresh token
       * @param userId - Optional user identifier for multi-user support
       */
      async hasRefreshToken(userId) {
        const key = this.getScopedKey(userId);
        const token = await this.storage.getToken(key);
        return !!token?.refresh_token;
      }
      /**
       * Check if token is valid (not expired)
       *
       * @param bufferSeconds - Refresh this many seconds before expiry (default: 300 = 5 min)
       * @param userId - Optional user identifier for multi-user support
       */
      async isValid(bufferSeconds = 300, userId) {
        const key = this.getScopedKey(userId);
        const token = await this.storage.getToken(key);
        if (!token) {
          return false;
        }
        const expiresAt = token.obtained_at + token.expires_in * 1e3;
        const bufferMs = bufferSeconds * 1e3;
        return Date.now() < expiresAt - bufferMs;
      }
      /**
       * Clear stored token
       * @param userId - Optional user identifier for multi-user support
       */
      async clear(userId) {
        const key = this.getScopedKey(userId);
        await this.storage.deleteToken(key);
      }
      /**
       * Get full token info
       * @param userId - Optional user identifier for multi-user support
       */
      async getTokenInfo(userId) {
        const key = this.getScopedKey(userId);
        return this.storage.getToken(key);
      }
    };
  }
});
function generatePKCE() {
  const codeVerifier = base64URLEncode(crypto2__namespace.randomBytes(32));
  const hash = crypto2__namespace.createHash("sha256").update(codeVerifier).digest();
  const codeChallenge = base64URLEncode(hash);
  return {
    codeVerifier,
    codeChallenge
  };
}
function base64URLEncode(buffer) {
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function generateState() {
  return crypto2__namespace.randomBytes(16).toString("hex");
}
var init_pkce = __esm({
  "src/connectors/oauth/utils/pkce.ts"() {
  }
});

// src/connectors/oauth/flows/AuthCodePKCE.ts
function isPublicClientError(responseBody) {
  const lower = responseBody.toLowerCase();
  return lower.includes("aadsts700025") || lower.includes("invalid_client") && lower.includes("public");
}
var AuthCodePKCEFlow;
var init_AuthCodePKCE = __esm({
  "src/connectors/oauth/flows/AuthCodePKCE.ts"() {
    init_TokenStore();
    init_pkce();
    AuthCodePKCEFlow = class {
      constructor(config) {
        this.config = config;
        const storageKey = config.storageKey || `auth_code:${config.clientId}`;
        this.tokenStore = new TokenStore(storageKey, config.storage);
      }
      tokenStore;
      // Store PKCE data per user with timestamps for cleanup
      codeVerifiers = /* @__PURE__ */ new Map();
      states = /* @__PURE__ */ new Map();
      // Store refresh locks per user to prevent concurrent refresh
      refreshLocks = /* @__PURE__ */ new Map();
      // PKCE data TTL: 15 minutes (auth flows should complete within this time)
      PKCE_TTL = 15 * 60 * 1e3;
      /**
       * Generate authorization URL for user to visit
       * Opens browser or redirects user to this URL
       *
       * @param userId - User identifier for multi-user support (optional)
       */
      async getAuthorizationUrl(userId) {
        if (!this.config.authorizationUrl) {
          throw new Error("authorizationUrl is required for authorization_code flow");
        }
        if (!this.config.redirectUri) {
          throw new Error("redirectUri is required for authorization_code flow");
        }
        this.cleanupExpiredPKCE();
        const userKey = userId || "default";
        const { codeVerifier, codeChallenge } = generatePKCE();
        this.codeVerifiers.set(userKey, { verifier: codeVerifier, timestamp: Date.now() });
        const state = generateState();
        this.states.set(userKey, { state, timestamp: Date.now() });
        const params = new URLSearchParams({
          response_type: "code",
          client_id: this.config.clientId,
          redirect_uri: this.config.redirectUri,
          state
        });
        if (this.config.scope) {
          params.append("scope", this.config.scope);
        }
        if (this.config.usePKCE !== false) {
          params.append("code_challenge", codeChallenge);
          params.append("code_challenge_method", "S256");
        }
        const stateWithUser = userId ? `${state}::${userId}` : state;
        params.set("state", stateWithUser);
        return `${this.config.authorizationUrl}?${params.toString()}`;
      }
      /**
       * Exchange authorization code for access token
       *
       * @param code - Authorization code from callback
       * @param state - State parameter from callback (for CSRF verification, may include userId)
       * @param userId - User identifier (optional, can be extracted from state)
       */
      async exchangeCode(code, state, userId) {
        let actualState = state;
        let actualUserId = userId;
        if (state.includes("::")) {
          const parts = state.split("::");
          actualState = parts[0];
          actualUserId = parts[1];
        }
        const userKey = actualUserId || "default";
        const stateData = this.states.get(userKey);
        if (!stateData) {
          throw new Error(`No PKCE state found for user ${actualUserId}. Authorization flow may have expired (15 min TTL).`);
        }
        const expectedState = stateData.state;
        if (actualState !== expectedState) {
          throw new Error(`State mismatch for user ${actualUserId} - possible CSRF attack. Expected: ${expectedState}, Got: ${actualState}`);
        }
        if (!this.config.redirectUri) {
          throw new Error("redirectUri is required");
        }
        const params = new URLSearchParams({
          grant_type: "authorization_code",
          code,
          redirect_uri: this.config.redirectUri,
          client_id: this.config.clientId
        });
        if (this.config.clientSecret) {
          params.append("client_secret", this.config.clientSecret);
        }
        const verifierData = this.codeVerifiers.get(userKey);
        if (this.config.usePKCE !== false && verifierData) {
          params.append("code_verifier", verifierData.verifier);
        }
        let response = await fetch(this.config.tokenUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: params
        });
        if (!response.ok && this.config.clientSecret) {
          const errorText = await response.text();
          if (isPublicClientError(errorText)) {
            params.delete("client_secret");
            response = await fetch(this.config.tokenUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: params
            });
            if (!response.ok) {
              const retryError = await response.text();
              throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${retryError}`);
            }
          } else {
            throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${errorText}`);
          }
        } else if (!response.ok) {
          const error = await response.text();
          throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${error}`);
        }
        const data = await response.json();
        await this.tokenStore.storeToken(data, actualUserId);
        this.codeVerifiers.delete(userKey);
        this.states.delete(userKey);
      }
      /**
       * Get valid token (auto-refreshes if needed)
       * @param userId - User identifier for multi-user support
       */
      async getToken(userId) {
        const key = userId || "default";
        if (this.refreshLocks.has(key)) {
          return this.refreshLocks.get(key);
        }
        if (await this.tokenStore.isValid(this.config.refreshBeforeExpiry, userId)) {
          return this.tokenStore.getAccessToken(userId);
        }
        if (await this.tokenStore.hasRefreshToken(userId)) {
          const refreshPromise = this.refreshToken(userId);
          this.refreshLocks.set(key, refreshPromise);
          try {
            return await refreshPromise;
          } finally {
            this.refreshLocks.delete(key);
          }
        }
        throw new Error(`No valid token available for ${userId ? `user: ${userId}` : "default user"}. User needs to authorize (call startAuthFlow).`);
      }
      /**
       * Refresh access token using refresh token
       * @param userId - User identifier for multi-user support
       */
      async refreshToken(userId) {
        const refreshToken = await this.tokenStore.getRefreshToken(userId);
        const params = new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: refreshToken,
          client_id: this.config.clientId
        });
        if (this.config.clientSecret) {
          params.append("client_secret", this.config.clientSecret);
        }
        let response = await fetch(this.config.tokenUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: params
        });
        if (!response.ok && this.config.clientSecret) {
          const errorText = await response.text();
          if (isPublicClientError(errorText)) {
            params.delete("client_secret");
            response = await fetch(this.config.tokenUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: params
            });
            if (!response.ok) {
              const retryError = await response.text();
              throw new Error(`Token refresh failed: ${response.status} ${response.statusText} - ${retryError}`);
            }
          } else {
            throw new Error(`Token refresh failed: ${response.status} ${response.statusText} - ${errorText}`);
          }
        } else if (!response.ok) {
          const error = await response.text();
          throw new Error(`Token refresh failed: ${response.status} ${response.statusText} - ${error}`);
        }
        const data = await response.json();
        await this.tokenStore.storeToken(data, userId);
        return data.access_token;
      }
      /**
       * Check if token is valid
       * @param userId - User identifier for multi-user support
       */
      async isTokenValid(userId) {
        return this.tokenStore.isValid(this.config.refreshBeforeExpiry, userId);
      }
      /**
       * Revoke token (if supported by provider)
       * @param revocationUrl - Optional revocation endpoint
       * @param userId - User identifier for multi-user support
       */
      async revokeToken(revocationUrl, userId) {
        if (!revocationUrl) {
          await this.tokenStore.clear(userId);
          return;
        }
        try {
          const token = await this.tokenStore.getAccessToken(userId);
          await fetch(revocationUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded"
            },
            body: new URLSearchParams({
              token,
              client_id: this.config.clientId
            })
          });
        } finally {
          await this.tokenStore.clear(userId);
        }
      }
      /**
       * Clean up expired PKCE data to prevent memory leaks
       * Removes verifiers and states older than PKCE_TTL (15 minutes)
       */
      cleanupExpiredPKCE() {
        const now = Date.now();
        for (const [key, data] of this.codeVerifiers) {
          if (now - data.timestamp > this.PKCE_TTL) {
            this.codeVerifiers.delete(key);
            this.states.delete(key);
          }
        }
      }
    };
  }
});

// src/connectors/oauth/flows/ClientCredentials.ts
var ClientCredentialsFlow;
var init_ClientCredentials = __esm({
  "src/connectors/oauth/flows/ClientCredentials.ts"() {
    init_TokenStore();
    ClientCredentialsFlow = class {
      constructor(config) {
        this.config = config;
        const storageKey = config.storageKey || `client_credentials:${config.clientId}`;
        this.tokenStore = new TokenStore(storageKey, config.storage);
      }
      tokenStore;
      /**
       * Get token using client credentials
       */
      async getToken() {
        if (await this.tokenStore.isValid(this.config.refreshBeforeExpiry)) {
          return this.tokenStore.getAccessToken();
        }
        return this.requestToken();
      }
      /**
       * Request a new token from the authorization server
       */
      async requestToken() {
        const auth2 = Buffer.from(`${this.config.clientId}:${this.config.clientSecret}`).toString(
          "base64"
        );
        const params = new URLSearchParams({
          grant_type: "client_credentials"
        });
        if (this.config.scope) {
          params.append("scope", this.config.scope);
        }
        const response = await fetch(this.config.tokenUrl, {
          method: "POST",
          headers: {
            Authorization: `Basic ${auth2}`,
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: params
        });
        if (!response.ok) {
          const error = await response.text();
          throw new Error(`Token request failed: ${response.status} ${response.statusText} - ${error}`);
        }
        const data = await response.json();
        await this.tokenStore.storeToken(data);
        return data.access_token;
      }
      /**
       * Refresh token (client credentials don't use refresh tokens)
       * Just requests a new token
       */
      async refreshToken() {
        await this.tokenStore.clear();
        return this.requestToken();
      }
      /**
       * Check if token is valid
       */
      async isTokenValid() {
        return this.tokenStore.isValid(this.config.refreshBeforeExpiry);
      }
    };
  }
});
var JWTBearerFlow;
var init_JWTBearer = __esm({
  "src/connectors/oauth/flows/JWTBearer.ts"() {
    init_TokenStore();
    JWTBearerFlow = class {
      constructor(config) {
        this.config = config;
        const storageKey = config.storageKey || `jwt_bearer:${config.clientId}`;
        this.tokenStore = new TokenStore(storageKey, config.storage);
        if (config.privateKey) {
          this.privateKey = config.privateKey;
        } else if (config.privateKeyPath) {
          try {
            this.privateKey = fs19__namespace.readFileSync(config.privateKeyPath, "utf8");
          } catch (error) {
            throw new Error(`Failed to read private key from ${config.privateKeyPath}: ${error.message}`);
          }
        } else {
          throw new Error("JWT Bearer flow requires privateKey or privateKeyPath");
        }
      }
      tokenStore;
      privateKey;
      /**
       * Generate signed JWT assertion
       */
      async generateJWT() {
        const now = Math.floor(Date.now() / 1e3);
        const alg = this.config.tokenSigningAlg || "RS256";
        const key = await jose.importPKCS8(this.privateKey, alg);
        const jwt = await new jose.SignJWT({
          scope: this.config.scope || ""
        }).setProtectedHeader({ alg }).setIssuer(this.config.clientId).setSubject(this.config.clientId).setAudience(this.config.audience || this.config.tokenUrl).setIssuedAt(now).setExpirationTime(now + 3600).sign(key);
        return jwt;
      }
      /**
       * Get token using JWT Bearer assertion
       */
      async getToken() {
        if (await this.tokenStore.isValid(this.config.refreshBeforeExpiry)) {
          return this.tokenStore.getAccessToken();
        }
        return this.requestToken();
      }
      /**
       * Request token using JWT assertion
       */
      async requestToken() {
        const assertion = await this.generateJWT();
        const params = new URLSearchParams({
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion
        });
        const response = await fetch(this.config.tokenUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: params
        });
        if (!response.ok) {
          const error = await response.text();
          throw new Error(`JWT Bearer token request failed: ${response.status} ${response.statusText} - ${error}`);
        }
        const data = await response.json();
        await this.tokenStore.storeToken(data);
        return data.access_token;
      }
      /**
       * Refresh token (generate new JWT and request new token)
       */
      async refreshToken() {
        await this.tokenStore.clear();
        return this.requestToken();
      }
      /**
       * Check if token is valid
       */
      async isTokenValid() {
        return this.tokenStore.isValid(this.config.refreshBeforeExpiry);
      }
    };
  }
});

// src/connectors/oauth/flows/StaticToken.ts
var StaticTokenFlow;
var init_StaticToken = __esm({
  "src/connectors/oauth/flows/StaticToken.ts"() {
    StaticTokenFlow = class {
      token;
      constructor(config) {
        if (!config.staticToken) {
          throw new Error("Static token flow requires staticToken in config");
        }
        this.token = config.staticToken;
      }
      /**
       * Get token (always returns the static token)
       */
      async getToken() {
        return this.token;
      }
      /**
       * Refresh token (no-op for static tokens)
       */
      async refreshToken() {
        return this.token;
      }
      /**
       * Token is always valid for static tokens
       */
      async isTokenValid() {
        return true;
      }
      /**
       * Update the static token
       */
      updateToken(newToken) {
        this.token = newToken;
      }
    };
  }
});

// src/connectors/oauth/OAuthManager.ts
exports.OAuthManager = void 0;
var init_OAuthManager = __esm({
  "src/connectors/oauth/OAuthManager.ts"() {
    init_AuthCodePKCE();
    init_ClientCredentials();
    init_JWTBearer();
    init_StaticToken();
    exports.OAuthManager = class {
      flow;
      constructor(config) {
        this.validateConfig(config);
        switch (config.flow) {
          case "authorization_code":
            this.flow = new AuthCodePKCEFlow(config);
            break;
          case "client_credentials":
            this.flow = new ClientCredentialsFlow(config);
            break;
          case "jwt_bearer":
            this.flow = new JWTBearerFlow(config);
            break;
          case "static_token":
            this.flow = new StaticTokenFlow(config);
            break;
          default:
            throw new Error(`Unknown OAuth flow: ${config.flow}`);
        }
      }
      /**
       * Get valid access token
       * Automatically refreshes if expired
       *
       * @param userId - User identifier for multi-user support (optional)
       */
      async getToken(userId) {
        return this.flow.getToken(userId);
      }
      /**
       * Force refresh the token
       *
       * @param userId - User identifier for multi-user support (optional)
       */
      async refreshToken(userId) {
        return this.flow.refreshToken(userId);
      }
      /**
       * Check if current token is valid
       *
       * @param userId - User identifier for multi-user support (optional)
       */
      async isTokenValid(userId) {
        return this.flow.isTokenValid(userId);
      }
      // ==================== Authorization Code Flow Methods ====================
      /**
       * Start authorization flow (Authorization Code only)
       * Returns URL for user to visit
       *
       * @param userId - User identifier for multi-user support (optional)
       * @returns Authorization URL for the user to visit
       */
      async startAuthFlow(userId) {
        if (!(this.flow instanceof AuthCodePKCEFlow)) {
          throw new Error("startAuthFlow() is only available for authorization_code flow");
        }
        return this.flow.getAuthorizationUrl(userId);
      }
      /**
       * Handle OAuth callback (Authorization Code only)
       * Call this with the callback URL after user authorizes
       *
       * @param callbackUrl - Full callback URL with code and state parameters
       * @param userId - Optional user identifier (can be extracted from state if embedded)
       */
      async handleCallback(callbackUrl, userId) {
        if (!(this.flow instanceof AuthCodePKCEFlow)) {
          throw new Error("handleCallback() is only available for authorization_code flow");
        }
        const url2 = new URL(callbackUrl);
        const code = url2.searchParams.get("code");
        const state = url2.searchParams.get("state");
        if (!code) {
          throw new Error("Missing authorization code in callback URL");
        }
        if (!state) {
          throw new Error("Missing state parameter in callback URL");
        }
        await this.flow.exchangeCode(code, state, userId);
      }
      /**
       * Revoke token (if supported by provider)
       *
       * @param revocationUrl - Optional revocation endpoint URL
       * @param userId - User identifier for multi-user support (optional)
       */
      async revokeToken(revocationUrl, userId) {
        if (this.flow instanceof AuthCodePKCEFlow) {
          await this.flow.revokeToken(revocationUrl, userId);
        } else {
          throw new Error("Token revocation not implemented for this flow");
        }
      }
      // ==================== Validation ====================
      validateConfig(config) {
        if (!config.flow) {
          throw new Error("OAuth flow is required (authorization_code, client_credentials, jwt_bearer, or static_token)");
        }
        if (config.flow !== "static_token") {
          if (!config.tokenUrl) {
            throw new Error("tokenUrl is required");
          }
          if (!config.clientId) {
            throw new Error("clientId is required");
          }
        }
        switch (config.flow) {
          case "authorization_code":
            if (!config.authorizationUrl) {
              throw new Error("authorizationUrl is required for authorization_code flow");
            }
            if (!config.redirectUri) {
              throw new Error("redirectUri is required for authorization_code flow");
            }
            break;
          case "client_credentials":
            if (!config.clientSecret) {
              throw new Error("clientSecret is required for client_credentials flow");
            }
            break;
          case "jwt_bearer":
            if (!config.privateKey && !config.privateKeyPath) {
              throw new Error(
                "privateKey or privateKeyPath is required for jwt_bearer flow"
              );
            }
            break;
          case "static_token":
            if (!config.staticToken) {
              throw new Error("staticToken is required for static_token flow");
            }
            break;
        }
        if (config.storage && !process.env.OAUTH_ENCRYPTION_KEY) {
          console.warn(
            "WARNING: Using persistent storage without OAUTH_ENCRYPTION_KEY environment variable. Tokens will be encrypted with auto-generated key that changes on restart!"
          );
        }
      }
    };
  }
});

// src/core/StorageRegistry.ts
exports.StorageRegistry = void 0;
var init_StorageRegistry = __esm({
  "src/core/StorageRegistry.ts"() {
    exports.StorageRegistry = class _StorageRegistry {
      /** Internal storage map */
      static entries = /* @__PURE__ */ new Map();
      /** Default context passed to all factory calls (set via setContext) */
      static _context;
      /**
       * Configure multiple storage backends at once.
       *
       * @example
       * ```typescript
       * // Single-tenant
       * StorageRegistry.configure({
       *   customTools: new MongoCustomToolStorage(),
       *   sessions: (agentId) => new RedisContextStorage(agentId),
       * });
       *
       * // Multi-tenant
       * StorageRegistry.configure({
       *   sessions: (agentId, ctx) => new TenantContextStorage(agentId, ctx?.tenantId),
       *   persistentInstructions: (agentId, ctx) => new TenantInstructionsStorage(agentId, ctx?.userId),
       * });
       * ```
       */
      static configure(config) {
        for (const [key, value] of Object.entries(config)) {
          if (value !== void 0) {
            _StorageRegistry.entries.set(key, value);
          }
        }
      }
      /**
       * Set the default StorageContext.
       *
       * This context is automatically passed to all per-agent factory calls
       * (sessions, persistentInstructions, workingMemory) when no explicit
       * context is provided. Typically set once at app startup with global
       * tenant/environment info, or per-request in multi-tenant servers.
       *
       * @example
       * ```typescript
       * // Single-tenant app — set once at init
       * StorageRegistry.setContext({ tenantId: 'acme', environment: 'production' });
       *
       * // Multi-tenant server — set per-request
       * app.use((req, res, next) => {
       *   StorageRegistry.setContext({ userId: req.user.id, tenantId: req.tenant.id });
       *   next();
       * });
       * ```
       */
      static setContext(context) {
        _StorageRegistry._context = context;
      }
      /**
       * Get the current default StorageContext.
       */
      static getContext() {
        return _StorageRegistry._context;
      }
      /**
       * Set a single storage backend.
       */
      static set(key, value) {
        _StorageRegistry.entries.set(key, value);
      }
      /**
       * Get a storage backend (or undefined if not configured).
       */
      static get(key) {
        return _StorageRegistry.entries.get(key);
      }
      /**
       * Resolve a storage backend, lazily creating and caching a default if needed.
       *
       * If a value has been configured via `set()` or `configure()`, returns that.
       * Otherwise, calls `defaultFactory()`, caches the result, and returns it.
       */
      static resolve(key, defaultFactory) {
        const existing = _StorageRegistry.entries.get(key);
        if (existing !== void 0) {
          return existing;
        }
        const value = defaultFactory();
        _StorageRegistry.entries.set(key, value);
        return value;
      }
      /**
       * Check if a storage backend has been configured.
       */
      static has(key) {
        return _StorageRegistry.entries.has(key);
      }
      /**
       * Clear all configured storage backends and context.
       * Useful for testing.
       */
      static reset() {
        _StorageRegistry.entries.clear();
        _StorageRegistry._context = void 0;
      }
    };
  }
});
exports.DEFAULT_CIRCUIT_BREAKER_CONFIG = void 0; exports.CircuitOpenError = void 0; exports.CircuitBreaker = void 0;
var init_CircuitBreaker = __esm({
  "src/infrastructure/resilience/CircuitBreaker.ts"() {
    exports.DEFAULT_CIRCUIT_BREAKER_CONFIG = {
      failureThreshold: 5,
      successThreshold: 2,
      resetTimeoutMs: 3e4,
      // 30 seconds
      windowMs: 6e4,
      // 1 minute
      isRetryable: () => true
      // All errors count by default
    };
    exports.CircuitOpenError = class extends Error {
      constructor(breakerName, nextRetryTime, failureCount, lastError) {
        const retryInSeconds = Math.ceil((nextRetryTime - Date.now()) / 1e3);
        super(
          `Circuit breaker '${breakerName}' is OPEN. Retry in ${retryInSeconds}s. (${failureCount} recent failures, last: ${lastError})`
        );
        this.breakerName = breakerName;
        this.nextRetryTime = nextRetryTime;
        this.failureCount = failureCount;
        this.lastError = lastError;
        this.name = "CircuitOpenError";
      }
    };
    exports.CircuitBreaker = class extends eventemitter3.EventEmitter {
      constructor(name, config = {}) {
        super();
        this.name = name;
        this.config = { ...exports.DEFAULT_CIRCUIT_BREAKER_CONFIG, ...config };
        this.lastStateChange = Date.now();
      }
      state = "closed";
      config;
      // Failure tracking
      failures = [];
      lastError = "";
      // Success tracking
      consecutiveSuccesses = 0;
      // Timing
      openedAt;
      lastStateChange;
      // Metrics
      totalRequests = 0;
      successCount = 0;
      failureCount = 0;
      rejectedCount = 0;
      lastFailureTime;
      lastSuccessTime;
      /**
       * Execute function with circuit breaker protection
       */
      async execute(fn) {
        this.totalRequests++;
        const now = Date.now();
        switch (this.state) {
          case "open":
            if (this.openedAt && now - this.openedAt >= this.config.resetTimeoutMs) {
              this.transitionTo("half-open");
            } else {
              this.rejectedCount++;
              const nextRetry = (this.openedAt || now) + this.config.resetTimeoutMs;
              throw new exports.CircuitOpenError(this.name, nextRetry, this.failures.length, this.lastError);
            }
            break;
        }
        try {
          const result = await fn();
          this.recordSuccess();
          return result;
        } catch (error) {
          this.recordFailure(error);
          throw error;
        }
      }
      /**
       * Record successful execution
       */
      recordSuccess() {
        this.successCount++;
        this.lastSuccessTime = Date.now();
        this.consecutiveSuccesses++;
        if (this.state === "half-open") {
          if (this.consecutiveSuccesses >= this.config.successThreshold) {
            this.transitionTo("closed");
          }
        } else if (this.state === "closed") {
          this.pruneOldFailures();
        }
      }
      /**
       * Record failed execution
       */
      recordFailure(error) {
        if (this.config.isRetryable && !this.config.isRetryable(error)) {
          return;
        }
        this.failureCount++;
        this.lastFailureTime = Date.now();
        this.lastError = error.message;
        this.consecutiveSuccesses = 0;
        this.failures.push({
          timestamp: Date.now(),
          error: error.message
        });
        this.pruneOldFailures();
        if (this.state === "half-open") {
          this.transitionTo("open");
        } else if (this.state === "closed") {
          if (this.failures.length >= this.config.failureThreshold) {
            this.transitionTo("open");
          }
        }
      }
      /**
       * Transition to new state
       */
      transitionTo(newState) {
        this.state = newState;
        this.lastStateChange = Date.now();
        switch (newState) {
          case "open":
            this.openedAt = Date.now();
            this.emit("opened", {
              name: this.name,
              failureCount: this.failures.length,
              lastError: this.lastError,
              nextRetryTime: this.openedAt + this.config.resetTimeoutMs
            });
            break;
          case "half-open":
            this.emit("half-open", {
              name: this.name,
              timestamp: Date.now()
            });
            break;
          case "closed":
            this.failures = [];
            this.consecutiveSuccesses = 0;
            this.openedAt = void 0;
            this.emit("closed", {
              name: this.name,
              successCount: this.consecutiveSuccesses,
              timestamp: Date.now()
            });
            break;
        }
      }
      /**
       * Remove failures outside the time window
       */
      pruneOldFailures() {
        const now = Date.now();
        const cutoff = now - this.config.windowMs;
        this.failures = this.failures.filter((f) => f.timestamp > cutoff);
      }
      /**
       * Get current state
       */
      getState() {
        return this.state;
      }
      /**
       * Get current metrics
       */
      getMetrics() {
        this.pruneOldFailures();
        const total = this.successCount + this.failureCount;
        const failureRate = total > 0 ? this.failureCount / total : 0;
        const successRate = total > 0 ? this.successCount / total : 0;
        return {
          name: this.name,
          state: this.state,
          totalRequests: this.totalRequests,
          successCount: this.successCount,
          failureCount: this.failureCount,
          rejectedCount: this.rejectedCount,
          recentFailures: this.failures.length,
          consecutiveSuccesses: this.consecutiveSuccesses,
          lastFailureTime: this.lastFailureTime,
          lastSuccessTime: this.lastSuccessTime,
          lastStateChange: this.lastStateChange,
          nextRetryTime: this.openedAt ? this.openedAt + this.config.resetTimeoutMs : void 0,
          failureRate,
          successRate
        };
      }
      /**
       * Manually reset circuit breaker (force close)
       */
      reset() {
        this.transitionTo("closed");
        this.totalRequests = 0;
        this.successCount = 0;
        this.failureCount = 0;
        this.rejectedCount = 0;
        this.lastFailureTime = void 0;
        this.lastSuccessTime = void 0;
      }
      /**
       * Check if circuit is allowing requests
       */
      isOpen() {
        if (this.state === "open" && this.openedAt) {
          const now = Date.now();
          if (now - this.openedAt >= this.config.resetTimeoutMs) {
            this.transitionTo("half-open");
            return false;
          }
          return true;
        }
        return false;
      }
      /**
       * Get configuration
       */
      getConfig() {
        return { ...this.config };
      }
    };
  }
});

// src/infrastructure/resilience/BackoffStrategy.ts
function calculateBackoff(attempt, config = exports.DEFAULT_BACKOFF_CONFIG) {
  let delay;
  switch (config.strategy) {
    case "exponential":
      delay = config.initialDelayMs * Math.pow(config.multiplier || 2, attempt - 1);
      break;
    case "linear":
      delay = config.initialDelayMs + (config.incrementMs || 1e3) * (attempt - 1);
      break;
    case "constant":
      delay = config.initialDelayMs;
      break;
    default:
      delay = config.initialDelayMs;
  }
  delay = Math.min(delay, config.maxDelayMs);
  if (config.jitter) {
    delay = addJitter(delay, config.jitterFactor || 0.1);
  }
  return Math.floor(delay);
}
function addJitter(delay, factor = 0.1) {
  const jitterRange = delay * factor;
  const jitter = (Math.random() * 2 - 1) * jitterRange;
  return delay + jitter;
}
async function backoffWait(attempt, config = exports.DEFAULT_BACKOFF_CONFIG) {
  const delay = calculateBackoff(attempt, config);
  await new Promise((resolve4) => setTimeout(resolve4, delay));
  return delay;
}
function* backoffSequence(config = exports.DEFAULT_BACKOFF_CONFIG, maxAttempts) {
  let attempt = 1;
  while (true) {
    if (maxAttempts && attempt > maxAttempts) {
      return;
    }
    yield calculateBackoff(attempt, config);
    attempt++;
  }
}
async function retryWithBackoff(fn, config = exports.DEFAULT_BACKOFF_CONFIG, maxAttempts) {
  let attempt = 0;
  let lastError;
  while (true) {
    attempt++;
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (config.isRetryable && !config.isRetryable(lastError)) {
        throw lastError;
      }
      if (maxAttempts && attempt >= maxAttempts) {
        throw lastError;
      }
      await backoffWait(attempt, config);
    }
  }
}
exports.DEFAULT_BACKOFF_CONFIG = void 0;
var init_BackoffStrategy = __esm({
  "src/infrastructure/resilience/BackoffStrategy.ts"() {
    exports.DEFAULT_BACKOFF_CONFIG = {
      strategy: "exponential",
      initialDelayMs: 1e3,
      // 1 second
      maxDelayMs: 3e4,
      // 30 seconds
      multiplier: 2,
      jitter: true,
      jitterFactor: 0.1
    };
  }
});
function safeStringify(obj, indent) {
  const seen = /* @__PURE__ */ new WeakSet();
  const replacer = (_key, value) => {
    if (value === null || value === void 0) {
      return value;
    }
    if (typeof value !== "object") {
      if (typeof value === "function") {
        return "[Function]";
      }
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    }
    const objValue = value;
    const constructor = objValue.constructor?.name || "";
    if (constructor === "Timeout" || constructor === "TimersList" || constructor === "Socket" || constructor === "Server" || constructor === "IncomingMessage" || constructor === "ServerResponse" || constructor === "WriteStream" || constructor === "ReadStream" || constructor === "EventEmitter") {
      return `[${constructor}]`;
    }
    if (seen.has(objValue)) {
      return "[Circular]";
    }
    if (objValue instanceof Error) {
      return {
        name: objValue.name,
        message: objValue.message,
        stack: objValue.stack
      };
    }
    if (objValue instanceof Date) {
      return objValue.toISOString();
    }
    if (objValue instanceof Map) {
      return Object.fromEntries(objValue);
    }
    if (objValue instanceof Set) {
      return Array.from(objValue);
    }
    if (Buffer.isBuffer(objValue)) {
      return `[Buffer(${objValue.length})]`;
    }
    seen.add(objValue);
    return value;
  };
  try {
    return JSON.stringify(obj, replacer, indent);
  } catch {
    return "[Unserializable]";
  }
}
var LOG_LEVEL_VALUES; exports.FrameworkLogger = void 0; exports.logger = void 0;
var init_Logger = __esm({
  "src/infrastructure/observability/Logger.ts"() {
    LOG_LEVEL_VALUES = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      silent: 100
    };
    exports.FrameworkLogger = class _FrameworkLogger {
      config;
      context;
      levelValue;
      fileStream;
      constructor(config = {}) {
        this.config = {
          level: config.level || process.env.LOG_LEVEL || "info",
          pretty: config.pretty ?? (process.env.LOG_PRETTY === "true" || process.env.NODE_ENV === "development"),
          destination: config.destination || "console",
          context: config.context || {},
          filePath: config.filePath || process.env.LOG_FILE
        };
        this.context = this.config.context || {};
        this.levelValue = LOG_LEVEL_VALUES[this.config.level || "info"];
        if (this.config.filePath) {
          this.initFileStream(this.config.filePath);
        }
      }
      /**
       * Initialize file stream for logging
       */
      initFileStream(filePath) {
        try {
          const dir = path2__namespace.dirname(filePath);
          if (!fs19__namespace.existsSync(dir)) {
            fs19__namespace.mkdirSync(dir, { recursive: true });
          }
          this.fileStream = fs19__namespace.createWriteStream(filePath, {
            flags: "a",
            // append mode
            encoding: "utf8"
          });
          this.fileStream.on("error", (err) => {
            console.error(`[Logger] File stream error: ${err.message}`);
            this.fileStream = void 0;
          });
        } catch (err) {
          console.error(`[Logger] Failed to initialize log file: ${err instanceof Error ? err.message : err}`);
        }
      }
      /**
       * Create child logger with additional context
       */
      child(context) {
        return new _FrameworkLogger({
          ...this.config,
          context: { ...this.context, ...context }
        });
      }
      /**
       * Trace log
       */
      trace(obj, msg) {
        this.log("trace", obj, msg);
      }
      /**
       * Debug log
       */
      debug(obj, msg) {
        this.log("debug", obj, msg);
      }
      /**
       * Info log
       */
      info(obj, msg) {
        this.log("info", obj, msg);
      }
      /**
       * Warn log
       */
      warn(obj, msg) {
        this.log("warn", obj, msg);
      }
      /**
       * Error log
       */
      error(obj, msg) {
        this.log("error", obj, msg);
      }
      /**
       * Internal log method
       */
      log(level, obj, msg) {
        if (LOG_LEVEL_VALUES[level] < this.levelValue) {
          return;
        }
        let data;
        let message;
        if (typeof obj === "string") {
          message = obj;
          data = {};
        } else {
          message = msg || "";
          data = obj;
        }
        const entry = {
          level,
          time: Date.now(),
          ...this.context,
          ...data,
          msg: message
        };
        this.output(entry);
      }
      /**
       * Output log entry
       */
      output(entry) {
        if (this.config.pretty) {
          this.prettyPrint(entry);
        } else {
          this.jsonPrint(entry);
        }
      }
      /**
       * Pretty print for development
       */
      prettyPrint(entry) {
        const levelColors = {
          trace: "\x1B[90m",
          // Gray
          debug: "\x1B[36m",
          // Cyan
          info: "\x1B[32m",
          // Green
          warn: "\x1B[33m",
          // Yellow
          error: "\x1B[31m",
          // Red
          silent: ""
        };
        const reset = "\x1B[0m";
        const color = this.fileStream ? "" : levelColors[entry.level] || "";
        const time = new Date(entry.time).toISOString().substring(11, 23);
        const levelStr = entry.level.toUpperCase().padEnd(5);
        const contextParts = [];
        for (const [key, value] of Object.entries(entry)) {
          if (key !== "level" && key !== "time" && key !== "msg") {
            contextParts.push(`${key}=${safeStringify(value)}`);
          }
        }
        const context = contextParts.length > 0 ? ` ${contextParts.join(" ")}` : "";
        const output = `${color}[${time}] ${levelStr}${reset} ${entry.msg}${context}`;
        if (this.fileStream) {
          const cleanOutput = output.replace(/\x1b\[[0-9;]*m/g, "");
          this.fileStream.write(cleanOutput + "\n");
          return;
        }
        switch (entry.level) {
          case "error":
          case "warn":
            console.error(output);
            break;
          default:
            console.log(output);
        }
      }
      /**
       * JSON print for production
       */
      jsonPrint(entry) {
        const json = safeStringify(entry);
        if (this.fileStream) {
          this.fileStream.write(json + "\n");
          return;
        }
        switch (this.config.destination) {
          case "stderr":
            console.error(json);
            break;
          default:
            console.log(json);
        }
      }
      /**
       * Update configuration
       */
      updateConfig(config) {
        this.config = { ...this.config, ...config };
        if (config.level) {
          this.levelValue = LOG_LEVEL_VALUES[config.level];
        }
        if (config.context) {
          this.context = { ...this.context, ...config.context };
        }
        if (config.filePath !== void 0) {
          this.closeFileStream();
          if (config.filePath) {
            this.initFileStream(config.filePath);
          }
        }
      }
      /**
       * Close file stream
       */
      closeFileStream() {
        if (this.fileStream) {
          this.fileStream.end();
          this.fileStream = void 0;
        }
      }
      /**
       * Cleanup resources (call before process exit)
       */
      close() {
        this.closeFileStream();
      }
      /**
       * Get current log level
       */
      getLevel() {
        return this.config.level || "info";
      }
      /**
       * Check if level is enabled
       */
      isLevelEnabled(level) {
        return LOG_LEVEL_VALUES[level] >= this.levelValue;
      }
    };
    exports.logger = new exports.FrameworkLogger({
      level: process.env.LOG_LEVEL || "info",
      pretty: process.env.LOG_PRETTY === "true" || process.env.NODE_ENV === "development",
      filePath: process.env.LOG_FILE
    });
    process.on("exit", () => {
      exports.logger.close();
    });
    process.on("SIGINT", () => {
      exports.logger.close();
      process.exit(0);
    });
    process.on("SIGTERM", () => {
      exports.logger.close();
      process.exit(0);
    });
  }
});

// src/infrastructure/observability/Metrics.ts
function createMetricsCollector(type, prefix) {
  const collectorType = type || process.env.METRICS_COLLECTOR || "noop";
  switch (collectorType) {
    case "console":
      return new exports.ConsoleMetrics(prefix);
    case "inmemory":
      return new exports.InMemoryMetrics();
    default:
      return new exports.NoOpMetrics();
  }
}
function setMetricsCollector(collector) {
  Object.assign(exports.metrics, collector);
}
exports.NoOpMetrics = void 0; exports.ConsoleMetrics = void 0; exports.InMemoryMetrics = void 0; exports.metrics = void 0;
var init_Metrics = __esm({
  "src/infrastructure/observability/Metrics.ts"() {
    exports.NoOpMetrics = class {
      increment() {
      }
      gauge() {
      }
      timing() {
      }
      histogram() {
      }
    };
    exports.ConsoleMetrics = class {
      prefix;
      constructor(prefix = "oneringai") {
        this.prefix = prefix;
      }
      increment(metric, value = 1, tags) {
        this.log("COUNTER", metric, value, tags);
      }
      gauge(metric, value, tags) {
        this.log("GAUGE", metric, value, tags);
      }
      timing(metric, duration, tags) {
        this.log("TIMING", metric, `${duration}ms`, tags);
      }
      histogram(metric, value, tags) {
        this.log("HISTOGRAM", metric, value, tags);
      }
      log(type, metric, value, tags) {
        const fullMetric = `${this.prefix}.${metric}`;
        const tagsStr = tags ? ` ${JSON.stringify(tags)}` : "";
        console.log(`[METRIC:${type}] ${fullMetric}=${value}${tagsStr}`);
      }
    };
    exports.InMemoryMetrics = class {
      counters = /* @__PURE__ */ new Map();
      gauges = /* @__PURE__ */ new Map();
      timings = /* @__PURE__ */ new Map();
      histograms = /* @__PURE__ */ new Map();
      increment(metric, value = 1, tags) {
        const key = this.makeKey(metric, tags);
        this.counters.set(key, (this.counters.get(key) || 0) + value);
      }
      gauge(metric, value, tags) {
        const key = this.makeKey(metric, tags);
        this.gauges.set(key, value);
      }
      timing(metric, duration, tags) {
        const key = this.makeKey(metric, tags);
        const timings = this.timings.get(key) || [];
        timings.push(duration);
        this.timings.set(key, timings);
      }
      histogram(metric, value, tags) {
        const key = this.makeKey(metric, tags);
        const values = this.histograms.get(key) || [];
        values.push(value);
        this.histograms.set(key, values);
      }
      makeKey(metric, tags) {
        if (!tags) return metric;
        const tagStr = Object.entries(tags).map(([k, v]) => `${k}:${v}`).sort().join(",");
        return `${metric}{${tagStr}}`;
      }
      /**
       * Get all metrics (for testing)
       */
      getMetrics() {
        return {
          counters: new Map(this.counters),
          gauges: new Map(this.gauges),
          timings: new Map(this.timings),
          histograms: new Map(this.histograms)
        };
      }
      /**
       * Clear all metrics
       */
      clear() {
        this.counters.clear();
        this.gauges.clear();
        this.timings.clear();
        this.histograms.clear();
      }
      /**
       * Get summary statistics for timings
       */
      getTimingStats(metric, tags) {
        const key = this.makeKey(metric, tags);
        const timings = this.timings.get(key);
        if (!timings || timings.length === 0) {
          return null;
        }
        const sorted = [...timings].sort((a, b) => a - b);
        const count = sorted.length;
        const sum = sorted.reduce((a, b) => a + b, 0);
        return {
          count,
          min: sorted[0] ?? 0,
          max: sorted[count - 1] ?? 0,
          mean: sum / count,
          p50: sorted[Math.floor(count * 0.5)] ?? 0,
          p95: sorted[Math.floor(count * 0.95)] ?? 0,
          p99: sorted[Math.floor(count * 0.99)] ?? 0
        };
      }
    };
    exports.metrics = createMetricsCollector(
      void 0,
      process.env.METRICS_PREFIX || "oneringai"
    );
  }
});

// src/core/ScopedConnectorRegistry.ts
exports.ScopedConnectorRegistry = void 0;
var init_ScopedConnectorRegistry = __esm({
  "src/core/ScopedConnectorRegistry.ts"() {
    init_Connector();
    exports.ScopedConnectorRegistry = class {
      constructor(policy, context) {
        this.policy = policy;
        this.context = context;
      }
      get(name) {
        if (!exports.Connector.has(name)) {
          const available = this.list().join(", ") || "none";
          throw new Error(`Connector '${name}' not found. Available: ${available}`);
        }
        const connector = exports.Connector.get(name);
        if (!this.policy.canAccess(connector, this.context)) {
          const available = this.list().join(", ") || "none";
          throw new Error(`Connector '${name}' not found. Available: ${available}`);
        }
        return connector;
      }
      has(name) {
        if (!exports.Connector.has(name)) return false;
        const connector = exports.Connector.get(name);
        return this.policy.canAccess(connector, this.context);
      }
      list() {
        return this.listAll().map((c) => c.name);
      }
      listAll() {
        return exports.Connector.listAll().filter((c) => this.policy.canAccess(c, this.context));
      }
      size() {
        return this.listAll().length;
      }
      getDescriptionsForTools() {
        const connectors = this.listAll();
        if (connectors.length === 0) {
          return "No connectors registered yet.";
        }
        return connectors.map((c) => `  - "${c.name}": ${c.displayName} - ${c.config.description || "No description"}`).join("\n");
      }
      getInfo() {
        const info = {};
        for (const connector of this.listAll()) {
          info[connector.name] = {
            displayName: connector.displayName,
            description: connector.config.description || "",
            baseURL: connector.baseURL
          };
        }
        return info;
      }
    };
  }
});

// src/core/Connector.ts
var Connector_exports = {};
__export(Connector_exports, {
  Connector: () => exports.Connector,
  DEFAULT_BASE_DELAY_MS: () => exports.DEFAULT_BASE_DELAY_MS,
  DEFAULT_CONNECTOR_TIMEOUT: () => exports.DEFAULT_CONNECTOR_TIMEOUT,
  DEFAULT_MAX_DELAY_MS: () => exports.DEFAULT_MAX_DELAY_MS,
  DEFAULT_MAX_RETRIES: () => exports.DEFAULT_MAX_RETRIES,
  DEFAULT_RETRYABLE_STATUSES: () => exports.DEFAULT_RETRYABLE_STATUSES
});
exports.DEFAULT_CONNECTOR_TIMEOUT = void 0; exports.DEFAULT_MAX_RETRIES = void 0; exports.DEFAULT_RETRYABLE_STATUSES = void 0; exports.DEFAULT_BASE_DELAY_MS = void 0; exports.DEFAULT_MAX_DELAY_MS = void 0; exports.Connector = void 0;
var init_Connector = __esm({
  "src/core/Connector.ts"() {
    init_OAuthManager();
    init_MemoryStorage();
    init_StorageRegistry();
    init_CircuitBreaker();
    init_BackoffStrategy();
    init_Logger();
    init_Metrics();
    init_ScopedConnectorRegistry();
    exports.DEFAULT_CONNECTOR_TIMEOUT = 3e4;
    exports.DEFAULT_MAX_RETRIES = 3;
    exports.DEFAULT_RETRYABLE_STATUSES = [429, 500, 502, 503, 504];
    exports.DEFAULT_BASE_DELAY_MS = 1e3;
    exports.DEFAULT_MAX_DELAY_MS = 3e4;
    exports.Connector = class _Connector {
      // ============ Static Registry ============
      static registry = /* @__PURE__ */ new Map();
      /**
       * Create and register a new connector
       * @param config - Must include `name` field
       */
      static create(config) {
        if (!config.name || config.name.trim().length === 0) {
          throw new Error("Connector name is required");
        }
        if (_Connector.registry.has(config.name)) {
          throw new Error(`Connector '${config.name}' already exists. Use Connector.get() or choose a different name.`);
        }
        const connector = new _Connector(config);
        _Connector.registry.set(config.name, connector);
        return connector;
      }
      /**
       * Get a connector by name
       */
      static get(name) {
        const connector = _Connector.registry.get(name);
        if (!connector) {
          const available = _Connector.list().join(", ") || "none";
          throw new Error(`Connector '${name}' not found. Available: ${available}`);
        }
        return connector;
      }
      /**
       * Check if a connector exists
       */
      static has(name) {
        return _Connector.registry.has(name);
      }
      /**
       * List all registered connector names
       */
      static list() {
        return Array.from(_Connector.registry.keys());
      }
      /**
       * Remove a connector
       */
      static remove(name) {
        const connector = _Connector.registry.get(name);
        if (connector) {
          connector.dispose();
        }
        return _Connector.registry.delete(name);
      }
      /**
       * Clear all connectors (useful for testing)
       */
      static clear() {
        for (const connector of _Connector.registry.values()) {
          connector.dispose();
        }
        _Connector.registry.clear();
      }
      /**
       * Get the default token storage for OAuth connectors.
       * Resolves from StorageRegistry, falling back to MemoryStorage.
       */
      static get defaultStorage() {
        return exports.StorageRegistry.resolve("oauthTokens", () => new exports.MemoryStorage());
      }
      /**
       * Set default token storage for OAuth connectors
       */
      static setDefaultStorage(storage) {
        exports.StorageRegistry.set("oauthTokens", storage);
      }
      /**
       * Get all registered connectors
       */
      static listAll() {
        return Array.from(_Connector.registry.values());
      }
      /**
       * Get number of registered connectors
       */
      static size() {
        return _Connector.registry.size;
      }
      // ============ Access Control ============
      static _accessPolicy = null;
      /**
       * Set a global access policy for connector scoping.
       * Pass null to clear the policy.
       */
      static setAccessPolicy(policy) {
        _Connector._accessPolicy = policy;
      }
      /**
       * Get the current global access policy (or null if none set).
       */
      static getAccessPolicy() {
        return _Connector._accessPolicy;
      }
      /**
       * Create a scoped (filtered) view of the connector registry.
       * Requires a global access policy to be set via setAccessPolicy().
       *
       * @param context - Opaque context passed to the policy (e.g., { userId, tenantId })
       * @returns IConnectorRegistry that only exposes accessible connectors
       * @throws Error if no access policy is set
       */
      static scoped(context) {
        if (!_Connector._accessPolicy) {
          throw new Error("No access policy set. Call Connector.setAccessPolicy() first.");
        }
        return new exports.ScopedConnectorRegistry(_Connector._accessPolicy, context);
      }
      /**
       * Return the static Connector methods as an IConnectorRegistry object (unfiltered).
       * Useful when code accepts the interface but you want the full admin view.
       */
      static asRegistry() {
        return {
          get: (name) => _Connector.get(name),
          has: (name) => _Connector.has(name),
          list: () => _Connector.list(),
          listAll: () => _Connector.listAll(),
          size: () => _Connector.size(),
          getDescriptionsForTools: () => _Connector.getDescriptionsForTools(),
          getInfo: () => _Connector.getInfo()
        };
      }
      /**
       * Get connector descriptions formatted for tool parameters
       * Useful for generating dynamic tool descriptions
       */
      static getDescriptionsForTools() {
        const connectors = _Connector.listAll();
        if (connectors.length === 0) {
          return "No connectors registered yet.";
        }
        return connectors.map((c) => `  - "${c.name}": ${c.displayName} - ${c.config.description || "No description"}`).join("\n");
      }
      /**
       * Get connector info (for tools and documentation)
       */
      static getInfo() {
        const info = {};
        for (const connector of _Connector.registry.values()) {
          info[connector.name] = {
            displayName: connector.displayName,
            description: connector.config.description || "",
            baseURL: connector.baseURL
          };
        }
        return info;
      }
      // ============ Instance ============
      name;
      vendor;
      config;
      oauthManager;
      circuitBreaker;
      disposed = false;
      // Metrics
      requestCount = 0;
      successCount = 0;
      failureCount = 0;
      totalLatencyMs = 0;
      constructor(config) {
        this.name = config.name;
        this.vendor = config.vendor;
        this.config = config;
        if (config.auth.type === "oauth") {
          this.initOAuthManager(config.auth);
        } else if (config.auth.type === "jwt") {
          this.initJWTManager(config.auth);
        }
        this.initCircuitBreaker();
      }
      /**
       * Initialize circuit breaker with config or defaults
       */
      initCircuitBreaker() {
        const cbConfig = this.config.circuitBreaker;
        const enabled = cbConfig?.enabled ?? true;
        if (enabled) {
          this.circuitBreaker = new exports.CircuitBreaker(`connector:${this.name}`, {
            failureThreshold: cbConfig?.failureThreshold ?? 5,
            successThreshold: cbConfig?.successThreshold ?? 2,
            resetTimeoutMs: cbConfig?.resetTimeoutMs ?? 3e4,
            windowMs: 6e4,
            // 1 minute window
            isRetryable: (error) => {
              if (error.message.includes("HTTP 4") && !error.message.includes("HTTP 429")) {
                return false;
              }
              return true;
            }
          });
          this.circuitBreaker.on("opened", ({ name, failureCount, lastError }) => {
            exports.logger.warn(`Circuit breaker opened for ${name}: ${failureCount} failures, last error: ${lastError}`);
            exports.metrics.increment("connector.circuit_breaker.opened", 1, { connector: this.name });
          });
          this.circuitBreaker.on("closed", ({ name }) => {
            exports.logger.info(`Circuit breaker closed for ${name}`);
            exports.metrics.increment("connector.circuit_breaker.closed", 1, { connector: this.name });
          });
        }
      }
      /**
       * Human-readable display name
       */
      get displayName() {
        return this.config.displayName || this.name;
      }
      /**
       * API base URL for this connector
       */
      get baseURL() {
        return this.config.baseURL || "";
      }
      /**
       * Get the API key (for api_key auth type)
       */
      getApiKey() {
        if (this.config.auth.type !== "api_key") {
          throw new Error(`Connector '${this.name}' does not use API key auth. Type: ${this.config.auth.type}`);
        }
        return this.config.auth.apiKey;
      }
      /**
       * Get the current access token (for OAuth, JWT, or API key)
       * Handles automatic refresh if needed
       */
      async getToken(userId) {
        if (this.config.auth.type === "api_key") {
          return this.config.auth.apiKey;
        }
        if (!this.oauthManager) {
          throw new Error(`OAuth manager not initialized for connector '${this.name}'`);
        }
        return this.oauthManager.getToken(userId);
      }
      /**
       * Start OAuth authorization flow
       * Returns the URL to redirect the user to
       */
      async startAuth(userId) {
        if (!this.oauthManager) {
          throw new Error(`Connector '${this.name}' is not an OAuth connector`);
        }
        return this.oauthManager.startAuthFlow(userId);
      }
      /**
       * Handle OAuth callback
       * Call this after user is redirected back from OAuth provider
       */
      async handleCallback(callbackUrl, userId) {
        if (!this.oauthManager) {
          throw new Error(`Connector '${this.name}' is not an OAuth connector`);
        }
        await this.oauthManager.handleCallback(callbackUrl, userId);
      }
      /**
       * Check if the connector has a valid token
       */
      async hasValidToken(userId) {
        try {
          if (this.config.auth.type === "api_key") {
            return true;
          }
          if (this.oauthManager) {
            const token = await this.oauthManager.getToken(userId);
            return !!token;
          }
          return false;
        } catch {
          return false;
        }
      }
      /**
       * Get vendor-specific options from config
       */
      getOptions() {
        return this.config.options ?? {};
      }
      /**
       * Get the service type (explicit or undefined)
       */
      get serviceType() {
        return this.config.serviceType;
      }
      /**
       * Get connector metrics
       */
      getMetrics() {
        return {
          requestCount: this.requestCount,
          successCount: this.successCount,
          failureCount: this.failureCount,
          avgLatencyMs: this.requestCount > 0 ? this.totalLatencyMs / this.requestCount : 0,
          circuitBreakerState: this.circuitBreaker?.getState()
        };
      }
      /**
       * Reset circuit breaker (force close)
       */
      resetCircuitBreaker() {
        this.circuitBreaker?.reset();
      }
      /**
       * Make an authenticated fetch request using this connector
       * This is the foundation for all vendor-dependent tools
       *
       * Features:
       * - Timeout with AbortController
       * - Circuit breaker protection
       * - Retry with exponential backoff
       * - Request/response logging
       *
       * @param endpoint - API endpoint (relative to baseURL) or full URL
       * @param options - Fetch options with connector-specific settings
       * @param userId - Optional user ID for multi-user OAuth
       * @returns Fetch Response
       */
      async fetch(endpoint, options, userId) {
        if (this.disposed) {
          throw new Error(`Connector '${this.name}' has been disposed`);
        }
        const startTime = Date.now();
        this.requestCount++;
        let url2;
        if (endpoint.startsWith("http")) {
          url2 = endpoint;
        } else {
          const base = (this.baseURL ?? "").replace(/\/+$/, "");
          const path6 = endpoint.startsWith("/") ? endpoint : `/${endpoint}`;
          url2 = `${base}${path6}`;
        }
        const timeout = options?.timeout ?? this.config.timeout ?? exports.DEFAULT_CONNECTOR_TIMEOUT;
        if (this.config.logging?.enabled) {
          this.logRequest(url2, options);
        }
        const doFetch = async () => {
          const token = await this.getToken(userId);
          const auth2 = this.config.auth;
          let headerName = "Authorization";
          let headerValue = `Bearer ${token}`;
          if (auth2.type === "api_key") {
            headerName = auth2.headerName || "Authorization";
            const prefix = auth2.headerPrefix ?? "Bearer";
            headerValue = prefix ? `${prefix} ${token}` : token;
          }
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          try {
            const response = await fetch(url2, {
              ...options,
              signal: controller.signal,
              headers: {
                ...options?.headers,
                [headerName]: headerValue
              }
            });
            return response;
          } finally {
            clearTimeout(timeoutId);
          }
        };
        const doFetchWithRetry = async () => {
          const retryConfig = this.config.retry;
          const maxRetries = retryConfig?.maxRetries ?? exports.DEFAULT_MAX_RETRIES;
          const retryableStatuses = retryConfig?.retryableStatuses ?? exports.DEFAULT_RETRYABLE_STATUSES;
          const baseDelayMs = retryConfig?.baseDelayMs ?? exports.DEFAULT_BASE_DELAY_MS;
          const maxDelayMs = retryConfig?.maxDelayMs ?? exports.DEFAULT_MAX_DELAY_MS;
          const backoffConfig = {
            strategy: "exponential",
            initialDelayMs: baseDelayMs,
            maxDelayMs,
            multiplier: 2,
            jitter: true,
            jitterFactor: 0.1
          };
          let lastError;
          let lastResponse;
          for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
            try {
              const response = await doFetch();
              if (!response.ok && retryableStatuses.includes(response.status) && attempt <= maxRetries) {
                lastResponse = response;
                const delay = calculateBackoff(attempt, backoffConfig);
                if (this.config.logging?.enabled) {
                  exports.logger.debug(`Connector ${this.name}: Retry ${attempt}/${maxRetries} after ${delay}ms (status ${response.status})`);
                }
                await this.sleep(delay);
                continue;
              }
              return response;
            } catch (error) {
              lastError = error;
              if (lastError.name === "AbortError") {
                throw new Error(`Request timeout after ${timeout}ms: ${url2}`);
              }
              if (attempt <= maxRetries && !options?.skipRetry) {
                const delay = calculateBackoff(attempt, backoffConfig);
                if (this.config.logging?.enabled) {
                  exports.logger.debug(`Connector ${this.name}: Retry ${attempt}/${maxRetries} after ${delay}ms (error: ${lastError.message})`);
                }
                await this.sleep(delay);
                continue;
              }
              throw lastError;
            }
          }
          if (lastResponse) {
            return lastResponse;
          }
          throw lastError ?? new Error("Unknown error during fetch");
        };
        try {
          let response;
          if (this.circuitBreaker && !options?.skipCircuitBreaker) {
            response = await this.circuitBreaker.execute(doFetchWithRetry);
          } else {
            response = await doFetchWithRetry();
          }
          const latency = Date.now() - startTime;
          this.successCount++;
          this.totalLatencyMs += latency;
          exports.metrics.timing("connector.latency", latency, { connector: this.name });
          exports.metrics.increment("connector.success", 1, { connector: this.name });
          if (this.config.logging?.enabled) {
            this.logResponse(url2, response, latency);
          }
          return response;
        } catch (error) {
          const latency = Date.now() - startTime;
          this.failureCount++;
          this.totalLatencyMs += latency;
          exports.metrics.increment("connector.failure", 1, { connector: this.name, error: error.name });
          if (this.config.logging?.enabled) {
            exports.logger.error(
              { connector: this.name, url: url2, latency, error: error.message },
              `Connector ${this.name} fetch failed: ${error.message}`
            );
          }
          throw error;
        }
      }
      /**
       * Make an authenticated fetch request and parse JSON response
       * Throws on non-OK responses
       *
       * @param endpoint - API endpoint (relative to baseURL) or full URL
       * @param options - Fetch options with connector-specific settings
       * @param userId - Optional user ID for multi-user OAuth
       * @returns Parsed JSON response
       */
      async fetchJSON(endpoint, options, userId) {
        const response = await this.fetch(endpoint, options, userId);
        const text = await response.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${text}`);
          }
          throw new Error(`Invalid JSON response: ${text.slice(0, 100)}`);
        }
        if (!response.ok) {
          const errorMsg = typeof data === "object" && data !== null ? JSON.stringify(data) : text;
          throw new Error(`HTTP ${response.status}: ${errorMsg}`);
        }
        return data;
      }
      // ============ Private Helpers ============
      sleep(ms) {
        return new Promise((resolve4) => setTimeout(resolve4, ms));
      }
      logRequest(url2, options) {
        const logData = {
          connector: this.name,
          method: options?.method ?? "GET",
          url: url2
        };
        if (this.config.logging?.logHeaders && options?.headers) {
          const headers = { ...options.headers };
          if (headers["Authorization"]) {
            headers["Authorization"] = "[REDACTED]";
          }
          if (headers["authorization"]) {
            headers["authorization"] = "[REDACTED]";
          }
          logData.headers = headers;
        }
        if (this.config.logging?.logBody && options?.body) {
          logData.body = typeof options.body === "string" ? options.body.slice(0, 1e3) : "[non-string body]";
        }
        exports.logger.debug(logData, `Connector ${this.name} request`);
      }
      logResponse(url2, response, latency) {
        exports.logger.debug(
          { connector: this.name, url: url2, status: response.status, latency },
          `Connector ${this.name} response`
        );
      }
      /**
       * Dispose of resources
       */
      dispose() {
        if (this.disposed) return;
        this.disposed = true;
        this.oauthManager = void 0;
        this.circuitBreaker = void 0;
      }
      /**
       * Check if connector is disposed
       */
      isDisposed() {
        return this.disposed;
      }
      // ============ Private ============
      initOAuthManager(auth2) {
        const oauthConfig = {
          flow: auth2.flow,
          clientId: auth2.clientId,
          clientSecret: auth2.clientSecret,
          tokenUrl: auth2.tokenUrl,
          authorizationUrl: auth2.authorizationUrl,
          redirectUri: auth2.redirectUri,
          scope: auth2.scope,
          usePKCE: auth2.usePKCE,
          privateKey: auth2.privateKey,
          privateKeyPath: auth2.privateKeyPath,
          audience: auth2.audience,
          refreshBeforeExpiry: auth2.refreshBeforeExpiry,
          storage: _Connector.defaultStorage,
          storageKey: auth2.storageKey ?? this.name
        };
        this.oauthManager = new exports.OAuthManager(oauthConfig);
      }
      initJWTManager(auth2) {
        this.oauthManager = new exports.OAuthManager({
          flow: "jwt_bearer",
          clientId: auth2.clientId,
          tokenUrl: auth2.tokenUrl,
          privateKey: auth2.privateKey,
          privateKeyPath: auth2.privateKeyPath,
          scope: auth2.scope,
          audience: auth2.audience,
          storage: _Connector.defaultStorage,
          storageKey: this.name
        });
      }
    };
  }
});

// src/core/constants.ts
var AGENT_DEFAULTS, TOKEN_ESTIMATION, DOCUMENT_DEFAULTS;
var init_constants = __esm({
  "src/core/constants.ts"() {
    AGENT_DEFAULTS = {
      /** Default maximum iterations for agentic loop */
      MAX_ITERATIONS: 50,
      /** Default temperature for LLM calls */
      DEFAULT_TEMPERATURE: 0.7,
      /** Message injected when max iterations is reached */
      MAX_ITERATIONS_MESSAGE: `You have reached the maximum iteration limit for this execution. Please:
1. Summarize what you have accomplished so far
2. Explain what remains to be done (if anything)
3. Ask the user if they would like you to continue

Do NOT use any tools in this response - just provide a clear summary and ask for confirmation to proceed.`
    };
    TOKEN_ESTIMATION = {
      /** Characters per token for code */
      CODE_CHARS_PER_TOKEN: 3,
      /** Characters per token for prose */
      PROSE_CHARS_PER_TOKEN: 4,
      /** Characters per token for mixed content */
      MIXED_CHARS_PER_TOKEN: 3.5,
      /** Default characters per token */
      DEFAULT_CHARS_PER_TOKEN: 4
    };
    DOCUMENT_DEFAULTS = {
      /** Maximum estimated tokens in output */
      MAX_OUTPUT_TOKENS: 1e5,
      /** Maximum output size in bytes (5MB) */
      MAX_OUTPUT_BYTES: 5 * 1024 * 1024,
      /** Maximum download size for URL sources (50MB) */
      MAX_DOWNLOAD_SIZE_BYTES: 50 * 1024 * 1024,
      /** Download timeout for URL sources */
      DOWNLOAD_TIMEOUT_MS: 6e4,
      /** Maximum extracted images from a single document */
      MAX_EXTRACTED_IMAGES: 50,
      /** Maximum Excel rows per sheet */
      MAX_EXCEL_ROWS: 1e3,
      /** Maximum Excel columns per sheet */
      MAX_EXCEL_COLUMNS: 50,
      /** Maximum HTML content length */
      MAX_HTML_LENGTH: 5e4,
      /** Characters per token estimate */
      CHARS_PER_TOKEN: 4,
      /** Estimated tokens for an image with auto detail */
      IMAGE_TOKENS_AUTO: 765,
      /** Estimated tokens for an image with low detail */
      IMAGE_TOKENS_LOW: 85,
      /** Image filter defaults */
      IMAGE_FILTER: {
        MIN_WIDTH: 50,
        MIN_HEIGHT: 50,
        MIN_SIZE_BYTES: 1024
      }
    };
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports$1._CodeOrName = _CodeOrName;
    exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports$1.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports$1.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports$1._Code = _Code;
    exports$1.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports$1._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify3(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify3(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports$1.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports$1.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports$1.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify3(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify3(x));
    }
    exports$1.stringify = stringify;
    function safeStringify3(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports$1.safeStringify = safeStringify3;
    function getProperty(key) {
      return typeof key == "string" && exports$1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports$1.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports$1.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports$1.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports$1.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
    exports$1.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports$1.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports$1.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports$1.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports$1.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports$1.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports$1.not = not;
    var andCode = mappend(exports$1.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports$1.and = and;
    var orCode = mappend(exports$1.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports$1.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.checkStrictMode = exports$1.getErrorPath = exports$1.Type = exports$1.useFunc = exports$1.setEvaluated = exports$1.evaluatedPropsToName = exports$1.mergeEvaluated = exports$1.eachItem = exports$1.unescapeJsonPointer = exports$1.escapeJsonPointer = exports$1.escapeFragment = exports$1.unescapeFragment = exports$1.schemaRefOrVal = exports$1.schemaHasRulesButRef = exports$1.schemaHasRules = exports$1.checkUnknownRules = exports$1.alwaysValidSchema = exports$1.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports$1.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports$1.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports$1.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports$1.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports$1.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports$1.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports$1.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports$1.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports$1.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports$1.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports$1.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports$1.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports$1.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports$1.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports$1.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports$1.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports$1.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports$1.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports$1.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports$1.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports$1.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports$1.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports$1.reportError = reportError;
    function reportExtraError(cxt, error = exports$1.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports$1.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports$1.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports$1.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.boolOrEmptySchema = exports$1.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports$1.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports$1.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getRules = exports$1.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports$1.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports$1.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.shouldUseRule = exports$1.shouldUseGroup = exports$1.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports$1.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports$1.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports$1.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.reportTypeError = exports$1.checkDataTypes = exports$1.checkDataType = exports$1.coerceAndCheckDataType = exports$1.getJSONTypes = exports$1.getSchemaTypes = exports$1.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports$1.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports$1.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports$1.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports$1.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports$1.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports$1.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports$1.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports$1.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateUnion = exports$1.validateArray = exports$1.usePattern = exports$1.callValidateCode = exports$1.schemaProperties = exports$1.allSchemaProperties = exports$1.noPropertyInData = exports$1.propertyInData = exports$1.isOwnProperty = exports$1.hasPropFunc = exports$1.reportMissingProp = exports$1.checkMissingProp = exports$1.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports$1.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports$1.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports$1.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports$1.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports$1.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports$1.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports$1.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports$1.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports$1.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports$1.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports$1.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports$1.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports$1.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateKeywordUsage = exports$1.validSchemaType = exports$1.funcKeywordCode = exports$1.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports$1.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports$1.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports$1.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports$1.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.extendSubschemaMode = exports$1.extendSubschemaData = exports$1.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports$1.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports$1.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports$1.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports$1, module) {
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports$1, module) {
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getSchemaRefs = exports$1.resolveUrl = exports$1.normalizeId = exports$1._getFullPath = exports$1.getFullPath = exports$1.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports$1.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize2) {
      if (normalize2 !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports$1.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports$1._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports$1.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports$1.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports$1.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getData = exports$1.KeywordCxt = exports$1.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports$1.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports$1.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports$1.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports$1.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports$1.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.resolveSchema = exports$1.getCompilingSchema = exports$1.resolveRef = exports$1.compileSchema = exports$1.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports$1.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports$1.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve4.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports$1.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports$1.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve4(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports$1.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports$1, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports$1, module) {
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path6) {
      let input = path6;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports$1, module) {
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path6, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path6 && path6 !== "/" ? path6 : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports$1, module) {
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve4(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative4, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative4 = parse(serialize(relative4, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative4.scheme) {
        target.scheme = relative4.scheme;
        target.userinfo = relative4.userinfo;
        target.host = relative4.host;
        target.port = relative4.port;
        target.path = removeDotSegments(relative4.path || "");
        target.query = relative4.query;
      } else {
        if (relative4.userinfo !== void 0 || relative4.host !== void 0 || relative4.port !== void 0) {
          target.userinfo = relative4.userinfo;
          target.host = relative4.host;
          target.port = relative4.port;
          target.path = removeDotSegments(relative4.path || "");
          target.query = relative4.query;
        } else {
          if (!relative4.path) {
            target.path = base.path;
            if (relative4.query !== void 0) {
              target.query = relative4.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative4.path[0] === "/") {
              target.path = removeDotSegments(relative4.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative4.path;
              } else if (!base.path) {
                target.path = relative4.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative4.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative4.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative4.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve: resolve4,
      resolveComponent,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports$1.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports$1.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.callRef = exports$1.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports$1.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports$1.callRef = callRef;
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports$1.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports$1.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        if ($data) {
          const { regExp } = it.opts.code;
          const regExpCode = regExp.code === "new RegExp" ? (0, codegen_1._)`new RegExp` : (0, util_1.useFunc)(gen, regExp);
          const valid = gen.let("valid");
          gen.try(() => gen.assign(valid, (0, codegen_1._)`${regExpCode}(${schemaCode}, ${u}).test(${data})`), () => gen.assign(valid, false));
          cxt.fail$data((0, codegen_1._)`!${valid}`);
        } else {
          const regExp = (0, code_1.usePattern)(cxt, schema);
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports$1.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports$1.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports$1.validateAdditionalItems = validateAdditionalItems;
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports$1.validateTuple = validateTuple;
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports$1.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports$1.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports$1.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports$1.validateSchemaDeps = validateSchemaDeps;
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports$1.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports$1.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.contentVocabulary = exports$1.metadataVocabulary = void 0;
    exports$1.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports$1.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports$1.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports$1.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports$1.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports$1, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports$1, module) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports$1.Ajv = Ajv2;
    module.exports = exports$1 = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatNames = exports$1.fastFormats = exports$1.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports$1.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports$1.fastFormats = {
      ...exports$1.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports$1.formatNames = Object.keys(exports$1.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -2147483648;
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports$1.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports$1.formatLimitDefinition);
      return ajv;
    };
    exports$1.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports$1, module) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs20, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs20[f]);
    }
    module.exports = exports$1 = formatsPlugin;
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.default = formatsPlugin;
  }
});

// src/capabilities/documents/handlers/TextHandler.ts
var CODE_FENCE_FORMATS, TextHandler;
var init_TextHandler = __esm({
  "src/capabilities/documents/handlers/TextHandler.ts"() {
    init_constants();
    CODE_FENCE_FORMATS = {
      json: "json",
      xml: "xml",
      yaml: "yaml",
      yml: "yaml"
    };
    TextHandler = class {
      name = "TextHandler";
      supportedFormats = ["txt", "md", "json", "xml", "yaml", "yml"];
      async handle(buffer, filename, format, _options) {
        const text = buffer.toString("utf-8");
        const fenceLanguage = CODE_FENCE_FORMATS[format];
        const content = fenceLanguage ? `\`\`\`${fenceLanguage}
${text}
\`\`\`` : text;
        const sizeBytes = Buffer.byteLength(content, "utf-8");
        return [
          {
            type: "text",
            content,
            metadata: {
              sourceFilename: filename,
              format,
              index: 0,
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
            }
          }
        ];
      }
    };
  }
});

// src/capabilities/documents/handlers/ImageHandler.ts
var MIME_TYPES, ImageHandler;
var init_ImageHandler = __esm({
  "src/capabilities/documents/handlers/ImageHandler.ts"() {
    init_constants();
    MIME_TYPES = {
      png: "image/png",
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      gif: "image/gif",
      webp: "image/webp",
      svg: "image/svg+xml"
    };
    ImageHandler = class {
      name = "ImageHandler";
      supportedFormats = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
      async handle(buffer, filename, format, _options) {
        const pieces = [];
        const mimeType = MIME_TYPES[format] || "application/octet-stream";
        pieces.push({
          type: "image",
          base64: buffer.toString("base64"),
          mimeType,
          metadata: {
            sourceFilename: filename,
            format,
            index: 0,
            sizeBytes: buffer.length,
            estimatedTokens: DOCUMENT_DEFAULTS.IMAGE_TOKENS_AUTO,
            label: filename
          }
        });
        if (format === "svg") {
          const svgText = buffer.toString("utf-8");
          const sizeBytes = Buffer.byteLength(svgText, "utf-8");
          pieces.push({
            type: "text",
            content: `\`\`\`svg
${svgText}
\`\`\``,
            metadata: {
              sourceFilename: filename,
              format,
              index: 1,
              section: "SVG source",
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
            }
          });
        }
        return pieces;
      }
    };
  }
});
async function getJSDOM() {
  if (!JSDOM) {
    const jsdom = await import('jsdom');
    JSDOM = jsdom.JSDOM;
  }
  return JSDOM;
}
async function htmlToMarkdown(html, url2, maxLength = 5e4) {
  const JSDOMClass = await getJSDOM();
  const dom = new JSDOMClass(html, { url: url2 });
  const document = dom.window.document;
  let title = document.title || "";
  let byline;
  let excerpt;
  let contentHtml = html;
  let wasReadabilityUsed = false;
  try {
    const clonedDoc = document.cloneNode(true);
    const reader = new readability.Readability(clonedDoc);
    const article = reader.parse();
    if (article && article.content && article.content.length > 100) {
      contentHtml = article.content;
      title = article.title || title;
      byline = article.byline || void 0;
      excerpt = article.excerpt || void 0;
      wasReadabilityUsed = true;
    }
  } catch {
  }
  const turndown = new TurndownService__default.default({
    headingStyle: "atx",
    codeBlockStyle: "fenced",
    bulletListMarker: "-",
    emDelimiter: "_"
  });
  turndown.remove(["script", "style", "nav", "footer", "aside", "iframe", "noscript"]);
  turndown.addRule("pre", {
    filter: ["pre"],
    replacement: (content, node) => {
      const element = node;
      const code = element.querySelector?.("code");
      const lang = code?.className?.match(/language-(\w+)/)?.[1] || "";
      const text = code?.textContent || content;
      return `
\`\`\`${lang}
${text}
\`\`\`
`;
    }
  });
  let markdown = turndown.turndown(contentHtml);
  markdown = markdown.replace(/\n{3,}/g, "\n\n").replace(/^\s+|\s+$/g, "").replace(/[ \t]+$/gm, "");
  let wasTruncated = false;
  if (markdown.length > maxLength) {
    const truncateAt = markdown.lastIndexOf("\n\n", maxLength);
    if (truncateAt > maxLength * 0.5) {
      markdown = markdown.slice(0, truncateAt) + "\n\n...[content truncated]";
    } else {
      markdown = markdown.slice(0, maxLength) + "...[truncated]";
    }
    wasTruncated = true;
  }
  return {
    markdown,
    title,
    byline,
    excerpt,
    wasReadabilityUsed,
    wasTruncated
  };
}
var JSDOM;
var init_htmlToMarkdown = __esm({
  "src/tools/web/htmlToMarkdown.ts"() {
    JSDOM = null;
  }
});

// src/capabilities/documents/handlers/HTMLHandler.ts
var HTMLHandler;
var init_HTMLHandler = __esm({
  "src/capabilities/documents/handlers/HTMLHandler.ts"() {
    init_constants();
    init_htmlToMarkdown();
    HTMLHandler = class {
      name = "HTMLHandler";
      supportedFormats = ["html"];
      async handle(buffer, filename, format, options) {
        const html = buffer.toString("utf-8");
        const maxLength = options.formatOptions?.html?.maxLength ?? DOCUMENT_DEFAULTS.MAX_HTML_LENGTH;
        const result = await htmlToMarkdown(html, `file://${filename}`, maxLength);
        const content = result.markdown;
        const sizeBytes = Buffer.byteLength(content, "utf-8");
        return [
          {
            type: "text",
            content,
            metadata: {
              sourceFilename: filename,
              format,
              index: 0,
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN),
              label: result.title || void 0
            }
          }
        ];
      }
    };
  }
});

// src/capabilities/documents/handlers/OfficeHandler.ts
async function getParseOffice() {
  if (!parseOffice) {
    const mod = await import('officeparser');
    parseOffice = mod.parseOffice;
  }
  return parseOffice;
}
var parseOffice, OfficeHandler;
var init_OfficeHandler = __esm({
  "src/capabilities/documents/handlers/OfficeHandler.ts"() {
    init_constants();
    parseOffice = null;
    OfficeHandler = class {
      name = "OfficeHandler";
      supportedFormats = ["docx", "pptx", "odt", "odp", "ods", "rtf"];
      async handle(buffer, filename, format, options) {
        const parse = await getParseOffice();
        const extractImages = options.extractImages !== false;
        const includeSpeakerNotes = options.formatOptions?.office?.includeSpeakerNotes !== false;
        const ast = await parse(buffer, {
          extractAttachments: extractImages,
          ignoreNotes: !includeSpeakerNotes
        });
        const pieces = [];
        let pieceIndex = 0;
        const content = ast.content || [];
        const markdown = this.astToMarkdown(content, format);
        if (format === "pptx" || format === "odp") {
          const slides = this.splitBySlides(content);
          for (let i = 0; i < slides.length; i++) {
            const slideContent = this.astToMarkdown(slides[i] ?? [], format);
            if (slideContent.trim()) {
              const sizeBytes = Buffer.byteLength(slideContent, "utf-8");
              pieces.push({
                type: "text",
                content: slideContent,
                metadata: {
                  sourceFilename: filename,
                  format,
                  index: pieceIndex++,
                  section: `Slide ${i + 1}`,
                  sizeBytes,
                  estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
                }
              });
            }
          }
        } else {
          if (markdown.trim()) {
            const sizeBytes = Buffer.byteLength(markdown, "utf-8");
            pieces.push({
              type: "text",
              content: markdown,
              metadata: {
                sourceFilename: filename,
                format,
                index: pieceIndex++,
                sizeBytes,
                estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
              }
            });
          }
        }
        if (extractImages && ast.attachments?.length > 0) {
          for (const attachment of ast.attachments) {
            if (attachment.type === "image" && attachment.data) {
              const imageData = attachment.data;
              const sizeBytes = Math.ceil(imageData.length * 0.75);
              pieces.push({
                type: "image",
                base64: imageData,
                mimeType: attachment.mimeType || "image/png",
                metadata: {
                  sourceFilename: filename,
                  format,
                  index: pieceIndex++,
                  sizeBytes,
                  estimatedTokens: DOCUMENT_DEFAULTS.IMAGE_TOKENS_AUTO,
                  label: attachment.altText || attachment.name || void 0
                }
              });
            }
          }
        }
        return pieces;
      }
      /**
       * Split AST content into slide groups
       */
      splitBySlides(content) {
        const slides = [];
        let currentSlide = [];
        for (const node of content) {
          if (node.type === "slide") {
            if (currentSlide.length > 0) {
              slides.push(currentSlide);
            }
            currentSlide = [node];
          } else {
            currentSlide.push(node);
          }
        }
        if (currentSlide.length > 0) {
          slides.push(currentSlide);
        }
        if (slides.length === 0 && content.length > 0) {
          slides.push(content);
        }
        return slides;
      }
      /**
       * Convert AST nodes to markdown
       */
      astToMarkdown(nodes, format) {
        const parts = [];
        for (const node of nodes) {
          const md = this.nodeToMarkdown(node, format);
          if (md) parts.push(md);
        }
        return parts.join("\n\n");
      }
      /**
       * Convert a single AST node to markdown
       */
      nodeToMarkdown(node, format) {
        if (!node) return "";
        switch (node.type) {
          case "heading": {
            const level = node.metadata?.level || 1;
            const prefix = "#".repeat(Math.min(level, 6));
            return `${prefix} ${node.text || ""}`;
          }
          case "paragraph":
            return this.formatText(node);
          case "text":
            return this.formatText(node);
          case "list": {
            const items = node.children || [];
            return items.map((item, i) => {
              const indent = "  ".repeat(node.metadata?.indentation || 0);
              const prefix = node.metadata?.listType === "ordered" ? `${i + 1}.` : "-";
              return `${indent}${prefix} ${item.text || this.getNodeText(item)}`;
            }).join("\n");
          }
          case "table": {
            return this.tableToMarkdown(node);
          }
          case "slide": {
            const slideNum = node.metadata?.slideNumber || "";
            const childContent = node.children ? node.children.map((c) => this.nodeToMarkdown(c, format)).filter(Boolean).join("\n\n") : node.text || "";
            return slideNum ? `### Slide ${slideNum}

${childContent}` : childContent;
          }
          case "note":
            return `> **Note:** ${node.text || this.getNodeText(node)}`;
          case "sheet": {
            const sheetName = node.metadata?.sheetName || "Sheet";
            const childContent = node.children ? node.children.map((c) => this.nodeToMarkdown(c, format)).filter(Boolean).join("\n") : "";
            return `## Sheet: ${sheetName}

${childContent}`;
          }
          case "page": {
            const pageNum = node.metadata?.pageNumber || "";
            const childContent = node.children ? node.children.map((c) => this.nodeToMarkdown(c, format)).filter(Boolean).join("\n\n") : node.text || "";
            return pageNum ? `--- Page ${pageNum} ---

${childContent}` : childContent;
          }
          case "image":
            return `[Image: ${node.metadata?.altText || node.metadata?.attachmentName || "embedded image"}]`;
          case "chart":
            return `[Chart: ${node.metadata?.attachmentName || "embedded chart"}]`;
          default:
            return node.text || this.getNodeText(node);
        }
      }
      /**
       * Get text from a node recursively
       */
      getNodeText(node) {
        if (node.text) return node.text;
        if (node.children) {
          return node.children.map((c) => this.getNodeText(c)).join("");
        }
        return "";
      }
      /**
       * Format text with markdown formatting
       */
      formatText(node) {
        if (!node.children || node.children.length === 0) {
          return node.text || "";
        }
        return node.children.map((child) => {
          let text = child.text || this.getNodeText(child);
          if (!text) return "";
          const fmt = child.formatting;
          if (fmt) {
            if (fmt.bold) text = `**${text}**`;
            if (fmt.italic) text = `_${text}_`;
            if (fmt.strikethrough) text = `~~${text}~~`;
          }
          if (child.metadata?.link && child.metadata?.linkType === "external") {
            text = `[${text}](${child.metadata.link})`;
          }
          return text;
        }).join("");
      }
      /**
       * Convert table node to markdown table
       */
      tableToMarkdown(node) {
        if (!node.children || node.children.length === 0) return "";
        const rows = [];
        for (const row of node.children) {
          if (row.type === "row" && row.children) {
            rows.push(row.children.map((cell) => {
              const text = cell.text || this.getNodeText(cell);
              return text.replace(/\|/g, "\\|").trim();
            }));
          }
        }
        if (rows.length === 0) return "";
        const maxCols = Math.max(...rows.map((r) => r.length));
        const normalizedRows = rows.map((r) => {
          while (r.length < maxCols) r.push("");
          return r;
        });
        const firstRow = normalizedRows[0] ?? [];
        const header = `| ${firstRow.join(" | ")} |`;
        const separator = `| ${firstRow.map(() => "---").join(" | ")} |`;
        const body = normalizedRows.slice(1).map((r) => `| ${r.join(" | ")} |`).join("\n");
        return body ? `${header}
${separator}
${body}` : `${header}
${separator}`;
      }
    };
  }
});

// src/capabilities/documents/handlers/ExcelHandler.ts
async function getExcelJS() {
  if (!ExcelJS) {
    ExcelJS = await import('exceljs');
  }
  return ExcelJS;
}
var ExcelJS, ExcelHandler;
var init_ExcelHandler = __esm({
  "src/capabilities/documents/handlers/ExcelHandler.ts"() {
    init_constants();
    ExcelJS = null;
    ExcelHandler = class {
      name = "ExcelHandler";
      supportedFormats = ["xlsx", "csv"];
      async handle(buffer, filename, format, options) {
        const exceljs = await getExcelJS();
        const Workbook = exceljs.Workbook || exceljs.default?.Workbook;
        const excelOpts = {
          maxRows: options.formatOptions?.excel?.maxRows ?? DOCUMENT_DEFAULTS.MAX_EXCEL_ROWS,
          maxColumns: options.formatOptions?.excel?.maxColumns ?? DOCUMENT_DEFAULTS.MAX_EXCEL_COLUMNS,
          tableFormat: options.formatOptions?.excel?.tableFormat ?? "markdown",
          includeFormulas: options.formatOptions?.excel?.includeFormulas ?? false
        };
        const workbook = new Workbook();
        if (format === "csv") {
          await workbook.csv.read(
            new (await import('stream')).Readable({
              read() {
                this.push(buffer);
                this.push(null);
              }
            })
          );
        } else {
          await workbook.xlsx.load(buffer);
        }
        const pieces = [];
        let pieceIndex = 0;
        const requestedSheets = options.pages;
        workbook.eachSheet((worksheet, sheetId) => {
          if (requestedSheets && requestedSheets.length > 0) {
            const isRequested = requestedSheets.some((p) => {
              if (typeof p === "number") return sheetId === p;
              return worksheet.name === p || String(sheetId) === p;
            });
            if (!isRequested) return;
          }
          const content = this.sheetToContent(worksheet, excelOpts);
          if (!content.trim()) return;
          const sheetContent = format === "csv" ? content : `## Sheet: ${worksheet.name}

${content}`;
          const sizeBytes = Buffer.byteLength(sheetContent, "utf-8");
          pieces.push({
            type: "text",
            content: sheetContent,
            metadata: {
              sourceFilename: filename,
              format,
              index: pieceIndex++,
              section: format === "csv" ? void 0 : worksheet.name,
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
            }
          });
        });
        return pieces;
      }
      /**
       * Convert a worksheet to the configured format
       */
      sheetToContent(worksheet, opts) {
        switch (opts.tableFormat) {
          case "csv":
            return this.sheetToCSV(worksheet, opts);
          case "json":
            return this.sheetToJSON(worksheet, opts);
          default:
            return this.sheetToMarkdownTable(worksheet, opts);
        }
      }
      /**
       * Convert worksheet to markdown table
       */
      sheetToMarkdownTable(worksheet, opts) {
        const rows = this.extractRows(worksheet, opts);
        if (rows.length === 0) return "";
        const maxCols = Math.min(
          Math.max(...rows.map((r) => r.length)),
          opts.maxColumns
        );
        const normalizedRows = rows.map((r) => {
          const truncated = r.slice(0, maxCols);
          while (truncated.length < maxCols) truncated.push("");
          return truncated;
        });
        const firstRow = normalizedRows[0] ?? [];
        const header = `| ${firstRow.join(" | ")} |`;
        const separator = `| ${firstRow.map(() => "---").join(" | ")} |`;
        const body = normalizedRows.slice(1).map((r) => `| ${r.join(" | ")} |`).join("\n");
        let result = `${header}
${separator}`;
        if (body) result += `
${body}`;
        if (worksheet.rowCount > opts.maxRows) {
          result += `

_...truncated (${worksheet.rowCount - opts.maxRows} more rows)_`;
        }
        return result;
      }
      /**
       * Convert worksheet to CSV
       */
      sheetToCSV(worksheet, opts) {
        const rows = this.extractRows(worksheet, opts);
        return rows.map(
          (row) => row.slice(0, opts.maxColumns).map((cell) => {
            if (cell.includes(",") || cell.includes('"') || cell.includes("\n")) {
              return `"${cell.replace(/"/g, '""')}"`;
            }
            return cell;
          }).join(",")
        ).join("\n");
      }
      /**
       * Convert worksheet to JSON
       */
      sheetToJSON(worksheet, opts) {
        const rows = this.extractRows(worksheet, opts);
        if (rows.length < 2) return "[]";
        const headers = (rows[0] ?? []).slice(0, opts.maxColumns);
        const data = rows.slice(1).map((row) => {
          const obj = {};
          headers.forEach((header, i) => {
            if (header && i < row.length) {
              obj[header] = row[i] ?? "";
            }
          });
          return obj;
        });
        return "```json\n" + JSON.stringify(data, null, 2) + "\n```";
      }
      /**
       * Extract rows from worksheet as string arrays
       */
      extractRows(worksheet, opts) {
        const rows = [];
        let rowCount = 0;
        worksheet.eachRow({ includeEmpty: false }, (row) => {
          if (rowCount >= opts.maxRows) return;
          rowCount++;
          const cells = [];
          row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
            if (colNumber > opts.maxColumns) return;
            let value = "";
            if (opts.includeFormulas && cell.formula) {
              value = `${this.getCellValue(cell)} (=${cell.formula})`;
            } else {
              value = this.getCellValue(cell);
            }
            while (cells.length < colNumber - 1) cells.push("");
            cells.push(value);
          });
          rows.push(cells);
        });
        return rows;
      }
      /**
       * Get cell value as string
       */
      getCellValue(cell) {
        if (cell.value === null || cell.value === void 0) return "";
        if (typeof cell.value === "object") {
          if (cell.value.richText) {
            return cell.value.richText.map((rt) => rt.text || "").join("");
          }
          if (cell.value.hyperlink) {
            return cell.value.text || cell.value.hyperlink;
          }
          if ("result" in cell.value) {
            return String(cell.value.result ?? "");
          }
          if (cell.value instanceof Date) {
            return cell.value.toISOString().split("T")[0];
          }
          return String(cell.value);
        }
        return String(cell.value).replace(/\|/g, "\\|");
      }
    };
  }
});

// src/capabilities/documents/handlers/PDFHandler.ts
async function getUnpdf() {
  if (!unpdfModule) {
    const mod = await import('unpdf');
    unpdfModule = {
      extractText: mod.extractText,
      extractImages: mod.extractImages,
      getMeta: mod.getMeta
    };
  }
  return unpdfModule;
}
var unpdfModule, PDFHandler;
var init_PDFHandler = __esm({
  "src/capabilities/documents/handlers/PDFHandler.ts"() {
    init_constants();
    unpdfModule = null;
    PDFHandler = class {
      name = "PDFHandler";
      supportedFormats = ["pdf"];
      async handle(buffer, filename, format, options) {
        const unpdf = await getUnpdf();
        const pieces = [];
        let pieceIndex = 0;
        let metadata = {};
        const includeMetadata = options.formatOptions?.pdf?.includeMetadata !== false;
        if (includeMetadata) {
          try {
            metadata = await unpdf.getMeta(buffer);
          } catch {
          }
        }
        const textResult = await unpdf.extractText(buffer, { mergePages: false });
        const pages = textResult?.pages || textResult?.text ? Array.isArray(textResult.text) ? textResult.text : [textResult.text] : [];
        const requestedPages = options.pages;
        const pageEntries = pages.map((text, i) => ({ text, pageNum: i + 1 }));
        const filteredPages = requestedPages && requestedPages.length > 0 ? pageEntries.filter(
          (p) => requestedPages.some((rp) => {
            const num = typeof rp === "string" ? parseInt(rp, 10) : rp;
            return num === p.pageNum;
          })
        ) : pageEntries;
        if (includeMetadata && metadata?.info) {
          const metaParts = [];
          if (metadata.info.Title) metaParts.push(`**Title:** ${metadata.info.Title}`);
          if (metadata.info.Author) metaParts.push(`**Author:** ${metadata.info.Author}`);
          if (metadata.info.Subject) metaParts.push(`**Subject:** ${metadata.info.Subject}`);
          if (metadata.info.Creator) metaParts.push(`**Creator:** ${metadata.info.Creator}`);
          if (pages.length) metaParts.push(`**Pages:** ${pages.length}`);
          if (metaParts.length > 0) {
            const metaContent = metaParts.join("\n");
            const sizeBytes = Buffer.byteLength(metaContent, "utf-8");
            pieces.push({
              type: "text",
              content: metaContent,
              metadata: {
                sourceFilename: filename,
                format,
                index: pieceIndex++,
                section: "Metadata",
                sizeBytes,
                estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
              }
            });
          }
        }
        for (const page of filteredPages) {
          const text = page.text.trim();
          if (!text) continue;
          const sizeBytes = Buffer.byteLength(text, "utf-8");
          pieces.push({
            type: "text",
            content: text,
            metadata: {
              sourceFilename: filename,
              format,
              index: pieceIndex++,
              section: `Page ${page.pageNum}`,
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
            }
          });
        }
        if (options.extractImages !== false) {
          try {
            const imagesResult = await unpdf.extractImages(buffer, {});
            const images = imagesResult?.images || [];
            for (const img of images) {
              if (!img.data) continue;
              const base64 = typeof img.data === "string" ? img.data : Buffer.from(img.data).toString("base64");
              const sizeBytes = Math.ceil(base64.length * 0.75);
              pieces.push({
                type: "image",
                base64,
                mimeType: img.mimeType || "image/png",
                width: img.width,
                height: img.height,
                metadata: {
                  sourceFilename: filename,
                  format,
                  index: pieceIndex++,
                  sizeBytes,
                  estimatedTokens: DOCUMENT_DEFAULTS.IMAGE_TOKENS_AUTO,
                  label: img.name || void 0
                }
              });
            }
          } catch {
          }
        }
        return pieces;
      }
    };
  }
});

// src/capabilities/documents/handlers/index.ts
var handlers_exports = {};
__export(handlers_exports, {
  ExcelHandler: () => ExcelHandler,
  HTMLHandler: () => HTMLHandler,
  ImageHandler: () => ImageHandler,
  OfficeHandler: () => OfficeHandler,
  PDFHandler: () => PDFHandler,
  TextHandler: () => TextHandler,
  getDefaultHandlers: () => getDefaultHandlers
});
function getDefaultHandlers() {
  return /* @__PURE__ */ new Map([
    ["text", new TextHandler()],
    ["image", new ImageHandler()],
    ["html", new HTMLHandler()],
    ["office", new OfficeHandler()],
    ["spreadsheet", new ExcelHandler()],
    ["pdf", new PDFHandler()]
  ]);
}
var init_handlers = __esm({
  "src/capabilities/documents/handlers/index.ts"() {
    init_TextHandler();
    init_ImageHandler();
    init_HTMLHandler();
    init_OfficeHandler();
    init_ExcelHandler();
    init_PDFHandler();
    init_TextHandler();
    init_ImageHandler();
    init_HTMLHandler();
    init_OfficeHandler();
    init_ExcelHandler();
    init_PDFHandler();
  }
});

// src/capabilities/documents/transformers/DefaultTransformers.ts
function normalizeTable(table) {
  const lines = table.trim().split("\n");
  if (lines.length < 2) return table;
  const rows = lines.map(
    (line) => line.split("|").slice(1, -1).map((cell) => cell.trim())
  );
  const colCount = Math.max(...rows.map((r) => r.length));
  const colWidths = new Array(colCount).fill(3);
  for (const row of rows) {
    for (let i = 0; i < row.length; i++) {
      const cell = row[i] ?? "";
      if (cell.match(/^[-:]+$/)) continue;
      colWidths[i] = Math.max(colWidths[i] ?? 3, cell.length);
    }
  }
  const result = rows.map((row, rowIndex) => {
    const cells = [];
    for (let i = 0; i < colCount; i++) {
      const cell = row[i] || "";
      if (rowIndex === 1) {
        cells.push("-".repeat(colWidths[i]));
      } else {
        cells.push(cell.padEnd(colWidths[i]));
      }
    }
    return `| ${cells.join(" | ")} |`;
  });
  return result.join("\n");
}
function getDefaultTransformers() {
  return [
    documentHeaderTransformer,
    tableFormattingTransformer,
    truncationTransformer
  ];
}
var documentHeaderTransformer, tableFormattingTransformer, truncationTransformer;
var init_DefaultTransformers = __esm({
  "src/capabilities/documents/transformers/DefaultTransformers.ts"() {
    init_constants();
    documentHeaderTransformer = {
      name: "documentHeaderTransformer",
      appliesTo: [],
      // applies to all formats
      priority: 10,
      async transform(pieces, context) {
        if (pieces.length === 0) return pieces;
        const totalSize = pieces.reduce((sum, p) => sum + p.metadata.sizeBytes, 0);
        const sizeStr = totalSize > 1024 * 1024 ? `${(totalSize / 1024 / 1024).toFixed(1)}MB` : `${(totalSize / 1024).toFixed(1)}KB`;
        const header = `# Document: ${context.filename}
_Format: ${context.format.toUpperCase()} | Size: ${sizeStr}_`;
        const headerBytes = Buffer.byteLength(header, "utf-8");
        const headerPiece = {
          type: "text",
          content: header,
          metadata: {
            sourceFilename: context.filename,
            format: context.format,
            index: -1,
            // will be re-indexed
            section: "Header",
            sizeBytes: headerBytes,
            estimatedTokens: Math.ceil(headerBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
          }
        };
        const result = [headerPiece, ...pieces];
        result.forEach((p, i) => {
          p.metadata.index = i;
        });
        return result;
      }
    };
    tableFormattingTransformer = {
      name: "tableFormattingTransformer",
      appliesTo: ["xlsx", "csv"],
      priority: 50,
      async transform(pieces, _context) {
        return pieces.map((piece) => {
          if (piece.type !== "text") return piece;
          let content = piece.content;
          content = content.replace(
            /(\|[^\n]+\|\n\|[\s\-:|]+\|\n(?:\|[^\n]+\|\n?)*)/g,
            (table) => normalizeTable(table)
          );
          if (content === piece.content) return piece;
          const sizeBytes = Buffer.byteLength(content, "utf-8");
          return {
            ...piece,
            content,
            metadata: {
              ...piece.metadata,
              sizeBytes,
              estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
            }
          };
        });
      }
    };
    truncationTransformer = {
      name: "truncationTransformer",
      appliesTo: [],
      // applies to all formats
      priority: 1e3,
      // runs last
      async transform(pieces, context) {
        const maxTokens = context.options.maxTokens ?? DOCUMENT_DEFAULTS.MAX_OUTPUT_TOKENS;
        const maxBytes = context.options.maxOutputBytes ?? DOCUMENT_DEFAULTS.MAX_OUTPUT_BYTES;
        let totalTokens = 0;
        let totalBytes = 0;
        const result = [];
        for (const piece of pieces) {
          totalTokens += piece.metadata.estimatedTokens;
          totalBytes += piece.metadata.sizeBytes;
          if (totalTokens > maxTokens || totalBytes > maxBytes) {
            if (piece.type === "text") {
              const remainingTokens = maxTokens - (totalTokens - piece.metadata.estimatedTokens);
              const remainingChars = remainingTokens * DOCUMENT_DEFAULTS.CHARS_PER_TOKEN;
              if (remainingChars > 100) {
                const content = piece.content;
                const truncateAt = content.lastIndexOf("\n\n", remainingChars);
                const cutPoint = truncateAt > remainingChars * 0.3 ? truncateAt : remainingChars;
                const truncated = content.slice(0, cutPoint) + "\n\n..._[content truncated]_";
                const sizeBytes = Buffer.byteLength(truncated, "utf-8");
                result.push({
                  ...piece,
                  content: truncated,
                  metadata: {
                    ...piece.metadata,
                    sizeBytes,
                    estimatedTokens: Math.ceil(sizeBytes / DOCUMENT_DEFAULTS.CHARS_PER_TOKEN)
                  }
                });
              }
            }
            break;
          }
          result.push(piece);
        }
        return result;
      }
    };
  }
});

// src/capabilities/documents/transformers/index.ts
var transformers_exports = {};
__export(transformers_exports, {
  documentHeaderTransformer: () => documentHeaderTransformer,
  getDefaultTransformers: () => getDefaultTransformers,
  tableFormattingTransformer: () => tableFormattingTransformer,
  truncationTransformer: () => truncationTransformer
});
var init_transformers = __esm({
  "src/capabilities/documents/transformers/index.ts"() {
    init_DefaultTransformers();
  }
});

// src/core/index.ts
init_Connector();
init_ScopedConnectorRegistry();
init_StorageRegistry();

// src/core/BaseAgent.ts
init_Connector();

// src/core/permissions/types.ts
var APPROVAL_STATE_VERSION = 1;
var DEFAULT_PERMISSION_CONFIG = {
  scope: "once",
  riskLevel: "low"
};
var DEFAULT_ALLOWLIST = [
  // Filesystem read-only tools
  "read_file",
  "glob",
  "grep",
  "list_directory",
  // Memory management (internal state - safe)
  "memory_store",
  "memory_retrieve",
  "memory_delete",
  "memory_query",
  "memory_cleanup_raw",
  // Context introspection (unified tool)
  "context_stats",
  // In-context memory tools
  "context_set",
  "context_delete",
  "context_list",
  // Persistent instructions tools
  "instructions_set",
  "instructions_remove",
  "instructions_list",
  "instructions_clear",
  // User info tools (user-specific data - safe)
  "user_info_set",
  "user_info_get",
  "user_info_remove",
  "user_info_clear",
  // Meta-tools (internal coordination)
  "_start_planning",
  "_modify_plan",
  "_report_progress",
  "_request_approval"
  // CRITICAL: Must be allowlisted to avoid circular dependency!
];

// src/core/permissions/ToolPermissionManager.ts
var ToolPermissionManager = class extends eventemitter3.EventEmitter {
  // Approval cache (session-level)
  approvalCache = /* @__PURE__ */ new Map();
  // Allow/block lists
  allowlist = /* @__PURE__ */ new Set();
  blocklist = /* @__PURE__ */ new Set();
  // Per-tool configurations
  toolConfigs = /* @__PURE__ */ new Map();
  // Defaults
  defaultScope;
  defaultRiskLevel;
  // Optional approval callback
  onApprovalRequired;
  constructor(config) {
    super();
    this.defaultScope = config?.defaultScope ?? DEFAULT_PERMISSION_CONFIG.scope;
    this.defaultRiskLevel = config?.defaultRiskLevel ?? DEFAULT_PERMISSION_CONFIG.riskLevel;
    for (const toolName of DEFAULT_ALLOWLIST) {
      this.allowlist.add(toolName);
    }
    if (config?.allowlist) {
      for (const toolName of config.allowlist) {
        this.allowlist.add(toolName);
      }
    }
    if (config?.blocklist) {
      for (const toolName of config.blocklist) {
        this.blocklist.add(toolName);
      }
    }
    if (config?.tools) {
      for (const [toolName, toolConfig] of Object.entries(config.tools)) {
        this.toolConfigs.set(toolName, toolConfig);
      }
    }
    this.onApprovalRequired = config?.onApprovalRequired;
  }
  // ==========================================================================
  // Core Permission Checking
  // ==========================================================================
  /**
   * Check if a tool needs approval before execution
   *
   * @param toolName - Name of the tool
   * @param _args - Optional arguments (for args-specific approval, reserved for future use)
   * @returns PermissionCheckResult with allowed/needsApproval/blocked status
   */
  checkPermission(toolName, _args) {
    const config = this.getEffectiveConfig(toolName);
    if (this.blocklist.has(toolName)) {
      return {
        allowed: false,
        needsApproval: false,
        blocked: true,
        reason: "Tool is blocklisted",
        config
      };
    }
    if (this.allowlist.has(toolName)) {
      return {
        allowed: true,
        needsApproval: false,
        blocked: false,
        reason: "Tool is allowlisted",
        config
      };
    }
    const scope = config.scope ?? this.defaultScope;
    switch (scope) {
      case "always":
        return {
          allowed: true,
          needsApproval: false,
          blocked: false,
          reason: 'Tool scope is "always"',
          config
        };
      case "never":
        return {
          allowed: false,
          needsApproval: false,
          blocked: true,
          reason: 'Tool scope is "never"',
          config
        };
      case "session":
        if (this.isApprovedForSession(toolName)) {
          return {
            allowed: true,
            needsApproval: false,
            blocked: false,
            reason: "Tool approved for session",
            config
          };
        }
        return {
          allowed: false,
          needsApproval: true,
          blocked: false,
          reason: "Session approval required",
          config
        };
      case "once":
      default:
        return {
          allowed: false,
          needsApproval: true,
          blocked: false,
          reason: "Per-call approval required",
          config
        };
    }
  }
  /**
   * Check if a tool call needs approval (uses ToolCall object)
   */
  needsApproval(toolCall) {
    const result = this.checkPermission(toolCall.function.name);
    return result.needsApproval;
  }
  /**
   * Check if a tool is blocked
   */
  isBlocked(toolName) {
    return this.checkPermission(toolName).blocked;
  }
  /**
   * Check if a tool is approved (either allowlisted or session-approved)
   */
  isApproved(toolName) {
    return this.checkPermission(toolName).allowed;
  }
  // ==========================================================================
  // Approval Management
  // ==========================================================================
  /**
   * Approve a tool (record approval)
   *
   * @param toolName - Name of the tool
   * @param decision - Approval decision with scope
   */
  approve(toolName, decision) {
    const scope = decision?.scope ?? "session";
    const config = this.getEffectiveConfig(toolName);
    let expiresAt;
    if (scope === "session" && config.sessionTTLMs) {
      expiresAt = new Date(Date.now() + config.sessionTTLMs);
    }
    const entry = {
      toolName,
      scope,
      approvedAt: /* @__PURE__ */ new Date(),
      approvedBy: decision?.approvedBy,
      expiresAt
    };
    this.approvalCache.set(toolName, entry);
    this.emit("tool:approved", {
      toolName,
      scope,
      approvedBy: decision?.approvedBy
    });
  }
  /**
   * Approve a tool for the entire session
   */
  approveForSession(toolName, approvedBy) {
    this.approve(toolName, { scope: "session", approvedBy });
  }
  /**
   * Revoke a tool's approval
   */
  revoke(toolName) {
    if (this.approvalCache.has(toolName)) {
      this.approvalCache.delete(toolName);
      this.emit("tool:revoked", { toolName });
    }
  }
  /**
   * Deny a tool execution (for audit trail)
   */
  deny(toolName, reason) {
    this.emit("tool:denied", { toolName, reason });
  }
  /**
   * Check if a tool has been approved for the current session
   */
  isApprovedForSession(toolName) {
    const entry = this.approvalCache.get(toolName);
    if (!entry) return false;
    if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
      this.approvalCache.delete(toolName);
      return false;
    }
    return entry.scope === "session" || entry.scope === "always";
  }
  // ==========================================================================
  // Allowlist / Blocklist Management
  // ==========================================================================
  /**
   * Add a tool to the allowlist (always allowed)
   */
  allowlistAdd(toolName) {
    this.blocklist.delete(toolName);
    this.allowlist.add(toolName);
    this.emit("allowlist:added", { toolName });
  }
  /**
   * Remove a tool from the allowlist
   */
  allowlistRemove(toolName) {
    if (this.allowlist.delete(toolName)) {
      this.emit("allowlist:removed", { toolName });
    }
  }
  /**
   * Check if a tool is in the allowlist
   */
  isAllowlisted(toolName) {
    return this.allowlist.has(toolName);
  }
  /**
   * Get all allowlisted tools
   */
  getAllowlist() {
    return Array.from(this.allowlist);
  }
  /**
   * Add a tool to the blocklist (always blocked)
   */
  blocklistAdd(toolName) {
    this.allowlist.delete(toolName);
    this.blocklist.add(toolName);
    this.emit("blocklist:added", { toolName });
  }
  /**
   * Remove a tool from the blocklist
   */
  blocklistRemove(toolName) {
    if (this.blocklist.delete(toolName)) {
      this.emit("blocklist:removed", { toolName });
    }
  }
  /**
   * Check if a tool is in the blocklist
   */
  isBlocklisted(toolName) {
    return this.blocklist.has(toolName);
  }
  /**
   * Get all blocklisted tools
   */
  getBlocklist() {
    return Array.from(this.blocklist);
  }
  // ==========================================================================
  // Tool Configuration
  // ==========================================================================
  /**
   * Set permission config for a specific tool
   */
  setToolConfig(toolName, config) {
    this.toolConfigs.set(toolName, config);
  }
  /**
   * Get permission config for a specific tool
   */
  getToolConfig(toolName) {
    return this.toolConfigs.get(toolName);
  }
  /**
   * Get effective config (tool-specific or defaults)
   */
  getEffectiveConfig(toolName) {
    const toolConfig = this.toolConfigs.get(toolName);
    return {
      scope: toolConfig?.scope ?? this.defaultScope,
      riskLevel: toolConfig?.riskLevel ?? this.defaultRiskLevel,
      approvalMessage: toolConfig?.approvalMessage,
      sensitiveArgs: toolConfig?.sensitiveArgs,
      sessionTTLMs: toolConfig?.sessionTTLMs
    };
  }
  // ==========================================================================
  // Approval Request Handler
  // ==========================================================================
  /**
   * Request approval for a tool call
   *
   * If an onApprovalRequired callback is set, it will be called.
   * Otherwise, this auto-approves for backward compatibility.
   *
   * NOTE: If you want to require explicit approval, you MUST either:
   * 1. Set onApprovalRequired callback in AgentPermissionsConfig
   * 2. Register an 'approve:tool' hook in the Agent
   * 3. Add tools to the blocklist if they should never run
   *
   * This auto-approval behavior preserves backward compatibility with
   * existing code that doesn't use the permission system.
   */
  async requestApproval(context) {
    if (this.onApprovalRequired) {
      const decision = await this.onApprovalRequired(context);
      if (decision.approved) {
        this.approve(context.toolCall.function.name, decision);
      } else {
        this.deny(context.toolCall.function.name, decision.reason ?? "User denied");
      }
      return decision;
    }
    return {
      approved: true,
      reason: "Auto-approved (no approval handler configured)"
    };
  }
  // ==========================================================================
  // Query Methods
  // ==========================================================================
  /**
   * Get all tools that have session approvals
   */
  getApprovedTools() {
    const approved = [];
    for (const [toolName, entry] of this.approvalCache) {
      if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
        continue;
      }
      approved.push(toolName);
    }
    return approved;
  }
  /**
   * Get the approval entry for a tool
   */
  getApprovalEntry(toolName) {
    const entry = this.approvalCache.get(toolName);
    if (!entry) return void 0;
    if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
      this.approvalCache.delete(toolName);
      return void 0;
    }
    return entry;
  }
  // ==========================================================================
  // Session Management
  // ==========================================================================
  /**
   * Clear all session approvals
   */
  clearSession() {
    this.approvalCache.clear();
    this.emit("session:cleared", {});
  }
  // ==========================================================================
  // Persistence (for Session integration)
  // ==========================================================================
  /**
   * Serialize approval state for persistence
   */
  getState() {
    const approvals = {};
    for (const [toolName, entry] of this.approvalCache) {
      if (entry.expiresAt && entry.expiresAt < /* @__PURE__ */ new Date()) {
        continue;
      }
      approvals[toolName] = {
        toolName: entry.toolName,
        scope: entry.scope,
        approvedAt: entry.approvedAt.toISOString(),
        approvedBy: entry.approvedBy,
        expiresAt: entry.expiresAt?.toISOString(),
        argsHash: entry.argsHash
      };
    }
    return {
      version: APPROVAL_STATE_VERSION,
      approvals,
      blocklist: Array.from(this.blocklist),
      allowlist: Array.from(this.allowlist)
    };
  }
  /**
   * Load approval state from persistence
   */
  loadState(state) {
    this.approvalCache.clear();
    if (state.version !== APPROVAL_STATE_VERSION) {
      console.warn(`ToolPermissionManager: Unknown state version ${state.version}, ignoring`);
      return;
    }
    for (const [toolName, entry] of Object.entries(state.approvals)) {
      const approvedAt = new Date(entry.approvedAt);
      const expiresAt = entry.expiresAt ? new Date(entry.expiresAt) : void 0;
      if (expiresAt && expiresAt < /* @__PURE__ */ new Date()) {
        continue;
      }
      this.approvalCache.set(toolName, {
        toolName: entry.toolName,
        scope: entry.scope,
        approvedAt,
        approvedBy: entry.approvedBy,
        expiresAt,
        argsHash: entry.argsHash
      });
    }
    for (const toolName of state.blocklist) {
      this.blocklist.add(toolName);
    }
    for (const toolName of state.allowlist) {
      this.blocklist.delete(toolName);
      this.allowlist.add(toolName);
    }
  }
  // ==========================================================================
  // Utility Methods
  // ==========================================================================
  /**
   * Get defaults
   */
  getDefaults() {
    return {
      scope: this.defaultScope,
      riskLevel: this.defaultRiskLevel
    };
  }
  /**
   * Set defaults
   */
  setDefaults(defaults) {
    if (defaults.scope) this.defaultScope = defaults.scope;
    if (defaults.riskLevel) this.defaultRiskLevel = defaults.riskLevel;
  }
  /**
   * Get summary statistics
   */
  getStats() {
    return {
      approvedCount: this.getApprovedTools().length,
      allowlistedCount: this.allowlist.size,
      blocklistedCount: this.blocklist.size,
      configuredCount: this.toolConfigs.size
    };
  }
  /**
   * Reset to initial state
   */
  reset() {
    this.approvalCache.clear();
    this.allowlist.clear();
    this.blocklist.clear();
    this.toolConfigs.clear();
    this.defaultScope = DEFAULT_PERMISSION_CONFIG.scope;
    this.defaultRiskLevel = DEFAULT_PERMISSION_CONFIG.riskLevel;
  }
};

// src/core/BaseAgent.ts
init_Logger();

// src/core/ToolManager.ts
init_CircuitBreaker();

// src/domain/errors/AIErrors.ts
var AIError = class _AIError extends Error {
  constructor(message, code, statusCode, originalError) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.originalError = originalError;
    this.name = "AIError";
    Object.setPrototypeOf(this, _AIError.prototype);
  }
};
var ProviderNotFoundError = class _ProviderNotFoundError extends AIError {
  constructor(providerName) {
    super(
      `Provider '${providerName}' not found. Did you configure it in OneRingAI constructor?`,
      "PROVIDER_NOT_FOUND",
      404
    );
    this.name = "ProviderNotFoundError";
    Object.setPrototypeOf(this, _ProviderNotFoundError.prototype);
  }
};
var ProviderAuthError = class _ProviderAuthError extends AIError {
  constructor(providerName, message = "Authentication failed") {
    super(
      `${providerName}: ${message}`,
      "PROVIDER_AUTH_ERROR",
      401
    );
    this.name = "ProviderAuthError";
    Object.setPrototypeOf(this, _ProviderAuthError.prototype);
  }
};
var ProviderRateLimitError = class _ProviderRateLimitError extends AIError {
  constructor(providerName, retryAfter) {
    super(
      `${providerName}: Rate limit exceeded${retryAfter ? `. Retry after ${retryAfter}ms` : ""}`,
      "PROVIDER_RATE_LIMIT",
      429
    );
    this.retryAfter = retryAfter;
    this.name = "ProviderRateLimitError";
    Object.setPrototypeOf(this, _ProviderRateLimitError.prototype);
  }
};
var ProviderContextLengthError = class _ProviderContextLengthError extends AIError {
  constructor(providerName, maxTokens, requestedTokens) {
    super(
      `${providerName}: Context length exceeded. Max: ${maxTokens}${requestedTokens ? `, Requested: ${requestedTokens}` : ""}`,
      "PROVIDER_CONTEXT_LENGTH_EXCEEDED",
      413
    );
    this.maxTokens = maxTokens;
    this.requestedTokens = requestedTokens;
    this.name = "ProviderContextLengthError";
    Object.setPrototypeOf(this, _ProviderContextLengthError.prototype);
  }
};
var ToolExecutionError = class _ToolExecutionError extends AIError {
  constructor(toolName, message, originalError) {
    super(
      `Tool '${toolName}' execution failed: ${message}`,
      "TOOL_EXECUTION_ERROR",
      500,
      originalError
    );
    this.originalError = originalError;
    this.name = "ToolExecutionError";
    Object.setPrototypeOf(this, _ToolExecutionError.prototype);
  }
};
var ToolTimeoutError = class _ToolTimeoutError extends AIError {
  constructor(toolName, timeoutMs) {
    super(
      `Tool '${toolName}' execution timed out after ${timeoutMs}ms`,
      "TOOL_TIMEOUT",
      408
    );
    this.timeoutMs = timeoutMs;
    this.name = "ToolTimeoutError";
    Object.setPrototypeOf(this, _ToolTimeoutError.prototype);
  }
};
var ToolNotFoundError = class _ToolNotFoundError extends AIError {
  constructor(toolName) {
    super(
      `Tool '${toolName}' not found. Did you register it with the agent?`,
      "TOOL_NOT_FOUND",
      404
    );
    this.name = "ToolNotFoundError";
    Object.setPrototypeOf(this, _ToolNotFoundError.prototype);
  }
};
var ModelNotSupportedError = class _ModelNotSupportedError extends AIError {
  constructor(providerName, model, capability) {
    super(
      `Model '${model}' from ${providerName} does not support ${capability}`,
      "MODEL_NOT_SUPPORTED",
      400
    );
    this.name = "ModelNotSupportedError";
    Object.setPrototypeOf(this, _ModelNotSupportedError.prototype);
  }
};
var InvalidConfigError = class _InvalidConfigError extends AIError {
  constructor(message) {
    super(message, "INVALID_CONFIG", 400);
    this.name = "InvalidConfigError";
    Object.setPrototypeOf(this, _InvalidConfigError.prototype);
  }
};
var InvalidToolArgumentsError = class _InvalidToolArgumentsError extends AIError {
  constructor(toolName, rawArguments, parseError) {
    super(
      `Invalid arguments for tool '${toolName}': ${parseError?.message || "Failed to parse JSON"}`,
      "INVALID_TOOL_ARGUMENTS",
      400,
      parseError
    );
    this.rawArguments = rawArguments;
    this.parseError = parseError;
    this.name = "InvalidToolArgumentsError";
    Object.setPrototypeOf(this, _InvalidToolArgumentsError.prototype);
  }
};
var ProviderError = class _ProviderError extends AIError {
  constructor(providerName, message, statusCode, originalError) {
    super(
      `${providerName}: ${message}`,
      "PROVIDER_ERROR",
      statusCode,
      originalError
    );
    this.providerName = providerName;
    this.name = "ProviderError";
    Object.setPrototypeOf(this, _ProviderError.prototype);
  }
};
var DependencyCycleError = class _DependencyCycleError extends AIError {
  constructor(cycle, planId) {
    super(
      `Dependency cycle detected: ${cycle.join(" -> ")}`,
      "DEPENDENCY_CYCLE",
      400
    );
    this.cycle = cycle;
    this.planId = planId;
    this.name = "DependencyCycleError";
    Object.setPrototypeOf(this, _DependencyCycleError.prototype);
  }
};
var TaskTimeoutError = class _TaskTimeoutError extends AIError {
  constructor(taskId, taskName, timeoutMs) {
    super(
      `Task '${taskName}' (${taskId}) timed out after ${timeoutMs}ms`,
      "TASK_TIMEOUT",
      408
    );
    this.taskId = taskId;
    this.taskName = taskName;
    this.timeoutMs = timeoutMs;
    this.name = "TaskTimeoutError";
    Object.setPrototypeOf(this, _TaskTimeoutError.prototype);
  }
};
var TaskValidationError = class _TaskValidationError extends AIError {
  constructor(taskId, taskName, reason) {
    super(
      `Task '${taskName}' (${taskId}) validation failed: ${reason}`,
      "TASK_VALIDATION_ERROR",
      422
    );
    this.taskId = taskId;
    this.taskName = taskName;
    this.reason = reason;
    this.name = "TaskValidationError";
    Object.setPrototypeOf(this, _TaskValidationError.prototype);
  }
};
var ParallelTasksError = class _ParallelTasksError extends AIError {
  constructor(failures) {
    const names = failures.map((f) => f.taskName).join(", ");
    super(
      `Multiple tasks failed in parallel execution: ${names}`,
      "PARALLEL_TASKS_ERROR",
      500
    );
    this.failures = failures;
    this.name = "ParallelTasksError";
    Object.setPrototypeOf(this, _ParallelTasksError.prototype);
  }
  /**
   * Get all failure errors
   */
  getErrors() {
    return this.failures.map((f) => f.error);
  }
  /**
   * Get failed task IDs
   */
  getFailedTaskIds() {
    return this.failures.map((f) => f.taskId);
  }
};
var DocumentReadError = class _DocumentReadError extends AIError {
  constructor(source, message, originalError) {
    super(
      `Failed to read document '${source}': ${message}`,
      "DOCUMENT_READ_ERROR",
      500,
      originalError
    );
    this.source = source;
    this.name = "DocumentReadError";
    Object.setPrototypeOf(this, _DocumentReadError.prototype);
  }
};
var UnsupportedFormatError = class _UnsupportedFormatError extends AIError {
  constructor(format, family) {
    super(
      `Unsupported document format: '${format}'${family ? ` (family: ${family})` : ""}`,
      "UNSUPPORTED_FORMAT",
      400
    );
    this.format = format;
    this.family = family;
    this.name = "UnsupportedFormatError";
    Object.setPrototypeOf(this, _UnsupportedFormatError.prototype);
  }
};
var ContextOverflowError = class _ContextOverflowError extends AIError {
  constructor(message, budget) {
    super(
      `Context overflow: ${message}. Actual: ${budget.actualTokens}, Max: ${budget.maxTokens}, Overage: ${budget.overageTokens}`,
      "CONTEXT_OVERFLOW",
      413
    );
    this.budget = budget;
    this.name = "ContextOverflowError";
    Object.setPrototypeOf(this, _ContextOverflowError.prototype);
  }
  /**
   * Get a formatted summary of what was tried
   */
  getDegradationSummary() {
    return this.budget.degradationLog.join("\n");
  }
  /**
   * Get the top token consumers
   */
  getTopConsumers(count = 5) {
    return Object.entries(this.budget.breakdown).map(([component, tokens]) => ({ component, tokens })).sort((a, b) => b.tokens - a.tokens).slice(0, count);
  }
};

// src/core/ToolManager.ts
init_Logger();
init_Metrics();

// src/core/tool-execution/ToolExecutionPipeline.ts
var DEFAULT_PRIORITY = 100;
var executionCounter = 0;
function generateExecutionId(useRandomUUID) {
  if (useRandomUUID && typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `exec_${Date.now()}_${++executionCounter}`;
}
function deepClone(value) {
  if (value === null || value === void 0) {
    return value;
  }
  if (typeof structuredClone === "function") {
    try {
      return structuredClone(value);
    } catch {
    }
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch {
    return value;
  }
}
var ToolExecutionPipeline = class {
  plugins = /* @__PURE__ */ new Map();
  sortedPlugins = [];
  useRandomUUID;
  constructor(options = {}) {
    this.useRandomUUID = options.useRandomUUID ?? true;
  }
  /**
   * Register a plugin with the pipeline.
   *
   * If a plugin with the same name is already registered, it will be
   * unregistered first (calling its onUnregister hook) and replaced.
   *
   * @param plugin - Plugin to register
   * @returns this for chaining
   */
  use(plugin) {
    if (this.plugins.has(plugin.name)) {
      this.remove(plugin.name);
    }
    this.plugins.set(plugin.name, plugin);
    this.rebuildSortedList();
    plugin.onRegister?.(this);
    return this;
  }
  /**
   * Remove a plugin by name.
   *
   * @param pluginName - Name of the plugin to remove
   * @returns true if the plugin was found and removed, false otherwise
   */
  remove(pluginName) {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      return false;
    }
    plugin.onUnregister?.();
    this.plugins.delete(pluginName);
    this.rebuildSortedList();
    return true;
  }
  /**
   * Check if a plugin is registered.
   *
   * @param pluginName - Name of the plugin to check
   */
  has(pluginName) {
    return this.plugins.has(pluginName);
  }
  /**
   * Get a registered plugin by name.
   *
   * @param pluginName - Name of the plugin to get
   */
  get(pluginName) {
    return this.plugins.get(pluginName);
  }
  /**
   * List all registered plugins, sorted by priority.
   */
  list() {
    return [...this.sortedPlugins];
  }
  /**
   * Execute a tool through the plugin pipeline.
   *
   * Execution phases:
   * 1. beforeExecute hooks (in priority order, lowest first)
   * 2. Tool execution (if not aborted)
   * 3. afterExecute hooks (in reverse priority order for proper unwinding)
   * 4. onError hooks if any phase fails
   *
   * @param tool - Tool function to execute
   * @param args - Arguments for the tool
   * @returns Result from tool execution (possibly transformed by plugins)
   */
  async execute(tool, args) {
    const ctx = {
      toolName: tool.definition.function.name,
      args,
      mutableArgs: deepClone(args),
      metadata: /* @__PURE__ */ new Map(),
      startTime: Date.now(),
      tool,
      executionId: generateExecutionId(this.useRandomUUID)
    };
    try {
      for (const plugin of this.sortedPlugins) {
        if (plugin.beforeExecute) {
          const hookResult = await plugin.beforeExecute(ctx);
          if (hookResult && "abort" in hookResult && hookResult.abort) {
            return hookResult.result;
          }
          if (hookResult && "modifiedArgs" in hookResult) {
            ctx.mutableArgs = hookResult.modifiedArgs;
          }
        }
      }
      let result = await tool.execute(ctx.mutableArgs);
      const reversedPlugins = [...this.sortedPlugins].reverse();
      for (const plugin of reversedPlugins) {
        if (plugin.afterExecute) {
          result = await plugin.afterExecute(ctx, result);
        }
      }
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      for (const plugin of this.sortedPlugins) {
        if (plugin.onError) {
          try {
            const recovered = await plugin.onError(ctx, err);
            if (recovered !== void 0) {
              return recovered;
            }
          } catch {
          }
        }
      }
      throw error;
    }
  }
  /**
   * Rebuild the sorted plugin list after registration changes.
   */
  rebuildSortedList() {
    this.sortedPlugins = [...this.plugins.values()].sort(
      (a, b) => (a.priority ?? DEFAULT_PRIORITY) - (b.priority ?? DEFAULT_PRIORITY)
    );
  }
};

// src/core/tool-execution/plugins/ResultNormalizerPlugin.ts
var ResultNormalizerPlugin = class {
  name = "result-normalizer";
  priority = 0;
  // Run LAST in afterExecute (reverse order)
  options;
  constructor(options = {}) {
    this.options = {
      wrapPrimitives: options.wrapPrimitives ?? false,
      addSuccessField: options.addSuccessField ?? false
    };
  }
  /**
   * Normalize result after all other plugins have processed it.
   * Converts undefined/null to error objects, optionally wraps primitives.
   */
  async afterExecute(ctx, result) {
    return this.normalize(result, ctx.toolName);
  }
  /**
   * Convert exceptions to error result objects (recovery).
   * This allows the tool call to return a valid result instead of throwing.
   */
  async onError(ctx, error) {
    return {
      success: false,
      error: error.message,
      errorType: error.name,
      toolName: ctx.toolName
    };
  }
  /**
   * Normalize a result to ensure it's valid and serializable.
   */
  normalize(result, toolName) {
    if (result === void 0 || result === null) {
      return {
        success: false,
        error: `Tool '${toolName}' returned no result`
      };
    }
    if (typeof result === "object" && "success" in result) {
      return result;
    }
    if (typeof result !== "object") {
      if (this.options.wrapPrimitives) {
        return { success: true, result };
      }
      return result;
    }
    if (this.options.addSuccessField) {
      return { success: true, ...result };
    }
    return result;
  }
};

// src/core/ToolManager.ts
var ToolManager = class extends eventemitter3.EventEmitter {
  registry = /* @__PURE__ */ new Map();
  namespaceIndex = /* @__PURE__ */ new Map();
  circuitBreakers = /* @__PURE__ */ new Map();
  toolLogger;
  _isDestroyed = false;
  pipeline;
  /** Optional tool context for execution (set by agent before runs) */
  _toolContext;
  /** Hard timeout for tool execution (0 = disabled) */
  _toolExecutionTimeout;
  constructor(config) {
    super();
    this._toolExecutionTimeout = config?.toolExecutionTimeout ?? 0;
    this.namespaceIndex.set("default", /* @__PURE__ */ new Set());
    this.toolLogger = exports.logger.child({ component: "ToolManager" });
    this.pipeline = new ToolExecutionPipeline();
    this.pipeline.use(new ResultNormalizerPlugin());
  }
  /**
   * Get or set the hard tool execution timeout in milliseconds.
   * 0 = disabled (relies on tool's own timeout).
   */
  get toolExecutionTimeout() {
    return this._toolExecutionTimeout;
  }
  set toolExecutionTimeout(value) {
    this._toolExecutionTimeout = Math.max(0, value);
  }
  /**
   * Access the execution pipeline for plugin management.
   *
   * Use this to register plugins that intercept and extend tool execution.
   *
   * @example
   * ```typescript
   * // Add logging plugin
   * toolManager.executionPipeline.use(new LoggingPlugin());
   *
   * // Add custom plugin
   * toolManager.executionPipeline.use({
   *   name: 'my-plugin',
   *   async afterExecute(ctx, result) {
   *     console.log(`${ctx.toolName} returned:`, result);
   *     return result;
   *   },
   * });
   * ```
   */
  get executionPipeline() {
    return this.pipeline;
  }
  /**
   * Returns true if destroy() has been called.
   */
  get isDestroyed() {
    return this._isDestroyed;
  }
  /**
   * Releases all resources held by this ToolManager.
   * Cleans up circuit breaker listeners and removes all event listeners.
   * Safe to call multiple times (idempotent).
   */
  destroy() {
    if (this._isDestroyed) {
      return;
    }
    this._isDestroyed = true;
    for (const breaker of this.circuitBreakers.values()) {
      breaker.removeAllListeners();
    }
    this.circuitBreakers.clear();
    this.registry.clear();
    this.namespaceIndex.clear();
    this.removeAllListeners();
  }
  /**
   * Set tool context for execution (called by agent before runs)
   */
  setToolContext(context) {
    this._toolContext = context;
  }
  /**
   * Get current tool context
   */
  getToolContext() {
    return this._toolContext;
  }
  // ==========================================================================
  // Registration
  // ==========================================================================
  /**
   * Register a tool with optional configuration
   */
  register(tool, options = {}) {
    const name = this.getToolName(tool);
    if (this.registry.has(name)) {
      const existing = this.registry.get(name);
      existing.tool = tool;
      if (options.enabled !== void 0) existing.enabled = options.enabled;
      if (options.namespace !== void 0) {
        this.moveToNamespace(name, existing.namespace, options.namespace);
        existing.namespace = options.namespace;
      }
      if (options.priority !== void 0) existing.priority = options.priority;
      if (options.conditions !== void 0) existing.conditions = options.conditions;
      if (options.permission !== void 0) existing.permission = options.permission;
      if (options.tags !== void 0) existing.tags = options.tags;
      if (options.category !== void 0) existing.category = options.category;
      if (options.source !== void 0) existing.source = options.source;
      return;
    }
    const namespace = options.namespace ?? "default";
    const effectivePermission = options.permission ?? tool.permission;
    const registration = {
      tool,
      enabled: options.enabled ?? true,
      namespace,
      priority: options.priority ?? 0,
      conditions: options.conditions ?? [],
      metadata: {
        registeredAt: /* @__PURE__ */ new Date(),
        usageCount: 0,
        totalExecutionMs: 0,
        avgExecutionMs: 0,
        successCount: 0,
        failureCount: 0
      },
      permission: effectivePermission,
      tags: options.tags,
      category: options.category,
      source: options.source
    };
    this.registry.set(name, registration);
    this.addToNamespace(name, namespace);
    this.emit("tool:registered", { name, namespace, enabled: registration.enabled });
  }
  /**
   * Register multiple tools at once
   */
  registerMany(tools, options = {}) {
    for (const tool of tools) {
      this.register(tool, options);
    }
  }
  /**
   * Unregister a tool by name
   */
  unregister(name) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    this.removeFromNamespace(name, registration.namespace);
    this.registry.delete(name);
    const breaker = this.circuitBreakers.get(name);
    if (breaker) {
      breaker.removeAllListeners();
      this.circuitBreakers.delete(name);
    }
    this.emit("tool:unregistered", { name });
    return true;
  }
  /**
   * Clear all tools and their circuit breakers.
   * Does NOT remove event listeners from this ToolManager (use destroy() for full cleanup).
   */
  clear() {
    this.registry.clear();
    this.namespaceIndex.clear();
    this.namespaceIndex.set("default", /* @__PURE__ */ new Set());
    for (const breaker of this.circuitBreakers.values()) {
      breaker.removeAllListeners();
    }
    this.circuitBreakers.clear();
  }
  // ==========================================================================
  // Enable/Disable
  // ==========================================================================
  /**
   * Enable a tool by name
   */
  enable(name) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    if (!registration.enabled) {
      registration.enabled = true;
      this.emit("tool:enabled", { name });
    }
    return true;
  }
  /**
   * Disable a tool by name (keeps it registered but inactive)
   */
  disable(name) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    if (registration.enabled) {
      registration.enabled = false;
      this.emit("tool:disabled", { name });
    }
    return true;
  }
  /**
   * Toggle a tool's enabled state
   */
  toggle(name) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    registration.enabled = !registration.enabled;
    this.emit(registration.enabled ? "tool:enabled" : "tool:disabled", { name });
    return registration.enabled;
  }
  /**
   * Check if a tool is enabled
   */
  isEnabled(name) {
    const registration = this.registry.get(name);
    return registration?.enabled ?? false;
  }
  /**
   * Set enabled state for multiple tools
   */
  setEnabled(names, enabled) {
    for (const name of names) {
      if (enabled) {
        this.enable(name);
      } else {
        this.disable(name);
      }
    }
  }
  // ==========================================================================
  // Namespaces
  // ==========================================================================
  /**
   * Set the namespace for a tool
   */
  setNamespace(toolName, namespace) {
    const registration = this.registry.get(toolName);
    if (!registration) return false;
    const oldNamespace = registration.namespace;
    if (oldNamespace === namespace) return true;
    this.moveToNamespace(toolName, oldNamespace, namespace);
    registration.namespace = namespace;
    return true;
  }
  /**
   * Enable all tools in a namespace
   */
  enableNamespace(namespace) {
    const tools = this.namespaceIndex.get(namespace);
    if (!tools) return;
    for (const name of tools) {
      this.enable(name);
    }
    this.emit("namespace:enabled", { namespace });
  }
  /**
   * Disable all tools in a namespace
   */
  disableNamespace(namespace) {
    const tools = this.namespaceIndex.get(namespace);
    if (!tools) return;
    for (const name of tools) {
      this.disable(name);
    }
    this.emit("namespace:disabled", { namespace });
  }
  /**
   * Get all namespace names
   */
  getNamespaces() {
    return Array.from(this.namespaceIndex.keys());
  }
  /**
   * Create a namespace with tools
   */
  createNamespace(namespace, tools, options = {}) {
    for (const tool of tools) {
      this.register(tool, { ...options, namespace });
    }
  }
  // ==========================================================================
  // Priority
  // ==========================================================================
  /**
   * Set priority for a tool
   */
  setPriority(name, priority) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    registration.priority = priority;
    return true;
  }
  /**
   * Get priority for a tool
   */
  getPriority(name) {
    return this.registry.get(name)?.priority;
  }
  /**
   * Get permission config for a tool
   */
  getPermission(name) {
    return this.registry.get(name)?.permission;
  }
  /**
   * Set permission config for a tool
   */
  setPermission(name, permission) {
    const registration = this.registry.get(name);
    if (!registration) return false;
    registration.permission = permission;
    return true;
  }
  // ==========================================================================
  // Query
  // ==========================================================================
  /**
   * Get a tool by name
   */
  get(name) {
    return this.registry.get(name)?.tool;
  }
  /**
   * Check if a tool exists
   */
  has(name) {
    return this.registry.has(name);
  }
  /**
   * Get all enabled tools (sorted by priority)
   */
  getEnabled() {
    return this.getSortedByPriority().filter((reg) => reg.enabled).map((reg) => reg.tool);
  }
  /**
   * Get all tools (enabled and disabled)
   */
  getAll() {
    return Array.from(this.registry.values()).map((reg) => reg.tool);
  }
  /**
   * Get tools by namespace
   */
  getByNamespace(namespace) {
    const toolNames = this.namespaceIndex.get(namespace);
    if (!toolNames) return [];
    return Array.from(toolNames).map((name) => this.registry.get(name)).filter((reg) => reg.enabled).sort((a, b) => b.priority - a.priority).map((reg) => reg.tool);
  }
  /**
   * Get tool registration info
   */
  getRegistration(name) {
    return this.registry.get(name);
  }
  /**
   * List all tool names
   */
  list() {
    return Array.from(this.registry.keys());
  }
  /**
   * List enabled tool names
   */
  listEnabled() {
    return Array.from(this.registry.entries()).filter(([_, reg]) => reg.enabled).map(([name]) => name);
  }
  /**
   * Get count of registered tools
   */
  get size() {
    return this.registry.size;
  }
  // ==========================================================================
  // Selection
  // ==========================================================================
  /**
   * Select tools based on context (uses conditions and smart filtering)
   */
  selectForContext(context) {
    const sorted = this.getSortedByPriority();
    const selected = [];
    for (const reg of sorted) {
      if (!reg.enabled) continue;
      if (reg.conditions.length > 0) {
        const allConditionsMet = reg.conditions.every((cond) => cond.predicate(context));
        if (!allConditionsMet) continue;
      }
      if (context.recentTools?.includes(this.getToolName(reg.tool))) {
        continue;
      }
      selected.push(reg.tool);
    }
    if (context.tokenBudget !== void 0) {
      return this.filterByTokenBudget(selected, context.tokenBudget);
    }
    return selected;
  }
  /**
   * Select tools by matching capability description
   */
  selectByCapability(description) {
    const lowerDesc = description.toLowerCase();
    const keywords = lowerDesc.split(/\s+/);
    return this.getEnabled().filter((tool) => {
      const toolDesc = (tool.definition.function.description ?? "").toLowerCase();
      const toolName = tool.definition.function.name.toLowerCase();
      return keywords.some((kw) => toolDesc.includes(kw) || toolName.includes(kw));
    });
  }
  /**
   * Filter tools to fit within a token budget
   */
  selectWithinBudget(budget) {
    return this.filterByTokenBudget(this.getEnabled(), budget);
  }
  // ==========================================================================
  // Execution Tracking
  // ==========================================================================
  /**
   * Record tool execution (called by agent/loop)
   */
  recordExecution(name, executionMs, success) {
    const registration = this.registry.get(name);
    if (!registration) return;
    const meta = registration.metadata;
    meta.usageCount++;
    meta.lastUsed = /* @__PURE__ */ new Date();
    meta.totalExecutionMs += executionMs;
    meta.avgExecutionMs = meta.totalExecutionMs / meta.usageCount;
    if (success) {
      meta.successCount++;
    } else {
      meta.failureCount++;
    }
    this.emit("tool:executed", {
      name,
      executionMs,
      success,
      totalUsage: meta.usageCount
    });
  }
  /**
   * Summarize tool result for logging (handles various result types)
   */
  summarizeResult(result) {
    if (result === null || result === void 0) {
      return { type: "null" };
    }
    if (typeof result !== "object") {
      return { type: typeof result, value: String(result).slice(0, 100) };
    }
    const obj = result;
    if ("success" in obj) {
      const summary = {
        success: obj.success
      };
      if ("error" in obj) summary.error = obj.error;
      if ("count" in obj) summary.count = obj.count;
      if ("results" in obj && Array.isArray(obj.results)) {
        summary.resultCount = obj.results.length;
      }
      if ("provider" in obj) summary.provider = obj.provider;
      return summary;
    }
    if (Array.isArray(result)) {
      return { type: "array", length: result.length };
    }
    const keys = Object.keys(obj);
    return {
      type: "object",
      keys: keys.slice(0, 10),
      keyCount: keys.length
    };
  }
  // ==========================================================================
  // Statistics
  // ==========================================================================
  /**
   * Get comprehensive statistics
   */
  getStats() {
    const registrations = Array.from(this.registry.values());
    const enabledCount = registrations.filter((r) => r.enabled).length;
    const toolsByNamespace = {};
    for (const [ns, tools] of this.namespaceIndex) {
      toolsByNamespace[ns] = tools.size;
    }
    const mostUsed = registrations.filter((r) => r.metadata.usageCount > 0).sort((a, b) => b.metadata.usageCount - a.metadata.usageCount).slice(0, 10).map((r) => ({
      name: this.getToolName(r.tool),
      count: r.metadata.usageCount
    }));
    const totalExecutions = registrations.reduce((sum, r) => sum + r.metadata.usageCount, 0);
    return {
      totalTools: this.registry.size,
      enabledTools: enabledCount,
      disabledTools: this.registry.size - enabledCount,
      namespaces: this.getNamespaces(),
      toolsByNamespace,
      mostUsed,
      totalExecutions
    };
  }
  // ==========================================================================
  // Execution (IToolExecutor implementation)
  // ==========================================================================
  /**
   * Execute a tool function with circuit breaker protection and plugin pipeline.
   * Implements IToolExecutor interface.
   *
   * Execution flow:
   * 1. Validate tool exists and is enabled
   * 2. Check circuit breaker state
   * 3. Run through plugin pipeline (beforeExecute -> execute -> afterExecute)
   * 4. Update metrics and circuit breaker state
   *
   * Simple execution - no caching, no parent context.
   * Context must be set via setToolContext() before calling.
   */
  async execute(toolName, args) {
    const registration = this.registry.get(toolName);
    if (!registration) {
      throw new ToolNotFoundError(toolName);
    }
    if (!registration.enabled) {
      throw new ToolExecutionError(toolName, "Tool is disabled");
    }
    const breaker = this.getOrCreateCircuitBreaker(toolName, registration);
    this.toolLogger.debug({ toolName, args }, "Tool execution started");
    const startTime = Date.now();
    exports.metrics.increment("tool.executed", 1, { tool: toolName });
    try {
      const executionPromise = breaker.execute(async () => {
        const toolWithContext = {
          ...registration.tool,
          execute: async (pipelineArgs) => {
            return await registration.tool.execute(pipelineArgs, this._toolContext);
          }
        };
        return await this.pipeline.execute(toolWithContext, args);
      });
      const result = this._toolExecutionTimeout > 0 ? await this.withHardTimeout(executionPromise, toolName, this._toolExecutionTimeout) : await executionPromise;
      const duration = Date.now() - startTime;
      this.recordExecution(toolName, duration, true);
      const resultSummary = this.summarizeResult(result);
      this.toolLogger.debug({
        toolName,
        duration,
        resultSummary
      }, "Tool execution completed");
      exports.metrics.timing("tool.duration", duration, { tool: toolName });
      exports.metrics.increment("tool.success", 1, { tool: toolName });
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.recordExecution(toolName, duration, false);
      this.toolLogger.error({
        toolName,
        error: error.message,
        duration
      }, "Tool execution failed");
      exports.metrics.increment("tool.failed", 1, {
        tool: toolName,
        error: error.name
      });
      throw new ToolExecutionError(
        toolName,
        error.message,
        error
      );
    }
  }
  /**
   * Check if tool is available (IToolExecutor interface)
   */
  hasToolFunction(toolName) {
    return this.registry.has(toolName);
  }
  /**
   * Get tool definition (IToolExecutor interface)
   */
  getToolDefinition(toolName) {
    const registration = this.registry.get(toolName);
    return registration?.tool.definition;
  }
  /**
   * Register a tool (IToolExecutor interface - delegates to register())
   */
  registerTool(tool) {
    this.register(tool);
  }
  /**
   * Unregister a tool (IToolExecutor interface - delegates to unregister())
   */
  unregisterTool(toolName) {
    this.unregister(toolName);
  }
  /**
   * List all registered tool names (IToolExecutor interface - delegates to list())
   */
  listTools() {
    return this.list();
  }
  // ==========================================================================
  // Hard Timeout
  // ==========================================================================
  /**
   * Wrap a promise with a hard timeout safety net.
   * If the promise doesn't resolve within the timeout, throws ToolExecutionError.
   */
  async withHardTimeout(promise, toolName, timeoutMs) {
    let timeoutId;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new ToolExecutionError(
          toolName,
          `Tool execution hard timeout after ${timeoutMs}ms (safety net - tool's own timeout may have failed)`
        ));
      }, timeoutMs);
    });
    try {
      return await Promise.race([promise, timeoutPromise]);
    } finally {
      clearTimeout(timeoutId);
    }
  }
  // ==========================================================================
  // Circuit Breaker Management
  // ==========================================================================
  /**
   * Get or create circuit breaker for a tool
   */
  getOrCreateCircuitBreaker(toolName, registration) {
    let breaker = this.circuitBreakers.get(toolName);
    if (!breaker) {
      const config = registration.circuitBreakerConfig || {
        failureThreshold: 3,
        successThreshold: 2,
        resetTimeoutMs: 6e4,
        // 1 minute
        windowMs: 3e5
        // 5 minutes
      };
      breaker = new exports.CircuitBreaker(`tool:${toolName}`, config);
      breaker.on("opened", (data) => {
        this.toolLogger.warn(data, `Circuit breaker opened for tool: ${toolName}`);
        exports.metrics.increment("circuit_breaker.opened", 1, {
          breaker: data.name,
          tool: toolName
        });
      });
      breaker.on("closed", (data) => {
        this.toolLogger.info(data, `Circuit breaker closed for tool: ${toolName}`);
        exports.metrics.increment("circuit_breaker.closed", 1, {
          breaker: data.name,
          tool: toolName
        });
      });
      this.circuitBreakers.set(toolName, breaker);
    }
    return breaker;
  }
  /**
   * Get circuit breaker states for all tools
   */
  getCircuitBreakerStates() {
    const states = /* @__PURE__ */ new Map();
    for (const [toolName, breaker] of this.circuitBreakers.entries()) {
      states.set(toolName, breaker.getState());
    }
    return states;
  }
  /**
   * Get circuit breaker metrics for a specific tool
   */
  getToolCircuitBreakerMetrics(toolName) {
    const breaker = this.circuitBreakers.get(toolName);
    return breaker?.getMetrics();
  }
  /**
   * Manually reset a tool's circuit breaker
   */
  resetToolCircuitBreaker(toolName) {
    const breaker = this.circuitBreakers.get(toolName);
    if (breaker) {
      breaker.reset();
      this.toolLogger.info({ toolName }, "Tool circuit breaker manually reset");
    }
  }
  /**
   * Configure circuit breaker for a tool
   */
  setCircuitBreakerConfig(toolName, config) {
    const registration = this.registry.get(toolName);
    if (!registration) return false;
    registration.circuitBreakerConfig = config;
    const existingBreaker = this.circuitBreakers.get(toolName);
    if (existingBreaker) {
      existingBreaker.removeAllListeners();
      this.circuitBreakers.delete(toolName);
    }
    return true;
  }
  // ==========================================================================
  // Persistence
  // ==========================================================================
  /**
   * Get serializable state (for session persistence)
   */
  getState() {
    const enabled = {};
    const namespaces = {};
    const priorities = {};
    const permissions = {};
    const tags = {};
    const categories = {};
    const sources = {};
    for (const [name, reg] of this.registry) {
      enabled[name] = reg.enabled;
      namespaces[name] = reg.namespace;
      priorities[name] = reg.priority;
      if (reg.permission) {
        permissions[name] = reg.permission;
      }
      if (reg.tags) {
        tags[name] = reg.tags;
      }
      if (reg.category) {
        categories[name] = reg.category;
      }
      if (reg.source) {
        sources[name] = reg.source;
      }
    }
    return { enabled, namespaces, priorities, permissions, tags, categories, sources };
  }
  /**
   * Load state (restores enabled/disabled, namespaces, priorities, permissions)
   * Note: Tools must be re-registered separately (they contain functions)
   */
  loadState(state) {
    for (const [name, isEnabled] of Object.entries(state.enabled)) {
      const reg = this.registry.get(name);
      if (reg) {
        reg.enabled = isEnabled;
      }
    }
    for (const [name, namespace] of Object.entries(state.namespaces)) {
      this.setNamespace(name, namespace);
    }
    for (const [name, priority] of Object.entries(state.priorities)) {
      this.setPriority(name, priority);
    }
    if (state.permissions) {
      for (const [name, permission] of Object.entries(state.permissions)) {
        this.setPermission(name, permission);
      }
    }
    if (state.tags) {
      for (const [name, toolTags] of Object.entries(state.tags)) {
        const reg = this.registry.get(name);
        if (reg) reg.tags = toolTags;
      }
    }
    if (state.categories) {
      for (const [name, category] of Object.entries(state.categories)) {
        const reg = this.registry.get(name);
        if (reg) reg.category = category;
      }
    }
    if (state.sources) {
      for (const [name, source] of Object.entries(state.sources)) {
        const reg = this.registry.get(name);
        if (reg) reg.source = source;
      }
    }
  }
  // ==========================================================================
  // Private Helpers
  // ==========================================================================
  getToolName(tool) {
    return tool.definition.function.name;
  }
  getSortedByPriority() {
    return Array.from(this.registry.values()).sort((a, b) => b.priority - a.priority);
  }
  addToNamespace(toolName, namespace) {
    if (!this.namespaceIndex.has(namespace)) {
      this.namespaceIndex.set(namespace, /* @__PURE__ */ new Set());
    }
    this.namespaceIndex.get(namespace).add(toolName);
  }
  removeFromNamespace(toolName, namespace) {
    this.namespaceIndex.get(namespace)?.delete(toolName);
  }
  moveToNamespace(toolName, oldNamespace, newNamespace) {
    this.removeFromNamespace(toolName, oldNamespace);
    this.addToNamespace(toolName, newNamespace);
  }
  filterByTokenBudget(tools, budget) {
    const result = [];
    let usedTokens = 0;
    for (const tool of tools) {
      const toolTokens = this.estimateToolTokens(tool);
      if (usedTokens + toolTokens <= budget) {
        result.push(tool);
        usedTokens += toolTokens;
      }
    }
    return result;
  }
  estimateToolTokens(tool) {
    const def = tool.definition.function;
    const nameTokens = Math.ceil((def.name?.length ?? 0) / 4);
    const descTokens = Math.ceil((def.description?.length ?? 0) / 4);
    const paramTokens = def.parameters ? Math.ceil(JSON.stringify(def.parameters).length / 4) : 0;
    return nameTokens + descTokens + paramTokens + 20;
  }
};

// src/core/Vendor.ts
var Vendor = {
  OpenAI: "openai",
  Anthropic: "anthropic",
  Google: "google",
  GoogleVertex: "google-vertex",
  Groq: "groq",
  Together: "together",
  Perplexity: "perplexity",
  Grok: "grok",
  DeepSeek: "deepseek",
  Mistral: "mistral",
  Ollama: "ollama",
  Custom: "custom"
  // OpenAI-compatible endpoint
};
var VENDORS = Object.values(Vendor);
function isVendor(value) {
  return VENDORS.includes(value);
}

// src/domain/entities/Model.ts
var LLM_MODELS = {
  [Vendor.OpenAI]: {
    // GPT-5.2 Series (Current Flagship)
    GPT_5_2: "gpt-5.2",
    GPT_5_2_PRO: "gpt-5.2-pro",
    // GPT-5 Series
    GPT_5: "gpt-5",
    GPT_5_MINI: "gpt-5-mini",
    GPT_5_NANO: "gpt-5-nano",
    // GPT-4.1 Series
    GPT_4_1: "gpt-4.1",
    GPT_4_1_MINI: "gpt-4.1-mini",
    GPT_4_1_NANO: "gpt-4.1-nano",
    // GPT-4o Series (Legacy, Audio Capable)
    GPT_4O: "gpt-4o",
    GPT_4O_MINI: "gpt-4o-mini",
    // Reasoning Models (o-series)
    O3_MINI: "o3-mini",
    O1: "o1"
  },
  [Vendor.Anthropic]: {
    // Claude 4.5 Series (Current)
    CLAUDE_OPUS_4_5: "claude-opus-4-5-20251101",
    CLAUDE_SONNET_4_5: "claude-sonnet-4-5-20250929",
    CLAUDE_HAIKU_4_5: "claude-haiku-4-5-20251001",
    // Claude 4.x Legacy
    CLAUDE_OPUS_4_1: "claude-opus-4-1-20250805",
    CLAUDE_SONNET_4: "claude-sonnet-4-20250514",
    CLAUDE_SONNET_3_7: "claude-3-7-sonnet-20250219",
    // Claude 3.x Legacy
    CLAUDE_HAIKU_3: "claude-3-haiku-20240307"
  },
  [Vendor.Google]: {
    // Gemini 3 Series (Preview)
    GEMINI_3_FLASH_PREVIEW: "gemini-3-flash-preview",
    GEMINI_3_PRO_PREVIEW: "gemini-3-pro-preview",
    GEMINI_3_PRO_IMAGE_PREVIEW: "gemini-3-pro-image-preview",
    // Gemini 2.5 Series (Production)
    GEMINI_2_5_PRO: "gemini-2.5-pro",
    GEMINI_2_5_FLASH: "gemini-2.5-flash",
    GEMINI_2_5_FLASH_LITE: "gemini-2.5-flash-lite",
    GEMINI_2_5_FLASH_IMAGE: "gemini-2.5-flash-image"
  },
  [Vendor.Grok]: {
    // Grok 4.1 Series (2M context, fast)
    GROK_4_1_FAST_REASONING: "grok-4-1-fast-reasoning",
    GROK_4_1_FAST_NON_REASONING: "grok-4-1-fast-non-reasoning",
    // Grok 4 Series
    GROK_4_FAST_REASONING: "grok-4-fast-reasoning",
    GROK_4_FAST_NON_REASONING: "grok-4-fast-non-reasoning",
    GROK_4_0709: "grok-4-0709",
    // Grok Code
    GROK_CODE_FAST_1: "grok-code-fast-1",
    // Grok 3 Series
    GROK_3: "grok-3",
    GROK_3_MINI: "grok-3-mini",
    // Grok 2 Series (Vision)
    GROK_2_VISION_1212: "grok-2-vision-1212"
  }
};
var MODEL_REGISTRY = {
  // ============================================================================
  // OpenAI Models (Verified from platform.openai.com)
  // ============================================================================
  // GPT-5.2 Series (Current Flagship)
  "gpt-5.2": {
    name: "gpt-5.2",
    provider: Vendor.OpenAI,
    description: "Flagship model for coding and agentic tasks. Reasoning.effort: none, low, medium, high, xhigh",
    isActive: true,
    releaseDate: "2025-12-01",
    knowledgeCutoff: "2025-08-31",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 4e5,
        text: true,
        image: true,
        cpm: 1.75
      },
      output: {
        tokens: 128e3,
        text: true,
        cpm: 14
      }
    }
  },
  "gpt-5.2-pro": {
    name: "gpt-5.2-pro",
    provider: Vendor.OpenAI,
    description: "GPT-5.2 pro produces smarter and more precise responses. Reasoning.effort: medium, high, xhigh",
    isActive: true,
    releaseDate: "2025-12-01",
    knowledgeCutoff: "2025-08-31",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 4e5,
        text: true,
        image: true,
        cpm: 21
      },
      output: {
        tokens: 128e3,
        text: true,
        cpm: 168
      }
    }
  },
  // GPT-5 Series
  "gpt-5": {
    name: "gpt-5",
    provider: Vendor.OpenAI,
    description: "Previous intelligent reasoning model for coding and agentic tasks. Reasoning.effort: minimal, low, medium, high",
    isActive: true,
    releaseDate: "2025-08-01",
    knowledgeCutoff: "2024-09-30",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 4e5,
        text: true,
        image: true,
        cpm: 1.25
      },
      output: {
        tokens: 128e3,
        text: true,
        cpm: 10
      }
    }
  },
  "gpt-5-mini": {
    name: "gpt-5-mini",
    provider: Vendor.OpenAI,
    description: "Faster, cost-efficient version of GPT-5 for well-defined tasks and precise prompts",
    isActive: true,
    releaseDate: "2025-08-01",
    knowledgeCutoff: "2024-05-31",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 4e5,
        text: true,
        image: true,
        cpm: 0.25
      },
      output: {
        tokens: 128e3,
        text: true,
        cpm: 2
      }
    }
  },
  "gpt-5-nano": {
    name: "gpt-5-nano",
    provider: Vendor.OpenAI,
    description: "Fastest, most cost-efficient GPT-5. Great for summarization and classification tasks",
    isActive: true,
    releaseDate: "2025-08-01",
    knowledgeCutoff: "2024-05-31",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 4e5,
        text: true,
        image: true,
        cpm: 0.05
      },
      output: {
        tokens: 128e3,
        text: true,
        cpm: 0.4
      }
    }
  },
  // GPT-4.1 Series
  "gpt-4.1": {
    name: "gpt-4.1",
    provider: Vendor.OpenAI,
    description: "GPT-4.1 specialized for coding with 1M token context window",
    isActive: true,
    releaseDate: "2025-04-14",
    knowledgeCutoff: "2025-04-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        cpm: 2
      },
      output: {
        tokens: 32768,
        text: true,
        cpm: 8
      }
    }
  },
  "gpt-4.1-mini": {
    name: "gpt-4.1-mini",
    provider: Vendor.OpenAI,
    description: "Efficient GPT-4.1 model, beats GPT-4o in many benchmarks at 83% lower cost",
    isActive: true,
    releaseDate: "2025-04-14",
    knowledgeCutoff: "2025-04-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        cpm: 0.4
      },
      output: {
        tokens: 16384,
        text: true,
        cpm: 1.6
      }
    }
  },
  "gpt-4.1-nano": {
    name: "gpt-4.1-nano",
    provider: Vendor.OpenAI,
    description: "Fastest and cheapest model with 1M context. 80.1% MMLU, ideal for classification/autocompletion",
    isActive: true,
    releaseDate: "2025-04-14",
    knowledgeCutoff: "2025-04-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        cpm: 0.1
      },
      output: {
        tokens: 16384,
        text: true,
        cpm: 0.4
      }
    }
  },
  // GPT-4o Series (Legacy, Audio Capable)
  "gpt-4o": {
    name: "gpt-4o",
    provider: Vendor.OpenAI,
    description: "Versatile omni model with audio support. Legacy but still available",
    isActive: true,
    releaseDate: "2024-05-13",
    knowledgeCutoff: "2024-04-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: true,
      realtime: true,
      vision: true,
      audio: true,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 128e3,
        text: true,
        image: true,
        audio: true,
        cpm: 2.5
      },
      output: {
        tokens: 16384,
        text: true,
        audio: true,
        cpm: 10
      }
    }
  },
  "gpt-4o-mini": {
    name: "gpt-4o-mini",
    provider: Vendor.OpenAI,
    description: "Fast, affordable omni model with audio support",
    isActive: true,
    releaseDate: "2024-07-18",
    knowledgeCutoff: "2024-04-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: true,
      predictedOutputs: false,
      realtime: true,
      vision: true,
      audio: true,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 128e3,
        text: true,
        image: true,
        audio: true,
        cpm: 0.15
      },
      output: {
        tokens: 16384,
        text: true,
        audio: true,
        cpm: 0.6
      }
    }
  },
  // Reasoning Models (o-series)
  "o3-mini": {
    name: "o3-mini",
    provider: Vendor.OpenAI,
    description: "Fast reasoning model tailored for coding, math, and science",
    isActive: true,
    releaseDate: "2025-01-31",
    knowledgeCutoff: "2024-10-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: false,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 1.1
      },
      output: {
        tokens: 1e5,
        text: true,
        cpm: 4.4
      }
    }
  },
  "o1": {
    name: "o1",
    provider: Vendor.OpenAI,
    description: "Advanced reasoning model for complex problems",
    isActive: true,
    releaseDate: "2024-12-17",
    knowledgeCutoff: "2024-10-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: false,
      parameters: {
        temperature: false,
        topP: false,
        frequencyPenalty: false,
        presencePenalty: false
      },
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 15
      },
      output: {
        tokens: 1e5,
        text: true,
        cpm: 60
      }
    }
  },
  // ============================================================================
  // Anthropic Models (Verified from platform.claude.com)
  // ============================================================================
  // Claude 4.5 Series (Current)
  "claude-opus-4-5-20251101": {
    name: "claude-opus-4-5-20251101",
    provider: Vendor.Anthropic,
    description: "Premium model combining maximum intelligence with practical performance",
    isActive: true,
    releaseDate: "2025-11-01",
    knowledgeCutoff: "2025-05-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 5,
        cpmCached: 0.5
      },
      output: {
        tokens: 64e3,
        text: true,
        cpm: 25
      }
    }
  },
  "claude-sonnet-4-5-20250929": {
    name: "claude-sonnet-4-5-20250929",
    provider: Vendor.Anthropic,
    description: "Smart model for complex agents and coding. Best balance of intelligence, speed, cost",
    isActive: true,
    releaseDate: "2025-09-29",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 3,
        cpmCached: 0.3
      },
      output: {
        tokens: 64e3,
        text: true,
        cpm: 15
      }
    }
  },
  "claude-haiku-4-5-20251001": {
    name: "claude-haiku-4-5-20251001",
    provider: Vendor.Anthropic,
    description: "Fastest model with near-frontier intelligence. Matches Sonnet 4 on coding",
    isActive: true,
    releaseDate: "2025-10-01",
    knowledgeCutoff: "2025-02-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 1,
        cpmCached: 0.1
      },
      output: {
        tokens: 64e3,
        text: true,
        cpm: 5
      }
    }
  },
  // Claude 4.x Legacy
  "claude-opus-4-1-20250805": {
    name: "claude-opus-4-1-20250805",
    provider: Vendor.Anthropic,
    description: "Legacy Opus 4.1 focused on agentic tasks, real-world coding, and reasoning",
    isActive: true,
    releaseDate: "2025-08-05",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 15,
        cpmCached: 1.5
      },
      output: {
        tokens: 32e3,
        text: true,
        cpm: 75
      }
    }
  },
  "claude-sonnet-4-20250514": {
    name: "claude-sonnet-4-20250514",
    provider: Vendor.Anthropic,
    description: "Legacy Sonnet 4. Default for most users, supports 1M context beta",
    isActive: true,
    releaseDate: "2025-05-14",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        // 1M with beta header
        text: true,
        image: true,
        cpm: 3,
        cpmCached: 0.3
      },
      output: {
        tokens: 64e3,
        text: true,
        cpm: 15
      }
    }
  },
  "claude-3-7-sonnet-20250219": {
    name: "claude-3-7-sonnet-20250219",
    provider: Vendor.Anthropic,
    description: "Claude 3.7 Sonnet with extended thinking, supports 128K output beta",
    isActive: true,
    releaseDate: "2025-02-19",
    knowledgeCutoff: "2024-10-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 3,
        cpmCached: 0.3
      },
      output: {
        tokens: 64e3,
        // 128K with beta header
        text: true,
        cpm: 15
      }
    }
  },
  // Claude 3.x Legacy
  "claude-3-haiku-20240307": {
    name: "claude-3-haiku-20240307",
    provider: Vendor.Anthropic,
    description: "Fast legacy model. Recommend migrating to Haiku 4.5",
    isActive: true,
    releaseDate: "2024-03-07",
    knowledgeCutoff: "2023-08-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      extendedThinking: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 2e5,
        text: true,
        image: true,
        cpm: 0.25,
        cpmCached: 0.03
      },
      output: {
        tokens: 4096,
        text: true,
        cpm: 1.25
      }
    }
  },
  // ============================================================================
  // Google Models (Verified from ai.google.dev)
  // ============================================================================
  // Gemini 3 Series (Preview)
  "gemini-3-flash-preview": {
    name: "gemini-3-flash-preview",
    provider: Vendor.Google,
    description: "Pro-grade reasoning with Flash-level latency and efficiency",
    isActive: true,
    releaseDate: "2025-11-18",
    knowledgeCutoff: "2025-08-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: true,
      video: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        audio: true,
        video: true,
        cpm: 0.15
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.6
      }
    }
  },
  "gemini-3-pro-preview": {
    name: "gemini-3-pro-preview",
    provider: Vendor.Google,
    description: "Most advanced reasoning Gemini model for complex tasks",
    isActive: true,
    releaseDate: "2025-11-18",
    knowledgeCutoff: "2025-08-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: true,
      video: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        audio: true,
        video: true,
        cpm: 1.25
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 10
      }
    }
  },
  "gemini-3-pro-image-preview": {
    name: "gemini-3-pro-image-preview",
    provider: Vendor.Google,
    description: "Highest quality image generation model",
    isActive: true,
    releaseDate: "2025-11-18",
    knowledgeCutoff: "2025-08-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: false,
      functionCalling: false,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        cpm: 1.25
      },
      output: {
        tokens: 65536,
        text: true,
        image: true,
        cpm: 10
      }
    }
  },
  // Gemini 2.5 Series (Production)
  "gemini-2.5-pro": {
    name: "gemini-2.5-pro",
    provider: Vendor.Google,
    description: "Advanced multimodal model built for deep reasoning and agents",
    isActive: true,
    releaseDate: "2025-03-01",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: true,
      video: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        audio: true,
        video: true,
        cpm: 1.25
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 10
      }
    }
  },
  "gemini-2.5-flash": {
    name: "gemini-2.5-flash",
    provider: Vendor.Google,
    description: "Fast, cost-effective model with excellent reasoning",
    isActive: true,
    releaseDate: "2025-06-17",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: true,
      video: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        audio: true,
        video: true,
        cpm: 0.15
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.6
      }
    }
  },
  "gemini-2.5-flash-lite": {
    name: "gemini-2.5-flash-lite",
    provider: Vendor.Google,
    description: "Lowest latency for high-volume tasks, summarization, classification",
    isActive: true,
    releaseDate: "2025-06-17",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: true,
      video: true,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        audio: true,
        video: true,
        cpm: 0.075
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.3
      }
    }
  },
  "gemini-2.5-flash-image": {
    name: "gemini-2.5-flash-image",
    provider: Vendor.Google,
    description: "Image generation and editing model",
    isActive: true,
    releaseDate: "2025-09-01",
    knowledgeCutoff: "2025-01-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: false,
      functionCalling: false,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: true,
      promptCaching: true,
      input: {
        tokens: 1e6,
        text: true,
        image: true,
        cpm: 0.15
      },
      output: {
        tokens: 65536,
        text: true,
        image: true,
        cpm: 0.6
      }
    }
  },
  // ============================================================================
  // xAI Grok Models (Verified from docs.x.ai - January 2026)
  // ============================================================================
  // Grok 4.1 Series (2M context, fast)
  "grok-4-1-fast-reasoning": {
    name: "grok-4-1-fast-reasoning",
    provider: Vendor.Grok,
    description: "Fast Grok 4.1 with reasoning capabilities, 2M context window, vision support",
    isActive: true,
    releaseDate: "2025-11-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 2e6,
        text: true,
        image: true,
        cpm: 0.2
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.5
      }
    }
  },
  "grok-4-1-fast-non-reasoning": {
    name: "grok-4-1-fast-non-reasoning",
    provider: Vendor.Grok,
    description: "Fast Grok 4.1 without reasoning, 2M context window, vision support",
    isActive: true,
    releaseDate: "2025-11-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 2e6,
        text: true,
        image: true,
        cpm: 0.2
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.5
      }
    }
  },
  // Grok Code Series
  "grok-code-fast-1": {
    name: "grok-code-fast-1",
    provider: Vendor.Grok,
    description: "Specialized coding model with reasoning capabilities, 256K context",
    isActive: true,
    releaseDate: "2025-10-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: false,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 256e3,
        text: true,
        cpm: 0.2
      },
      output: {
        tokens: 32768,
        text: true,
        cpm: 1.5
      }
    }
  },
  // Grok 4 Series
  "grok-4-fast-reasoning": {
    name: "grok-4-fast-reasoning",
    provider: Vendor.Grok,
    description: "Fast Grok 4 with reasoning capabilities, 2M context window",
    isActive: true,
    releaseDate: "2025-09-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: true,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: false,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 2e6,
        text: true,
        cpm: 0.2
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.5
      }
    }
  },
  "grok-4-fast-non-reasoning": {
    name: "grok-4-fast-non-reasoning",
    provider: Vendor.Grok,
    description: "Fast Grok 4 without reasoning, 2M context window, vision support",
    isActive: true,
    releaseDate: "2025-09-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 2e6,
        text: true,
        image: true,
        cpm: 0.2
      },
      output: {
        tokens: 65536,
        text: true,
        cpm: 0.5
      }
    }
  },
  "grok-4-0709": {
    name: "grok-4-0709",
    provider: Vendor.Grok,
    description: "Grok 4 flagship model (July 2025 release), 256K context, vision support",
    isActive: true,
    releaseDate: "2025-07-09",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 256e3,
        text: true,
        image: true,
        cpm: 3
      },
      output: {
        tokens: 32768,
        text: true,
        cpm: 15
      }
    }
  },
  // Grok 3 Series
  "grok-3-mini": {
    name: "grok-3-mini",
    provider: Vendor.Grok,
    description: "Lightweight, cost-efficient model for simpler tasks, 131K context",
    isActive: true,
    releaseDate: "2025-06-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: false,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 131072,
        text: true,
        cpm: 0.3
      },
      output: {
        tokens: 32768,
        text: true,
        cpm: 0.5
      }
    }
  },
  "grok-3": {
    name: "grok-3",
    provider: Vendor.Grok,
    description: "Production model for general-purpose tasks, 131K context",
    isActive: true,
    releaseDate: "2025-06-01",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: false,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 131072,
        text: true,
        cpm: 3
      },
      output: {
        tokens: 32768,
        text: true,
        cpm: 15
      }
    }
  },
  // Grok 2 Series (Vision)
  "grok-2-vision-1212": {
    name: "grok-2-vision-1212",
    provider: Vendor.Grok,
    description: "Vision-capable model for image understanding, 32K context",
    isActive: true,
    releaseDate: "2024-12-12",
    knowledgeCutoff: "2024-11-01",
    features: {
      reasoning: false,
      streaming: true,
      structuredOutput: true,
      functionCalling: true,
      fineTuning: false,
      predictedOutputs: false,
      realtime: false,
      vision: true,
      audio: false,
      video: false,
      batchAPI: false,
      promptCaching: false,
      input: {
        tokens: 32768,
        text: true,
        image: true,
        cpm: 2
      },
      output: {
        tokens: 8192,
        text: true,
        cpm: 10
      }
    }
  }
};
function getModelInfo(modelName) {
  return MODEL_REGISTRY[modelName];
}
function getModelsByVendor(vendor) {
  return Object.values(MODEL_REGISTRY).filter((model) => model.provider === vendor);
}
function getActiveModels() {
  return Object.values(MODEL_REGISTRY).filter((model) => model.isActive);
}
function calculateCost(model, inputTokens, outputTokens, options) {
  const modelInfo = getModelInfo(model);
  if (!modelInfo) {
    return null;
  }
  const inputCPM = options?.useCachedInput && modelInfo.features.input.cpmCached !== void 0 ? modelInfo.features.input.cpmCached : modelInfo.features.input.cpm;
  const outputCPM = modelInfo.features.output.cpm;
  const inputCost = inputTokens / 1e6 * inputCPM;
  const outputCost = outputTokens / 1e6 * outputCPM;
  return inputCost + outputCost;
}

// src/domain/entities/Message.ts
var MessageRole = /* @__PURE__ */ ((MessageRole2) => {
  MessageRole2["USER"] = "user";
  MessageRole2["ASSISTANT"] = "assistant";
  MessageRole2["DEVELOPER"] = "developer";
  return MessageRole2;
})(MessageRole || {});

// src/domain/entities/Content.ts
var ContentType = /* @__PURE__ */ ((ContentType2) => {
  ContentType2["INPUT_TEXT"] = "input_text";
  ContentType2["INPUT_IMAGE_URL"] = "input_image_url";
  ContentType2["INPUT_FILE"] = "input_file";
  ContentType2["OUTPUT_TEXT"] = "output_text";
  ContentType2["TOOL_USE"] = "tool_use";
  ContentType2["TOOL_RESULT"] = "tool_result";
  return ContentType2;
})(ContentType || {});

// src/core/context-nextgen/BasePluginNextGen.ts
init_constants();
var simpleTokenEstimator = {
  estimateTokens(text) {
    if (!text || text.length === 0) return 0;
    return Math.ceil(text.length / TOKEN_ESTIMATION.MIXED_CHARS_PER_TOKEN);
  },
  estimateDataTokens(data) {
    const text = typeof data === "string" ? data : JSON.stringify(data);
    return this.estimateTokens(text);
  },
  estimateImageTokens(width, height, detail) {
    if (detail === "low") return 85;
    if (width && height) {
      const tiles = Math.ceil(width / 512) * Math.ceil(height / 512);
      return 85 + 170 * tiles;
    }
    return 1e3;
  }
};
var BasePluginNextGen = class {
  /**
   * Cached token size for content.
   * Updated via updateTokenCache(), cleared via invalidateTokenCache().
   */
  _contentTokenCache = null;
  /**
   * Cached token size for instructions.
   * Computed once on first call to getInstructionsTokenSize().
   */
  _instructionsTokenCache = null;
  /**
   * Token estimator instance.
   * Override this in subclass to use a custom estimator (e.g., tiktoken).
   *
   * @example
   * ```typescript
   * class MyPlugin extends BasePluginNextGen {
   *   protected estimator = myCustomTiktokenEstimator;
   * }
   * ```
   */
  estimator = simpleTokenEstimator;
  // ============================================================================
  // Token size tracking
  // ============================================================================
  /**
   * Get current token size of content.
   *
   * Returns the cached value from the last `updateTokenCache()` call.
   * Returns 0 if cache is null (content hasn't been calculated yet).
   *
   * **Note:** This is synchronous but `getContent()` is async. Plugins
   * should call `updateTokenCache()` in their `getContent()` implementation
   * to keep the cache accurate.
   *
   * @returns Cached token count (0 if cache not set)
   */
  getTokenSize() {
    if (this._contentTokenCache === null) {
      return 0;
    }
    return this._contentTokenCache;
  }
  /**
   * Get token size of instructions (cached after first call).
   *
   * Instructions are static, so this is computed once and cached permanently.
   * The cache is never invalidated since instructions don't change.
   *
   * @returns Token count for instructions (0 if no instructions)
   */
  getInstructionsTokenSize() {
    if (this._instructionsTokenCache === null) {
      const instructions = this.getInstructions();
      this._instructionsTokenCache = instructions ? this.estimator.estimateTokens(instructions) : 0;
    }
    return this._instructionsTokenCache;
  }
  /**
   * Invalidate the content token cache.
   *
   * Call this when plugin state changes in a way that affects content size.
   * The next call to `getTokenSize()` will return 0 until `updateTokenCache()`
   * is called (typically in `getContent()`).
   *
   * @example
   * ```typescript
   * delete(key: string): boolean {
   *   const deleted = this._entries.delete(key);
   *   if (deleted) {
   *     this.invalidateTokenCache();  // Content changed
   *   }
   *   return deleted;
   * }
   * ```
   */
  invalidateTokenCache() {
    this._contentTokenCache = null;
  }
  /**
   * Update the content token cache with a new value.
   *
   * Call this in `getContent()` after formatting content, passing the
   * estimated token count. This keeps budget calculations accurate.
   *
   * @param tokens - New token count to cache
   *
   * @example
   * ```typescript
   * async getContent(): Promise<string | null> {
   *   const content = this.formatEntries();
   *   this.updateTokenCache(this.estimator.estimateTokens(content));
   *   return content;
   * }
   * ```
   */
  updateTokenCache(tokens) {
    this._contentTokenCache = tokens;
  }
  /**
   * Recalculate and cache token size from current content.
   *
   * Convenience method that calls `getContent()`, estimates tokens,
   * and updates the cache. Use this when you need to immediately
   * refresh the cache after a state change.
   *
   * @returns Calculated token count
   *
   * @example
   * ```typescript
   * async store(key: string, value: unknown): Promise<void> {
   *   this._entries.set(key, value);
   *   await this.recalculateTokenCache();  // Refresh immediately
   * }
   * ```
   */
  async recalculateTokenCache() {
    const content = await this.getContent();
    const tokens = content ? this.estimator.estimateTokens(content) : 0;
    this._contentTokenCache = tokens;
    return tokens;
  }
  // ============================================================================
  // Default implementations
  // ============================================================================
  /**
   * Default: not compactable.
   *
   * Override to return `true` if your plugin can reduce its content size
   * when context is tight. Also implement `compact()` to handle the actual
   * compaction logic.
   *
   * @returns false by default
   */
  isCompactable() {
    return false;
  }
  /**
   * Default: no compaction (returns 0).
   *
   * Override to implement compaction logic. Should attempt to free
   * approximately `targetTokensToFree` tokens. Remember to call
   * `invalidateTokenCache()` after modifying content.
   *
   * @param _targetTokensToFree - Approximate tokens to free (best effort)
   * @returns 0 by default (no tokens freed)
   *
   * @example
   * ```typescript
   * async compact(targetTokensToFree: number): Promise<number> {
   *   let freed = 0;
   *   // Remove entries by priority until target reached
   *   for (const [key, entry] of this.sortedByPriority()) {
   *     if (entry.priority === 'critical') continue;
   *     if (freed >= targetTokensToFree) break;
   *     freed += entry.tokens;
   *     this._entries.delete(key);
   *   }
   *   this.invalidateTokenCache();
   *   return freed;
   * }
   * ```
   */
  async compact(_targetTokensToFree) {
    return 0;
  }
  /**
   * Default: no tools (returns empty array).
   *
   * Override to provide plugin-specific tools. Tools are auto-registered
   * with ToolManager when the plugin is added to the context.
   *
   * Use a consistent naming convention: `<prefix>_<action>`
   * - `memory_store`, `memory_retrieve`, `memory_delete`
   * - `context_set`, `context_delete`, `context_list`
   *
   * @returns Empty array by default
   */
  getTools() {
    return [];
  }
  /**
   * Default: no-op cleanup.
   *
   * Override if your plugin has resources to release (file handles,
   * timers, connections, etc.). Called when context is destroyed.
   */
  destroy() {
  }
  /**
   * Default: returns empty object.
   *
   * Override to serialize plugin state for session persistence.
   * Return a JSON-serializable object. Consider including a version
   * number for future migration support.
   *
   * @returns Empty object by default
   *
   * @example
   * ```typescript
   * getState(): unknown {
   *   return {
   *     version: 1,
   *     entries: [...this._entries].map(([k, v]) => ({ key: k, ...v })),
   *   };
   * }
   * ```
   */
  getState() {
    return {};
  }
  /**
   * Default: no-op (ignores state).
   *
   * Override to restore plugin state from saved session. The state
   * comes from a previous `getState()` call.
   *
   * **IMPORTANT:** Call `invalidateTokenCache()` after restoring state
   * to ensure token counts are recalculated on next `getContent()` call.
   *
   * @param _state - Previously serialized state from getState()
   *
   * @example
   * ```typescript
   * restoreState(state: unknown): void {
   *   const s = state as { entries: Array<{ key: string; value: unknown }> };
   *   this._entries.clear();
   *   for (const entry of s.entries || []) {
   *     this._entries.set(entry.key, entry);
   *   }
   *   this.invalidateTokenCache();  // Don't forget this!
   * }
   * ```
   */
  restoreState(_state) {
  }
};

// src/core/context-nextgen/AgentContextNextGen.ts
init_Connector();

// src/domain/entities/Memory.ts
function isTaskAwareScope(scope) {
  return typeof scope === "object" && scope !== null && "type" in scope;
}
function isSimpleScope(scope) {
  return scope === "session" || scope === "persistent";
}
function scopeEquals(a, b) {
  if (isSimpleScope(a) && isSimpleScope(b)) {
    return a === b;
  }
  if (isTaskAwareScope(a) && isTaskAwareScope(b)) {
    if (a.type !== b.type) return false;
    if (a.type === "task" && b.type === "task") {
      if (a.taskIds.length !== b.taskIds.length) return false;
      const sortedA = [...a.taskIds].sort();
      const sortedB = [...b.taskIds].sort();
      return sortedA.every((id, i) => id === sortedB[i]);
    }
    return true;
  }
  return false;
}
function scopeMatches(entryScope, filterScope) {
  if (scopeEquals(entryScope, filterScope)) return true;
  if (isSimpleScope(filterScope)) return false;
  if (isTaskAwareScope(entryScope) && isTaskAwareScope(filterScope)) {
    return entryScope.type === filterScope.type;
  }
  return false;
}
var MEMORY_PRIORITY_VALUES = {
  critical: 4,
  high: 3,
  normal: 2,
  low: 1
};
var TIER_PRIORITIES = {
  raw: "low",
  summary: "normal",
  findings: "high"
};
var TIER_KEY_PREFIXES = {
  raw: "raw.",
  summary: "summary.",
  findings: "findings."
};
function getTierFromKey(key) {
  if (key.startsWith(TIER_KEY_PREFIXES.raw)) return "raw";
  if (key.startsWith(TIER_KEY_PREFIXES.summary)) return "summary";
  if (key.startsWith(TIER_KEY_PREFIXES.findings)) return "findings";
  return void 0;
}
function stripTierPrefix(key) {
  const tier = getTierFromKey(key);
  if (!tier) return key;
  return key.substring(TIER_KEY_PREFIXES[tier].length);
}
function addTierPrefix(key, tier) {
  const existingTier = getTierFromKey(key);
  if (existingTier) {
    const baseKey = stripTierPrefix(key);
    return TIER_KEY_PREFIXES[tier] + baseKey;
  }
  return TIER_KEY_PREFIXES[tier] + key;
}
var TERMINAL_MEMORY_STATUSES = ["completed", "failed", "skipped", "cancelled"];
function isTerminalMemoryStatus(status) {
  return TERMINAL_MEMORY_STATUSES.includes(status);
}
var staticPriorityCalculator = (entry) => {
  if (entry.pinned) return "critical";
  return entry.basePriority;
};
function detectStaleEntries(entries, completedTaskId, taskStates) {
  const stale = [];
  for (const entry of entries) {
    if (entry.pinned) continue;
    const scope = entry.scope;
    if (!isTaskAwareScope(scope) || scope.type !== "task") continue;
    if (!scope.taskIds.includes(completedTaskId)) continue;
    const allTerminal = scope.taskIds.every((taskId) => {
      const status = taskStates.get(taskId);
      return status ? isTerminalMemoryStatus(status) : false;
    });
    if (allTerminal) {
      stale.push({
        key: entry.key,
        description: entry.description,
        reason: "task_completed",
        previousPriority: entry.basePriority,
        newPriority: "low",
        taskIds: scope.taskIds
      });
    }
  }
  return stale;
}
function forTasks(key, description, value, taskIds, options) {
  return {
    key,
    description,
    value,
    scope: { type: "task", taskIds },
    priority: options?.priority,
    pinned: options?.pinned
  };
}
function forPlan(key, description, value, options) {
  return {
    key,
    description,
    value,
    scope: { type: "plan" },
    priority: options?.priority,
    pinned: options?.pinned
  };
}
var DEFAULT_MEMORY_CONFIG = {
  maxSizeBytes: 25 * 1024 * 1024,
  // 25MB default
  maxIndexEntries: 30,
  // Limit index entries to prevent context bloat
  descriptionMaxLength: 150,
  softLimitPercent: 80,
  contextAllocationPercent: 20
};
function validateMemoryKey(key) {
  if (!key || key.length === 0) {
    throw new Error("Memory key cannot be empty");
  }
  if (key.startsWith(".") || key.endsWith(".") || key.includes("..")) {
    throw new Error("Invalid memory key format: keys cannot start/end with dots or contain consecutive dots");
  }
  if (!/^[a-zA-Z0-9._-]+$/.test(key)) {
    throw new Error("Invalid memory key format: only alphanumeric, dots, dashes, and underscores allowed");
  }
}
function calculateEntrySize(value) {
  if (value === void 0) {
    return 0;
  }
  const serialized = JSON.stringify(value);
  if (typeof Buffer !== "undefined") {
    return Buffer.byteLength(serialized, "utf8");
  }
  return new Blob([serialized]).size;
}
function createMemoryEntry(input, config = DEFAULT_MEMORY_CONFIG) {
  validateMemoryKey(input.key);
  if (input.description.length > config.descriptionMaxLength) {
    throw new Error(`Description exceeds maximum length of ${config.descriptionMaxLength} characters`);
  }
  if (input.scope && isTaskAwareScope(input.scope) && input.scope.type === "task") {
    if (input.scope.taskIds.length === 0) {
      console.warn(`Memory entry "${input.key}" has empty taskIds array - will have low priority`);
    }
  }
  const now = Date.now();
  const sizeBytes = calculateEntrySize(input.value);
  const pinned = input.pinned ?? false;
  const priority = pinned ? "critical" : input.priority ?? "normal";
  return {
    key: input.key,
    description: input.description,
    value: input.value,
    sizeBytes,
    scope: input.scope ?? "session",
    basePriority: priority,
    pinned,
    createdAt: now,
    lastAccessedAt: now,
    accessCount: 0
  };
}
function formatSizeHuman(bytes) {
  if (bytes === 0) return "0B";
  if (bytes < 1024) return `${bytes}B`;
  const kb = bytes / 1024;
  if (bytes < 1024 * 1024) {
    return `${kb.toFixed(1).replace(/\.0$/, "")}KB`;
  }
  const mb = bytes / (1024 * 1024);
  if (bytes < 1024 * 1024 * 1024) {
    return `${mb.toFixed(1).replace(/\.0$/, "")}MB`;
  }
  const gb = bytes / (1024 * 1024 * 1024);
  return `${gb.toFixed(1).replace(/\.0$/, "")}GB`;
}
function formatScope(scope) {
  if (isSimpleScope(scope)) {
    return scope;
  }
  if (scope.type === "task") {
    return `task:${scope.taskIds.join(",")}`;
  }
  return scope.type;
}
function formatEntryFlags(entry) {
  const flags = [];
  if (entry.pinned) {
    flags.push("pinned");
  } else if (entry.effectivePriority !== "normal") {
    flags.push(entry.effectivePriority);
  }
  flags.push(formatScope(entry.scope));
  return flags.join(", ");
}
function formatMemoryIndex(index) {
  const lines = [];
  const utilPercent = Number.isInteger(index.utilizationPercent) ? index.utilizationPercent.toString() : index.utilizationPercent.toFixed(1).replace(/\.0$/, "");
  lines.push(`## Working Memory (${index.totalSizeHuman} / ${index.limitHuman} - ${utilPercent}%)`);
  lines.push("");
  if (index.entries.length === 0) {
    lines.push("Memory is empty.");
  } else {
    const pinned = index.entries.filter((e) => e.pinned);
    const critical = index.entries.filter((e) => !e.pinned && e.effectivePriority === "critical");
    const high = index.entries.filter((e) => !e.pinned && e.effectivePriority === "high");
    const normal = index.entries.filter((e) => !e.pinned && e.effectivePriority === "normal");
    const low = index.entries.filter((e) => !e.pinned && e.effectivePriority === "low");
    if (pinned.length > 0) {
      lines.push("**Pinned (never evicted):**");
      for (const entry of pinned) {
        lines.push(`- \`${entry.key}\` (${entry.size}): ${entry.description} [${formatEntryFlags(entry)}]`);
      }
      lines.push("");
    }
    if (critical.length > 0) {
      lines.push("**Critical priority:**");
      for (const entry of critical) {
        lines.push(`- \`${entry.key}\` (${entry.size}): ${entry.description} [${formatEntryFlags(entry)}]`);
      }
      lines.push("");
    }
    if (high.length > 0) {
      lines.push("**High priority:**");
      for (const entry of high) {
        lines.push(`- \`${entry.key}\` (${entry.size}): ${entry.description} [${formatEntryFlags(entry)}]`);
      }
      lines.push("");
    }
    if (normal.length > 0) {
      lines.push("**Normal priority:**");
      for (const entry of normal) {
        lines.push(`- \`${entry.key}\` (${entry.size}): ${entry.description} [${formatEntryFlags(entry)}]`);
      }
      lines.push("");
    }
    if (low.length > 0) {
      lines.push("**Low priority (evicted first):**");
      for (const entry of low) {
        lines.push(`- \`${entry.key}\` (${entry.size}): ${entry.description} [${formatEntryFlags(entry)}]`);
      }
      lines.push("");
    }
    if (index.utilizationPercent > 80) {
      lines.push("Warning: Memory utilization is high. Consider deleting unused entries.");
      lines.push("");
    }
    if (index.omittedCount > 0) {
      lines.push(`*${index.omittedCount} additional low-priority entries not shown. Use \`memory_query()\` to see all.*`);
      lines.push("");
    }
  }
  lines.push('Use `memory_retrieve("key")` to load full content.');
  lines.push('Use `memory_persist("key")` to keep data after task completion.');
  return lines.join("\n");
}

// src/infrastructure/storage/InMemoryStorage.ts
var InMemoryStorage = class {
  store = /* @__PURE__ */ new Map();
  async get(key) {
    return this.store.get(key);
  }
  async set(key, entry) {
    this.store.set(key, entry);
  }
  async delete(key) {
    this.store.delete(key);
  }
  async has(key) {
    return this.store.has(key);
  }
  async getAll() {
    return Array.from(this.store.values());
  }
  async getByScope(scope) {
    return Array.from(this.store.values()).filter((entry) => scopeMatches(entry.scope, scope));
  }
  async clearScope(scope) {
    const toDelete = [];
    for (const [key, entry] of this.store.entries()) {
      if (scopeMatches(entry.scope, scope)) {
        toDelete.push(key);
      }
    }
    for (const key of toDelete) {
      this.store.delete(key);
    }
  }
  async clear() {
    this.store.clear();
  }
  async getTotalSize() {
    let total = 0;
    for (const entry of this.store.values()) {
      total += entry.sizeBytes;
    }
    return total;
  }
};
var InMemoryPlanStorage = class {
  plans = /* @__PURE__ */ new Map();
  async savePlan(plan) {
    this.plans.set(plan.id, JSON.parse(JSON.stringify(plan)));
  }
  async getPlan(planId) {
    const plan = this.plans.get(planId);
    return plan ? JSON.parse(JSON.stringify(plan)) : void 0;
  }
  async updateTask(planId, task) {
    const plan = this.plans.get(planId);
    if (!plan) {
      throw new Error(`Plan ${planId} not found`);
    }
    const taskIndex = plan.tasks.findIndex((t) => t.id === task.id);
    if (taskIndex === -1) {
      throw new Error(`Task ${task.id} not found in plan ${planId}`);
    }
    plan.tasks[taskIndex] = JSON.parse(JSON.stringify(task));
  }
  async addTask(planId, task) {
    const plan = this.plans.get(planId);
    if (!plan) {
      throw new Error(`Plan ${planId} not found`);
    }
    plan.tasks.push(JSON.parse(JSON.stringify(task)));
  }
  async deletePlan(planId) {
    this.plans.delete(planId);
  }
  async listPlans(filter) {
    const allPlans = Array.from(this.plans.values());
    if (!filter || !filter.status) {
      return allPlans.map((p) => JSON.parse(JSON.stringify(p)));
    }
    return allPlans.filter((plan) => filter.status.includes(plan.status)).map((p) => JSON.parse(JSON.stringify(p)));
  }
  async findByWebhookId(webhookId) {
    for (const plan of this.plans.values()) {
      for (const task of plan.tasks) {
        if (task.externalDependency?.webhookId === webhookId) {
          return {
            plan: JSON.parse(JSON.stringify(plan)),
            task: JSON.parse(JSON.stringify(task))
          };
        }
      }
    }
    return void 0;
  }
};
var InMemoryAgentStateStorage = class {
  agents = /* @__PURE__ */ new Map();
  async save(state) {
    this.agents.set(state.id, JSON.parse(JSON.stringify(state)));
  }
  async load(agentId) {
    const state = this.agents.get(agentId);
    return state ? JSON.parse(JSON.stringify(state)) : void 0;
  }
  async delete(agentId) {
    this.agents.delete(agentId);
  }
  async list(filter) {
    const allStates = Array.from(this.agents.values());
    if (!filter || !filter.status) {
      return allStates.map((s) => JSON.parse(JSON.stringify(s)));
    }
    return allStates.filter((state) => filter.status.includes(state.status)).map((s) => JSON.parse(JSON.stringify(s)));
  }
  async patch(agentId, updates) {
    const state = this.agents.get(agentId);
    if (!state) {
      throw new Error(`Agent ${agentId} not found`);
    }
    Object.assign(state, updates);
  }
};
function createAgentStorage(options = {}) {
  return {
    memory: options.memory ?? new InMemoryStorage(),
    plan: options.plan ?? new InMemoryPlanStorage(),
    agent: options.agent ?? new InMemoryAgentStateStorage()
  };
}

// src/core/context-nextgen/plugins/WorkingMemoryPluginNextGen.ts
init_StorageRegistry();
var memoryStoreDefinition = {
  type: "function",
  function: {
    name: "memory_store",
    description: `Store data in working memory. Use this to save important information.

TIER SYSTEM (for research/analysis):
- "raw": Low priority, evicted first. Unprocessed data.
- "summary": Normal priority. Processed summaries.
- "findings": High priority, kept longest. Final conclusions.`,
    parameters: {
      type: "object",
      properties: {
        key: { type: "string", description: 'Namespaced key (e.g., "user.profile")' },
        description: { type: "string", description: "Brief description (max 150 chars)" },
        value: { description: "Data to store (any JSON value)" },
        tier: {
          type: "string",
          enum: ["raw", "summary", "findings"],
          description: "Memory tier (sets priority automatically)"
        },
        scope: {
          type: "string",
          enum: ["session", "plan", "persistent"],
          description: "Lifecycle scope (default: session)"
        },
        priority: {
          type: "string",
          enum: ["low", "normal", "high", "critical"],
          description: "Override priority (ignored if tier is set)"
        },
        pinned: { type: "boolean", description: "Never evict this entry" }
      },
      required: ["key", "description", "value"]
    }
  }
};
var memoryRetrieveDefinition = {
  type: "function",
  function: {
    name: "memory_retrieve",
    description: "Retrieve full data from working memory by key.",
    parameters: {
      type: "object",
      properties: {
        key: { type: "string", description: "Key to retrieve" }
      },
      required: ["key"]
    }
  }
};
var memoryDeleteDefinition = {
  type: "function",
  function: {
    name: "memory_delete",
    description: "Delete data from working memory.",
    parameters: {
      type: "object",
      properties: {
        key: { type: "string", description: "Key to delete" }
      },
      required: ["key"]
    }
  }
};
var memoryQueryDefinition = {
  type: "function",
  function: {
    name: "memory_query",
    description: `Query working memory. List, search, or retrieve values.

Examples:
- memory_query() \u2192 list all keys
- memory_query({ pattern: "findings.*" }) \u2192 match pattern
- memory_query({ tier: "raw", includeValues: true }) \u2192 get raw tier values`,
    parameters: {
      type: "object",
      properties: {
        pattern: { type: "string", description: 'Glob pattern (e.g., "raw.*")' },
        tier: { type: "string", enum: ["raw", "summary", "findings"], description: "Filter by tier" },
        includeValues: { type: "boolean", description: "Include values (default: false)" },
        includeStats: { type: "boolean", description: "Include memory stats" }
      },
      required: []
    }
  }
};
var memoryCleanupRawDefinition = {
  type: "function",
  function: {
    name: "memory_cleanup_raw",
    description: "Delete ALL entries in the raw tier. Use after creating summaries.",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  }
};
var WORKING_MEMORY_INSTRUCTIONS = `Working Memory stores data EXTERNALLY with an index shown below.
You see descriptions but must use memory_retrieve(key) to get full values.

**Tier System** (for research/analysis):
- \`raw\`: Low priority, evicted first. Unprocessed data to summarize later.
- \`summary\`: Normal priority. Processed summaries of raw data.
- \`findings\`: High priority, kept longest. Final conclusions and insights.

**Workflow:**
1. Store raw data: \`memory_store({ key: "topic", tier: "raw", ... })\`
2. Process and summarize: \`memory_store({ key: "topic", tier: "summary", ... })\`
3. Extract findings: \`memory_store({ key: "topic", tier: "findings", ... })\`
4. Clean up raw: \`memory_cleanup_raw()\` or \`memory_delete(key)\`

**Tools:** memory_store, memory_retrieve, memory_delete, memory_query, memory_cleanup_raw`;
var WorkingMemoryPluginNextGen = class {
  name = "working_memory";
  storage;
  config;
  priorityCalculator;
  priorityContext = {};
  estimator = simpleTokenEstimator;
  _destroyed = false;
  _tokenCache = null;
  _instructionsTokenCache = null;
  /**
   * Synchronous snapshot of entries for getState() serialization.
   * Updated on every mutation (store, delete, evict, cleanupRaw, restoreState).
   * Solves the async/sync mismatch: IMemoryStorage.getAll() is async but
   * IContextPluginNextGen.getState() must be sync.
   */
  _syncEntries = /* @__PURE__ */ new Map();
  constructor(pluginConfig = {}) {
    const registryFactory = exports.StorageRegistry.get("workingMemory");
    this.storage = pluginConfig.storage ?? registryFactory?.(exports.StorageRegistry.getContext()) ?? new InMemoryStorage();
    this.config = pluginConfig.config ?? DEFAULT_MEMORY_CONFIG;
    this.priorityCalculator = pluginConfig.priorityCalculator ?? staticPriorityCalculator;
  }
  // ============================================================================
  // IContextPluginNextGen Implementation
  // ============================================================================
  getInstructions() {
    return WORKING_MEMORY_INSTRUCTIONS;
  }
  async getContent() {
    const entries = await this.storage.getAll();
    if (entries.length === 0) {
      return null;
    }
    const index = this.buildMemoryIndex(entries);
    const formatted = formatMemoryIndex(index);
    this._tokenCache = this.estimator.estimateTokens(formatted);
    return formatted;
  }
  getContents() {
    return this.storage.getAll();
  }
  getTokenSize() {
    return this._tokenCache ?? 0;
  }
  getInstructionsTokenSize() {
    if (this._instructionsTokenCache === null) {
      this._instructionsTokenCache = this.estimator.estimateTokens(WORKING_MEMORY_INSTRUCTIONS);
    }
    return this._instructionsTokenCache;
  }
  isCompactable() {
    return true;
  }
  async compact(_targetTokensToFree) {
    const before = this.getTokenSize();
    await this.evict(3, "lru");
    const content = await this.getContent();
    const after = content ? this.estimator.estimateTokens(content) : 0;
    return Math.max(0, before - after);
  }
  getTools() {
    return [
      this.createMemoryStoreTool(),
      this.createMemoryRetrieveTool(),
      this.createMemoryDeleteTool(),
      this.createMemoryQueryTool(),
      this.createMemoryCleanupRawTool()
    ];
  }
  destroy() {
    if (this._destroyed) return;
    this._destroyed = true;
    this._tokenCache = null;
  }
  getState() {
    return {
      version: 1,
      entries: Array.from(this._syncEntries.values())
    };
  }
  restoreState(state) {
    const s = state;
    if (!s || !s.entries) return;
    this._syncEntries.clear();
    for (const entry of s.entries) {
      const memEntry = createMemoryEntry({
        key: entry.key,
        description: entry.description,
        value: entry.value,
        scope: entry.scope,
        priority: entry.basePriority,
        pinned: entry.pinned
      }, this.config);
      this.storage.set(entry.key, memEntry);
      this._syncEntries.set(entry.key, {
        key: entry.key,
        description: entry.description,
        value: entry.value,
        scope: entry.scope,
        sizeBytes: entry.sizeBytes,
        basePriority: entry.basePriority,
        pinned: entry.pinned
      });
    }
    this._tokenCache = null;
  }
  // ============================================================================
  // Memory Operations (Core Implementation)
  // ============================================================================
  /**
   * Store a value in memory
   */
  async store(key, description, value, options) {
    this.assertNotDestroyed();
    let finalKey = key;
    let finalPriority = options?.priority;
    if (options?.tier) {
      finalKey = addTierPrefix(key, options.tier);
      finalPriority = TIER_PRIORITIES[options.tier];
    }
    let scope = options?.scope ?? "session";
    const entry = createMemoryEntry({
      key: finalKey,
      description,
      value,
      scope,
      priority: finalPriority,
      pinned: options?.pinned
    }, this.config);
    await this.ensureCapacity(entry.sizeBytes);
    await this.storage.set(finalKey, entry);
    this._syncEntries.set(finalKey, {
      key: finalKey,
      description,
      value,
      scope,
      sizeBytes: entry.sizeBytes,
      basePriority: finalPriority,
      pinned: options?.pinned
    });
    this._tokenCache = null;
    return { key: finalKey, sizeBytes: entry.sizeBytes };
  }
  /**
   * Retrieve a value from memory
   */
  async retrieve(key) {
    this.assertNotDestroyed();
    const entry = await this.storage.get(key);
    if (entry) {
      entry.lastAccessedAt = Date.now();
      entry.accessCount++;
      await this.storage.set(key, entry);
      return entry.value;
    }
    return void 0;
  }
  /**
   * Delete a key from memory
   */
  async delete(key) {
    this.assertNotDestroyed();
    const exists = await this.storage.has(key);
    if (exists) {
      await this.storage.delete(key);
      this._syncEntries.delete(key);
      this._tokenCache = null;
      return true;
    }
    return false;
  }
  /**
   * Query memory entries
   */
  async query(options) {
    this.assertNotDestroyed();
    let entries = await this.storage.getAll();
    if (options?.tier) {
      entries = entries.filter((e) => getTierFromKey(e.key) === options.tier);
    }
    if (options?.pattern && options.pattern !== "*") {
      const regex = new RegExp(
        "^" + options.pattern.replace(/\./g, "\\.").replace(/\*/g, ".*") + "$"
      );
      entries = entries.filter((e) => regex.test(e.key));
    }
    const result = entries.map((e) => ({
      key: e.key,
      description: e.description,
      tier: getTierFromKey(e.key),
      ...options?.includeValues ? { value: e.value } : {}
    }));
    if (options?.includeStats) {
      return {
        entries: result,
        stats: {
          count: entries.length,
          totalBytes: entries.reduce((sum, e) => sum + e.sizeBytes, 0)
        }
      };
    }
    return { entries: result };
  }
  /**
   * Format memory index for context
   */
  async formatIndex() {
    const entries = await this.storage.getAll();
    const index = this.buildMemoryIndex(entries);
    return formatMemoryIndex(index);
  }
  /**
   * Evict entries to free space
   */
  async evict(count, strategy = "lru") {
    const entries = await this.storage.getAll();
    const evictable = entries.filter((e) => !e.pinned && this.computePriority(e) !== "critical").sort((a, b) => {
      const priorityDiff = MEMORY_PRIORITY_VALUES[this.computePriority(a)] - MEMORY_PRIORITY_VALUES[this.computePriority(b)];
      if (priorityDiff !== 0) return priorityDiff;
      if (strategy === "lru") {
        return a.lastAccessedAt - b.lastAccessedAt;
      } else {
        return b.sizeBytes - a.sizeBytes;
      }
    });
    const toEvict = evictable.slice(0, count);
    const evictedKeys = [];
    for (const entry of toEvict) {
      await this.storage.delete(entry.key);
      this._syncEntries.delete(entry.key);
      evictedKeys.push(entry.key);
    }
    if (evictedKeys.length > 0) {
      this._tokenCache = null;
    }
    return evictedKeys;
  }
  /**
   * Cleanup raw tier entries
   */
  async cleanupRaw() {
    const entries = await this.storage.getAll();
    const rawEntries = entries.filter((e) => getTierFromKey(e.key) === "raw");
    const keys = [];
    for (const entry of rawEntries) {
      await this.storage.delete(entry.key);
      this._syncEntries.delete(entry.key);
      keys.push(entry.key);
    }
    if (keys.length > 0) {
      this._tokenCache = null;
    }
    return { deleted: keys.length, keys };
  }
  // ============================================================================
  // Private Helpers
  // ============================================================================
  computePriority(entry) {
    return this.priorityCalculator(entry, this.priorityContext);
  }
  /**
   * Build a MemoryIndex from raw entries
   */
  buildMemoryIndex(entries) {
    const maxSize = this.config.maxSizeBytes ?? DEFAULT_MEMORY_CONFIG.maxSizeBytes;
    const maxIndexEntries = this.config.maxIndexEntries ?? DEFAULT_MEMORY_CONFIG.maxIndexEntries;
    const totalSize = entries.reduce((sum, e) => sum + e.sizeBytes, 0);
    const sorted = [...entries].sort((a, b) => {
      const priorityDiff = MEMORY_PRIORITY_VALUES[this.computePriority(b)] - MEMORY_PRIORITY_VALUES[this.computePriority(a)];
      if (priorityDiff !== 0) return priorityDiff;
      return b.lastAccessedAt - a.lastAccessedAt;
    });
    const displayed = sorted.slice(0, maxIndexEntries);
    const omittedCount = Math.max(0, entries.length - maxIndexEntries);
    const indexEntries = displayed.map((e) => ({
      key: e.key,
      description: e.description,
      size: formatSizeHuman(e.sizeBytes),
      scope: e.scope,
      effectivePriority: this.computePriority(e),
      pinned: e.pinned
    }));
    return {
      entries: indexEntries,
      totalSizeBytes: totalSize,
      totalSizeHuman: formatSizeHuman(totalSize),
      limitBytes: maxSize,
      limitHuman: formatSizeHuman(maxSize),
      utilizationPercent: maxSize > 0 ? totalSize / maxSize * 100 : 0,
      totalEntryCount: entries.length,
      omittedCount
    };
  }
  async ensureCapacity(neededBytes) {
    const entries = await this.storage.getAll();
    const currentSize = entries.reduce((sum, e) => sum + e.sizeBytes, 0);
    const maxSize = this.config.maxSizeBytes ?? DEFAULT_MEMORY_CONFIG.maxSizeBytes;
    const maxEntries = this.config.maxIndexEntries ?? DEFAULT_MEMORY_CONFIG.maxIndexEntries;
    const needsSizeEviction = currentSize + neededBytes > maxSize;
    const needsCountEviction = entries.length >= maxEntries;
    if (!needsSizeEviction && !needsCountEviction) return;
    const evictable = entries.filter((e) => !e.pinned && this.computePriority(e) !== "critical").sort((a, b) => {
      const priorityDiff = MEMORY_PRIORITY_VALUES[this.computePriority(a)] - MEMORY_PRIORITY_VALUES[this.computePriority(b)];
      if (priorityDiff !== 0) return priorityDiff;
      return a.lastAccessedAt - b.lastAccessedAt;
    });
    const bytesToFree = needsSizeEviction ? currentSize + neededBytes - maxSize * 0.8 : 0;
    const entriesToFree = needsCountEviction ? entries.length - maxEntries + 1 : 0;
    let freedBytes = 0;
    let freedCount = 0;
    for (const entry of evictable) {
      if (freedBytes >= bytesToFree && freedCount >= entriesToFree) break;
      await this.storage.delete(entry.key);
      this._syncEntries.delete(entry.key);
      freedBytes += entry.sizeBytes;
      freedCount++;
    }
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("WorkingMemoryPluginNextGen is destroyed");
    }
  }
  // ============================================================================
  // Tool Factories
  // ============================================================================
  createMemoryStoreTool() {
    return {
      definition: memoryStoreDefinition,
      execute: async (args) => {
        const result = await this.store(
          args.key,
          args.description,
          args.value,
          {
            tier: args.tier,
            scope: args.scope,
            priority: args.priority,
            pinned: args.pinned
          }
        );
        return { success: true, ...result };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `store ${args.key}`
    };
  }
  createMemoryRetrieveTool() {
    return {
      definition: memoryRetrieveDefinition,
      execute: async (args) => {
        const value = await this.retrieve(args.key);
        if (value === void 0) {
          return { found: false, key: args.key };
        }
        return { found: true, key: args.key, value };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `retrieve ${args.key}`
    };
  }
  createMemoryDeleteTool() {
    return {
      definition: memoryDeleteDefinition,
      execute: async (args) => {
        const deleted = await this.delete(args.key);
        return { deleted, key: args.key };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `delete ${args.key}`
    };
  }
  createMemoryQueryTool() {
    return {
      definition: memoryQueryDefinition,
      execute: async (args) => {
        return await this.query({
          pattern: args.pattern,
          tier: args.tier,
          includeValues: args.includeValues,
          includeStats: args.includeStats
        });
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => args.pattern ? `query ${args.pattern}` : "query all"
    };
  }
  createMemoryCleanupRawTool() {
    return {
      definition: memoryCleanupRawDefinition,
      execute: async () => {
        return await this.cleanupRaw();
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: () => "cleanup raw tier"
    };
  }
};

// src/core/context-nextgen/plugins/InContextMemoryPluginNextGen.ts
var PRIORITY_VALUES = {
  low: 1,
  normal: 2,
  high: 3,
  critical: 4
};
var DEFAULT_CONFIG = {
  maxEntries: 20,
  maxTotalTokens: 4e3,
  defaultPriority: "normal",
  showTimestamps: false
};
var IN_CONTEXT_MEMORY_INSTRUCTIONS = `In-Context Memory stores key-value pairs DIRECTLY in context.
Values are immediately visible - no retrieval needed.

**Use for:** Current state, preferences, counters, small results.
**Do NOT use for:** Large data (use Working Memory instead).

**Priority levels** (for eviction when space is tight):
- \`low\`: Evicted first. Temporary data.
- \`normal\`: Default. Standard importance.
- \`high\`: Keep longer. Important state.
- \`critical\`: Never auto-evicted.

**UI Display:** Set \`showInUI: true\` in context_set to display the entry in the user's side panel.
Values shown in the UI support the same rich markdown formatting as the chat window
(see formatting instructions above). Use this for dashboards, progress displays, and results the user should see.

**Tools:** context_set, context_delete, context_list`;
var contextSetDefinition = {
  type: "function",
  function: {
    name: "context_set",
    description: `Store or update a key-value pair in live context.
Value appears directly in context - no retrieval needed.
Set showInUI to true to also display the entry in the user's side panel.`,
    parameters: {
      type: "object",
      properties: {
        key: { type: "string", description: 'Unique key (e.g., "current_state")' },
        description: { type: "string", description: "Brief description (shown in context)" },
        value: { description: "Value to store (any JSON-serializable data)" },
        priority: {
          type: "string",
          enum: ["low", "normal", "high", "critical"],
          description: 'Eviction priority. Default: "normal"'
        },
        showInUI: {
          type: "boolean",
          description: "If true, display this entry in the user's side panel with full rich markdown rendering \u2014 same capabilities as the chat window (code blocks, tables, LaTeX, Mermaid diagrams, Vega-Lite charts, mindmaps, etc. \u2014 see formatting instructions in system prompt). Use this for dashboards, status displays, and structured results the user should see. Default: false"
        }
      },
      required: ["key", "description", "value"]
    }
  }
};
var contextDeleteDefinition = {
  type: "function",
  function: {
    name: "context_delete",
    description: "Delete an entry from live context to free space.",
    parameters: {
      type: "object",
      properties: {
        key: { type: "string", description: "Key to delete" }
      },
      required: ["key"]
    }
  }
};
var contextListDefinition = {
  type: "function",
  function: {
    name: "context_list",
    description: "List all keys in live context with metadata.",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  }
};
var InContextMemoryPluginNextGen = class {
  name = "in_context_memory";
  entries = /* @__PURE__ */ new Map();
  config;
  estimator = simpleTokenEstimator;
  _destroyed = false;
  _tokenCache = null;
  _instructionsTokenCache = null;
  _notifyTimer = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  // ============================================================================
  // IContextPluginNextGen Implementation
  // ============================================================================
  getInstructions() {
    return IN_CONTEXT_MEMORY_INSTRUCTIONS;
  }
  async getContent() {
    if (this.entries.size === 0) {
      return null;
    }
    const content = this.formatEntries();
    this._tokenCache = this.estimator.estimateTokens(content);
    return content;
  }
  getContents() {
    return new Map(this.entries);
  }
  getTokenSize() {
    return this._tokenCache ?? 0;
  }
  getInstructionsTokenSize() {
    if (this._instructionsTokenCache === null) {
      this._instructionsTokenCache = this.estimator.estimateTokens(IN_CONTEXT_MEMORY_INSTRUCTIONS);
    }
    return this._instructionsTokenCache;
  }
  isCompactable() {
    return true;
  }
  async compact(targetTokensToFree) {
    const before = this.getTokenSize();
    const evictable = Array.from(this.entries.values()).filter((e) => e.priority !== "critical").sort((a, b) => {
      const priorityDiff = PRIORITY_VALUES[a.priority] - PRIORITY_VALUES[b.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return a.updatedAt - b.updatedAt;
    });
    let freed = 0;
    let evicted = false;
    for (const entry of evictable) {
      if (freed >= targetTokensToFree) break;
      const entryTokens = this.estimator.estimateTokens(this.formatEntry(entry));
      this.entries.delete(entry.key);
      freed += entryTokens;
      evicted = true;
    }
    this._tokenCache = null;
    const content = await this.getContent();
    const after = content ? this.estimator.estimateTokens(content) : 0;
    if (evicted) this.notifyEntriesChanged();
    return Math.max(0, before - after);
  }
  getTools() {
    return [
      this.createContextSetTool(),
      this.createContextDeleteTool(),
      this.createContextListTool()
    ];
  }
  destroy() {
    if (this._destroyed) return;
    if (this._notifyTimer) clearTimeout(this._notifyTimer);
    this.entries.clear();
    this._destroyed = true;
    this._tokenCache = null;
  }
  getState() {
    return {
      entries: Array.from(this.entries.values())
    };
  }
  restoreState(state) {
    const s = state;
    if (!s || !s.entries) return;
    this.entries.clear();
    for (const entry of s.entries) {
      this.entries.set(entry.key, entry);
    }
    this._tokenCache = null;
    this.notifyEntriesChanged();
  }
  // ============================================================================
  // Entry Management
  // ============================================================================
  /**
   * Store or update a key-value pair
   */
  set(key, description, value, priority, showInUI) {
    this.assertNotDestroyed();
    const entry = {
      key,
      description,
      value,
      updatedAt: Date.now(),
      priority: priority ?? this.config.defaultPriority,
      showInUI: showInUI ?? false
    };
    this.entries.set(key, entry);
    this.enforceMaxEntries();
    this.enforceTokenLimit();
    this._tokenCache = null;
    this.notifyEntriesChanged();
  }
  /**
   * Get a value by key
   */
  get(key) {
    this.assertNotDestroyed();
    return this.entries.get(key)?.value;
  }
  /**
   * Check if a key exists
   */
  has(key) {
    this.assertNotDestroyed();
    return this.entries.has(key);
  }
  /**
   * Delete an entry
   */
  delete(key) {
    this.assertNotDestroyed();
    const deleted = this.entries.delete(key);
    if (deleted) {
      this._tokenCache = null;
      this.notifyEntriesChanged();
    }
    return deleted;
  }
  /**
   * List all entries with metadata
   */
  list() {
    this.assertNotDestroyed();
    return Array.from(this.entries.values()).map((e) => ({
      key: e.key,
      description: e.description,
      priority: e.priority,
      updatedAt: e.updatedAt,
      showInUI: e.showInUI ?? false
    }));
  }
  /**
   * Clear all entries
   */
  clear() {
    this.assertNotDestroyed();
    this.entries.clear();
    this._tokenCache = null;
    this.notifyEntriesChanged();
  }
  // ============================================================================
  // Private Helpers
  // ============================================================================
  formatEntries() {
    const lines = [];
    const sorted = Array.from(this.entries.values()).sort((a, b) => PRIORITY_VALUES[b.priority] - PRIORITY_VALUES[a.priority]);
    for (const entry of sorted) {
      lines.push(this.formatEntry(entry));
    }
    return lines.join("\n\n");
  }
  formatEntry(entry) {
    const valueStr = typeof entry.value === "string" ? entry.value : JSON.stringify(entry.value, null, 2);
    let line = `**${entry.key}** (${entry.priority}): ${entry.description}`;
    if (this.config.showTimestamps) {
      line += ` [${new Date(entry.updatedAt).toISOString()}]`;
    }
    line += `
\`\`\`
${valueStr}
\`\`\``;
    return line;
  }
  enforceMaxEntries() {
    if (this.entries.size <= this.config.maxEntries) return;
    const evictable = this.getEvictableEntries();
    while (this.entries.size > this.config.maxEntries && evictable.length > 0) {
      const toEvict = evictable.shift();
      this.entries.delete(toEvict.key);
    }
  }
  enforceTokenLimit() {
    const maxTokens = this.config.maxTotalTokens;
    if (maxTokens <= 0) return;
    let totalTokens = this.estimateTotalTokens();
    if (totalTokens <= maxTokens) return;
    const evictable = this.getEvictableEntries();
    while (totalTokens > maxTokens && evictable.length > 0) {
      const toEvict = evictable.shift();
      const entryTokens = this.estimator.estimateTokens(this.formatEntry(toEvict));
      this.entries.delete(toEvict.key);
      totalTokens -= entryTokens;
    }
  }
  estimateTotalTokens() {
    let total = 0;
    for (const entry of this.entries.values()) {
      total += this.estimator.estimateTokens(this.formatEntry(entry));
    }
    return total;
  }
  /**
   * Get entries sorted by eviction priority (lowest priority, oldest first).
   * Critical entries are excluded.
   */
  getEvictableEntries() {
    return Array.from(this.entries.values()).filter((e) => e.priority !== "critical").sort((a, b) => {
      const priorityDiff = PRIORITY_VALUES[a.priority] - PRIORITY_VALUES[b.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return a.updatedAt - b.updatedAt;
    });
  }
  /**
   * Debounced notification when entries change.
   * Calls config.onEntriesChanged with all current entries.
   */
  notifyEntriesChanged() {
    if (!this.config.onEntriesChanged) return;
    if (this._notifyTimer) clearTimeout(this._notifyTimer);
    this._notifyTimer = setTimeout(() => {
      this._notifyTimer = null;
      if (!this._destroyed && this.config.onEntriesChanged) {
        this.config.onEntriesChanged(Array.from(this.entries.values()));
      }
    }, 100);
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("InContextMemoryPluginNextGen is destroyed");
    }
  }
  // ============================================================================
  // Tool Factories
  // ============================================================================
  createContextSetTool() {
    return {
      definition: contextSetDefinition,
      execute: async (args) => {
        this.set(
          args.key,
          args.description,
          args.value,
          args.priority,
          args.showInUI
        );
        return {
          success: true,
          key: args.key,
          showInUI: args.showInUI ?? false,
          message: `Stored "${args.key}" in live context${args.showInUI ? " (visible in UI)" : ""}`
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `set ${args.key}${args.showInUI ? " [UI]" : ""}`
    };
  }
  createContextDeleteTool() {
    return {
      definition: contextDeleteDefinition,
      execute: async (args) => {
        const deleted = this.delete(args.key);
        return { deleted, key: args.key };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `delete ${args.key}`
    };
  }
  createContextListTool() {
    return {
      definition: contextListDefinition,
      execute: async () => {
        return { entries: this.list() };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: () => "list entries"
    };
  }
};
function getDefaultBaseDirectory() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "agents");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "agents");
}
function sanitizeAgentId(agentId) {
  return agentId.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || "default";
}
var FilePersistentInstructionsStorage = class {
  directory;
  filePath;
  legacyFilePath;
  agentId;
  constructor(config) {
    this.agentId = config.agentId;
    const sanitizedId = sanitizeAgentId(config.agentId);
    const baseDir = config.baseDirectory ?? getDefaultBaseDirectory();
    const filename = config.filename ?? "custom_instructions.json";
    this.directory = path2.join(baseDir, sanitizedId);
    this.filePath = path2.join(this.directory, filename);
    this.legacyFilePath = path2.join(this.directory, "custom_instructions.md");
  }
  /**
   * Load instruction entries from file.
   * Falls back to legacy .md file migration if JSON not found.
   */
  async load() {
    try {
      const raw = await fs19.promises.readFile(this.filePath, "utf-8");
      const data = JSON.parse(raw);
      if (data.version === 2 && Array.isArray(data.entries)) {
        return data.entries.length > 0 ? data.entries : null;
      }
      return null;
    } catch (error) {
      if (!(error instanceof Error && "code" in error && error.code === "ENOENT")) {
        throw error;
      }
    }
    try {
      const content = await fs19.promises.readFile(this.legacyFilePath, "utf-8");
      const trimmed = content.trim();
      if (!trimmed) return null;
      const now = Date.now();
      return [{
        id: "legacy_instructions",
        content: trimmed,
        createdAt: now,
        updatedAt: now
      }];
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return null;
      }
      throw error;
    }
  }
  /**
   * Save instruction entries to file as JSON.
   * Creates directory if it doesn't exist.
   * Cleans up legacy .md file if present.
   */
  async save(entries) {
    await this.ensureDirectory();
    const data = {
      version: 2,
      entries
    };
    const tempPath = `${this.filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
      await fs19.promises.rename(tempPath, this.filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
    await this.removeLegacyFile();
  }
  /**
   * Delete instructions file (and legacy .md if exists)
   */
  async delete() {
    try {
      await fs19.promises.unlink(this.filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
    await this.removeLegacyFile();
  }
  /**
   * Check if instructions file exists (JSON or legacy .md)
   */
  async exists() {
    try {
      await fs19.promises.access(this.filePath);
      return true;
    } catch {
      try {
        await fs19.promises.access(this.legacyFilePath);
        return true;
      } catch {
        return false;
      }
    }
  }
  /**
   * Get the file path (for display/debugging)
   */
  getPath() {
    return this.filePath;
  }
  /**
   * Get the agent ID
   */
  getAgentId() {
    return this.agentId;
  }
  /**
   * Ensure the directory exists
   */
  async ensureDirectory() {
    try {
      await fs19.promises.mkdir(this.directory, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
  /**
   * Remove legacy .md file if it exists
   */
  async removeLegacyFile() {
    try {
      await fs19.promises.unlink(this.legacyFilePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        console.warn(`Failed to remove legacy instructions file: ${this.legacyFilePath}`);
      }
    }
  }
};

// src/core/context-nextgen/plugins/PersistentInstructionsPluginNextGen.ts
init_StorageRegistry();
var DEFAULT_MAX_TOTAL_LENGTH = 5e4;
var DEFAULT_MAX_ENTRIES = 50;
var KEY_MAX_LENGTH = 100;
var KEY_PATTERN = /^[a-zA-Z0-9_-]+$/;
var PERSISTENT_INSTRUCTIONS_INSTRUCTIONS = `Persistent Instructions are stored on disk and survive across sessions.
Each instruction is a keyed entry that can be independently managed.

**To modify:**
- \`instructions_set(key, content)\`: Add or update a single instruction by key
- \`instructions_remove(key)\`: Remove a single instruction by key
- \`instructions_list()\`: List all instructions with keys and content
- \`instructions_clear(confirm: true)\`: Remove all instructions (destructive!)

**Use for:** Agent personality, user preferences, learned rules, guidelines.`;
var instructionsSetDefinition = {
  type: "function",
  function: {
    name: "instructions_set",
    description: `Add or update a single persistent instruction by key. Persists across sessions.
If the key exists, it will be updated. If not, a new entry is created.`,
    parameters: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Unique key for the instruction (alphanumeric, dash, underscore; max 100 chars)"
        },
        content: {
          type: "string",
          description: "Instruction content (markdown supported)"
        }
      },
      required: ["key", "content"]
    }
  }
};
var instructionsRemoveDefinition = {
  type: "function",
  function: {
    name: "instructions_remove",
    description: "Remove a single persistent instruction by key.",
    parameters: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Key of the instruction to remove"
        }
      },
      required: ["key"]
    }
  }
};
var instructionsListDefinition = {
  type: "function",
  function: {
    name: "instructions_list",
    description: "List all persistent instructions with their keys and content.",
    parameters: {
      type: "object",
      properties: {},
      required: []
    }
  }
};
var instructionsClearDefinition = {
  type: "function",
  function: {
    name: "instructions_clear",
    description: "Clear all persistent instructions (DESTRUCTIVE). Requires confirmation.",
    parameters: {
      type: "object",
      properties: {
        confirm: {
          type: "boolean",
          description: "Must be true to confirm deletion"
        }
      },
      required: ["confirm"]
    }
  }
};
function validateKey(key) {
  if (typeof key !== "string") return "Key must be a string";
  const trimmed = key.trim();
  if (trimmed.length === 0) return "Key cannot be empty";
  if (trimmed.length > KEY_MAX_LENGTH) return `Key exceeds maximum length (${KEY_MAX_LENGTH} chars)`;
  if (!KEY_PATTERN.test(trimmed)) return "Key must contain only alphanumeric characters, dashes, and underscores";
  return null;
}
var PersistentInstructionsPluginNextGen = class {
  name = "persistent_instructions";
  _entries = /* @__PURE__ */ new Map();
  _initialized = false;
  _destroyed = false;
  storage;
  maxTotalLength;
  maxEntries;
  agentId;
  estimator = simpleTokenEstimator;
  _tokenCache = null;
  _instructionsTokenCache = null;
  constructor(config) {
    if (!config.agentId) {
      throw new Error("PersistentInstructionsPluginNextGen requires agentId");
    }
    this.agentId = config.agentId;
    this.maxTotalLength = config.maxTotalLength ?? DEFAULT_MAX_TOTAL_LENGTH;
    this.maxEntries = config.maxEntries ?? DEFAULT_MAX_ENTRIES;
    const registryFactory = exports.StorageRegistry.get("persistentInstructions");
    this.storage = config.storage ?? registryFactory?.(config.agentId, exports.StorageRegistry.getContext()) ?? new FilePersistentInstructionsStorage({ agentId: config.agentId });
  }
  // ============================================================================
  // IContextPluginNextGen Implementation
  // ============================================================================
  getInstructions() {
    return PERSISTENT_INSTRUCTIONS_INSTRUCTIONS;
  }
  async getContent() {
    await this.ensureInitialized();
    if (this._entries.size === 0) {
      this._tokenCache = 0;
      return null;
    }
    const rendered = this.renderContent();
    this._tokenCache = this.estimator.estimateTokens(rendered);
    return rendered;
  }
  getContents() {
    return new Map(this._entries);
  }
  getTokenSize() {
    return this._tokenCache ?? 0;
  }
  getInstructionsTokenSize() {
    if (this._instructionsTokenCache === null) {
      this._instructionsTokenCache = this.estimator.estimateTokens(PERSISTENT_INSTRUCTIONS_INSTRUCTIONS);
    }
    return this._instructionsTokenCache;
  }
  isCompactable() {
    return false;
  }
  async compact(_targetTokensToFree) {
    return 0;
  }
  getTools() {
    return [
      this.createInstructionsSetTool(),
      this.createInstructionsRemoveTool(),
      this.createInstructionsListTool(),
      this.createInstructionsClearTool()
    ];
  }
  destroy() {
    if (this._destroyed) return;
    this._entries.clear();
    this._destroyed = true;
    this._tokenCache = null;
  }
  getState() {
    return {
      entries: Array.from(this._entries.values()),
      agentId: this.agentId,
      version: 2
    };
  }
  restoreState(state) {
    if (!state || typeof state !== "object") return;
    const s = state;
    if ("version" in s && s.version === 2 && Array.isArray(s.entries)) {
      this._entries.clear();
      for (const entry of s.entries) {
        this._entries.set(entry.id, entry);
      }
      this._initialized = true;
      this._tokenCache = null;
      return;
    }
    if ("content" in s) {
      this._entries.clear();
      const content = s.content;
      if (content) {
        const now = Date.now();
        this._entries.set("legacy_instructions", {
          id: "legacy_instructions",
          content,
          createdAt: now,
          updatedAt: now
        });
      }
      this._initialized = true;
      this._tokenCache = null;
    }
  }
  // ============================================================================
  // Public API
  // ============================================================================
  /**
   * Initialize by loading from storage (called lazily)
   */
  async initialize() {
    if (this._initialized || this._destroyed) return;
    try {
      const entries = await this.storage.load();
      this._entries.clear();
      if (entries) {
        for (const entry of entries) {
          this._entries.set(entry.id, entry);
        }
      }
      this._initialized = true;
    } catch (error) {
      console.warn(`Failed to load persistent instructions for agent '${this.agentId}':`, error);
      this._entries.clear();
      this._initialized = true;
    }
    this._tokenCache = null;
  }
  /**
   * Add or update an instruction entry by key
   */
  async set(key, content) {
    this.assertNotDestroyed();
    await this.ensureInitialized();
    const keyError = validateKey(key);
    if (keyError) return false;
    const trimmedContent = content.trim();
    if (trimmedContent.length === 0) return false;
    if (!this._entries.has(key) && this._entries.size >= this.maxEntries) {
      return false;
    }
    const currentTotal = this.calculateTotalContentLength();
    const existingLength = this._entries.get(key)?.content.length ?? 0;
    const newTotal = currentTotal - existingLength + trimmedContent.length;
    if (newTotal > this.maxTotalLength) {
      return false;
    }
    const now = Date.now();
    const existing = this._entries.get(key);
    this._entries.set(key, {
      id: key,
      content: trimmedContent,
      createdAt: existing?.createdAt ?? now,
      updatedAt: now
    });
    await this.persistToStorage();
    this._tokenCache = null;
    return true;
  }
  /**
   * Remove an instruction entry by key
   */
  async remove(key) {
    this.assertNotDestroyed();
    await this.ensureInitialized();
    if (!this._entries.has(key)) return false;
    this._entries.delete(key);
    if (this._entries.size === 0) {
      await this.storage.delete();
    } else {
      await this.persistToStorage();
    }
    this._tokenCache = null;
    return true;
  }
  /**
   * Get one entry by key, or all entries if no key provided
   */
  async get(key) {
    this.assertNotDestroyed();
    await this.ensureInitialized();
    if (key !== void 0) {
      return this._entries.get(key) ?? null;
    }
    if (this._entries.size === 0) return null;
    return this.getSortedEntries();
  }
  /**
   * List metadata for all entries
   */
  async list() {
    this.assertNotDestroyed();
    await this.ensureInitialized();
    return this.getSortedEntries().map((entry) => ({
      key: entry.id,
      contentLength: entry.content.length,
      createdAt: entry.createdAt,
      updatedAt: entry.updatedAt
    }));
  }
  /**
   * Clear all instruction entries
   */
  async clear() {
    this.assertNotDestroyed();
    this._entries.clear();
    await this.storage.delete();
    this._tokenCache = null;
  }
  /**
   * Check if initialized
   */
  get isInitialized() {
    return this._initialized;
  }
  // ============================================================================
  // Private Helpers
  // ============================================================================
  async ensureInitialized() {
    if (!this._initialized) {
      await this.initialize();
    }
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("PersistentInstructionsPluginNextGen is destroyed");
    }
  }
  /**
   * Persist current entries to storage
   */
  async persistToStorage() {
    await this.storage.save(Array.from(this._entries.values()));
  }
  /**
   * Calculate total content length across all entries
   */
  calculateTotalContentLength() {
    let total = 0;
    for (const entry of this._entries.values()) {
      total += entry.content.length;
    }
    return total;
  }
  /**
   * Get entries sorted by createdAt (oldest first)
   */
  getSortedEntries() {
    return Array.from(this._entries.values()).sort((a, b) => a.createdAt - b.createdAt);
  }
  /**
   * Render all entries as markdown for context injection
   */
  renderContent() {
    return this.getSortedEntries().map((entry) => `### ${entry.id}
${entry.content}`).join("\n\n");
  }
  // ============================================================================
  // Tool Factories
  // ============================================================================
  createInstructionsSetTool() {
    return {
      definition: instructionsSetDefinition,
      execute: async (args) => {
        const key = args.key;
        const content = args.content;
        const keyError = validateKey(key);
        if (keyError) {
          return { error: keyError };
        }
        if (!content || content.trim().length === 0) {
          return { error: "Content cannot be empty. Use instructions_remove to delete an entry." };
        }
        const isUpdate = this._entries.has(key.trim());
        const success = await this.set(key.trim(), content);
        if (!success) {
          if (!isUpdate && this._entries.size >= this.maxEntries) {
            return { error: `Maximum number of entries reached (${this.maxEntries})` };
          }
          return { error: `Content would exceed maximum total length (${this.maxTotalLength} chars)` };
        }
        return {
          success: true,
          message: isUpdate ? `Instruction '${key.trim()}' updated` : `Instruction '${key.trim()}' added`,
          key: key.trim(),
          contentLength: content.trim().length
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `set instruction '${args.key}'`
    };
  }
  createInstructionsRemoveTool() {
    return {
      definition: instructionsRemoveDefinition,
      execute: async (args) => {
        const key = args.key;
        if (!key || typeof key !== "string" || key.trim().length === 0) {
          return { error: "Key is required" };
        }
        const success = await this.remove(key.trim());
        if (!success) {
          return { error: `Instruction '${key.trim()}' not found` };
        }
        return {
          success: true,
          message: `Instruction '${key.trim()}' removed`,
          key: key.trim()
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `remove instruction '${args.key}'`
    };
  }
  createInstructionsListTool() {
    return {
      definition: instructionsListDefinition,
      execute: async () => {
        const entries = await this.list();
        const all = await this.get();
        if (entries.length === 0) {
          return {
            count: 0,
            entries: [],
            message: "(no custom instructions set)"
          };
        }
        const allEntries = all;
        return {
          count: entries.length,
          entries: allEntries.map((e) => ({
            key: e.id,
            content: e.content,
            contentLength: e.content.length,
            createdAt: e.createdAt,
            updatedAt: e.updatedAt
          })),
          agentId: this.agentId
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: () => "list instructions"
    };
  }
  createInstructionsClearTool() {
    return {
      definition: instructionsClearDefinition,
      execute: async (args) => {
        if (args.confirm !== true) {
          return { error: "Must pass confirm: true to clear instructions" };
        }
        await this.clear();
        return {
          success: true,
          message: "All custom instructions cleared"
        };
      },
      permission: { scope: "once", riskLevel: "medium" },
      describeCall: () => "clear instructions"
    };
  }
};
function getDefaultBaseDirectory2() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "users");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "users");
}
var DEFAULT_USER_ID = "default";
function sanitizeUserId(userId) {
  if (!userId) return DEFAULT_USER_ID;
  return userId.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || DEFAULT_USER_ID;
}
var FileUserInfoStorage = class {
  baseDirectory;
  filename;
  constructor(config) {
    this.baseDirectory = config?.baseDirectory ?? getDefaultBaseDirectory2();
    this.filename = config?.filename ?? "user_info.json";
  }
  /**
   * Get the directory path for a specific user
   */
  getUserDirectory(userId) {
    const sanitizedId = sanitizeUserId(userId);
    return path2.join(this.baseDirectory, sanitizedId);
  }
  /**
   * Get the file path for a specific user
   */
  getUserFilePath(userId) {
    return path2.join(this.getUserDirectory(userId), this.filename);
  }
  /**
   * Load user info entries from file for a specific user
   */
  async load(userId) {
    const filePath = this.getUserFilePath(userId);
    try {
      const raw = await fs19.promises.readFile(filePath, "utf-8");
      const data = JSON.parse(raw);
      if (data.version === 1 && Array.isArray(data.entries)) {
        return data.entries.length > 0 ? data.entries : null;
      }
      return null;
    } catch (error) {
      if (!(error instanceof Error && "code" in error && error.code === "ENOENT")) {
        throw error;
      }
      return null;
    }
  }
  /**
   * Save user info entries to file for a specific user
   * Creates directory if it doesn't exist.
   */
  async save(userId, entries) {
    const directory = this.getUserDirectory(userId);
    const filePath = this.getUserFilePath(userId);
    await this.ensureDirectory(directory);
    const data = {
      version: 1,
      userId: userId || DEFAULT_USER_ID,
      entries
    };
    const tempPath = `${filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
      await fs19.promises.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
  }
  /**
   * Delete user info file for a specific user
   */
  async delete(userId) {
    const filePath = this.getUserFilePath(userId);
    try {
      await fs19.promises.unlink(filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
  }
  /**
   * Check if user info file exists for a specific user
   */
  async exists(userId) {
    const filePath = this.getUserFilePath(userId);
    try {
      await fs19.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get the file path for a specific user (for display/debugging)
   */
  getPath(userId) {
    return this.getUserFilePath(userId);
  }
  /**
   * Ensure the directory exists
   */
  async ensureDirectory(directory) {
    try {
      await fs19.promises.mkdir(directory, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
};

// src/core/context-nextgen/plugins/UserInfoPluginNextGen.ts
init_StorageRegistry();
var DEFAULT_MAX_TOTAL_SIZE = 1e5;
var DEFAULT_MAX_ENTRIES2 = 100;
var KEY_MAX_LENGTH2 = 100;
var KEY_PATTERN2 = /^[a-zA-Z0-9_-]+$/;
var USER_INFO_INSTRUCTIONS = `User Info stores key-value information about the current user.
Data is user-specific and persists across sessions and agents.
User info is automatically shown in context \u2014 no need to call user_info_get every turn.

**To manage:**
- \`user_info_set(key, value, description?)\`: Store/update user information
- \`user_info_get(key?)\`: Retrieve one entry by key, or all entries if no key
- \`user_info_remove(key)\`: Remove a specific entry
- \`user_info_clear(confirm: true)\`: Remove all entries (destructive!)

**Use for:** User preferences, context, metadata (theme, language, timezone, role, etc.) It is also perfectly fine to search the web and other external sources for information about the user and then store it in user info for future use.

**Important:** Do not store sensitive information (passwords, tokens, PII) in user info. It is not encrypted and may be accessible to other parts of the system. Always follow best practices for security.

**Rules after each user message:** If the user provides new information about themselves, update user info accordingly. If they ask to change or remove existing information, do that as well. Always keep user info up to date with the latest information provided by the user. Learn about the user proactively!`;
var userInfoSetDefinition = {
  type: "function",
  function: {
    name: "user_info_set",
    description: `Store or update user information by key. Data persists across sessions.
If the key exists, it will be updated. If not, a new entry is created.`,
    parameters: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Unique key for the information (alphanumeric, dash, underscore; max 100 chars)"
        },
        value: {
          description: "Value to store (any JSON-serializable data: string, number, boolean, object, array)"
        },
        description: {
          type: "string",
          description: "Optional description for self-documentation"
        }
      },
      required: ["key", "value"]
    }
  }
};
var userInfoGetDefinition = {
  type: "function",
  function: {
    name: "user_info_get",
    description: "Retrieve user information. If key is provided, returns that entry. Otherwise returns all entries.",
    parameters: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Key of the entry to retrieve (optional - omit to get all entries)"
        }
      },
      required: []
    }
  }
};
var userInfoRemoveDefinition = {
  type: "function",
  function: {
    name: "user_info_remove",
    description: "Remove a specific user information entry by key.",
    parameters: {
      type: "object",
      properties: {
        key: {
          type: "string",
          description: "Key of the entry to remove"
        }
      },
      required: ["key"]
    }
  }
};
var userInfoClearDefinition = {
  type: "function",
  function: {
    name: "user_info_clear",
    description: "Clear all user information entries (DESTRUCTIVE). Requires confirmation.",
    parameters: {
      type: "object",
      properties: {
        confirm: {
          type: "boolean",
          description: "Must be true to confirm deletion"
        }
      },
      required: ["confirm"]
    }
  }
};
function validateKey2(key) {
  if (typeof key !== "string") return "Key must be a string";
  const trimmed = key.trim();
  if (trimmed.length === 0) return "Key cannot be empty";
  if (trimmed.length > KEY_MAX_LENGTH2) return `Key exceeds maximum length (${KEY_MAX_LENGTH2} chars)`;
  if (!KEY_PATTERN2.test(trimmed)) return "Key must contain only alphanumeric characters, dashes, and underscores";
  return null;
}
function getValueType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}
function calculateValueSize(value) {
  const json = JSON.stringify(value);
  return Buffer.byteLength(json, "utf-8");
}
function buildStorageContext(toolContext) {
  const global2 = exports.StorageRegistry.getContext();
  if (global2) return global2;
  if (toolContext?.userId) return { userId: toolContext.userId };
  return void 0;
}
function formatValue(value) {
  if (value === null) return "null";
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  return JSON.stringify(value);
}
var UserInfoPluginNextGen = class {
  name = "user_info";
  _destroyed = false;
  _storage = null;
  /** In-memory cache of entries */
  _entries = /* @__PURE__ */ new Map();
  /** Whether entries have been loaded from storage */
  _initialized = false;
  maxTotalSize;
  maxEntries;
  estimator = simpleTokenEstimator;
  explicitStorage;
  /** UserId for getContent() and lazy initialization */
  userId;
  _tokenCache = null;
  _instructionsTokenCache = null;
  constructor(config) {
    this.maxTotalSize = config?.maxTotalSize ?? DEFAULT_MAX_TOTAL_SIZE;
    this.maxEntries = config?.maxEntries ?? DEFAULT_MAX_ENTRIES2;
    this.explicitStorage = config?.storage;
    this.userId = config?.userId;
  }
  // ============================================================================
  // IContextPluginNextGen Implementation
  // ============================================================================
  getInstructions() {
    return USER_INFO_INSTRUCTIONS;
  }
  async getContent() {
    await this.ensureInitialized();
    if (this._entries.size === 0) {
      this._tokenCache = 0;
      return null;
    }
    const rendered = this.renderContent();
    this._tokenCache = this.estimator.estimateTokens(rendered);
    return rendered;
  }
  getContents() {
    return new Map(this._entries);
  }
  getTokenSize() {
    return this._tokenCache ?? 0;
  }
  getInstructionsTokenSize() {
    if (this._instructionsTokenCache === null) {
      this._instructionsTokenCache = this.estimator.estimateTokens(USER_INFO_INSTRUCTIONS);
    }
    return this._instructionsTokenCache;
  }
  isCompactable() {
    return false;
  }
  async compact(_targetTokensToFree) {
    return 0;
  }
  getTools() {
    return [
      this.createUserInfoSetTool(),
      this.createUserInfoGetTool(),
      this.createUserInfoRemoveTool(),
      this.createUserInfoClearTool()
    ];
  }
  destroy() {
    if (this._destroyed) return;
    this._entries.clear();
    this._destroyed = true;
    this._tokenCache = null;
  }
  getState() {
    return {
      version: 1,
      entries: Array.from(this._entries.values()),
      userId: this.userId
    };
  }
  restoreState(state) {
    if (!state || typeof state !== "object") return;
    const s = state;
    if ("version" in s && s.version === 1 && Array.isArray(s.entries)) {
      this._entries.clear();
      for (const entry of s.entries) {
        this._entries.set(entry.id, entry);
      }
      this._initialized = true;
      this._tokenCache = null;
    }
  }
  // ============================================================================
  // Public API
  // ============================================================================
  /**
   * Check if initialized
   */
  get isInitialized() {
    return this._initialized;
  }
  // ============================================================================
  // Private Helpers
  // ============================================================================
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("UserInfoPluginNextGen is destroyed");
    }
  }
  /**
   * Lazy load entries from storage
   */
  async ensureInitialized() {
    if (this._initialized || this._destroyed) return;
    try {
      const storage = this.resolveStorage();
      const entries = await storage.load(this.userId);
      this._entries.clear();
      if (entries) {
        for (const entry of entries) {
          this._entries.set(entry.id, entry);
        }
      }
      this._initialized = true;
    } catch (error) {
      console.warn(`Failed to load user info for userId '${this.userId ?? "default"}':`, error);
      this._entries.clear();
      this._initialized = true;
    }
    this._tokenCache = null;
  }
  /**
   * Render entries as markdown for context injection
   */
  renderContent() {
    const sorted = Array.from(this._entries.values()).sort((a, b) => a.createdAt - b.createdAt);
    return sorted.map((entry) => `### ${entry.id}
${formatValue(entry.value)}`).join("\n\n");
  }
  /**
   * Resolve storage instance (lazy singleton)
   */
  resolveStorage(context) {
    if (this._storage) return this._storage;
    if (this.explicitStorage) {
      this._storage = this.explicitStorage;
      return this._storage;
    }
    const factory = exports.StorageRegistry.get("userInfo");
    if (factory) {
      this._storage = factory(buildStorageContext(context));
      return this._storage;
    }
    this._storage = new FileUserInfoStorage();
    return this._storage;
  }
  /**
   * Persist current entries to storage
   */
  async persistToStorage(userId) {
    const storage = this.resolveStorage();
    if (this._entries.size === 0) {
      await storage.delete(userId);
    } else {
      await storage.save(userId, Array.from(this._entries.values()));
    }
  }
  // ============================================================================
  // Tool Factories
  // ============================================================================
  createUserInfoSetTool() {
    return {
      definition: userInfoSetDefinition,
      execute: async (args, context) => {
        this.assertNotDestroyed();
        await this.ensureInitialized();
        const userId = context?.userId ?? this.userId;
        const key = args.key;
        const value = args.value;
        const description = args.description;
        const keyError = validateKey2(key);
        if (keyError) {
          return { error: keyError };
        }
        const trimmedKey = key.trim();
        if (value === void 0) {
          return { error: "Value cannot be undefined. Use null for explicit null value." };
        }
        if (!this._entries.has(trimmedKey) && this._entries.size >= this.maxEntries) {
          return { error: `Maximum number of entries reached (${this.maxEntries})` };
        }
        const valueSize = calculateValueSize(value);
        let currentTotal = 0;
        for (const e of this._entries.values()) {
          currentTotal += calculateValueSize(e.value);
        }
        const existingSize = this._entries.has(trimmedKey) ? calculateValueSize(this._entries.get(trimmedKey).value) : 0;
        const newTotal = currentTotal - existingSize + valueSize;
        if (newTotal > this.maxTotalSize) {
          return { error: `Total size would exceed maximum (${this.maxTotalSize} bytes)` };
        }
        const now = Date.now();
        const existing = this._entries.get(trimmedKey);
        const entry = {
          id: trimmedKey,
          value,
          valueType: getValueType(value),
          description,
          createdAt: existing?.createdAt ?? now,
          updatedAt: now
        };
        this._entries.set(trimmedKey, entry);
        this._tokenCache = null;
        await this.persistToStorage(userId);
        return {
          success: true,
          message: existing ? `User info '${trimmedKey}' updated` : `User info '${trimmedKey}' added`,
          key: trimmedKey,
          valueType: entry.valueType,
          valueSize
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `set user info '${args.key}'`
    };
  }
  createUserInfoGetTool() {
    return {
      definition: userInfoGetDefinition,
      execute: async (args, _context) => {
        this.assertNotDestroyed();
        await this.ensureInitialized();
        const key = args.key;
        if (this._entries.size === 0) {
          return { error: "User info not found" };
        }
        if (key !== void 0) {
          const trimmedKey = key.trim();
          const entry = this._entries.get(trimmedKey);
          if (!entry) {
            return { error: `User info '${trimmedKey}' not found` };
          }
          return {
            key: entry.id,
            value: entry.value,
            valueType: entry.valueType,
            description: entry.description,
            createdAt: entry.createdAt,
            updatedAt: entry.updatedAt
          };
        }
        const entries = Array.from(this._entries.values());
        return {
          count: entries.length,
          entries: entries.map((e) => ({
            key: e.id,
            value: e.value,
            valueType: e.valueType,
            description: e.description,
            createdAt: e.createdAt,
            updatedAt: e.updatedAt
          }))
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => args.key ? `get user info '${args.key}'` : "get all user info"
    };
  }
  createUserInfoRemoveTool() {
    return {
      definition: userInfoRemoveDefinition,
      execute: async (args, context) => {
        this.assertNotDestroyed();
        await this.ensureInitialized();
        const userId = context?.userId ?? this.userId;
        const key = args.key;
        if (!key || typeof key !== "string" || key.trim().length === 0) {
          return { error: "Key is required" };
        }
        const trimmedKey = key.trim();
        if (!this._entries.has(trimmedKey)) {
          return { error: `User info '${trimmedKey}' not found` };
        }
        this._entries.delete(trimmedKey);
        this._tokenCache = null;
        await this.persistToStorage(userId);
        return {
          success: true,
          message: `User info '${trimmedKey}' removed`,
          key: trimmedKey
        };
      },
      permission: { scope: "always", riskLevel: "low" },
      describeCall: (args) => `remove user info '${args.key}'`
    };
  }
  createUserInfoClearTool() {
    return {
      definition: userInfoClearDefinition,
      execute: async (args, context) => {
        this.assertNotDestroyed();
        const userId = context?.userId ?? this.userId;
        if (args.confirm !== true) {
          return { error: "Must pass confirm: true to clear user info" };
        }
        this._entries.clear();
        this._tokenCache = null;
        const storage = this.resolveStorage(context);
        await storage.delete(userId);
        return {
          success: true,
          message: "All user information cleared"
        };
      },
      permission: { scope: "once", riskLevel: "medium" },
      describeCall: () => "clear user info"
    };
  }
};

// src/core/context-nextgen/AgentContextNextGen.ts
init_StorageRegistry();

// src/core/context-nextgen/strategies/DefaultCompactionStrategy.ts
var DEFAULT_THRESHOLD = 0.7;
var DefaultCompactionStrategy = class {
  name = "default";
  displayName = "Dumb";
  description = "Do not use";
  threshold;
  constructor(config) {
    this.threshold = config?.threshold ?? DEFAULT_THRESHOLD;
  }
  /**
   * Emergency compaction when thresholds exceeded.
   *
   * Strategy:
   * 1. Compact plugins first (in_context_memory, then working_memory)
   * 2. If still needed, remove oldest conversation messages (preserving tool pairs)
   */
  async compact(context, targetToFree) {
    const log = [];
    const pluginsCompacted = [];
    let tokensFreed = 0;
    let messagesRemoved = 0;
    let remaining = targetToFree;
    log.push(`Compaction started: need to free ~${targetToFree} tokens`);
    const compactablePlugins = [...context.plugins].filter((p) => p.isCompactable()).sort((a, b) => {
      const order = {
        "in_context_memory": 1,
        "working_memory": 2
      };
      return (order[a.name] ?? 10) - (order[b.name] ?? 10);
    });
    for (const plugin of compactablePlugins) {
      if (remaining <= 0) break;
      const freed = await context.compactPlugin(plugin.name, remaining);
      if (freed > 0) {
        tokensFreed += freed;
        remaining -= freed;
        pluginsCompacted.push(plugin.name);
        log.push(`Compacted ${plugin.name}: freed ~${freed} tokens`);
      }
    }
    if (remaining > 0 && context.conversation.length > 0) {
      const conversationResult = await this.compactConversation(context, remaining, log);
      tokensFreed += conversationResult.tokensFreed;
      messagesRemoved = conversationResult.messagesRemoved;
      remaining -= conversationResult.tokensFreed;
    }
    log.push(`Compaction complete: freed ~${tokensFreed} tokens total`);
    return {
      tokensFreed,
      messagesRemoved,
      pluginsCompacted,
      log
    };
  }
  /**
   * Post-cycle consolidation.
   *
   * Default strategy does nothing - override in subclasses for:
   * - Conversation summarization
   * - Memory deduplication
   * - Data promotion to persistent storage
   */
  async consolidate(_context) {
    return {
      performed: false,
      tokensChanged: 0,
      actions: []
    };
  }
  /**
   * Compact conversation by removing oldest messages.
   * Preserves tool pairs (tool_use + tool_result).
   */
  async compactConversation(context, targetToFree, log) {
    const conversation = context.conversation;
    if (conversation.length === 0) {
      return { tokensFreed: 0, messagesRemoved: 0 };
    }
    const toolPairs = this.findToolPairs(conversation);
    const inPair = /* @__PURE__ */ new Set();
    for (const indices of toolPairs.values()) {
      for (const idx of indices) {
        inPair.add(idx);
      }
    }
    const safeToRemove = [];
    for (let i = 0; i < conversation.length; i++) {
      if (!inPair.has(i)) {
        safeToRemove.push(i);
      }
    }
    for (const [, indices] of toolPairs) {
      if (indices.length >= 2) {
        for (const idx of indices) {
          if (!safeToRemove.includes(idx)) {
            safeToRemove.push(idx);
          }
        }
      }
    }
    safeToRemove.sort((a, b) => a - b);
    let tokensFreed = 0;
    const indicesToRemove = [];
    for (const idx of safeToRemove) {
      if (tokensFreed >= targetToFree) break;
      const item = conversation[idx];
      if (!item) continue;
      const toolUseId = this.getToolUseId(item);
      if (toolUseId) {
        const pairIndices = toolPairs.get(toolUseId);
        if (pairIndices && pairIndices.length >= 2) {
          for (const pairIdx of pairIndices) {
            if (!indicesToRemove.includes(pairIdx)) {
              indicesToRemove.push(pairIdx);
              const pairItem = conversation[pairIdx];
              if (pairItem) {
                tokensFreed += context.estimateTokens(pairItem);
              }
            }
          }
          continue;
        }
      }
      if (!indicesToRemove.includes(idx)) {
        indicesToRemove.push(idx);
        tokensFreed += context.estimateTokens(item);
      }
    }
    if (indicesToRemove.length > 0) {
      await context.removeMessages(indicesToRemove);
      log.push(`Removed ${indicesToRemove.length} messages from conversation: freed ~${tokensFreed} tokens`);
    }
    return {
      tokensFreed,
      messagesRemoved: indicesToRemove.length
    };
  }
  /**
   * Find tool_use/tool_result pairs in conversation.
   * Returns Map<tool_use_id, array of message indices>.
   */
  findToolPairs(conversation) {
    const pairs = /* @__PURE__ */ new Map();
    for (let i = 0; i < conversation.length; i++) {
      const item = conversation[i];
      if (item?.type !== "message") continue;
      const content = item.content;
      if (!content) continue;
      for (const c of content) {
        if (c.type === "tool_use") {
          const toolUseId = c.id;
          if (toolUseId) {
            const existing = pairs.get(toolUseId) ?? [];
            existing.push(i);
            pairs.set(toolUseId, existing);
          }
        } else if (c.type === "tool_result") {
          const toolUseId = c.tool_use_id;
          if (toolUseId) {
            const existing = pairs.get(toolUseId) ?? [];
            existing.push(i);
            pairs.set(toolUseId, existing);
          }
        }
      }
    }
    return pairs;
  }
  /**
   * Get tool_use_id from an item (if it contains tool_use or tool_result).
   */
  getToolUseId(item) {
    const msg = item;
    if (msg?.type !== "message") return null;
    const content = msg.content;
    if (!content) return null;
    for (const c of content) {
      if (c.type === "tool_use") {
        return c.id;
      } else if (c.type === "tool_result") {
        return c.tool_use_id;
      }
    }
    return null;
  }
};

// src/core/context-nextgen/strategies/AlgorithmicCompactionStrategy.ts
var DEFAULT_THRESHOLD2 = 0.75;
var DEFAULT_TOOL_RESULT_SIZE_THRESHOLD = 1024;
var DEFAULT_MAX_TOOL_PAIRS = 10;
var AlgorithmicCompactionStrategy = class {
  name = "algorithmic";
  displayName = "Algorithmic";
  description = "Moves large tool results to working memory, limits tool pairs, applies rolling window. Ideal for tool-heavy agents.";
  threshold;
  requiredPlugins = ["working_memory"];
  toolResultSizeThreshold;
  maxToolPairs;
  constructor(config) {
    this.threshold = config?.threshold ?? DEFAULT_THRESHOLD2;
    this.toolResultSizeThreshold = config?.toolResultSizeThreshold ?? DEFAULT_TOOL_RESULT_SIZE_THRESHOLD;
    this.maxToolPairs = config?.maxToolPairs ?? DEFAULT_MAX_TOOL_PAIRS;
  }
  /**
   * Emergency compaction when context exceeds threshold.
   *
   * Strategy:
   * 1. Run consolidate() first to move tool results to memory
   * 2. If still need space, apply rolling window (remove oldest messages)
   */
  async compact(context, targetToFree) {
    const log = [];
    let tokensFreed = 0;
    let messagesRemoved = 0;
    const pluginsCompacted = [];
    log.push(`Algorithmic compaction started: need to free ~${targetToFree} tokens`);
    const consolidateResult = await this.consolidate(context);
    if (consolidateResult.performed) {
      tokensFreed += Math.abs(consolidateResult.tokensChanged);
      log.push(...consolidateResult.actions);
    }
    let remaining = targetToFree - tokensFreed;
    if (remaining > 0 && context.conversation.length > 0) {
      log.push(`Rolling window: need to free ~${remaining} more tokens`);
      const result = await this.applyRollingWindow(context, remaining, log);
      tokensFreed += result.tokensFreed;
      messagesRemoved = result.messagesRemoved;
    }
    log.push(`Algorithmic compaction complete: freed ~${tokensFreed} tokens total`);
    return { tokensFreed, messagesRemoved, pluginsCompacted, log };
  }
  /**
   * Post-cycle consolidation.
   *
   * 1. Find all tool pairs in conversation
   * 2. Move large tool results (> threshold) to Working Memory
   * 3. Limit remaining tool pairs to maxToolPairs
   */
  async consolidate(context) {
    const log = [];
    let tokensChanged = 0;
    const memory = this.getWorkingMemory(context);
    const toolPairs = this.findToolPairs(context.conversation);
    if (toolPairs.length === 0) {
      return { performed: false, tokensChanged: 0, actions: [] };
    }
    const indicesToRemove = [];
    for (const pair of toolPairs) {
      if (pair.resultSizeBytes > this.toolResultSizeThreshold) {
        const key = this.generateKey(pair.toolName, pair.toolUseId);
        const desc = this.generateDescription(pair.toolName, pair.toolArgs);
        await memory.store(key, desc, pair.resultContent, {
          tier: "raw",
          priority: "normal"
        });
        if (!indicesToRemove.includes(pair.toolUseIndex)) {
          indicesToRemove.push(pair.toolUseIndex);
        }
        if (!indicesToRemove.includes(pair.toolResultIndex)) {
          indicesToRemove.push(pair.toolResultIndex);
        }
        log.push(
          `Moved ${pair.toolName} result (${this.formatBytes(pair.resultSizeBytes)}) to memory: ${key}`
        );
      }
    }
    const remainingPairs = toolPairs.filter(
      (p) => !indicesToRemove.includes(p.toolUseIndex) && !indicesToRemove.includes(p.toolResultIndex)
    );
    if (remainingPairs.length > this.maxToolPairs) {
      const toRemove = remainingPairs.slice(0, remainingPairs.length - this.maxToolPairs);
      for (const pair of toRemove) {
        if (!indicesToRemove.includes(pair.toolUseIndex)) {
          indicesToRemove.push(pair.toolUseIndex);
        }
        if (!indicesToRemove.includes(pair.toolResultIndex)) {
          indicesToRemove.push(pair.toolResultIndex);
        }
        log.push(`Removed old tool pair: ${pair.toolName} (exceeds ${this.maxToolPairs} pair limit)`);
      }
    }
    if (indicesToRemove.length > 0) {
      tokensChanged = -await context.removeMessages(indicesToRemove);
      log.push(`Removed ${indicesToRemove.length} messages, freed ~${Math.abs(tokensChanged)} tokens`);
    }
    return {
      performed: indicesToRemove.length > 0,
      tokensChanged,
      actions: log
    };
  }
  /**
   * Get the Working Memory plugin from context.
   * @throws Error if plugin is not available
   */
  getWorkingMemory(context) {
    const plugin = context.plugins.find((p) => p.name === "working_memory");
    if (!plugin) {
      throw new Error("AlgorithmicCompactionStrategy requires working_memory plugin");
    }
    return plugin;
  }
  /**
   * Find all tool_use/tool_result pairs in conversation.
   * Returns pairs sorted by oldest first (lowest index).
   */
  findToolPairs(conversation) {
    const toolUses = /* @__PURE__ */ new Map();
    const toolResults = /* @__PURE__ */ new Map();
    for (let i = 0; i < conversation.length; i++) {
      const item = conversation[i];
      if (item?.type !== "message") continue;
      const content = item.content;
      if (!Array.isArray(content)) continue;
      for (const block of content) {
        if (block.type === "tool_use") {
          const toolUseId = block.id;
          if (toolUseId) {
            toolUses.set(toolUseId, {
              index: i,
              toolName: block.name || "unknown",
              toolArgs: block.input
            });
          }
        } else if (block.type === "tool_result") {
          const toolUseId = block.tool_use_id;
          if (toolUseId) {
            const resultContent = block.content;
            const sizeBytes = this.estimateSize(resultContent);
            toolResults.set(toolUseId, {
              index: i,
              content: resultContent,
              sizeBytes
            });
          }
        }
      }
    }
    const pairs = [];
    for (const [toolUseId, useInfo] of toolUses) {
      const resultInfo = toolResults.get(toolUseId);
      if (resultInfo) {
        pairs.push({
          toolUseId,
          toolUseIndex: useInfo.index,
          toolResultIndex: resultInfo.index,
          toolName: useInfo.toolName,
          toolArgs: useInfo.toolArgs,
          resultContent: resultInfo.content,
          resultSizeBytes: resultInfo.sizeBytes
        });
      }
    }
    pairs.sort((a, b) => a.toolUseIndex - b.toolUseIndex);
    return pairs;
  }
  /**
   * Generate a key for storing tool result in memory.
   * Format: tool_result.<tool_name>.<short_id>
   */
  generateKey(toolName, toolUseId) {
    const shortId = toolUseId.slice(-8);
    const safeName = toolName.replace(/[^a-zA-Z0-9_]/g, "_");
    return `tool_result.${safeName}.${shortId}`;
  }
  /**
   * Generate a description for the stored tool result.
   * Format: "Result of <tool_name>(<arg_summary>)"
   */
  generateDescription(toolName, toolArgs) {
    const argSummary = this.summarizeArgs(toolArgs, 100);
    const desc = `Result of ${toolName}(${argSummary})`;
    return desc.length > 150 ? desc.slice(0, 147) + "..." : desc;
  }
  /**
   * Summarize arguments for description, limiting to maxLength chars.
   */
  summarizeArgs(args, maxLength) {
    if (args === void 0 || args === null) {
      return "";
    }
    try {
      if (typeof args === "object") {
        const entries = Object.entries(args);
        const parts = [];
        let totalLen = 0;
        for (const [key, value] of entries) {
          let valueStr;
          if (typeof value === "string") {
            valueStr = value.length > 30 ? `"${value.slice(0, 27)}..."` : `"${value}"`;
          } else if (typeof value === "object" && value !== null) {
            valueStr = Array.isArray(value) ? `[${value.length} items]` : "{...}";
          } else {
            valueStr = String(value);
          }
          const part = `${key}=${valueStr}`;
          if (totalLen + part.length + 2 > maxLength) {
            parts.push("...");
            break;
          }
          parts.push(part);
          totalLen += part.length + 2;
        }
        return parts.join(", ");
      }
      return String(args).slice(0, maxLength);
    } catch {
      return "...";
    }
  }
  /**
   * Estimate the size of a value in bytes.
   */
  estimateSize(value) {
    if (value === void 0 || value === null) {
      return 0;
    }
    try {
      const json = JSON.stringify(value);
      return new TextEncoder().encode(json).length;
    } catch {
      return String(value).length * 2;
    }
  }
  /**
   * Format bytes for logging.
   */
  formatBytes(bytes) {
    if (bytes < 1024) return `${bytes}B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  }
  /**
   * Apply rolling window compaction - remove oldest messages until target is met.
   */
  async applyRollingWindow(context, targetToFree, log) {
    const conversation = context.conversation;
    if (conversation.length === 0) {
      return { tokensFreed: 0, messagesRemoved: 0 };
    }
    const toolPairs = this.findToolPairs(conversation);
    const pairIndices = /* @__PURE__ */ new Set();
    for (const pair of toolPairs) {
      pairIndices.add(pair.toolUseIndex);
      pairIndices.add(pair.toolResultIndex);
    }
    const nonToolIndices = [];
    for (let i = 0; i < conversation.length; i++) {
      if (!pairIndices.has(i)) {
        nonToolIndices.push(i);
      }
    }
    let tokensFreed = 0;
    const indicesToRemove = [];
    for (const idx of nonToolIndices) {
      if (tokensFreed >= targetToFree) break;
      const item = conversation[idx];
      if (item) {
        tokensFreed += context.estimateTokens(item);
        indicesToRemove.push(idx);
      }
    }
    if (tokensFreed < targetToFree) {
      for (const pair of toolPairs) {
        if (tokensFreed >= targetToFree) break;
        const useItem = conversation[pair.toolUseIndex];
        const resultItem = conversation[pair.toolResultIndex];
        if (useItem && !indicesToRemove.includes(pair.toolUseIndex)) {
          tokensFreed += context.estimateTokens(useItem);
          indicesToRemove.push(pair.toolUseIndex);
        }
        if (resultItem && !indicesToRemove.includes(pair.toolResultIndex)) {
          tokensFreed += context.estimateTokens(resultItem);
          indicesToRemove.push(pair.toolResultIndex);
        }
      }
    }
    if (indicesToRemove.length > 0) {
      await context.removeMessages(indicesToRemove);
      log.push(`Rolling window removed ${indicesToRemove.length} messages`);
    }
    return {
      tokensFreed,
      messagesRemoved: indicesToRemove.length
    };
  }
};

// src/core/context-nextgen/strategies/StrategyRegistry.ts
var StrategyRegistry = class {
  static registry = /* @__PURE__ */ new Map();
  static initialized = false;
  /**
   * Ensure built-in strategies are registered
   */
  static ensureInitialized() {
    if (this.initialized) return;
    this.registerInternal(DefaultCompactionStrategy, { isBuiltIn: true });
    this.registerInternal(AlgorithmicCompactionStrategy, { isBuiltIn: true });
    this.initialized = true;
  }
  /**
   * Internal registration that reads metadata from strategy instance
   */
  static registerInternal(strategyClass, options = {}) {
    const instance = new strategyClass();
    const entry = {
      name: instance.name,
      displayName: instance.displayName,
      description: instance.description,
      threshold: instance.threshold,
      isBuiltIn: options.isBuiltIn ?? false,
      strategyClass
    };
    if (this.registry.has(entry.name)) {
      throw new Error(
        `Strategy '${entry.name}' is already registered. Available strategies: ${this.list().join(", ")}`
      );
    }
    this.registry.set(entry.name, entry);
  }
  /**
   * Register a new strategy class.
   *
   * Metadata (name, displayName, description, threshold) is read from
   * the strategy class itself.
   *
   * @param strategyClass - Strategy class to register
   * @param options - Registration options (isBuiltIn defaults to false)
   * @throws Error if a strategy with this name already exists
   *
   * @example
   * ```typescript
   * // Simple registration
   * StrategyRegistry.register(SmartCompactionStrategy);
   *
   * // With options
   * StrategyRegistry.register(SmartCompactionStrategy, { isBuiltIn: false });
   * ```
   */
  static register(strategyClass, options) {
    this.ensureInitialized();
    this.registerInternal(strategyClass, options);
  }
  /**
   * Get a strategy entry by name.
   *
   * @throws Error if strategy not found
   */
  static get(name) {
    this.ensureInitialized();
    const entry = this.registry.get(name);
    if (!entry) {
      throw new Error(
        `Strategy '${name}' not found. Available strategies: ${this.list().join(", ")}`
      );
    }
    return entry;
  }
  /**
   * Check if a strategy exists.
   */
  static has(name) {
    this.ensureInitialized();
    return this.registry.has(name);
  }
  /**
   * List all registered strategy names.
   */
  static list() {
    this.ensureInitialized();
    return Array.from(this.registry.keys());
  }
  /**
   * Create a strategy instance by name.
   *
   * @param name - Strategy name
   * @param config - Optional configuration for the strategy
   * @throws Error if strategy not found
   */
  static create(name, config) {
    const entry = this.get(name);
    return new entry.strategyClass(config);
  }
  /**
   * Get strategy information for UI display (serializable, no class refs).
   *
   * Returns array of StrategyInfo objects that can be safely serialized
   * and sent over IPC.
   */
  static getInfo() {
    this.ensureInitialized();
    return Array.from(this.registry.values()).map(
      ({ name, displayName, description, threshold, isBuiltIn }) => ({
        name,
        displayName,
        description,
        threshold,
        isBuiltIn
      })
    );
  }
  /**
   * Remove a strategy from the registry.
   *
   * @param name - Strategy name to remove
   * @returns true if removed, false if not found
   * @throws Error if trying to remove a built-in strategy
   */
  static remove(name) {
    this.ensureInitialized();
    const entry = this.registry.get(name);
    if (!entry) {
      return false;
    }
    if (entry.isBuiltIn) {
      throw new Error(`Cannot remove built-in strategy '${name}'`);
    }
    return this.registry.delete(name);
  }
  /**
   * Get a strategy entry without throwing.
   * Returns undefined if not found.
   */
  static getIfExists(name) {
    this.ensureInitialized();
    return this.registry.get(name);
  }
  /**
   * Reset the registry to initial state (for testing).
   * @internal
   */
  static _reset() {
    this.registry.clear();
    this.initialized = false;
  }
};

// src/core/context-nextgen/types.ts
var DEFAULT_FEATURES = {
  workingMemory: true,
  inContextMemory: false,
  persistentInstructions: false,
  userInfo: false
};
var DEFAULT_CONFIG2 = {
  responseReserve: 4096,
  strategy: "algorithmic"
};

// src/core/context-nextgen/AgentContextNextGen.ts
var AgentContextNextGen = class _AgentContextNextGen extends eventemitter3.EventEmitter {
  // ============================================================================
  // Private State
  // ============================================================================
  /** Configuration */
  _config;
  /** Maximum context tokens for the model */
  _maxContextTokens;
  /** Compaction strategy */
  _compactionStrategy;
  /** System prompt (user-provided) */
  _systemPrompt;
  /** Conversation history (excludes current input) */
  _conversation = [];
  /** Current input (pending, will be added to conversation after LLM response) */
  _currentInput = [];
  /** Registered plugins */
  _plugins = /* @__PURE__ */ new Map();
  /** Tool manager */
  _tools;
  /** Token estimator for conversation/input */
  _estimator = simpleTokenEstimator;
  /** Session ID (if loaded/saved) */
  _sessionId = null;
  /** Agent ID */
  _agentId;
  /** User ID for multi-user scenarios */
  _userId;
  /** Allowed connector names (when agent is restricted to a subset) */
  _allowedConnectors;
  /** Storage backend */
  _storage;
  /** Destroyed flag */
  _destroyed = false;
  /** Cached budget from last prepare() call */
  _cachedBudget = null;
  /** Callback for beforeCompaction hook (set by Agent) */
  _beforeCompactionCallback = null;
  // ============================================================================
  // Static Factory
  // ============================================================================
  /**
   * Create a new AgentContextNextGen instance.
   */
  static create(config) {
    return new _AgentContextNextGen(config);
  }
  // ============================================================================
  // Constructor
  // ============================================================================
  constructor(config) {
    super();
    const modelInfo = getModelInfo(config.model);
    this._maxContextTokens = config.maxContextTokens ?? modelInfo?.features?.input?.tokens ?? 128e3;
    this._config = {
      model: config.model,
      maxContextTokens: this._maxContextTokens,
      responseReserve: config.responseReserve ?? DEFAULT_CONFIG2.responseReserve,
      systemPrompt: config.systemPrompt,
      strategy: config.strategy ?? DEFAULT_CONFIG2.strategy,
      features: { ...DEFAULT_FEATURES, ...config.features },
      agentId: config.agentId ?? this.generateId(),
      storage: config.storage
    };
    this._systemPrompt = config.systemPrompt;
    this._agentId = this._config.agentId;
    this._userId = config.userId;
    this._allowedConnectors = config.connectors;
    const sessionFactory = exports.StorageRegistry.get("sessions");
    const storageCtx = exports.StorageRegistry.getContext() ?? (config.userId ? { userId: config.userId } : void 0);
    this._storage = config.storage ?? (sessionFactory ? sessionFactory(this._agentId, storageCtx) : void 0);
    this._compactionStrategy = config.compactionStrategy ?? StrategyRegistry.create(this._config.strategy);
    this._tools = new ToolManager(
      config.toolExecutionTimeout ? { toolExecutionTimeout: config.toolExecutionTimeout } : void 0
    );
    if (config.tools) {
      for (const tool of config.tools) {
        this._tools.register(tool);
      }
    }
    this.initializePlugins(config.plugins);
    this.syncToolContext();
  }
  /**
   * Initialize plugins based on feature flags.
   * Called automatically in constructor.
   */
  initializePlugins(pluginConfigs) {
    const features = this._config.features;
    const configs = pluginConfigs ?? {};
    if (features.workingMemory) {
      this.registerPlugin(new WorkingMemoryPluginNextGen(
        configs.workingMemory
      ));
    }
    if (features.inContextMemory) {
      this.registerPlugin(new InContextMemoryPluginNextGen(
        configs.inContextMemory
      ));
    }
    if (features.persistentInstructions) {
      if (!this._agentId) {
        throw new Error("persistentInstructions feature requires agentId to be set");
      }
      const piConfig = configs.persistentInstructions;
      this.registerPlugin(new PersistentInstructionsPluginNextGen({
        agentId: this._agentId,
        ...piConfig
      }));
    }
    if (features.userInfo) {
      const uiConfig = configs.userInfo;
      this.registerPlugin(new UserInfoPluginNextGen({
        userId: this._userId,
        ...uiConfig
      }));
    }
    this.validateStrategyDependencies(this._compactionStrategy);
  }
  /**
   * Validate that a strategy's required plugins are registered.
   * @throws Error if any required plugin is missing
   */
  validateStrategyDependencies(strategy) {
    if (!strategy.requiredPlugins?.length) return;
    const availablePlugins = new Set(this._plugins.keys());
    const missing = strategy.requiredPlugins.filter((name) => !availablePlugins.has(name));
    if (missing.length > 0) {
      throw new Error(
        `Strategy '${strategy.name}' requires plugins that are not registered: ${missing.join(", ")}. Available plugins: ${Array.from(availablePlugins).join(", ") || "none"}`
      );
    }
  }
  /**
   * Sync identity fields and connector registry to ToolContext.
   * Merges with existing ToolContext to preserve other fields (memory, signal, taskId).
   *
   * Connector registry resolution order:
   * 1. If `connectors` (allowed names) is set → filtered view of global registry
   * 2. If access policy + userId → scoped view via Connector.scoped()
   * 3. Otherwise → full global registry
   */
  syncToolContext() {
    const existing = this._tools.getToolContext();
    this._tools.setToolContext({
      ...existing,
      agentId: this._agentId,
      userId: this._userId,
      connectorRegistry: this.buildConnectorRegistry()
    });
  }
  /**
   * Build the connector registry appropriate for this agent's config.
   */
  buildConnectorRegistry() {
    if (this._allowedConnectors?.length) {
      const allowedSet = new Set(this._allowedConnectors);
      const base = this._userId && exports.Connector.getAccessPolicy() ? exports.Connector.scoped({ userId: this._userId }) : exports.Connector.asRegistry();
      return {
        get: (name) => {
          if (!allowedSet.has(name)) {
            const available = this._allowedConnectors.filter((n) => base.has(n)).join(", ") || "none";
            throw new Error(`Connector '${name}' not found. Available: ${available}`);
          }
          return base.get(name);
        },
        has: (name) => allowedSet.has(name) && base.has(name),
        list: () => base.list().filter((n) => allowedSet.has(n)),
        listAll: () => base.listAll().filter((c) => allowedSet.has(c.name)),
        size: () => base.listAll().filter((c) => allowedSet.has(c.name)).length,
        getDescriptionsForTools: () => {
          const connectors = base.listAll().filter((c) => allowedSet.has(c.name));
          if (connectors.length === 0) return "No connectors registered yet.";
          return connectors.map((c) => `  - "${c.name}": ${c.displayName} - ${c.config.description || "No description"}`).join("\n");
        },
        getInfo: () => {
          const info = {};
          for (const c of base.listAll().filter((c2) => allowedSet.has(c2.name))) {
            info[c.name] = { displayName: c.displayName, description: c.config.description || "", baseURL: c.baseURL };
          }
          return info;
        }
      };
    }
    if (this._userId && exports.Connector.getAccessPolicy()) {
      return exports.Connector.scoped({ userId: this._userId });
    }
    return exports.Connector.asRegistry();
  }
  // ============================================================================
  // Public Properties
  // ============================================================================
  /** Get the tool manager */
  get tools() {
    return this._tools;
  }
  /** Get the model name */
  get model() {
    return this._config.model;
  }
  /** Get the agent ID */
  get agentId() {
    return this._agentId;
  }
  /** Get the current user ID */
  get userId() {
    return this._userId;
  }
  /** Set user ID. Automatically updates ToolContext for all tool executions. */
  set userId(value) {
    this._userId = value;
    this.syncToolContext();
  }
  /** Get the allowed connector names (undefined = all visible connectors) */
  get connectors() {
    return this._allowedConnectors;
  }
  /** Set allowed connector names. Updates ToolContext.connectorRegistry. */
  set connectors(value) {
    this._allowedConnectors = value;
    this.syncToolContext();
  }
  /** Get/set system prompt */
  get systemPrompt() {
    return this._systemPrompt;
  }
  set systemPrompt(value) {
    this._systemPrompt = value;
  }
  /** Get feature configuration */
  get features() {
    return this._config.features;
  }
  /** Check if destroyed */
  get isDestroyed() {
    return this._destroyed;
  }
  /** Get current session ID */
  get sessionId() {
    return this._sessionId;
  }
  /** Get storage (null if not configured) */
  get storage() {
    return this._storage ?? null;
  }
  /** Get max context tokens */
  get maxContextTokens() {
    return this._maxContextTokens;
  }
  /** Get response reserve tokens */
  get responseReserve() {
    return this._config.responseReserve;
  }
  /** Get current tools token usage (useful for debugging) */
  get toolsTokens() {
    return this.calculateToolsTokens();
  }
  /**
   * Get the cached budget from the last prepare() call.
   * Returns null if prepare() hasn't been called yet.
   */
  get lastBudget() {
    return this._cachedBudget;
  }
  /**
   * Get the current compaction strategy.
   */
  get compactionStrategy() {
    return this._compactionStrategy;
  }
  /**
   * Set the compaction strategy.
   * Can be changed at runtime to switch compaction behavior.
   */
  setCompactionStrategy(strategy) {
    this.assertNotDestroyed();
    this.validateStrategyDependencies(strategy);
    this._compactionStrategy = strategy;
  }
  /**
   * Set the beforeCompaction callback.
   * Called by Agent to wire up lifecycle hooks.
   */
  setBeforeCompactionCallback(callback) {
    this._beforeCompactionCallback = callback;
  }
  // ============================================================================
  // Compatibility / Migration Helpers
  // ============================================================================
  /**
   * Get working memory plugin (if registered).
   * This is a compatibility accessor for code expecting ctx.memory
   */
  get memory() {
    const plugin = this._plugins.get("working_memory");
    return plugin;
  }
  /**
   * Get the last message (most recent user message or tool results).
   * Used for compatibility with old code that expected a single item.
   */
  getLastUserMessage() {
    if (this._conversation.length === 0) return null;
    const last = this._conversation[this._conversation.length - 1];
    if (!last) return null;
    if ("role" in last && last.role === "user" /* USER */) return last;
    return null;
  }
  /**
   * Set current input (user message).
   * Adds a user message to the conversation and sets it as the current input for prepare().
   */
  setCurrentInput(content) {
    this.assertNotDestroyed();
    this._currentInput = [];
    this.addUserMessage(content);
    const lastMsg = this._conversation[this._conversation.length - 1];
    if (lastMsg) {
      this._currentInput.push(lastMsg);
    }
  }
  /**
   * Add multiple input items to conversation (legacy compatibility).
   */
  addInputItems(items) {
    this.assertNotDestroyed();
    for (const item of items) {
      this._conversation.push(item);
    }
  }
  /**
   * Legacy alias for prepare() - returns prepared context.
   */
  async prepareConversation() {
    return this.prepare();
  }
  /**
   * Add a message (legacy compatibility).
   * For user messages, use addUserMessage instead.
   * For assistant messages, use addAssistantResponse instead.
   */
  addMessage(role, content) {
    this.assertNotDestroyed();
    if (role === "user") {
      return this.addUserMessage(content);
    }
    const outputItem = {
      type: "message",
      role: "assistant" /* ASSISTANT */,
      content: [{
        type: "output_text" /* OUTPUT_TEXT */,
        text: typeof content === "string" ? content : JSON.stringify(content)
      }]
    };
    return this.addAssistantResponse([outputItem]);
  }
  // ============================================================================
  // Plugin Management
  // ============================================================================
  /**
   * Register a plugin.
   * Plugin's tools are automatically registered with ToolManager.
   */
  registerPlugin(plugin) {
    this.assertNotDestroyed();
    if (this._plugins.has(plugin.name)) {
      throw new Error(`Plugin '${plugin.name}' is already registered`);
    }
    this._plugins.set(plugin.name, plugin);
    const tools = plugin.getTools();
    for (const tool of tools) {
      this._tools.register(tool);
    }
  }
  /**
   * Get a plugin by name.
   */
  getPlugin(name) {
    return this._plugins.get(name) ?? null;
  }
  /**
   * Check if a plugin is registered.
   */
  hasPlugin(name) {
    return this._plugins.has(name);
  }
  /**
   * Get all registered plugins.
   */
  getPlugins() {
    return Array.from(this._plugins.values());
  }
  // ============================================================================
  // Conversation Management
  // ============================================================================
  /**
   * Add a user message.
   * Returns the message ID.
   */
  addUserMessage(content) {
    this.assertNotDestroyed();
    const id = this.generateId();
    const contentArray = typeof content === "string" ? [{ type: "input_text" /* INPUT_TEXT */, text: content }] : content;
    const message = {
      type: "message",
      id,
      role: "user" /* USER */,
      content: contentArray
    };
    this._currentInput = [message];
    this.emit("message:added", { role: "user", index: this._conversation.length });
    return id;
  }
  /**
   * Add assistant response (from LLM output).
   * Also moves current input to conversation history.
   * Returns the message ID.
   */
  addAssistantResponse(output) {
    this.assertNotDestroyed();
    if (this._currentInput.length > 0) {
      this._conversation.push(...this._currentInput);
      this._currentInput = [];
    }
    const id = this.generateId();
    const contentArray = [];
    for (const item of output) {
      if (item.type === "message" && "content" in item) {
        const msg = item;
        for (const c of msg.content) {
          if (c.type === "output_text" /* OUTPUT_TEXT */ || c.type === "input_text" /* INPUT_TEXT */) {
            contentArray.push({
              type: "output_text" /* OUTPUT_TEXT */,
              text: c.text || ""
            });
          } else if (c.type === "tool_use" /* TOOL_USE */) {
            contentArray.push(c);
          }
        }
      } else if (item.type === "compaction" || item.type === "reasoning") {
        continue;
      }
    }
    if (contentArray.length > 0) {
      const message = {
        type: "message",
        id,
        role: "assistant" /* ASSISTANT */,
        content: contentArray
      };
      this._conversation.push(message);
      this.emit("message:added", { role: "assistant", index: this._conversation.length - 1 });
    }
    return id;
  }
  /**
   * Add tool results.
   * Returns the message ID.
   */
  addToolResults(results) {
    this.assertNotDestroyed();
    if (results.length === 0) {
      return "";
    }
    const id = this.generateId();
    const contentArray = results.map((r) => {
      let contentStr;
      let images;
      if (typeof r.content === "string") {
        contentStr = r.content;
      } else if (r.content && Array.isArray(r.content.__images) && r.content.__images.length > 0) {
        images = r.content.__images;
        const { __images: _, base64: __, ...rest } = r.content;
        contentStr = JSON.stringify(rest);
      } else {
        contentStr = JSON.stringify(r.content);
      }
      return {
        type: "tool_result" /* TOOL_RESULT */,
        tool_use_id: r.tool_use_id,
        content: contentStr,
        error: r.error,
        ...images ? { __images: images } : {}
      };
    });
    const message = {
      type: "message",
      id,
      role: "user" /* USER */,
      // Tool results are user role in most APIs
      content: contentArray
    };
    this._currentInput = [message];
    this.emit("message:added", { role: "tool", index: this._conversation.length });
    return id;
  }
  /**
   * Get conversation history (read-only).
   */
  getConversation() {
    return this._conversation;
  }
  /**
   * Get current input (read-only).
   */
  getCurrentInput() {
    return this._currentInput;
  }
  /**
   * Get conversation length.
   */
  getConversationLength() {
    return this._conversation.length;
  }
  /**
   * Clear conversation history.
   */
  clearConversation(reason) {
    this.assertNotDestroyed();
    this._conversation = [];
    this._currentInput = [];
    this.emit("conversation:cleared", { reason });
  }
  // ============================================================================
  // Context Preparation (THE main method)
  // ============================================================================
  /**
   * Prepare context for LLM call.
   *
   * This method:
   * 1. Calculates tool definition tokens (never compacted)
   * 2. Builds the system message from all components
   * 3. Calculates token budget
   * 4. Handles oversized current input if needed
   * 5. Runs compaction if needed
   * 6. Returns final InputItem[] ready for LLM
   *
   * IMPORTANT: Call this ONCE right before each LLM call!
   */
  async prepare() {
    this.assertNotDestroyed();
    const compactionLog = [];
    const toolsTokens = this.calculateToolsTokens();
    const availableForContent = this._maxContextTokens - this._config.responseReserve - toolsTokens;
    if (availableForContent <= 0) {
      throw new Error(
        `Too many tools registered: tools use ${toolsTokens} tokens, only ${this._maxContextTokens - this._config.responseReserve} available. Consider reducing the number of tools or their descriptions.`
      );
    }
    const { systemMessage, systemTokens, breakdown } = await this.buildSystemMessage();
    let currentInputTokens = this.calculateInputTokens(this._currentInput);
    const systemPlusInput = systemTokens + currentInputTokens;
    if (systemPlusInput > availableForContent) {
      const result = await this.handleOversizedInput(
        availableForContent - systemTokens
      );
      this.emit("input:oversized", { result });
      if (!result.accepted) {
        throw new Error(result.error || "Current input is too large for context");
      }
      currentInputTokens = this.calculateInputTokens(this._currentInput);
    }
    let conversationTokens = this.calculateConversationTokens();
    let totalUsed = systemTokens + conversationTokens + currentInputTokens;
    let compacted = false;
    const strategyThreshold = this._compactionStrategy.threshold;
    if (totalUsed / availableForContent > strategyThreshold) {
      const targetToFree = totalUsed - Math.floor(availableForContent * (strategyThreshold - 0.1));
      const freed = await this.runCompaction(targetToFree, compactionLog);
      compacted = freed > 0;
      conversationTokens = this.calculateConversationTokens();
      totalUsed = systemTokens + conversationTokens + currentInputTokens;
    }
    const totalUsedWithTools = totalUsed + toolsTokens;
    const budget = {
      maxTokens: this._maxContextTokens,
      responseReserve: this._config.responseReserve,
      systemMessageTokens: systemTokens,
      toolsTokens,
      conversationTokens,
      currentInputTokens,
      totalUsed: totalUsedWithTools,
      available: this._maxContextTokens - this._config.responseReserve - totalUsedWithTools,
      utilizationPercent: totalUsedWithTools / (this._maxContextTokens - this._config.responseReserve) * 100,
      breakdown: {
        ...breakdown,
        tools: toolsTokens,
        conversation: conversationTokens,
        currentInput: currentInputTokens
      }
    };
    this._cachedBudget = budget;
    this.emit("budget:updated", { budget, timestamp: Date.now() });
    if (budget.utilizationPercent >= 90) {
      this.emit("budget:critical", { budget });
    } else if (budget.utilizationPercent >= 70) {
      this.emit("budget:warning", { budget });
    }
    let input = [
      systemMessage,
      ...this._conversation,
      ...this._currentInput
    ];
    input = this.sanitizeToolPairs(input);
    this.emit("context:prepared", { budget, compacted });
    return {
      input,
      budget,
      compacted,
      compactionLog
    };
  }
  // ============================================================================
  // System Message Building
  // ============================================================================
  /**
   * Build the system message containing all context components.
   */
  async buildSystemMessage() {
    const parts = [];
    const breakdown = {
      systemPrompt: 0,
      persistentInstructions: 0,
      pluginInstructions: 0,
      pluginContents: {}
    };
    if (this._systemPrompt) {
      parts.push(`# System Prompt

${this._systemPrompt}`);
      breakdown.systemPrompt = this._estimator.estimateTokens(this._systemPrompt);
    }
    const persistentPlugin = this._plugins.get("persistent_instructions");
    if (persistentPlugin) {
      const content = await persistentPlugin.getContent();
      if (content) {
        parts.push(`# Persistent Instructions

${content}`);
        breakdown.persistentInstructions = persistentPlugin.getTokenSize();
      }
    }
    const instructionParts = [];
    let totalInstructionTokens = 0;
    for (const plugin of this._plugins.values()) {
      const instructions = plugin.getInstructions();
      if (instructions) {
        instructionParts.push(`## ${this.formatPluginName(plugin.name)}

${instructions}`);
        totalInstructionTokens += plugin.getInstructionsTokenSize();
      }
    }
    if (instructionParts.length > 0) {
      parts.push(`# Instructions for Context Plugins

${instructionParts.join("\n\n")}`);
      breakdown.pluginInstructions = totalInstructionTokens;
    }
    for (const plugin of this._plugins.values()) {
      if (plugin.name === "persistent_instructions") continue;
      const content = await plugin.getContent();
      if (content) {
        const sectionTitle = this.formatPluginName(plugin.name);
        parts.push(`# ${sectionTitle}

${content}`);
        breakdown.pluginContents[plugin.name] = plugin.getTokenSize();
      }
    }
    const now = /* @__PURE__ */ new Date();
    parts.push(`CURRENT DATE AND TIME: ${now.toLocaleString("en-US", { dateStyle: "full", timeStyle: "long", timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone })}`);
    const systemText = parts.join("\n\n---\n\n");
    const systemTokens = this._estimator.estimateTokens(systemText);
    const systemMessage = {
      type: "message",
      role: "developer" /* DEVELOPER */,
      content: [{ type: "input_text" /* INPUT_TEXT */, text: systemText }]
    };
    return { systemMessage, systemTokens, breakdown };
  }
  /**
   * Format plugin name for display (e.g., 'working_memory' -> 'Working Memory')
   */
  formatPluginName(name) {
    return name.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  }
  // ============================================================================
  // Token Calculations
  // ============================================================================
  /**
   * Calculate tokens used by tool definitions.
   * Tools are sent separately to the LLM and take up context space.
   */
  calculateToolsTokens() {
    const enabledTools = this._tools.getEnabled();
    if (enabledTools.length === 0) return 0;
    let total = 0;
    for (const tool of enabledTools) {
      const fn = tool.definition.function;
      total += this._estimator.estimateTokens(fn.name);
      if (fn.description) {
        total += this._estimator.estimateTokens(fn.description);
      }
      if (fn.parameters) {
        total += this._estimator.estimateDataTokens(fn.parameters);
      }
      total += 10;
    }
    total += 20;
    return total;
  }
  /**
   * Calculate tokens for conversation history.
   */
  calculateConversationTokens() {
    let total = 0;
    for (const item of this._conversation) {
      total += this.estimateItemTokens(item);
    }
    return total;
  }
  /**
   * Calculate tokens for current input.
   */
  calculateInputTokens(items) {
    let total = 0;
    for (const item of items) {
      total += this.estimateItemTokens(item);
    }
    return total;
  }
  /**
   * Estimate tokens for a single InputItem.
   */
  estimateItemTokens(item) {
    if (item.type !== "message") return 50;
    const msg = item;
    let total = 4;
    for (const c of msg.content) {
      if (c.type === "input_text" /* INPUT_TEXT */ || c.type === "output_text" /* OUTPUT_TEXT */) {
        total += this._estimator.estimateTokens(c.text || "");
      } else if (c.type === "tool_use" /* TOOL_USE */) {
        total += this._estimator.estimateTokens(c.name || "");
        total += this._estimator.estimateDataTokens(c.input || {});
      } else if (c.type === "tool_result" /* TOOL_RESULT */) {
        total += this._estimator.estimateTokens(c.content || "");
        const images = c.__images;
        if (images?.length) {
          for (const _img of images) {
            total += this._estimateImageTokens();
          }
        }
      } else if (c.type === "input_image_url" /* INPUT_IMAGE_URL */) {
        const imgContent = c;
        const detail = imgContent.image_url?.detail;
        total += this._estimateImageTokens(void 0, void 0, detail);
      }
    }
    return total;
  }
  /**
   * Estimate tokens for a single image, using the estimator's image method if available.
   */
  _estimateImageTokens(width, height, detail) {
    if (this._estimator.estimateImageTokens) {
      return this._estimator.estimateImageTokens(width, height, detail);
    }
    return 1e3;
  }
  // ============================================================================
  // Compaction
  // ============================================================================
  /**
   * Run compaction to free up tokens.
   * Delegates to the current compaction strategy.
   * Returns total tokens freed.
   */
  async runCompaction(targetToFree, log) {
    const timestamp = Date.now();
    if (this._cachedBudget) {
      this.emit("compaction:starting", {
        budget: this._cachedBudget,
        targetTokensToFree: targetToFree,
        timestamp
      });
    }
    if (this._beforeCompactionCallback && this._cachedBudget) {
      try {
        await this._beforeCompactionCallback({
          budget: this._cachedBudget,
          targetTokensToFree: targetToFree,
          strategy: this._compactionStrategy.name
        });
      } catch (error) {
        log.push(`beforeCompaction callback error: ${error.message}`);
      }
    }
    const context = this.buildCompactionContext();
    const result = await this._compactionStrategy.compact(context, targetToFree);
    log.push(...result.log);
    if (result.tokensFreed > 0) {
      this.emit("context:compacted", { tokensFreed: result.tokensFreed, log });
    }
    return result.tokensFreed;
  }
  /**
   * Run post-cycle consolidation.
   * Called by Agent after agentic cycle completes (before session save).
   *
   * Delegates to the current compaction strategy's consolidate() method.
   * Use for more expensive operations like summarization.
   */
  async consolidate() {
    this.assertNotDestroyed();
    const context = this.buildCompactionContext();
    return this._compactionStrategy.consolidate(context);
  }
  /**
   * Build CompactionContext for strategy.
   * Provides controlled access to context state.
   */
  buildCompactionContext() {
    const self = this;
    return {
      get budget() {
        return self._cachedBudget ?? {
          maxTokens: self._maxContextTokens,
          responseReserve: self._config.responseReserve,
          systemMessageTokens: 0,
          toolsTokens: 0,
          conversationTokens: 0,
          currentInputTokens: 0,
          totalUsed: 0,
          available: self._maxContextTokens - self._config.responseReserve,
          utilizationPercent: 0,
          breakdown: {
            systemPrompt: 0,
            persistentInstructions: 0,
            pluginInstructions: 0,
            pluginContents: {},
            tools: 0,
            conversation: 0,
            currentInput: 0
          }
        };
      },
      get conversation() {
        return self._conversation;
      },
      get currentInput() {
        return self._currentInput;
      },
      get plugins() {
        return Array.from(self._plugins.values());
      },
      get strategyName() {
        return self._compactionStrategy.name;
      },
      async removeMessages(indices) {
        return self.removeMessagesByIndices(indices);
      },
      async compactPlugin(pluginName, targetTokens) {
        const plugin = self._plugins.get(pluginName);
        if (!plugin || !plugin.isCompactable()) {
          return 0;
        }
        return plugin.compact(targetTokens);
      },
      estimateTokens(item) {
        return self.estimateItemTokens(item);
      }
    };
  }
  /**
   * Remove messages by indices.
   * Handles tool pair preservation internally.
   * Used by CompactionContext.removeMessages().
   */
  removeMessagesByIndices(indices) {
    if (indices.length === 0 || this._conversation.length === 0) {
      return 0;
    }
    let tokensFreed = 0;
    const indicesToRemove = new Set(indices);
    for (const idx of indicesToRemove) {
      const item = this._conversation[idx];
      if (item) {
        tokensFreed += this.estimateItemTokens(item);
      }
    }
    this._conversation = this._conversation.filter((_, i) => !indicesToRemove.has(i));
    return tokensFreed;
  }
  /**
   * Sanitize tool pairs in the input array.
   * Removes orphan TOOL_USE (no matching TOOL_RESULT) and
   * orphan TOOL_RESULT (no matching TOOL_USE).
   *
   * This is CRITICAL - LLM APIs require matching pairs.
   */
  sanitizeToolPairs(items) {
    const toolUseIds = /* @__PURE__ */ new Set();
    const toolResultIds = /* @__PURE__ */ new Set();
    for (const item of items) {
      if (item.type !== "message") continue;
      const msg = item;
      for (const c of msg.content) {
        if (c.type === "tool_use" /* TOOL_USE */) {
          toolUseIds.add(c.id);
        } else if (c.type === "tool_result" /* TOOL_RESULT */) {
          toolResultIds.add(c.tool_use_id);
        }
      }
    }
    const orphanToolUseIds = /* @__PURE__ */ new Set();
    const orphanToolResultIds = /* @__PURE__ */ new Set();
    for (const id of toolUseIds) {
      if (!toolResultIds.has(id)) {
        orphanToolUseIds.add(id);
      }
    }
    for (const id of toolResultIds) {
      if (!toolUseIds.has(id)) {
        orphanToolResultIds.add(id);
      }
    }
    if (orphanToolUseIds.size === 0 && orphanToolResultIds.size === 0) {
      return items;
    }
    const result = [];
    for (const item of items) {
      if (item.type !== "message") {
        result.push(item);
        continue;
      }
      const msg = item;
      const filteredContent = [];
      for (const c of msg.content) {
        if (c.type === "tool_use" /* TOOL_USE */) {
          const id = c.id;
          if (!orphanToolUseIds.has(id)) {
            filteredContent.push(c);
          }
        } else if (c.type === "tool_result" /* TOOL_RESULT */) {
          const id = c.tool_use_id;
          if (!orphanToolResultIds.has(id)) {
            filteredContent.push(c);
          }
        } else {
          filteredContent.push(c);
        }
      }
      if (filteredContent.length > 0) {
        result.push({
          ...msg,
          content: filteredContent
        });
      }
    }
    return result;
  }
  // ============================================================================
  // Oversized Input Handling
  // ============================================================================
  /**
   * Handle oversized current input.
   */
  async handleOversizedInput(maxTokens) {
    if (this._currentInput.length === 0) {
      return { accepted: true, content: "", originalSize: 0, finalSize: 0 };
    }
    const input = this._currentInput[0];
    if (input?.type !== "message") {
      return { accepted: false, content: "", error: "Invalid input type", originalSize: 0, finalSize: 0 };
    }
    const msg = input;
    const hasToolResult = msg.content.some((c) => c.type === "tool_result" /* TOOL_RESULT */);
    if (!hasToolResult) {
      const originalSize = this.estimateItemTokens(input);
      return {
        accepted: false,
        content: "",
        error: `User input is too large (${originalSize} tokens) for available context (${maxTokens} tokens). Please provide shorter input.`,
        originalSize,
        finalSize: 0
      };
    }
    return this.emergencyToolResultsTruncation(msg, maxTokens);
  }
  /**
   * Emergency truncation of tool results to fit in context.
   */
  emergencyToolResultsTruncation(msg, maxTokens) {
    const originalSize = this.estimateItemTokens(msg);
    const truncatedContent = [];
    const maxChars = Math.floor(maxTokens * 3.5);
    let totalCharsUsed = 0;
    for (const c of msg.content) {
      if (c.type === "tool_result" /* TOOL_RESULT */) {
        const toolResult = c;
        const content = toolResult.content || "";
        const images = toolResult.__images;
        if (!images?.length && this.isBinaryContent(content)) {
          truncatedContent.push({
            type: "tool_result" /* TOOL_RESULT */,
            tool_use_id: toolResult.tool_use_id,
            content: "[Binary content too large - rejected. Please try a different approach or request smaller output.]",
            error: "Binary content too large"
          });
          totalCharsUsed += 100;
        } else {
          const availableChars = maxChars - totalCharsUsed - 200;
          if (content.length > availableChars && availableChars > 0) {
            const truncated = content.slice(0, availableChars);
            truncatedContent.push({
              type: "tool_result" /* TOOL_RESULT */,
              tool_use_id: toolResult.tool_use_id,
              content: `${truncated}

[TRUNCATED: Original output was ${Math.round(content.length / 1024)}KB. Only first ${Math.round(availableChars / 1024)}KB shown. Consider using more targeted queries.]`,
              // Preserve images even when text is truncated — they're handled natively by providers
              ...images ? { __images: images } : {}
            });
            totalCharsUsed += truncated.length + 150;
          } else if (availableChars > 0) {
            truncatedContent.push(c);
            totalCharsUsed += content.length;
          } else {
            truncatedContent.push({
              type: "tool_result" /* TOOL_RESULT */,
              tool_use_id: toolResult.tool_use_id,
              content: "[Output too large - skipped due to context limits. Try a more targeted query.]",
              error: "Output too large",
              // Preserve images even when text is dropped
              ...images ? { __images: images } : {}
            });
            totalCharsUsed += 100;
          }
        }
      } else {
        truncatedContent.push(c);
      }
    }
    msg.content = truncatedContent;
    const finalSize = this.estimateItemTokens(msg);
    return {
      accepted: true,
      content: JSON.stringify(truncatedContent),
      warning: `Tool results truncated from ${originalSize} to ${finalSize} tokens to fit in context.`,
      originalSize,
      finalSize
    };
  }
  /**
   * Check if content appears to be binary (base64, etc.)
   */
  isBinaryContent(content) {
    if (!content || content.length < 100) return false;
    const base64Ratio = (content.match(/[A-Za-z0-9+/=]/g)?.length ?? 0) / content.length;
    if (base64Ratio > 0.95 && content.length > 1e3) {
      return true;
    }
    if (/^[A-Za-z0-9+/]{50,}={0,2}$/.test(content.slice(0, 100))) {
      return true;
    }
    return false;
  }
  // ============================================================================
  // Session Persistence
  // ============================================================================
  /**
   * Save context state to storage.
   *
   * @param sessionId - Optional session ID (uses current or generates new)
   * @param metadata - Optional additional metadata to merge
   * @param stateOverride - Optional state override (for agent-level state injection)
   */
  async save(sessionId, metadata, stateOverride) {
    this.assertNotDestroyed();
    if (!this._storage) {
      throw new Error("No storage configured");
    }
    const targetSessionId = sessionId ?? this._sessionId ?? this.generateId();
    const state = stateOverride ?? this.getState();
    if (metadata) {
      state.metadata = { ...state.metadata, ...metadata };
    }
    await this._storage.save(targetSessionId, state);
    this._sessionId = targetSessionId;
  }
  /**
   * Load context state from storage.
   */
  async load(sessionId) {
    this.assertNotDestroyed();
    if (!this._storage) {
      throw new Error("No storage configured");
    }
    const stored = await this._storage.load(sessionId);
    if (!stored) {
      return false;
    }
    const state = stored.state;
    this._conversation = state.conversation;
    this._systemPrompt = state.systemPrompt;
    for (const [name, pluginState] of Object.entries(state.pluginStates)) {
      const plugin = this._plugins.get(name);
      if (plugin) {
        plugin.restoreState(pluginState);
      }
    }
    this._sessionId = sessionId;
    return true;
  }
  /**
   * Load raw state from storage without restoring.
   * Used by BaseAgent for custom state restoration.
   */
  async loadRaw(sessionId) {
    this.assertNotDestroyed();
    if (!this._storage) {
      throw new Error("No storage configured");
    }
    const stored = await this._storage.load(sessionId);
    if (!stored) {
      return null;
    }
    this._sessionId = sessionId;
    return { state: stored.state, stored };
  }
  /**
   * Check if session exists in storage.
   */
  async sessionExists(sessionId) {
    if (!this._storage) {
      return false;
    }
    return this._storage.exists(sessionId);
  }
  /**
   * Delete a session from storage.
   */
  async deleteSession(sessionId) {
    if (!this._storage) {
      throw new Error("No storage configured");
    }
    const targetSessionId = sessionId ?? this._sessionId;
    if (!targetSessionId) {
      throw new Error("No session ID provided or loaded");
    }
    await this._storage.delete(targetSessionId);
    if (targetSessionId === this._sessionId) {
      this._sessionId = null;
    }
  }
  /**
   * Get serialized state for persistence.
   * Used by BaseAgent to inject agent-level state.
   */
  getState() {
    this.assertNotDestroyed();
    const pluginStates = {};
    for (const [name, plugin] of this._plugins) {
      pluginStates[name] = plugin.getState();
    }
    return {
      conversation: this._conversation,
      pluginStates,
      systemPrompt: this._systemPrompt,
      metadata: {
        savedAt: Date.now(),
        agentId: this._agentId,
        userId: this._userId,
        model: this._config.model
      }
    };
  }
  /**
   * Restore state from serialized form.
   * Used by BaseAgent for custom state restoration.
   */
  restoreState(state) {
    this.assertNotDestroyed();
    this._conversation = state.conversation ?? [];
    this._systemPrompt = state.systemPrompt;
    if (state.pluginStates) {
      for (const [name, pluginState] of Object.entries(state.pluginStates)) {
        const plugin = this._plugins.get(name);
        if (plugin) {
          plugin.restoreState(pluginState);
        }
      }
    }
  }
  // ============================================================================
  // Inspection / Monitoring
  // ============================================================================
  /**
   * Get the current token budget.
   *
   * Returns the cached budget from the last prepare() call if available.
   * If prepare() hasn't been called yet, calculates a fresh budget.
   *
   * For monitoring purposes, prefer using the `lastBudget` getter or
   * subscribing to the `budget:updated` event for reactive updates.
   *
   * @returns Current token budget breakdown
   */
  async calculateBudget() {
    this.assertNotDestroyed();
    if (this._cachedBudget) {
      return this._cachedBudget;
    }
    const toolsTokens = this.calculateToolsTokens();
    const { systemTokens, breakdown } = await this.buildSystemMessage();
    const conversationTokens = this.calculateConversationTokens();
    const currentInputTokens = this.calculateInputTokens(this._currentInput);
    const totalUsed = systemTokens + conversationTokens + currentInputTokens + toolsTokens;
    const availableForContent = this._maxContextTokens - this._config.responseReserve;
    return {
      maxTokens: this._maxContextTokens,
      responseReserve: this._config.responseReserve,
      systemMessageTokens: systemTokens,
      toolsTokens,
      conversationTokens,
      currentInputTokens,
      totalUsed,
      available: availableForContent - totalUsed,
      utilizationPercent: totalUsed / availableForContent * 100,
      breakdown: {
        ...breakdown,
        tools: toolsTokens,
        conversation: conversationTokens,
        currentInput: currentInputTokens
      }
    };
  }
  /**
   * Get the current strategy threshold (percentage at which compaction triggers).
   */
  get strategyThreshold() {
    return this._compactionStrategy.threshold;
  }
  /**
   * Get the current strategy name.
   */
  get strategy() {
    return this._compactionStrategy.name;
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Generate unique ID.
   */
  generateId() {
    return `${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * Assert context is not destroyed.
   */
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new Error("AgentContextNextGen is destroyed");
    }
  }
  // ============================================================================
  // Cleanup
  // ============================================================================
  /**
   * Destroy context and release resources.
   */
  destroy() {
    if (this._destroyed) return;
    for (const plugin of this._plugins.values()) {
      plugin.destroy();
    }
    this._plugins.clear();
    this._tools.destroy();
    this._conversation = [];
    this._currentInput = [];
    this.removeAllListeners();
    this._destroyed = true;
  }
};

// src/infrastructure/providers/base/BaseProvider.ts
var BaseProvider = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Validate provider configuration
   * Returns validation result with details
   */
  async validateConfig() {
    const validation = this.validateApiKey();
    return validation.isValid;
  }
  /**
   * Validate API key format and presence
   * Can be overridden by providers with specific key formats
   */
  validateApiKey() {
    const apiKey = this.config.apiKey;
    if (!apiKey || apiKey.trim().length === 0) {
      return { isValid: false };
    }
    const placeholders = [
      "your-api-key",
      "YOUR_API_KEY",
      "sk-xxx",
      "api-key-here",
      "REPLACE_ME",
      "<your-key>"
    ];
    if (placeholders.some((p) => apiKey.includes(p))) {
      return {
        isValid: false,
        warning: `API key appears to be a placeholder value`
      };
    }
    return this.validateProviderSpecificKeyFormat(apiKey);
  }
  /**
   * Override this method in provider implementations for specific key format validation
   */
  validateProviderSpecificKeyFormat(_apiKey) {
    return { isValid: true };
  }
  /**
   * Validate config and throw if invalid
   */
  assertValidConfig() {
    const validation = this.validateApiKey();
    if (!validation.isValid) {
      throw new InvalidConfigError(
        `Invalid API key for provider '${this.name}'${validation.warning ? `: ${validation.warning}` : ""}`
      );
    }
  }
  /**
   * Get API key from config
   */
  getApiKey() {
    return this.config.apiKey;
  }
  /**
   * Get base URL if configured
   */
  getBaseURL() {
    return this.config.baseURL;
  }
  /**
   * Get timeout configuration
   */
  getTimeout() {
    return this.config.timeout || 6e4;
  }
  /**
   * Get max retries configuration
   */
  getMaxRetries() {
    return this.config.maxRetries || 3;
  }
};

// src/infrastructure/providers/base/BaseTextProvider.ts
init_CircuitBreaker();
init_Logger();
init_Metrics();
var BaseTextProvider = class extends BaseProvider {
  circuitBreaker;
  logger;
  _isObservabilityInitialized = false;
  constructor(config) {
    super(config);
    this.logger = exports.logger.child({
      component: "Provider",
      provider: "unknown"
    });
  }
  /**
   * Auto-initialize observability on first use (lazy initialization)
   * This is called automatically by executeWithCircuitBreaker()
   * @internal
   */
  ensureObservabilityInitialized() {
    if (this._isObservabilityInitialized) {
      return;
    }
    const providerName = this.name || "unknown";
    const cbConfig = this.config.circuitBreaker || exports.DEFAULT_CIRCUIT_BREAKER_CONFIG;
    this.circuitBreaker = new exports.CircuitBreaker(
      `provider:${providerName}`,
      cbConfig
    );
    this.logger = exports.logger.child({
      component: "Provider",
      provider: providerName
    });
    this.circuitBreaker.on("opened", (data) => {
      this.logger.warn(data, "Circuit breaker opened");
      exports.metrics.increment("circuit_breaker.opened", 1, {
        breaker: data.name,
        provider: providerName
      });
    });
    this.circuitBreaker.on("closed", (data) => {
      this.logger.info(data, "Circuit breaker closed");
      exports.metrics.increment("circuit_breaker.closed", 1, {
        breaker: data.name,
        provider: providerName
      });
    });
    this._isObservabilityInitialized = true;
  }
  /**
   * DEPRECATED: No longer needed, kept for backward compatibility
   * Observability is now auto-initialized on first use
   * @deprecated Initialization happens automatically
   */
  initializeObservability(_providerName) {
    this.ensureObservabilityInitialized();
  }
  /**
   * Execute with circuit breaker protection (helper for subclasses)
   */
  async executeWithCircuitBreaker(operation, model) {
    this.ensureObservabilityInitialized();
    const startTime = Date.now();
    const operationName = "llm.generate";
    this.logger.debug({
      operation: operationName,
      model
    }, "LLM call started");
    exports.metrics.increment("provider.llm.request", 1, {
      provider: this.name,
      model: model || "unknown"
    });
    try {
      if (!this.circuitBreaker) {
        return await operation();
      }
      const result = await this.circuitBreaker.execute(operation);
      const duration = Date.now() - startTime;
      this.logger.info({
        operation: operationName,
        model,
        duration
      }, "LLM call completed");
      exports.metrics.timing("provider.llm.latency", duration, {
        provider: this.name,
        model: model || "unknown"
      });
      exports.metrics.increment("provider.llm.response", 1, {
        provider: this.name,
        model: model || "unknown",
        status: "success"
      });
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error({
        operation: operationName,
        model,
        error: error.message,
        duration
      }, "LLM call failed");
      exports.metrics.increment("provider.llm.error", 1, {
        provider: this.name,
        model: model || "unknown",
        error: error.name
      });
      throw error;
    }
  }
  /**
   * Get circuit breaker metrics
   */
  getCircuitBreakerMetrics() {
    if (!this.circuitBreaker) {
      return null;
    }
    return this.circuitBreaker.getMetrics();
  }
  /**
   * Normalize input to string (helper for providers that don't support complex input)
   */
  normalizeInputToString(input) {
    if (typeof input === "string") {
      return input;
    }
    const textParts = [];
    for (const item of input) {
      if (item.type === "message") {
        for (const content of item.content) {
          if (content.type === "input_text") {
            textParts.push(content.text);
          } else if (content.type === "output_text") {
            textParts.push(content.text);
          }
        }
      }
    }
    return textParts.join("\n");
  }
  /**
   * Clean up provider resources (circuit breaker listeners, etc.)
   * Should be called when the provider is no longer needed.
   */
  destroy() {
    if (this.circuitBreaker) {
      this.circuitBreaker.removeAllListeners();
      this.circuitBreaker = void 0;
    }
    this._isObservabilityInitialized = false;
  }
};

// src/infrastructure/providers/openai/OpenAIResponsesConverter.ts
var OpenAIResponsesConverter = class {
  /**
   * Convert our input format to Responses API format
   */
  convertInput(input, instructions) {
    if (typeof input === "string") {
      return {
        input,
        instructions
      };
    }
    const items = [];
    for (const item of input) {
      if (item.type === "message") {
        const messageContent = [];
        const isAssistant = item.role === "assistant";
        for (const content of item.content) {
          switch (content.type) {
            case "input_text":
            case "output_text":
              messageContent.push({
                type: isAssistant ? "output_text" : "input_text",
                text: content.text
              });
              break;
            case "input_image_url":
              if (!isAssistant) {
                messageContent.push({
                  type: "input_image",
                  image_url: content.image_url.url,
                  ...content.image_url.detail && { detail: content.image_url.detail }
                });
              }
              break;
            case "tool_use":
              items.push({
                type: "function_call",
                call_id: content.id,
                name: content.name,
                arguments: content.arguments
              });
              break;
            case "tool_result": {
              const contentImages = content.__images;
              let outputText;
              let images;
              if (contentImages?.length) {
                outputText = typeof content.content === "string" ? content.content : JSON.stringify(content.content);
                images = contentImages;
              } else {
                const rawOutput = typeof content.content === "string" ? content.content : JSON.stringify(content.content);
                const extracted = this.extractImagesFromOutput(rawOutput);
                outputText = extracted.text;
                images = extracted.images;
              }
              items.push({
                type: "function_call_output",
                call_id: content.tool_use_id,
                output: outputText
              });
              if (images.length > 0) {
                const imageContent = images.map((img) => ({
                  type: "input_image",
                  image_url: `data:${img.mediaType};base64,${img.base64}`
                }));
                items.push({
                  type: "message",
                  role: "user",
                  content: [
                    { type: "input_text", text: "[Screenshot from tool result]" },
                    ...imageContent
                  ],
                  status: "completed"
                });
              }
              break;
            }
          }
        }
        if (messageContent.length > 0) {
          items.push({
            type: "message",
            role: item.role,
            content: messageContent,
            // Only include id if it's a valid OpenAI message ID (starts with msg_)
            // New messages shouldn't have id; previous outputs keep their original id
            ...item.id?.startsWith("msg_") ? { id: item.id } : {},
            status: "completed"
          });
        }
      } else if (item.type === "compaction") {
        items.push({
          type: "compaction",
          id: item.id,
          encrypted_content: item.encrypted_content
        });
      }
    }
    return {
      input: items,
      instructions
    };
  }
  /**
   * Convert Responses API response to our LLMResponse format
   */
  convertResponse(response) {
    const content = [];
    let outputText = "";
    let messageId;
    for (const item of response.output || []) {
      if (item.type === "message") {
        const messageItem = item;
        if (!messageId && messageItem.id) {
          messageId = messageItem.id;
        }
        for (const contentItem of messageItem.content || []) {
          if (contentItem.type === "output_text") {
            const textContent = contentItem;
            content.push({
              type: "output_text",
              text: textContent.text,
              annotations: textContent.annotations || []
            });
            outputText += textContent.text;
          }
        }
      } else if (item.type === "function_call") {
        const functionCall = item;
        content.push({
          type: "tool_use",
          id: functionCall.call_id,
          name: functionCall.name,
          arguments: functionCall.arguments
        });
      } else if (item.type === "reasoning") {
        const reasoning = item;
        if (reasoning.summary) {
          content.push({
            type: "reasoning",
            summary: reasoning.summary,
            // effort field may not exist in all versions
            ..."effort" in reasoning && { effort: reasoning.effort }
          });
        }
      }
    }
    if (!outputText) {
      outputText = response.output_text || "";
    }
    const finalMessageId = messageId || response.id;
    return {
      id: response.id,
      object: "response",
      created_at: response.created_at,
      status: response.status || "completed",
      model: response.model,
      output: [
        {
          type: "message",
          id: finalMessageId,
          role: "assistant" /* ASSISTANT */,
          content
        }
      ],
      output_text: outputText,
      usage: {
        input_tokens: response.usage?.input_tokens || 0,
        output_tokens: response.usage?.output_tokens || 0,
        total_tokens: response.usage?.total_tokens || 0
      }
    };
  }
  /**
   * Convert our tool definitions to Responses API format
   *
   * Key difference: Responses API uses internally-tagged format
   * (no nested `function` object) and strict mode requires proper schemas
   */
  convertTools(tools) {
    return tools.map((tool) => {
      if (tool.type === "function") {
        const funcDef = tool.function;
        const useStrict = funcDef.strict === true;
        return {
          type: "function",
          name: funcDef.name,
          description: funcDef.description || "",
          parameters: funcDef.parameters || null,
          strict: useStrict
        };
      }
      return tool;
    });
  }
  /**
   * Convert tool_choice option to Responses API format
   */
  convertToolChoice(toolChoice) {
    if (!toolChoice || toolChoice === "auto") {
      return "auto";
    }
    if (toolChoice === "required") {
      return "required";
    }
    return {
      type: "function",
      name: toolChoice.function.name
    };
  }
  /**
   * Convert response_format option to Responses API format (modalities)
   */
  convertResponseFormat(responseFormat) {
    if (!responseFormat) {
      return void 0;
    }
    if (responseFormat.type === "json_schema" && responseFormat.json_schema) {
      return {
        type: "text",
        text: {
          type: "json_schema",
          name: responseFormat.json_schema.name || "response",
          schema: responseFormat.json_schema.schema || responseFormat.json_schema,
          description: responseFormat.json_schema.description,
          strict: responseFormat.json_schema.strict !== false
        }
      };
    }
    if (responseFormat.type === "json_object") {
      return {
        type: "text",
        text: {
          type: "json_object"
        }
      };
    }
    return {
      type: "text",
      text: {
        type: "text"
      }
    };
  }
  /**
   * Extract __images from a JSON tool result and return cleaned text + images.
   * Used by the __images convention for multimodal tool results.
   */
  extractImagesFromOutput(output) {
    try {
      const parsed = JSON.parse(output);
      if (parsed && Array.isArray(parsed.__images) && parsed.__images.length > 0) {
        const images = parsed.__images;
        const { __images: _, base64: __, ...rest } = parsed;
        return { text: JSON.stringify(rest), images };
      }
    } catch {
    }
    return { text: output, images: [] };
  }
};

// src/domain/entities/StreamEvent.ts
var StreamEventType = /* @__PURE__ */ ((StreamEventType2) => {
  StreamEventType2["RESPONSE_CREATED"] = "response.created";
  StreamEventType2["RESPONSE_IN_PROGRESS"] = "response.in_progress";
  StreamEventType2["OUTPUT_TEXT_DELTA"] = "response.output_text.delta";
  StreamEventType2["OUTPUT_TEXT_DONE"] = "response.output_text.done";
  StreamEventType2["TOOL_CALL_START"] = "response.tool_call.start";
  StreamEventType2["TOOL_CALL_ARGUMENTS_DELTA"] = "response.tool_call_arguments.delta";
  StreamEventType2["TOOL_CALL_ARGUMENTS_DONE"] = "response.tool_call_arguments.done";
  StreamEventType2["TOOL_EXECUTION_START"] = "response.tool_execution.start";
  StreamEventType2["TOOL_EXECUTION_DONE"] = "response.tool_execution.done";
  StreamEventType2["ITERATION_COMPLETE"] = "response.iteration.complete";
  StreamEventType2["RESPONSE_COMPLETE"] = "response.complete";
  StreamEventType2["ERROR"] = "response.error";
  return StreamEventType2;
})(StreamEventType || {});
function isStreamEvent(event, type) {
  return event.type === type;
}
function isOutputTextDelta(event) {
  return event.type === "response.output_text.delta" /* OUTPUT_TEXT_DELTA */;
}
function isToolCallStart(event) {
  return event.type === "response.tool_call.start" /* TOOL_CALL_START */;
}
function isToolCallArgumentsDelta(event) {
  return event.type === "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */;
}
function isToolCallArgumentsDone(event) {
  return event.type === "response.tool_call_arguments.done" /* TOOL_CALL_ARGUMENTS_DONE */;
}
function isResponseComplete(event) {
  return event.type === "response.complete" /* RESPONSE_COMPLETE */;
}
function isErrorEvent(event) {
  return event.type === "response.error" /* ERROR */;
}

// src/infrastructure/providers/openai/OpenAIResponsesStreamConverter.ts
var OpenAIResponsesStreamConverter = class {
  /**
   * Convert Responses API stream to our StreamEvent format
   */
  async *convertStream(stream) {
    let responseId = "";
    let sequenceNumber = 0;
    const activeItems = /* @__PURE__ */ new Map();
    const toolCallBuffers = /* @__PURE__ */ new Map();
    for await (const event of stream) {
      if (process.env.DEBUG_OPENAI) {
        console.error("[DEBUG] Responses API event:", event.type);
      }
      switch (event.type) {
        case "response.created": {
          responseId = event.response.id;
          yield {
            type: "response.created" /* RESPONSE_CREATED */,
            response_id: responseId,
            model: event.response.model,
            created_at: event.response.created_at
          };
          break;
        }
        case "response.output_item.added": {
          const addedEvent = event;
          const item = addedEvent.item;
          activeItems.set(addedEvent.output_index.toString(), {
            type: item.type
          });
          if (item.type === "function_call") {
            const functionCall = item;
            const toolCallId = functionCall.call_id;
            const toolName = functionCall.name;
            activeItems.set(addedEvent.output_index.toString(), {
              type: "function_call",
              toolCallId,
              toolName
            });
            toolCallBuffers.set(toolCallId, {
              id: toolCallId,
              name: toolName,
              args: ""
            });
            yield {
              type: "response.tool_call.start" /* TOOL_CALL_START */,
              response_id: responseId,
              item_id: `item_${addedEvent.output_index}`,
              tool_call_id: toolCallId,
              tool_name: toolName
            };
          }
          break;
        }
        case "response.output_text.delta": {
          const textEvent = event;
          yield {
            type: "response.output_text.delta" /* OUTPUT_TEXT_DELTA */,
            response_id: responseId,
            item_id: textEvent.item_id,
            output_index: textEvent.output_index,
            content_index: textEvent.content_index,
            delta: textEvent.delta || "",
            sequence_number: sequenceNumber++
          };
          break;
        }
        case "response.function_call_arguments.delta": {
          const argsEvent = event;
          const itemInfo = activeItems.get(argsEvent.output_index.toString());
          if (itemInfo?.toolCallId) {
            const buffer = toolCallBuffers.get(itemInfo.toolCallId);
            if (buffer) {
              buffer.args += argsEvent.delta || "";
              yield {
                type: "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */,
                response_id: responseId,
                item_id: argsEvent.item_id,
                tool_call_id: buffer.id,
                tool_name: buffer.name,
                delta: argsEvent.delta || "",
                sequence_number: sequenceNumber++
              };
            }
          }
          break;
        }
        case "response.output_item.done": {
          const doneEvent = event;
          const item = doneEvent.item;
          if (item.type === "function_call") {
            const functionCall = item;
            const buffer = toolCallBuffers.get(functionCall.call_id);
            if (buffer) {
              yield {
                type: "response.tool_call_arguments.done" /* TOOL_CALL_ARGUMENTS_DONE */,
                response_id: responseId,
                tool_call_id: buffer.id,
                tool_name: buffer.name,
                arguments: buffer.args || functionCall.arguments
              };
            }
          }
          break;
        }
        case "response.completed": {
          const completedEvent = event;
          const response = completedEvent.response;
          let status = "completed";
          if (response.status === "failed") {
            status = "failed";
          } else if (response.status === "incomplete") {
            status = "incomplete";
          }
          yield {
            type: "response.complete" /* RESPONSE_COMPLETE */,
            response_id: responseId,
            status,
            usage: {
              input_tokens: response.usage?.input_tokens || 0,
              output_tokens: response.usage?.output_tokens || 0,
              total_tokens: response.usage?.total_tokens || 0
            },
            iterations: 1
          };
          break;
        }
        // Handle other event types if needed
        default:
          if (process.env.DEBUG_OPENAI) {
            console.error("[DEBUG] Unhandled Responses API event type:", event.type);
          }
      }
    }
  }
};

// src/infrastructure/providers/base/ModelCapabilityResolver.ts
function mapRegistryToCapabilities(info) {
  return {
    supportsTools: info.features.functionCalling ?? false,
    supportsVision: info.features.vision ?? false,
    supportsJSON: info.features.structuredOutput ?? false,
    supportsJSONSchema: info.features.structuredOutput ?? false,
    maxTokens: info.features.input.tokens,
    maxInputTokens: info.features.input.tokens,
    maxOutputTokens: info.features.output.tokens
  };
}
function resolveModelCapabilities(model, vendorDefaults) {
  const info = getModelInfo(model);
  if (info) {
    return mapRegistryToCapabilities(info);
  }
  return vendorDefaults;
}
function resolveMaxContextTokens(model, fallback) {
  if (!model) return fallback;
  const info = getModelInfo(model);
  return info ? info.features.input.tokens : fallback;
}

// src/infrastructure/providers/openai/OpenAITextProvider.ts
var OpenAITextProvider = class extends BaseTextProvider {
  name = "openai";
  capabilities = {
    text: true,
    images: true,
    videos: false,
    audio: true
  };
  client;
  converter;
  streamConverter;
  constructor(config) {
    super(config);
    this.client = new OpenAI3__default.default({
      apiKey: this.getApiKey(),
      baseURL: this.getBaseURL(),
      organization: config.organization,
      timeout: this.getTimeout(),
      maxRetries: this.getMaxRetries()
    });
    this.converter = new OpenAIResponsesConverter();
    this.streamConverter = new OpenAIResponsesStreamConverter();
  }
  /**
   * Check if a parameter is supported by the model
   */
  supportsParameter(model, parameter) {
    const modelInfo = getModelInfo(model);
    if (!modelInfo?.features.parameters) {
      return true;
    }
    return modelInfo.features.parameters[parameter] !== false;
  }
  /**
   * Generate response using OpenAI Responses API
   */
  async generate(options) {
    return this.executeWithCircuitBreaker(async () => {
      try {
        const { input, instructions } = this.converter.convertInput(
          options.input,
          options.instructions
        );
        const params = {
          model: options.model,
          input,
          ...instructions && { instructions },
          ...options.tools && options.tools.length > 0 && {
            tools: this.converter.convertTools(options.tools)
          },
          ...options.tool_choice && {
            tool_choice: this.converter.convertToolChoice(options.tool_choice)
          },
          ...options.temperature !== void 0 && this.supportsParameter(options.model, "temperature") && { temperature: options.temperature },
          ...options.max_output_tokens && { max_output_tokens: options.max_output_tokens },
          ...options.response_format && {
            text: this.converter.convertResponseFormat(options.response_format)
          },
          ...options.parallel_tool_calls !== void 0 && {
            parallel_tool_calls: options.parallel_tool_calls
          },
          ...options.previous_response_id && {
            previous_response_id: options.previous_response_id
          },
          ...options.metadata && { metadata: options.metadata }
        };
        const response = await this.client.responses.create(params);
        return this.converter.convertResponse(response);
      } catch (error) {
        this.handleError(error, options.model);
        throw error;
      }
    }, options.model);
  }
  /**
   * Stream response using OpenAI Responses API
   */
  async *streamGenerate(options) {
    try {
      const { input, instructions } = this.converter.convertInput(
        options.input,
        options.instructions
      );
      const params = {
        model: options.model,
        input,
        ...instructions && { instructions },
        ...options.tools && options.tools.length > 0 && {
          tools: this.converter.convertTools(options.tools)
        },
        ...options.tool_choice && {
          tool_choice: this.converter.convertToolChoice(options.tool_choice)
        },
        ...options.temperature !== void 0 && this.supportsParameter(options.model, "temperature") && { temperature: options.temperature },
        ...options.max_output_tokens && { max_output_tokens: options.max_output_tokens },
        ...options.response_format && {
          text: this.converter.convertResponseFormat(options.response_format)
        },
        ...options.parallel_tool_calls !== void 0 && {
          parallel_tool_calls: options.parallel_tool_calls
        },
        ...options.previous_response_id && {
          previous_response_id: options.previous_response_id
        },
        ...options.metadata && { metadata: options.metadata },
        stream: true
      };
      const stream = await this.client.responses.create(params);
      yield* this.streamConverter.convertStream(stream);
    } catch (error) {
      this.handleError(error, options.model);
      throw error;
    }
  }
  /**
   * Get model capabilities (registry-driven with OpenAI vendor defaults)
   */
  getModelCapabilities(model) {
    return resolveModelCapabilities(model, {
      supportsTools: true,
      supportsVision: true,
      supportsJSON: true,
      supportsJSONSchema: true,
      maxTokens: 128e3,
      maxInputTokens: 128e3,
      maxOutputTokens: 16384
    });
  }
  /**
   * Handle OpenAI-specific errors
   */
  handleError(error, model) {
    if (error.status === 401) {
      throw new ProviderAuthError("openai", "Invalid API key");
    }
    if (error.status === 429) {
      const retryAfter = error.headers?.["retry-after"];
      throw new ProviderRateLimitError(
        "openai",
        retryAfter ? parseInt(retryAfter) * 1e3 : void 0
      );
    }
    if (error.code === "context_length_exceeded" || error.status === 413) {
      throw new ProviderContextLengthError("openai", resolveMaxContextTokens(model, 128e3));
    }
    throw error;
  }
};
function buildLLMResponse(options) {
  const {
    provider,
    rawId,
    model,
    status,
    content,
    usage,
    messageId,
    createdAt = Math.floor(Date.now() / 1e3)
  } = options;
  const responseId = rawId ? `resp_${provider}_${rawId}` : `resp_${provider}_${crypto2.randomUUID()}`;
  const msgId = messageId || `msg_${provider}_${crypto2.randomUUID()}`;
  const output = [
    {
      type: "message",
      id: msgId,
      role: "assistant" /* ASSISTANT */,
      content
    }
  ];
  const outputText = extractTextFromContent(content);
  return {
    id: responseId,
    object: "response",
    created_at: createdAt,
    status,
    model,
    output,
    output_text: outputText,
    usage: {
      input_tokens: usage.inputTokens,
      output_tokens: usage.outputTokens,
      total_tokens: usage.totalTokens ?? usage.inputTokens + usage.outputTokens
    }
  };
}
function extractTextFromContent(content) {
  return content.filter(
    (c) => c.type === "output_text" /* OUTPUT_TEXT */
  ).map((c) => c.text).join("\n");
}
function createTextContent(text) {
  return {
    type: "output_text" /* OUTPUT_TEXT */,
    text,
    annotations: []
  };
}
function createToolUseContent(id, name, args) {
  return {
    type: "tool_use" /* TOOL_USE */,
    id,
    name,
    arguments: typeof args === "string" ? args : JSON.stringify(args)
  };
}
function mapAnthropicStatus(stopReason) {
  switch (stopReason) {
    case "end_turn":
    case "tool_use":
    case "stop_sequence":
      return "completed";
    case "max_tokens":
      return "incomplete";
    default:
      return "incomplete";
  }
}
function mapGoogleStatus(finishReason) {
  switch (finishReason) {
    case "STOP":
      return "completed";
    case "MAX_TOKENS":
      return "incomplete";
    case "SAFETY":
    case "RECITATION":
      return "failed";
    case "OTHER":
    default:
      return "incomplete";
  }
}
function generateToolCallId(provider) {
  const uuid = crypto2.randomUUID();
  return `${provider}_${uuid}` ;
}

// src/infrastructure/providers/shared/ToolConversionUtils.ts
function extractFunctionTools(tools) {
  return tools.filter((t) => t.type === "function");
}
function convertToolsToStandardFormat(tools) {
  return extractFunctionTools(tools).map((tool) => ({
    name: tool.function.name,
    description: tool.function.description || "",
    parameters: tool.function.parameters || { type: "object", properties: {} }
  }));
}
function transformForAnthropic(tool) {
  return {
    name: tool.name,
    description: tool.description,
    input_schema: tool.parameters
  };
}

// src/infrastructure/providers/base/BaseConverter.ts
var BaseConverter = class {
  // ==========================================================================
  // Protected Helper Methods (shared by all providers)
  // ==========================================================================
  /**
   * Convert InputItem array to provider messages
   * @param input - String or InputItem array
   * @returns Normalized input ready for provider conversion
   */
  normalizeInput(input) {
    if (typeof input === "string") {
      return [
        {
          type: "message",
          role: "user" /* USER */,
          content: [{ type: "input_text" /* INPUT_TEXT */, text: input }]
        }
      ];
    }
    return input;
  }
  /**
   * Map our role to provider-specific role
   * Override in subclass if provider uses different role names
   */
  mapRole(role) {
    if (role === "developer" /* DEVELOPER */) {
      return "user";
    }
    return role;
  }
  /**
   * Convert our Tool[] to provider-specific tool format
   */
  convertTools(tools) {
    if (!tools || tools.length === 0) {
      return void 0;
    }
    const standardTools = convertToolsToStandardFormat(tools);
    return standardTools.map((tool) => this.transformTool(tool));
  }
  /**
   * Parse tool arguments from JSON string
   * Throws InvalidToolArgumentsError on parse failure
   */
  parseToolArguments(name, argsString) {
    try {
      return JSON.parse(argsString);
    } catch (parseError) {
      throw new InvalidToolArgumentsError(
        name,
        argsString,
        parseError instanceof Error ? parseError : new Error(String(parseError))
      );
    }
  }
  /**
   * Parse a data URI into components
   * @returns Parsed image data or null if not a data URI
   */
  parseDataUri(url2) {
    const matches = url2.match(/^data:image\/(\w+);base64,(.+)$/);
    if (!matches || matches.length < 3) {
      return null;
    }
    const format = matches[1];
    const data = matches[2];
    return {
      format,
      mediaType: `image/${format}`,
      data
    };
  }
  /**
   * Check if URL is a data URI
   */
  isDataUri(url2) {
    return url2.startsWith("data:");
  }
  /**
   * Build standardized LLMResponse using shared utility
   */
  buildResponse(options) {
    return buildLLMResponse({
      provider: this.providerName,
      ...options
    });
  }
  /**
   * Create a text content block
   */
  createText(text) {
    return createTextContent(text);
  }
  /**
   * Create a tool_use content block
   */
  createToolUse(id, name, args) {
    return createToolUseContent(id, name, args);
  }
  /**
   * Extract text from Content array
   */
  extractText(content) {
    return content.filter((c) => c.type === "output_text" /* OUTPUT_TEXT */).map((c) => c.text).join("\n");
  }
  /**
   * Handle content conversion for common content types
   * Can be used as a starting point in subclass convertContent methods
   */
  handleCommonContent(content, _handlers) {
    const handlers = _handlers;
    switch (content.type) {
      case "input_text" /* INPUT_TEXT */:
      case "output_text" /* OUTPUT_TEXT */:
        handlers.onText?.(content.text);
        return true;
      case "input_image_url" /* INPUT_IMAGE_URL */: {
        const imgContent = content;
        const parsed = this.parseDataUri(imgContent.image_url.url);
        handlers.onImage?.(imgContent.image_url.url, parsed);
        return true;
      }
      case "tool_use" /* TOOL_USE */: {
        const toolContent = content;
        const parsedArgs = this.parseToolArguments(toolContent.name, toolContent.arguments);
        handlers.onToolUse?.(toolContent.id, toolContent.name, parsedArgs);
        return true;
      }
      case "tool_result" /* TOOL_RESULT */: {
        const resultContent = content;
        const isError = !!resultContent.error;
        handlers.onToolResult?.(
          resultContent.tool_use_id,
          resultContent.content,
          isError,
          resultContent.error
        );
        return true;
      }
      default:
        return false;
    }
  }
  // ==========================================================================
  // Resource Cleanup (required lifecycle method)
  // ==========================================================================
  /**
   * Clean up any internal state/caches
   * Should be called after each request/response cycle to prevent memory leaks
   *
   * Default implementation does nothing - override if subclass maintains state
   */
  clear() {
  }
  /**
   * Alias for clear() - reset converter state
   */
  reset() {
    this.clear();
  }
};

// src/infrastructure/providers/anthropic/AnthropicConverter.ts
var AnthropicConverter = class extends BaseConverter {
  providerName = "anthropic";
  /**
   * Convert our format -> Anthropic Messages API format
   */
  convertRequest(options) {
    const messages = this.convertMessages(options.input);
    const tools = this.convertAnthropicTools(options.tools);
    const params = {
      model: options.model,
      max_tokens: options.max_output_tokens || 4096,
      messages
    };
    if (options.instructions) {
      params.system = options.instructions;
    }
    if (tools && tools.length > 0) {
      params.tools = tools;
    }
    if (options.temperature !== void 0) {
      params.temperature = options.temperature;
    }
    return params;
  }
  /**
   * Convert Anthropic response -> our LLMResponse format
   */
  convertResponse(response) {
    return this.buildResponse({
      rawId: response.id,
      model: response.model,
      status: this.mapProviderStatus(response.stop_reason),
      content: this.convertProviderContent(response.content),
      messageId: response.id,
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens
      }
    });
  }
  // ==========================================================================
  // BaseConverter Abstract Method Implementations
  // ==========================================================================
  /**
   * Transform standardized tool to Anthropic format
   */
  transformTool(tool) {
    return {
      ...transformForAnthropic(tool),
      input_schema: {
        type: "object",
        ...tool.parameters
      }
    };
  }
  /**
   * Convert Anthropic content blocks to our Content[]
   */
  convertProviderContent(blocks) {
    const content = [];
    for (const block of blocks) {
      if (block.type === "text") {
        content.push(this.createText(block.text));
      } else if (block.type === "tool_use") {
        content.push(this.createToolUse(block.id, block.name, block.input));
      }
    }
    return content;
  }
  /**
   * Map Anthropic stop_reason to ResponseStatus
   */
  mapProviderStatus(status) {
    return mapAnthropicStatus(status);
  }
  // ==========================================================================
  // Anthropic-Specific Conversion Methods
  // ==========================================================================
  /**
   * Convert our InputItem[] -> Anthropic messages
   */
  convertMessages(input) {
    if (typeof input === "string") {
      return [{ role: "user", content: input }];
    }
    const messages = [];
    for (const item of input) {
      if (item.type === "message") {
        const role = this.mapRole(item.role);
        const content = this.convertContent(item.content);
        if (!content || Array.isArray(content) && content.length === 0 || content === "") {
          continue;
        }
        messages.push({
          role,
          content
        });
      }
    }
    return messages;
  }
  /**
   * Convert our Content[] -> Anthropic content blocks
   */
  convertContent(content) {
    const blocks = [];
    for (const c of content) {
      switch (c.type) {
        case "input_text" /* INPUT_TEXT */:
        case "output_text" /* OUTPUT_TEXT */: {
          const textContent = c.text;
          if (textContent && textContent.trim()) {
            blocks.push({
              type: "text",
              text: textContent
            });
          }
          break;
        }
        case "input_image_url" /* INPUT_IMAGE_URL */: {
          const imgContent = c;
          const block = this.convertImageToAnthropicBlock(imgContent.image_url.url);
          if (block) {
            blocks.push(block);
          }
          break;
        }
        case "tool_result" /* TOOL_RESULT */: {
          const resultContent = c;
          blocks.push(this.convertToolResultToAnthropicBlock(resultContent));
          break;
        }
        case "tool_use" /* TOOL_USE */: {
          const toolContent = c;
          const parsedInput = this.parseToolArguments(toolContent.name, toolContent.arguments);
          blocks.push({
            type: "tool_use",
            id: toolContent.id,
            name: toolContent.name,
            input: parsedInput
          });
          break;
        }
      }
    }
    if (blocks.length === 1 && blocks[0]?.type === "text") {
      return blocks[0].text;
    }
    return blocks;
  }
  /**
   * Convert image URL to Anthropic image block
   */
  convertImageToAnthropicBlock(url2) {
    const parsed = this.parseDataUri(url2);
    if (parsed) {
      return {
        type: "image",
        source: {
          type: "base64",
          media_type: parsed.mediaType,
          data: parsed.data
        }
      };
    } else {
      return {
        type: "image",
        source: {
          type: "url",
          url: url2
        }
      };
    }
  }
  /**
   * Convert tool result to Anthropic block
   * Anthropic requires non-empty content when is_error is true
   * Supports __images convention: tool results with __images get multimodal content
   */
  convertToolResultToAnthropicBlock(resultContent) {
    const isError = !!resultContent.error;
    let toolResultContent;
    if (typeof resultContent.content === "string") {
      toolResultContent = resultContent.content || (isError ? resultContent.error : "");
    } else {
      toolResultContent = JSON.stringify(resultContent.content);
    }
    if (isError && !toolResultContent) {
      toolResultContent = resultContent.error || "Tool execution failed";
    }
    const images = resultContent.__images?.length ? resultContent.__images : this.extractImages(toolResultContent);
    if (images) {
      const textContent = resultContent.__images?.length ? toolResultContent : this.stripImagesFromContent(toolResultContent);
      const contentBlocks = [];
      if (textContent.trim()) {
        contentBlocks.push({ type: "text", text: textContent });
      }
      for (const img of images) {
        contentBlocks.push({
          type: "image",
          source: {
            type: "base64",
            media_type: img.mediaType || "image/png",
            data: img.base64
          }
        });
      }
      return {
        type: "tool_result",
        tool_use_id: resultContent.tool_use_id,
        content: contentBlocks.length > 0 ? contentBlocks : textContent,
        is_error: isError
      };
    }
    return {
      type: "tool_result",
      tool_use_id: resultContent.tool_use_id,
      content: toolResultContent,
      is_error: isError
    };
  }
  /**
   * Extract __images from a JSON-stringified tool result content.
   * Returns null if no images found.
   */
  extractImages(content) {
    try {
      const parsed = JSON.parse(content);
      if (parsed && Array.isArray(parsed.__images) && parsed.__images.length > 0) {
        return parsed.__images;
      }
    } catch {
    }
    return null;
  }
  /**
   * Strip __images and base64 fields from JSON content to reduce token usage in text.
   */
  stripImagesFromContent(content) {
    try {
      const parsed = JSON.parse(content);
      const { __images: _, base64: __, ...rest } = parsed;
      return JSON.stringify(rest);
    } catch {
      return content;
    }
  }
  /**
   * Convert our Tool[] -> Anthropic tools
   * Uses shared conversion utilities (DRY)
   */
  convertAnthropicTools(tools) {
    if (!tools || tools.length === 0) {
      return void 0;
    }
    const standardTools = convertToolsToStandardFormat(tools);
    return standardTools.map((tool) => this.transformTool(tool));
  }
};

// src/infrastructure/providers/base/BaseStreamConverter.ts
var BaseStreamConverter = class {
  // ==========================================================================
  // Protected State (shared across all stream converters)
  // ==========================================================================
  /** Current response ID */
  responseId = "";
  /** Model name */
  model = "";
  /** Event sequence number for ordering */
  sequenceNumber = 0;
  /** Usage statistics */
  usage = { inputTokens: 0, outputTokens: 0 };
  /** Buffers for accumulating tool call arguments */
  toolCallBuffers = /* @__PURE__ */ new Map();
  // ==========================================================================
  // Public API
  // ==========================================================================
  /**
   * Convert provider stream to our StreamEvent format
   *
   * @param stream - Provider-specific async stream
   * @param model - Model name (may not be available in all events)
   */
  async *convertStream(stream, model) {
    this.reset();
    if (model) {
      this.model = model;
    }
    try {
      for await (const event of stream) {
        const converted = this.convertEvent(event);
        for (const evt of converted) {
          yield evt;
        }
      }
    } finally {
    }
  }
  /**
   * Clear all internal state
   * Should be called after stream is fully processed
   */
  clear() {
    this.responseId = "";
    this.model = "";
    this.sequenceNumber = 0;
    this.usage = { inputTokens: 0, outputTokens: 0 };
    this.toolCallBuffers.clear();
  }
  /**
   * Reset converter state for a new stream
   * Alias for clear()
   */
  reset() {
    this.clear();
  }
  // ==========================================================================
  // Protected Helper Methods
  // ==========================================================================
  /**
   * Generate a response ID with provider prefix
   */
  generateResponseId() {
    const uuid = crypto.randomUUID();
    return `resp_${this.providerName}_${uuid}`;
  }
  /**
   * Get next sequence number (auto-increments)
   */
  nextSequence() {
    return this.sequenceNumber++;
  }
  /**
   * Create RESPONSE_CREATED event
   */
  emitResponseCreated(responseId) {
    if (responseId) {
      this.responseId = responseId;
    } else if (!this.responseId) {
      this.responseId = this.generateResponseId();
    }
    return {
      type: "response.created" /* RESPONSE_CREATED */,
      response_id: this.responseId,
      model: this.model,
      created_at: Date.now()
    };
  }
  /**
   * Create OUTPUT_TEXT_DELTA event
   */
  emitTextDelta(delta, options) {
    return {
      type: "response.output_text.delta" /* OUTPUT_TEXT_DELTA */,
      response_id: this.responseId,
      item_id: options?.itemId || `msg_${this.responseId}`,
      output_index: options?.outputIndex ?? 0,
      content_index: options?.contentIndex ?? 0,
      delta,
      sequence_number: this.nextSequence()
    };
  }
  /**
   * Create TOOL_CALL_START event
   */
  emitToolCallStart(toolCallId, toolName, itemId) {
    this.toolCallBuffers.set(toolCallId, {
      id: toolCallId,
      name: toolName,
      args: ""
    });
    return {
      type: "response.tool_call.start" /* TOOL_CALL_START */,
      response_id: this.responseId,
      item_id: itemId || `msg_${this.responseId}`,
      tool_call_id: toolCallId,
      tool_name: toolName
    };
  }
  /**
   * Create TOOL_CALL_ARGUMENTS_DELTA event and accumulate args
   */
  emitToolCallArgsDelta(toolCallId, delta, toolName) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    if (buffer) {
      buffer.args += delta;
    }
    return {
      type: "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */,
      response_id: this.responseId,
      item_id: `msg_${this.responseId}`,
      tool_call_id: toolCallId,
      tool_name: toolName || buffer?.name || "",
      delta,
      sequence_number: this.nextSequence()
    };
  }
  /**
   * Create TOOL_CALL_ARGUMENTS_DONE event with accumulated args
   */
  emitToolCallArgsDone(toolCallId, toolName) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    const args = buffer?.args || "{}";
    const name = toolName || buffer?.name || "";
    return {
      type: "response.tool_call_arguments.done" /* TOOL_CALL_ARGUMENTS_DONE */,
      response_id: this.responseId,
      tool_call_id: toolCallId,
      tool_name: name,
      arguments: args
    };
  }
  /**
   * Create RESPONSE_COMPLETE event
   */
  emitResponseComplete(status = "completed") {
    return {
      type: "response.complete" /* RESPONSE_COMPLETE */,
      response_id: this.responseId,
      status,
      usage: {
        input_tokens: this.usage.inputTokens,
        output_tokens: this.usage.outputTokens,
        total_tokens: this.usage.inputTokens + this.usage.outputTokens
      },
      iterations: 1
    };
  }
  /**
   * Update usage statistics
   */
  updateUsage(inputTokens, outputTokens) {
    if (inputTokens !== void 0) {
      this.usage.inputTokens = inputTokens;
    }
    if (outputTokens !== void 0) {
      this.usage.outputTokens = outputTokens;
    }
  }
  /**
   * Get accumulated arguments for a tool call
   */
  getAccumulatedArgs(toolCallId) {
    return this.toolCallBuffers.get(toolCallId)?.args || "{}";
  }
  /**
   * Check if we have buffered data for a tool call
   */
  hasToolCallBuffer(toolCallId) {
    return this.toolCallBuffers.has(toolCallId);
  }
};

// src/infrastructure/providers/anthropic/AnthropicStreamConverter.ts
var AnthropicStreamConverter = class extends BaseStreamConverter {
  providerName = "anthropic";
  /** Map of content block index to block info */
  contentBlockIndex = /* @__PURE__ */ new Map();
  /**
   * Convert a single Anthropic event to our StreamEvent(s)
   */
  convertEvent(event) {
    const eventType = event.type;
    switch (eventType) {
      case "message_start":
        return this.handleMessageStart(event);
      case "content_block_start":
        return this.handleContentBlockStart(event);
      case "content_block_delta":
        return this.handleContentBlockDelta(event);
      case "content_block_stop":
        return this.handleContentBlockStop(event);
      case "message_delta":
        return this.handleMessageDelta(event);
      case "message_stop":
        return this.handleMessageStop();
      default:
        return [];
    }
  }
  /**
   * Clear all internal state
   */
  clear() {
    super.clear();
    this.contentBlockIndex.clear();
  }
  // ==========================================================================
  // Anthropic-Specific Event Handlers
  // ==========================================================================
  /**
   * Handle message_start event
   */
  handleMessageStart(event) {
    this.responseId = event.message.id;
    if (event.message.usage) {
      this.updateUsage(event.message.usage.input_tokens, void 0);
    }
    return [this.emitResponseCreated(this.responseId)];
  }
  /**
   * Handle content_block_start event
   */
  handleContentBlockStart(event) {
    const index = event.index;
    const block = event.content_block;
    if (block.type === "text") {
      this.contentBlockIndex.set(index, { type: "text" });
      return [];
    } else if (block.type === "tool_use") {
      this.contentBlockIndex.set(index, {
        type: "tool_use",
        id: block.id,
        name: block.name
      });
      return [this.emitToolCallStart(block.id, block.name, `msg_${this.responseId}`)];
    }
    return [];
  }
  /**
   * Handle content_block_delta event
   */
  handleContentBlockDelta(event) {
    const index = event.index;
    const delta = event.delta;
    const blockInfo = this.contentBlockIndex.get(index);
    if (!blockInfo) return [];
    if (delta.type === "text_delta") {
      return [
        this.emitTextDelta(delta.text, {
          itemId: `msg_${this.responseId}`,
          contentIndex: index
        })
      ];
    } else if (delta.type === "input_json_delta") {
      const toolCallId = blockInfo.id || "";
      return [this.emitToolCallArgsDelta(toolCallId, delta.partial_json, blockInfo.name)];
    }
    return [];
  }
  /**
   * Handle content_block_stop event
   */
  handleContentBlockStop(event) {
    const index = event.index;
    const blockInfo = this.contentBlockIndex.get(index);
    if (!blockInfo) return [];
    if (blockInfo.type === "tool_use") {
      return [this.emitToolCallArgsDone(blockInfo.id || "", blockInfo.name)];
    }
    return [];
  }
  /**
   * Handle message_delta event (usage info, stop_reason)
   */
  handleMessageDelta(event) {
    if (event.usage) {
      this.updateUsage(void 0, event.usage.output_tokens);
    }
    return [];
  }
  /**
   * Handle message_stop event (final event)
   */
  handleMessageStop() {
    return [this.emitResponseComplete("completed")];
  }
};

// src/infrastructure/providers/anthropic/AnthropicTextProvider.ts
var AnthropicTextProvider = class extends BaseTextProvider {
  name = "anthropic";
  capabilities = {
    text: true,
    images: true,
    // Claude 3+ supports vision
    videos: false,
    audio: false
  };
  client;
  converter;
  streamConverter;
  constructor(config) {
    super(config);
    this.client = new Anthropic__default.default({
      apiKey: this.getApiKey(),
      baseURL: this.getBaseURL(),
      maxRetries: this.getMaxRetries()
    });
    this.converter = new AnthropicConverter();
    this.streamConverter = new AnthropicStreamConverter();
  }
  /**
   * Generate response using Anthropic Messages API
   */
  async generate(options) {
    return this.executeWithCircuitBreaker(async () => {
      try {
        const anthropicRequest = this.converter.convertRequest(options);
        const anthropicResponse = await this.client.messages.create({
          ...anthropicRequest,
          stream: false
        });
        return this.converter.convertResponse(anthropicResponse);
      } catch (error) {
        this.handleError(error, options.model);
        throw error;
      }
    }, options.model);
  }
  /**
   * Stream response using Anthropic Messages API
   */
  async *streamGenerate(options) {
    try {
      const anthropicRequest = this.converter.convertRequest(options);
      const stream = await this.client.messages.create({
        ...anthropicRequest,
        stream: true
      });
      this.streamConverter.reset();
      yield* this.streamConverter.convertStream(stream, options.model);
    } catch (error) {
      this.handleError(error, options.model);
      throw error;
    } finally {
      this.streamConverter.clear();
    }
  }
  /**
   * Get model capabilities (registry-driven with Anthropic vendor defaults)
   */
  getModelCapabilities(model) {
    const caps = resolveModelCapabilities(model, {
      supportsTools: true,
      supportsVision: true,
      supportsJSON: true,
      supportsJSONSchema: false,
      maxTokens: 2e5,
      maxInputTokens: 2e5,
      maxOutputTokens: 8192
    });
    caps.supportsJSONSchema = false;
    return caps;
  }
  /**
   * Handle Anthropic-specific errors
   */
  handleError(error, model) {
    if (error.status === 401) {
      throw new ProviderAuthError("anthropic", "Invalid API key");
    }
    if (error.status === 429) {
      const retryAfter = error.headers?.["retry-after"];
      throw new ProviderRateLimitError(
        "anthropic",
        retryAfter ? parseInt(retryAfter) * 1e3 : void 0
      );
    }
    if (error.type === "invalid_request_error" && (error.message?.includes("prompt is too long") || error.message?.includes("maximum context length"))) {
      throw new ProviderContextLengthError("anthropic", resolveMaxContextTokens(model, 2e5));
    }
    throw error;
  }
};

// src/utils/imageUtils.ts
var DEFAULT_TIMEOUT_MS = 3e4;
var DEFAULT_MAX_SIZE_BYTES = 10 * 1024 * 1024;
async function fetchImageAsBase64(url2, options) {
  const { timeoutMs = DEFAULT_TIMEOUT_MS, maxSizeBytes = DEFAULT_MAX_SIZE_BYTES } = {};
  if (url2.startsWith("data:image/")) {
    const matches = url2.match(/^data:(image\/\w+);base64,(.+)$/);
    if (matches) {
      const base64Data = matches[2] || "";
      const size = calculateBase64Size(base64Data);
      if (size > maxSizeBytes) {
        throw new Error(`Image size (${formatBytes(size)}) exceeds maximum allowed (${formatBytes(maxSizeBytes)})`);
      }
      return {
        mimeType: matches[1] || "image/png",
        base64Data,
        size
      };
    }
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(url2, {
      signal: controller.signal
    });
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
    }
    const contentLength = response.headers.get("content-length");
    if (contentLength) {
      const size = parseInt(contentLength, 10);
      if (size > maxSizeBytes) {
        throw new Error(
          `Image size (${formatBytes(size)}) exceeds maximum allowed (${formatBytes(maxSizeBytes)})`
        );
      }
    }
    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error("Failed to get response body reader");
    }
    const chunks = [];
    let totalSize = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      totalSize += value.length;
      if (totalSize > maxSizeBytes) {
        reader.cancel();
        throw new Error(
          `Image size exceeds maximum allowed (${formatBytes(maxSizeBytes)})`
        );
      }
      chunks.push(value);
    }
    const buffer = Buffer.concat(chunks.map((chunk) => Buffer.from(chunk)));
    const base64Data = buffer.toString("base64");
    let mimeType = response.headers.get("content-type") || "image/png";
    if (!mimeType.startsWith("image/")) {
      mimeType = detectImageFormatFromBuffer(buffer);
    }
    return {
      mimeType,
      base64Data,
      size: buffer.length
    };
  } catch (error) {
    if (error.name === "AbortError") {
      throw new Error(`Image fetch timed out after ${timeoutMs}ms`);
    }
    throw new Error(`Failed to fetch image from URL: ${error.message}`);
  } finally {
    clearTimeout(timeoutId);
  }
}
function detectImageFormatFromBuffer(buffer) {
  const magic = buffer.slice(0, 4).toString("hex");
  if (magic.startsWith("89504e47")) return "image/png";
  if (magic.startsWith("ffd8ff")) return "image/jpeg";
  if (magic.startsWith("47494638")) return "image/gif";
  if (magic.startsWith("52494646")) return "image/webp";
  throw new Error("URL does not point to a valid image");
}
function calculateBase64Size(base64Data) {
  const data = base64Data.includes(",") ? base64Data.split(",")[1] : base64Data;
  if (!data || data.length === 0) return 0;
  let padding = 0;
  if (data.endsWith("==")) padding = 2;
  else if (data.endsWith("=")) padding = 1;
  return Math.floor(data.length * 3 / 4) - padding;
}
function formatBytes(bytes) {
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

// src/infrastructure/providers/google/GoogleConverter.ts
var GoogleConverter = class {
  // Track tool call ID → tool name mapping for tool results
  toolCallMapping = /* @__PURE__ */ new Map();
  // Track tool call ID → thought signature for Gemini 3+
  // NOTE: This map is shared with GoogleStreamConverter for streaming responses
  thoughtSignatures = /* @__PURE__ */ new Map();
  /**
   * Get the thought signatures storage map
   * Used by GoogleStreamConverter to store signatures from streaming responses
   */
  getThoughtSignatureStorage() {
    return this.thoughtSignatures;
  }
  /**
   * Get the tool call mapping storage
   * Used by GoogleStreamConverter to store tool name mappings from streaming responses
   */
  getToolCallMappingStorage() {
    return this.toolCallMapping;
  }
  /**
   * Convert our format → Google Gemini format
   */
  async convertRequest(options) {
    if (process.env.DEBUG_GOOGLE && Array.isArray(options.input)) {
      console.error("[DEBUG] Input messages:", JSON.stringify(options.input.map((msg) => ({
        type: msg.type,
        role: msg.role,
        contentTypes: msg.content?.map((c) => c.type)
      })), null, 2));
    }
    const contents = await this.convertMessages(options.input);
    const tools = this.convertTools(options.tools);
    if (process.env.DEBUG_GOOGLE) {
      console.error("[DEBUG] Final contents array length:", contents.length);
    }
    const request = {
      contents
    };
    if (options.instructions) {
      request.systemInstruction = { parts: [{ text: options.instructions }] };
    }
    if (tools && tools.length > 0) {
      request.tools = [{ functionDeclarations: tools }];
      request.toolConfig = {
        functionCallingConfig: {
          mode: options.tool_choice === "required" ? "ANY" : "AUTO"
        }
      };
    }
    request.generationConfig = {
      temperature: options.temperature,
      maxOutputTokens: options.max_output_tokens
    };
    if (options.vendorOptions?.thinkingLevel) {
      request.generationConfig.thinkingConfig = {
        thinkingLevel: options.vendorOptions.thinkingLevel
      };
    }
    if (tools && tools.length > 0) {
      request.generationConfig.allowCodeExecution = false;
    }
    if (options.response_format) {
      if (options.response_format.type === "json_object") {
        request.generationConfig.responseMimeType = "application/json";
      } else if (options.response_format.type === "json_schema") {
        request.generationConfig.responseMimeType = "application/json";
      }
    }
    return request;
  }
  /**
   * Convert our InputItem[] → Google contents
   */
  async convertMessages(input) {
    if (typeof input === "string") {
      return [
        {
          role: "user",
          parts: [{ text: input }]
        }
      ];
    }
    const contents = [];
    for (const item of input) {
      if (item.type === "message") {
        const role = item.role === "user" /* USER */ || item.role === "developer" /* DEVELOPER */ ? "user" : "model";
        const parts = await this.convertContentToParts(item.content);
        if (process.env.DEBUG_GOOGLE) {
          console.error(
            `[DEBUG] Converting message - role: ${item.role} \u2192 ${role}, parts: ${parts.length}`,
            parts.map((p) => Object.keys(p))
          );
        }
        if (parts.length > 0) {
          contents.push({
            role,
            parts
          });
        }
      }
    }
    return contents;
  }
  /**
   * Convert our Content[] → Google parts
   */
  async convertContentToParts(content) {
    const parts = [];
    for (const c of content) {
      switch (c.type) {
        case "input_text" /* INPUT_TEXT */:
        case "output_text" /* OUTPUT_TEXT */:
          parts.push({ text: c.text });
          break;
        case "input_image_url" /* INPUT_IMAGE_URL */:
          try {
            const imageData = await fetchImageAsBase64(c.image_url.url);
            parts.push({
              inlineData: {
                mimeType: imageData.mimeType,
                data: imageData.base64Data
              }
            });
          } catch (error) {
            console.error(`Failed to fetch image: ${error.message}`);
            parts.push({
              text: `[Error: Could not load image from ${c.image_url.url}]`
            });
          }
          break;
        case "tool_use" /* TOOL_USE */:
          this.toolCallMapping.set(c.id, c.name);
          let parsedArgs;
          try {
            parsedArgs = JSON.parse(c.arguments);
          } catch (parseError) {
            throw new InvalidToolArgumentsError(
              c.name,
              c.arguments,
              parseError instanceof Error ? parseError : new Error(String(parseError))
            );
          }
          const functionCallPart = {
            functionCall: {
              name: c.name,
              args: parsedArgs
            }
          };
          const signature = this.thoughtSignatures.get(c.id);
          if (process.env.DEBUG_GOOGLE) {
            console.error(`[DEBUG] Looking up signature for tool ID: ${c.id}`);
            console.error(`[DEBUG] Found signature:`, signature ? "YES" : "NO");
            console.error(`[DEBUG] Available signatures:`, Array.from(this.thoughtSignatures.keys()));
          }
          if (signature) {
            functionCallPart.thoughtSignature = signature;
          }
          parts.push(functionCallPart);
          break;
        case "tool_result" /* TOOL_RESULT */: {
          const functionName = this.toolCallMapping.get(c.tool_use_id) || this.extractToolName(c.tool_use_id);
          const contentImages = c.__images;
          let resultText;
          let resultImages;
          if (contentImages?.length) {
            resultText = typeof c.content === "string" ? c.content : JSON.stringify(c.content);
            resultImages = contentImages;
          } else {
            const resultStr = typeof c.content === "string" ? c.content : JSON.stringify(c.content);
            const extracted = this.extractImagesFromResult(resultStr);
            resultText = extracted.text;
            resultImages = extracted.images;
          }
          parts.push({
            functionResponse: {
              name: functionName,
              response: {
                result: resultText
              }
            }
          });
          for (const img of resultImages) {
            parts.push({
              inlineData: {
                mimeType: img.mediaType || "image/png",
                data: img.base64
              }
            });
          }
          break;
        }
      }
    }
    return parts;
  }
  /**
   * Convert our Tool[] → Google function declarations
   */
  convertTools(tools) {
    if (!tools || tools.length === 0) {
      return void 0;
    }
    const standardTools = convertToolsToStandardFormat(tools);
    return standardTools.map((tool) => ({
      name: tool.name,
      description: tool.description,
      parameters: this.convertParametersSchema(tool.parameters)
    }));
  }
  /**
   * Convert JSON Schema parameters to Google's format
   */
  convertParametersSchema(schema) {
    if (!schema) return void 0;
    const converted = {
      type: "OBJECT",
      // Google uses uppercase 'OBJECT'
      properties: {}
    };
    if (schema.properties) {
      for (const [key, value] of Object.entries(schema.properties)) {
        const prop = value;
        converted.properties[key] = {
          type: prop.type?.toUpperCase() || "STRING",
          description: prop.description
        };
        if (prop.enum) {
          converted.properties[key].enum = prop.enum;
        }
        if (prop.type === "object" && prop.properties) {
          converted.properties[key] = this.convertParametersSchema(prop);
        }
        if (prop.type === "array" && prop.items) {
          converted.properties[key].items = this.convertParametersSchema(prop.items);
        }
      }
    }
    if (schema.required) {
      converted.required = schema.required;
    }
    return converted;
  }
  /**
   * Convert Google response → our LLMResponse format
   */
  convertResponse(response) {
    const candidate = response.candidates?.[0];
    const geminiContent = candidate?.content;
    const content = this.convertGeminiPartsToContent(geminiContent?.parts || []);
    if (process.env.DEBUG_GOOGLE) {
      console.error("[DEBUG] Content array:", JSON.stringify(content, null, 2));
      console.error("[DEBUG] Raw parts:", JSON.stringify(geminiContent?.parts, null, 2));
    }
    return buildLLMResponse({
      provider: "google",
      model: response.modelVersion || "gemini",
      status: mapGoogleStatus(candidate?.finishReason),
      content,
      messageId: response.id,
      usage: {
        inputTokens: response.usageMetadata?.promptTokenCount || 0,
        outputTokens: response.usageMetadata?.candidatesTokenCount || 0,
        totalTokens: response.usageMetadata?.totalTokenCount || 0
      }
    });
  }
  /**
   * Convert Google parts → our Content[]
   */
  convertGeminiPartsToContent(parts) {
    const content = [];
    for (const part of parts) {
      if ("text" in part && part.text) {
        content.push(createTextContent(part.text));
      } else if ("functionCall" in part && part.functionCall) {
        const toolId = generateToolCallId("google");
        const functionName = part.functionCall.name || "";
        if ("thoughtSignature" in part && part.thoughtSignature) {
          const sig = part.thoughtSignature;
          this.thoughtSignatures.set(toolId, sig);
          if (process.env.DEBUG_GOOGLE) {
            console.error(`[DEBUG] Captured thought signature for tool ID: ${toolId}`);
            console.error(`[DEBUG] Signature length:`, sig.length);
          }
        } else if (process.env.DEBUG_GOOGLE) {
          console.error(`[DEBUG] NO thought signature in part for ${functionName}`);
          console.error(`[DEBUG] Part keys:`, Object.keys(part));
        }
        content.push(createToolUseContent(toolId, functionName, part.functionCall.args || {}));
      }
    }
    return content;
  }
  /**
   * Extract tool name from tool_use_id using tracked mapping
   */
  extractToolName(toolUseId) {
    const name = this.toolCallMapping.get(toolUseId);
    if (name) {
      return name;
    }
    console.warn(`[GoogleConverter] Tool name not found for ID: ${toolUseId}`);
    return "unknown_tool";
  }
  /**
   * Check if content array has tool calls requiring follow-up
   * Used to determine when to clear thought signatures (must persist across tool execution)
   */
  hasToolCalls(content) {
    return content.some((c) => c.type === "tool_use" /* TOOL_USE */);
  }
  /**
   * Clear all internal mappings
   * Should be called after each request/response cycle to prevent memory leaks
   */
  clearMappings() {
    this.toolCallMapping.clear();
    this.thoughtSignatures.clear();
  }
  /**
   * Reset converter state for a new request
   * Alias for clearMappings()
   */
  reset() {
    this.clearMappings();
  }
  /**
   * Extract __images from a JSON tool result and return cleaned text + images.
   * Used by the __images convention for multimodal tool results.
   */
  extractImagesFromResult(content) {
    try {
      const parsed = JSON.parse(content);
      if (parsed && Array.isArray(parsed.__images) && parsed.__images.length > 0) {
        const images = parsed.__images;
        const { __images: _, base64: __, ...rest } = parsed;
        return { text: JSON.stringify(rest), images };
      }
    } catch {
    }
    return { text: content, images: [] };
  }
};
var GoogleStreamConverter = class {
  responseId = "";
  model = "";
  sequenceNumber = 0;
  isFirst = true;
  toolCallBuffers = /* @__PURE__ */ new Map();
  hadToolCalls = false;
  // External storage for thought signatures (shared with GoogleConverter)
  thoughtSignatureStorage = null;
  // External storage for tool call ID → name mapping (shared with GoogleConverter)
  toolCallMappingStorage = null;
  /**
   * Set external storage for thought signatures
   * This allows sharing signatures with GoogleConverter for multi-turn conversations
   */
  setThoughtSignatureStorage(storage) {
    this.thoughtSignatureStorage = storage;
  }
  /**
   * Set external storage for tool call mappings
   * This allows sharing tool name lookups with GoogleConverter
   */
  setToolCallMappingStorage(storage) {
    this.toolCallMappingStorage = storage;
  }
  /**
   * Convert Google stream to our StreamEvent format
   */
  async *convertStream(googleStream, model) {
    this.model = model;
    this.sequenceNumber = 0;
    this.isFirst = true;
    this.toolCallBuffers.clear();
    this.hadToolCalls = false;
    let lastUsage = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    };
    for await (const chunk of googleStream) {
      if (this.isFirst) {
        this.responseId = this.generateResponseId();
        yield {
          type: "response.created" /* RESPONSE_CREATED */,
          response_id: this.responseId,
          model: this.model,
          created_at: Date.now()
        };
        this.isFirst = false;
      }
      const usage = this.extractUsage(chunk);
      if (usage) {
        lastUsage = usage;
      }
      const events = this.convertChunk(chunk);
      for (const event of events) {
        yield event;
      }
    }
    if (this.toolCallBuffers.size > 0) {
      for (const [toolCallId, buffer] of this.toolCallBuffers) {
        yield {
          type: "response.tool_call_arguments.done" /* TOOL_CALL_ARGUMENTS_DONE */,
          response_id: this.responseId,
          tool_call_id: toolCallId,
          tool_name: buffer.name,
          arguments: buffer.args
        };
      }
    }
    yield {
      type: "response.complete" /* RESPONSE_COMPLETE */,
      response_id: this.responseId,
      status: "completed",
      usage: lastUsage,
      iterations: 1
    };
  }
  /**
   * Extract usage from Google chunk
   */
  extractUsage(chunk) {
    const usage = chunk.usageMetadata;
    if (!usage) return null;
    return {
      input_tokens: usage.promptTokenCount || 0,
      output_tokens: usage.candidatesTokenCount || 0,
      total_tokens: usage.totalTokenCount || 0
    };
  }
  /**
   * Convert single Google chunk to our event(s)
   */
  convertChunk(chunk) {
    const events = [];
    const candidate = chunk.candidates?.[0];
    if (!candidate?.content?.parts) return events;
    for (const part of candidate.content.parts) {
      if (part.text) {
        events.push({
          type: "response.output_text.delta" /* OUTPUT_TEXT_DELTA */,
          response_id: this.responseId,
          item_id: `msg_${this.responseId}`,
          output_index: 0,
          content_index: 0,
          delta: part.text,
          sequence_number: this.sequenceNumber++
        });
      } else if (part.functionCall) {
        const functionCall = part.functionCall;
        const toolName = functionCall.name || "unknown";
        const toolCallId = `call_${this.responseId}_${toolName}`;
        const thoughtSignature = "thoughtSignature" in part ? part.thoughtSignature : void 0;
        if (!this.toolCallBuffers.has(toolCallId)) {
          this.hadToolCalls = true;
          this.toolCallBuffers.set(toolCallId, {
            name: toolName,
            args: "",
            signature: thoughtSignature
          });
          if (this.toolCallMappingStorage) {
            this.toolCallMappingStorage.set(toolCallId, toolName);
          }
          if (thoughtSignature && this.thoughtSignatureStorage) {
            this.thoughtSignatureStorage.set(toolCallId, thoughtSignature);
            if (process.env.DEBUG_GOOGLE) {
              console.error(`[DEBUG] Stream: Captured thought signature for tool ID: ${toolCallId}`);
            }
          } else if (process.env.DEBUG_GOOGLE && !thoughtSignature) {
            console.error(`[DEBUG] Stream: NO thought signature in part for ${toolName}`);
          }
          events.push({
            type: "response.tool_call.start" /* TOOL_CALL_START */,
            response_id: this.responseId,
            item_id: `msg_${this.responseId}`,
            tool_call_id: toolCallId,
            tool_name: toolName
          });
        } else if (thoughtSignature) {
          const buffer = this.toolCallBuffers.get(toolCallId);
          if (!buffer.signature) {
            buffer.signature = thoughtSignature;
            if (this.thoughtSignatureStorage) {
              this.thoughtSignatureStorage.set(toolCallId, thoughtSignature);
              if (process.env.DEBUG_GOOGLE) {
                console.error(`[DEBUG] Stream: Updated thought signature for tool ID: ${toolCallId}`);
              }
            }
          }
        }
        if (functionCall.args) {
          const argsJson = JSON.stringify(functionCall.args);
          const buffer = this.toolCallBuffers.get(toolCallId);
          if (argsJson !== buffer.args) {
            const delta = argsJson.slice(buffer.args.length);
            buffer.args = argsJson;
            if (delta) {
              events.push({
                type: "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */,
                response_id: this.responseId,
                item_id: `msg_${this.responseId}`,
                tool_call_id: toolCallId,
                tool_name: toolName,
                delta,
                sequence_number: this.sequenceNumber++
              });
            }
          }
        }
      }
    }
    return events;
  }
  /**
   * Generate unique response ID using cryptographically secure UUID
   */
  generateResponseId() {
    return `resp_google_${crypto2.randomUUID()}`;
  }
  /**
   * Check if the stream had tool calls
   * Used to determine when to clear thought signatures (must persist across tool execution)
   */
  hasToolCalls() {
    return this.hadToolCalls;
  }
  /**
   * Clear all internal state
   * Should be called after each stream completes to prevent memory leaks
   */
  clear() {
    this.responseId = "";
    this.model = "";
    this.sequenceNumber = 0;
    this.isFirst = true;
    this.toolCallBuffers.clear();
    this.hadToolCalls = false;
  }
  /**
   * Reset converter state for a new stream
   * Alias for clear()
   */
  reset() {
    this.clear();
  }
};

// src/infrastructure/providers/google/GoogleTextProvider.ts
var GoogleTextProvider = class extends BaseTextProvider {
  name = "google";
  capabilities = {
    text: true,
    images: true,
    // Gemini supports vision
    videos: false,
    audio: false
  };
  client;
  converter;
  streamConverter;
  constructor(config) {
    super(config);
    this.client = new genai.GoogleGenAI({
      apiKey: this.getApiKey(),
      // Pass custom baseURL for proxy support (e.g. when routing through EW proxy)
      ...config.baseURL ? { httpOptions: { baseUrl: config.baseURL } } : {}
    });
    this.converter = new GoogleConverter();
    this.streamConverter = new GoogleStreamConverter();
    this.streamConverter.setThoughtSignatureStorage(this.converter.getThoughtSignatureStorage());
    this.streamConverter.setToolCallMappingStorage(this.converter.getToolCallMappingStorage());
  }
  /**
   * Generate response using Google Gemini API
   */
  async generate(options) {
    return this.executeWithCircuitBreaker(async () => {
      try {
        const googleRequest = await this.converter.convertRequest(options);
        if (process.env.DEBUG_GOOGLE) {
          console.error("[DEBUG] Google Request:", JSON.stringify({
            model: options.model,
            tools: googleRequest.tools,
            toolConfig: googleRequest.toolConfig,
            generationConfig: googleRequest.generationConfig,
            contents: googleRequest.contents?.slice(0, 1)
            // First message only
          }, null, 2));
        }
        const result = await this.client.models.generateContent({
          model: options.model,
          contents: googleRequest.contents,
          config: {
            systemInstruction: googleRequest.systemInstruction,
            tools: googleRequest.tools,
            toolConfig: googleRequest.toolConfig,
            ...googleRequest.generationConfig
          }
        });
        if (process.env.DEBUG_GOOGLE) {
          console.error("[DEBUG] Google Response:", JSON.stringify({
            candidates: result.candidates?.map((c) => ({
              finishReason: c.finishReason,
              content: c.content
            })),
            usageMetadata: result.usageMetadata
          }, null, 2));
        }
        const response = this.converter.convertResponse(result);
        const firstOutput = response.output?.[0];
        const outputContent = firstOutput && "content" in firstOutput ? firstOutput.content : [];
        const hasToolCalls = this.converter.hasToolCalls(outputContent);
        if (!hasToolCalls) {
          this.converter.clearMappings();
        }
        return response;
      } catch (error) {
        this.converter.clearMappings();
        this.handleError(error, options.model);
        throw error;
      }
    }, options.model);
  }
  /**
   * Stream response using Google Gemini API
   */
  async *streamGenerate(options) {
    try {
      const googleRequest = await this.converter.convertRequest(options);
      const stream = await this.client.models.generateContentStream({
        model: options.model,
        contents: googleRequest.contents,
        config: {
          systemInstruction: googleRequest.systemInstruction,
          tools: googleRequest.tools,
          toolConfig: googleRequest.toolConfig,
          ...googleRequest.generationConfig
        }
      });
      this.streamConverter.reset();
      yield* this.streamConverter.convertStream(stream, options.model);
      if (!this.streamConverter.hasToolCalls()) {
        this.converter.clearMappings();
        this.streamConverter.clear();
      }
    } catch (error) {
      this.converter.clearMappings();
      this.streamConverter.clear();
      this.handleError(error, options.model);
      throw error;
    }
  }
  /**
   * Get model capabilities (registry-driven with Google vendor defaults)
   */
  getModelCapabilities(model) {
    return resolveModelCapabilities(model, {
      supportsTools: true,
      supportsVision: true,
      supportsJSON: true,
      supportsJSONSchema: false,
      maxTokens: 1048576,
      maxInputTokens: 1048576,
      maxOutputTokens: 65536
    });
  }
  /**
   * Handle Google-specific errors
   */
  handleError(error, model) {
    const errorMessage = error.message || "";
    if (error.status === 401 || errorMessage.includes("API key not valid")) {
      throw new ProviderAuthError("google", "Invalid API key");
    }
    if (error.status === 429 || errorMessage.includes("Resource exhausted")) {
      throw new ProviderRateLimitError("google");
    }
    if (errorMessage.includes("context length") || errorMessage.includes("too long")) {
      throw new ProviderContextLengthError("google", resolveMaxContextTokens(model, 1048576));
    }
    throw error;
  }
};
var VertexAITextProvider = class extends BaseTextProvider {
  name = "vertex-ai";
  capabilities = {
    text: true,
    images: true,
    videos: true,
    // Vertex AI supports video input
    audio: true
    // Vertex AI supports audio input
  };
  client;
  converter;
  config;
  constructor(config) {
    super(config);
    this.config = config;
    if (!config.projectId) {
      throw new InvalidConfigError("Vertex AI requires projectId");
    }
    if (!config.location) {
      throw new InvalidConfigError('Vertex AI requires location (e.g., "us-central1")');
    }
    process.env.GOOGLE_GENAI_USE_VERTEXAI = "True";
    process.env.GOOGLE_CLOUD_PROJECT = config.projectId;
    process.env.GOOGLE_CLOUD_LOCATION = config.location;
    if (config.credentials) ;
    this.client = new genai.GoogleGenAI({
      // No API key for Vertex AI - uses Application Default Credentials
    });
    this.converter = new GoogleConverter();
  }
  /**
   * Generate response using Vertex AI
   */
  async generate(options) {
    try {
      const googleRequest = await this.converter.convertRequest(options);
      const result = await this.client.models.generateContent({
        model: options.model,
        contents: googleRequest.contents,
        config: {
          systemInstruction: googleRequest.systemInstruction,
          tools: googleRequest.tools,
          toolConfig: googleRequest.toolConfig,
          ...googleRequest.generationConfig
        }
      });
      return this.converter.convertResponse(result);
    } catch (error) {
      this.handleError(error, options.model);
      throw error;
    }
  }
  /**
   * Stream response using Vertex AI
   */
  async *streamGenerate(options) {
    try {
      const googleRequest = await this.converter.convertRequest(options);
      const stream = await this.client.models.generateContentStream({
        model: options.model,
        contents: googleRequest.contents,
        config: {
          systemInstruction: googleRequest.systemInstruction,
          tools: googleRequest.tools,
          toolConfig: googleRequest.toolConfig,
          ...googleRequest.generationConfig
        }
      });
      const streamConverter = new GoogleStreamConverter();
      yield* streamConverter.convertStream(stream, options.model);
    } catch (error) {
      this.handleError(error, options.model);
      throw error;
    }
  }
  /**
   * Get model capabilities (registry-driven with Vertex AI vendor defaults)
   */
  getModelCapabilities(model) {
    return resolveModelCapabilities(model, {
      supportsTools: true,
      supportsVision: true,
      supportsJSON: true,
      supportsJSONSchema: false,
      maxTokens: 1048576,
      maxInputTokens: 1048576,
      maxOutputTokens: 65536
    });
  }
  /**
   * Handle Vertex AI-specific errors
   */
  handleError(error, model) {
    const errorMessage = error.message || "";
    if (error.status === 401 || error.status === 403 || errorMessage.includes("not authenticated") || errorMessage.includes("permission denied")) {
      throw new ProviderAuthError(
        "vertex-ai",
        "Authentication failed. Make sure you have set up Application Default Credentials or provided service account credentials."
      );
    }
    if (error.status === 429 || errorMessage.includes("Resource exhausted")) {
      throw new ProviderRateLimitError("vertex-ai");
    }
    if (errorMessage.includes("context length") || errorMessage.includes("too long")) {
      throw new ProviderContextLengthError("vertex-ai", resolveMaxContextTokens(model, 1048576));
    }
    throw error;
  }
};

// src/infrastructure/providers/generic/GenericOpenAIProvider.ts
var GenericOpenAIProvider = class extends OpenAITextProvider {
  name;
  capabilities;
  constructor(name, config, capabilities) {
    super(config);
    this.name = name;
    if (capabilities) {
      this.capabilities = {
        text: capabilities.text ?? true,
        images: capabilities.images ?? false,
        videos: capabilities.videos ?? false,
        audio: capabilities.audio ?? false
      };
    } else {
      this.capabilities = {
        text: true,
        images: false,
        // Conservative default
        videos: false,
        audio: false
      };
    }
  }
  /**
   * Override model capabilities for generic providers (registry-driven with conservative defaults)
   */
  getModelCapabilities(model) {
    return resolveModelCapabilities(model, {
      supportsTools: true,
      supportsVision: false,
      supportsJSON: true,
      supportsJSONSchema: false,
      maxTokens: 32e3,
      maxInputTokens: 32e3,
      maxOutputTokens: 4096
    });
  }
};

// src/core/createProvider.ts
var VENDOR_DEFAULT_URLS = (() => {
  const map = /* @__PURE__ */ new Map();
  try {
    map.set(Vendor.OpenAI, new OpenAI3__default.default({ apiKey: "_" }).baseURL);
  } catch {
  }
  try {
    map.set(Vendor.Anthropic, new Anthropic__default.default({ apiKey: "_" }).baseURL);
  } catch {
  }
  map.set(Vendor.Google, "https://generativelanguage.googleapis.com");
  map.set(Vendor.GoogleVertex, "https://us-central1-aiplatform.googleapis.com");
  map.set(Vendor.Groq, "https://api.groq.com/openai/v1");
  map.set(Vendor.Together, "https://api.together.xyz/v1");
  map.set(Vendor.Perplexity, "https://api.perplexity.ai");
  map.set(Vendor.Grok, "https://api.x.ai/v1");
  map.set(Vendor.DeepSeek, "https://api.deepseek.com/v1");
  map.set(Vendor.Mistral, "https://api.mistral.ai/v1");
  map.set(Vendor.Ollama, "http://localhost:11434/v1");
  return map;
})();
function getVendorDefaultBaseURL(vendor) {
  return VENDOR_DEFAULT_URLS.get(vendor);
}
function createProvider(connector) {
  const injectedProvider = connector.getOptions().provider;
  if (injectedProvider && typeof injectedProvider.generate === "function") {
    return injectedProvider;
  }
  const vendor = connector.vendor;
  if (!vendor) {
    throw new Error(
      `Connector '${connector.name}' has no vendor specified. Set vendor to create an AI provider.`
    );
  }
  const config = extractProviderConfig(connector);
  switch (vendor) {
    case Vendor.OpenAI:
      return new OpenAITextProvider({
        ...config,
        organization: connector.getOptions().organization,
        project: connector.getOptions().project
      });
    case Vendor.Anthropic:
      return new AnthropicTextProvider({
        ...config,
        anthropicVersion: connector.getOptions().anthropicVersion
      });
    case Vendor.Google:
      return new GoogleTextProvider(config);
    case Vendor.GoogleVertex:
      return new VertexAITextProvider({
        ...config,
        projectId: connector.getOptions().projectId || "",
        location: connector.getOptions().location || "us-central1"
      });
    // OpenAI-compatible providers (use connector.name for unique identification)
    case Vendor.Groq:
    case Vendor.Together:
    case Vendor.Perplexity:
    case Vendor.Grok:
    case Vendor.DeepSeek:
    case Vendor.Mistral:
    case Vendor.Ollama:
      return new GenericOpenAIProvider(connector.name, {
        ...config,
        baseURL: config.baseURL || getVendorDefaultBaseURL(vendor)
      });
    case Vendor.Custom:
      if (!config.baseURL) {
        throw new Error(
          `Connector '${connector.name}' with Custom vendor requires baseURL`
        );
      }
      return new GenericOpenAIProvider(connector.name, {
        ...config,
        baseURL: config.baseURL
      });
    default:
      throw new Error(`Unknown vendor: ${vendor}`);
  }
}
function extractProviderConfig(connector) {
  const auth2 = connector.config.auth;
  let apiKey;
  if (auth2.type === "api_key") {
    apiKey = auth2.apiKey;
  } else if (auth2.type === "none") {
    apiKey = "mock-key";
  } else if (auth2.type === "oauth") {
    throw new Error(
      `Connector '${connector.name}' uses OAuth. Call connector.getToken() to get the access token first.`
    );
  } else if (auth2.type === "jwt") {
    throw new Error(
      `Connector '${connector.name}' uses JWT auth. JWT auth for AI providers is not yet supported.`
    );
  } else {
    throw new Error(`Unknown auth type for connector '${connector.name}'`);
  }
  return {
    apiKey,
    baseURL: connector.config.baseURL,
    timeout: connector.getOptions().timeout,
    maxRetries: connector.getOptions().maxRetries
  };
}

// src/core/BaseAgent.ts
var BaseAgent = class extends eventemitter3.EventEmitter {
  // ===== Core Properties =====
  name;
  connector;
  model;
  // ===== Protected State =====
  _config;
  _agentContext;
  // SINGLE SOURCE OF TRUTH for tools and sessions
  _permissionManager;
  _ownsContext = true;
  _isDestroyed = false;
  _cleanupCallbacks = [];
  _logger;
  _lifecycleHooks;
  // Session state
  _sessionConfig = null;
  _autoSaveInterval = null;
  _pendingSessionLoad = null;
  /** Whether caller provided explicit instructions/systemPrompt (takes precedence over saved session) */
  _hasExplicitInstructions = false;
  // Provider for LLM calls - single instance shared by all methods
  _provider;
  // ===== Constructor =====
  constructor(config, loggerComponent) {
    super();
    this._config = config;
    this.connector = this.resolveConnector(config.connector);
    this.name = config.name ?? `${this.getAgentType()}-${Date.now()}`;
    this.model = config.model;
    this._logger = exports.logger.child({
      component: loggerComponent,
      agentName: this.name,
      model: this.model,
      connector: this.connector.name
    });
    this._agentContext = this.initializeAgentContext(config);
    if (config.tools) {
      for (const tool of config.tools) {
        this._agentContext.tools.register(tool);
      }
    }
    this._permissionManager = this.initializePermissionManager(config.permissions, config.tools);
    this._lifecycleHooks = config.lifecycleHooks ?? {};
    this._provider = createProvider(this.connector);
  }
  // ===== Protected Initialization Helpers =====
  /**
   * Resolve connector from string name or instance
   */
  resolveConnector(ref) {
    if (typeof ref === "string") {
      return this._config.registry ? this._config.registry.get(ref) : exports.Connector.get(ref);
    }
    return ref;
  }
  /**
   * Initialize AgentContextNextGen (single source of truth for tools and sessions).
   * If AgentContextNextGen is provided, use it directly.
   * Otherwise, create a new one with the provided configuration.
   */
  initializeAgentContext(config) {
    if (config.context instanceof AgentContextNextGen) {
      this._ownsContext = false;
      return config.context;
    }
    this._ownsContext = true;
    const contextConfig = {
      model: config.model,
      agentId: config.name,
      userId: config.userId,
      connectors: config.connectors,
      // Include storage and sessionId if session config is provided
      storage: config.session?.storage,
      // Thread tool execution timeout to ToolManager
      toolExecutionTimeout: config.toolExecutionTimeout,
      // Subclasses can add systemPrompt via their config
      // Note: context-level toolExecutionTimeout overrides agent-level if both set
      ...typeof config.context === "object" && config.context !== null ? config.context : {}
    };
    return AgentContextNextGen.create(contextConfig);
  }
  /**
   * Initialize permission manager
   */
  initializePermissionManager(config, tools) {
    const manager = new ToolPermissionManager(config);
    if (tools) {
      for (const tool of tools) {
        if (tool.permission) {
          manager.setToolConfig(tool.definition.function.name, tool.permission);
        }
      }
    }
    return manager;
  }
  /**
   * Initialize session management (call from subclass constructor after other setup)
   * Now uses AgentContext.save()/load() for persistence.
   */
  initializeSession(sessionConfig) {
    if (!sessionConfig) {
      return;
    }
    this._sessionConfig = sessionConfig;
    if (sessionConfig.id) {
      this._pendingSessionLoad = this.loadSession(sessionConfig.id);
    }
    if (sessionConfig.autoSave) {
      const interval = sessionConfig.autoSaveIntervalMs ?? 3e4;
      this._autoSaveInterval = setInterval(async () => {
        try {
          if (this._agentContext.sessionId) {
            await this._agentContext.save();
            this._logger.debug({ sessionId: this._agentContext.sessionId }, "Auto-saved session");
          }
        } catch (error) {
          this._logger.error({ error: error.message }, "Auto-save failed");
        }
      }, interval);
    }
  }
  /**
   * Ensure any pending session load is complete
   */
  async ensureSessionLoaded() {
    if (this._pendingSessionLoad) {
      await this._pendingSessionLoad;
      this._pendingSessionLoad = null;
    }
  }
  // ===== Public Session API =====
  /**
   * Get the current session ID (if session is enabled)
   * Delegates to AgentContext.
   */
  getSessionId() {
    return this._agentContext.sessionId;
  }
  /**
   * Check if this agent has session support enabled
   */
  hasSession() {
    return this._agentContext.storage !== null;
  }
  /**
   * Save the current session to storage.
   * Uses getContextState() to get state, allowing subclasses to inject agent-level state.
   *
   * @param sessionId - Optional session ID (uses current or generates new)
   * @param metadata - Optional session metadata
   * @throws Error if storage is not configured
   */
  async saveSession(sessionId, metadata) {
    await this.ensureSessionLoaded();
    const state = await this.getContextState();
    await this._agentContext.save(sessionId, metadata, state);
    this._logger.debug({ sessionId: this._agentContext.sessionId }, "Session saved");
    this.emit("session:saved", { sessionId: this._agentContext.sessionId });
  }
  /**
   * Load a session from storage.
   * Uses restoreContextState() to restore state, allowing subclasses to restore agent-level state.
   *
   * @param sessionId - Session ID to load
   * @returns true if session was found and loaded, false if not found
   * @throws Error if storage is not configured
   */
  async loadSession(sessionId) {
    const result = await this._agentContext.loadRaw(sessionId);
    if (!result) {
      this._logger.warn({ sessionId }, "Session not found");
      return false;
    }
    await this.restoreContextState(result.state);
    this._logger.info({ sessionId }, "Session loaded");
    this.emit("session:loaded", { sessionId });
    return true;
  }
  /**
   * Check if a session exists in storage.
   * Delegates to AgentContext.sessionExists().
   */
  async sessionExists(sessionId) {
    return this._agentContext.sessionExists(sessionId);
  }
  /**
   * Delete a session from storage.
   * Delegates to AgentContext.deleteSession().
   */
  async deleteSession(sessionId) {
    await this._agentContext.deleteSession(sessionId);
    this._logger.debug({ sessionId }, "Session deleted");
  }
  /**
   * Get context state for session persistence.
   * Override in subclasses to include agent-specific state in agentState field.
   */
  async getContextState() {
    return this._agentContext.getState();
  }
  /**
   * Restore context from saved state.
   * Override in subclasses to restore agent-specific state from agentState field.
   * Preserves explicit instructions if caller provided them at construction time.
   */
  async restoreContextState(state) {
    const explicitPrompt = this._hasExplicitInstructions ? this._agentContext.systemPrompt : void 0;
    this._agentContext.restoreState(state);
    if (this._hasExplicitInstructions && explicitPrompt !== void 0) {
      this._agentContext.systemPrompt = explicitPrompt;
    }
  }
  // ===== Public Permission API =====
  /**
   * Advanced tool management. Returns ToolManager for fine-grained control.
   * This is delegated to AgentContextNextGen.tools (single source of truth).
   */
  get tools() {
    return this._agentContext.tools;
  }
  /**
   * Get the AgentContextNextGen (unified context management).
   * This is the primary way to access tools, memory, and history.
   */
  get context() {
    return this._agentContext;
  }
  /**
   * Get the current user ID. Delegates to AgentContextNextGen.
   */
  get userId() {
    return this._agentContext.userId;
  }
  /**
   * Set user ID at runtime. Automatically updates ToolContext for all tool executions.
   */
  set userId(value) {
    this._agentContext.userId = value;
  }
  /**
   * Get the allowed connector names (undefined = all visible connectors).
   */
  get connectors() {
    return this._agentContext.connectors;
  }
  /**
   * Restrict this agent to a subset of connectors. Updates ToolContext.connectorRegistry.
   */
  set connectors(value) {
    this._agentContext.connectors = value;
  }
  /**
   * Permission management. Returns ToolPermissionManager for approval control.
   */
  get permissions() {
    return this._permissionManager;
  }
  // ===== Tool Management =====
  /**
   * Add a tool to the agent.
   * Tools are registered with AgentContext (single source of truth).
   */
  addTool(tool) {
    this._agentContext.tools.register(tool);
    if (tool.permission) {
      this._permissionManager.setToolConfig(tool.definition.function.name, tool.permission);
    }
  }
  /**
   * Remove a tool from the agent.
   * Tools are unregistered from AgentContext (single source of truth).
   */
  removeTool(toolName) {
    this._agentContext.tools.unregister(toolName);
  }
  /**
   * List registered tools (returns enabled tool names)
   */
  listTools() {
    return this._agentContext.tools.listEnabled();
  }
  /**
   * Replace all tools with a new array
   */
  setTools(tools) {
    this._agentContext.tools.clear();
    for (const tool of tools) {
      this._agentContext.tools.register(tool);
      if (tool.permission) {
        this._permissionManager.setToolConfig(tool.definition.function.name, tool.permission);
      }
    }
  }
  /**
   * Get enabled tool definitions (for passing to LLM).
   * This is a helper that extracts definitions from enabled tools.
   *
   * If a tool has a `descriptionFactory`, it's called to generate a dynamic description
   * that reflects current state (e.g., available connectors). This ensures the LLM
   * always sees up-to-date tool descriptions.
   */
  getEnabledToolDefinitions() {
    const toolContext = this._agentContext.tools.getToolContext();
    return this._agentContext.tools.getEnabled().map((tool) => {
      if (tool.descriptionFactory) {
        const dynamicDescription = tool.descriptionFactory(toolContext);
        return {
          ...tool.definition,
          function: {
            ...tool.definition.function,
            description: dynamicDescription
          }
        };
      }
      return tool.definition;
    });
  }
  // ===== Direct LLM Access (Bypasses AgentContext) =====
  /**
   * Get the provider for LLM calls.
   * Returns the single shared provider instance.
   */
  getProvider() {
    return this._provider;
  }
  /**
   * Make a direct LLM call bypassing all context management.
   *
   * This method:
   * - Does NOT track messages in history
   * - Does NOT use AgentContext features (memory, cache, etc.)
   * - Does NOT prepare context or run compaction
   * - Does NOT go through the agentic loop (no tool execution)
   *
   * Use this for simple, stateless interactions where you want raw LLM access
   * without the overhead of context management.
   *
   * @param input - Text string or array of InputItems (supports multimodal: text + images)
   * @param options - Optional configuration for the call
   * @returns Raw LLM response
   *
   * @example
   * ```typescript
   * // Simple text call
   * const response = await agent.runDirect('What is 2 + 2?');
   * console.log(response.output_text);
   *
   * // With options
   * const response = await agent.runDirect('Summarize this', {
   *   instructions: 'Be concise',
   *   temperature: 0.5,
   * });
   *
   * // Multimodal (text + image)
   * const response = await agent.runDirect([
   *   { type: 'message', role: 'user', content: [
   *     { type: 'input_text', text: 'What is in this image?' },
   *     { type: 'input_image', image_url: 'https://...' }
   *   ]}
   * ]);
   *
   * // With tools (single call, no loop)
   * const response = await agent.runDirect('Get the weather', {
   *   includeTools: true,
   * });
   * // Note: If the LLM returns a tool call, you must handle it yourself
   * ```
   */
  async runDirect(input, options = {}) {
    if (this._isDestroyed) {
      throw new Error("Agent has been destroyed");
    }
    const provider = this.getProvider();
    const generateOptions = {
      model: this.model,
      input,
      instructions: options.instructions,
      tools: options.includeTools ? this.getEnabledToolDefinitions() : void 0,
      temperature: options.temperature,
      max_output_tokens: options.maxOutputTokens,
      response_format: options.responseFormat,
      vendorOptions: options.vendorOptions
    };
    this._logger.debug({ inputType: typeof input }, "runDirect called");
    try {
      const response = await provider.generate(generateOptions);
      this._logger.debug({ outputLength: response.output_text?.length }, "runDirect completed");
      return response;
    } catch (error) {
      this._logger.error({ error: error.message }, "runDirect failed");
      throw error;
    }
  }
  /**
   * Stream a direct LLM call bypassing all context management.
   *
   * Same as runDirect but returns a stream of events instead of waiting
   * for the complete response. Useful for real-time output display.
   *
   * @param input - Text string or array of InputItems (supports multimodal)
   * @param options - Optional configuration for the call
   * @returns Async iterator of stream events
   *
   * @example
   * ```typescript
   * for await (const event of agent.streamDirect('Tell me a story')) {
   *   if (event.type === 'output_text_delta') {
   *     process.stdout.write(event.delta);
   *   }
   * }
   * ```
   */
  async *streamDirect(input, options = {}) {
    if (this._isDestroyed) {
      throw new Error("Agent has been destroyed");
    }
    const provider = this.getProvider();
    const generateOptions = {
      model: this.model,
      input,
      instructions: options.instructions,
      tools: options.includeTools ? this.getEnabledToolDefinitions() : void 0,
      temperature: options.temperature,
      max_output_tokens: options.maxOutputTokens,
      response_format: options.responseFormat,
      vendorOptions: options.vendorOptions
    };
    this._logger.debug({ inputType: typeof input }, "streamDirect called");
    try {
      yield* provider.streamGenerate(generateOptions);
      this._logger.debug("streamDirect completed");
    } catch (error) {
      this._logger.error({ error: error.message }, "streamDirect failed");
      throw error;
    }
  }
  // ===== Lifecycle Hooks =====
  /**
   * Get the current lifecycle hooks configuration
   */
  get lifecycleHooks() {
    return this._lifecycleHooks;
  }
  /**
   * Set or update lifecycle hooks at runtime
   */
  setLifecycleHooks(hooks) {
    this._lifecycleHooks = { ...this._lifecycleHooks, ...hooks };
  }
  /**
   * Invoke beforeToolExecution hook if defined.
   * Call this before executing a tool.
   *
   * @throws Error if hook throws (prevents tool execution)
   */
  async invokeBeforeToolExecution(context) {
    if (this._lifecycleHooks.beforeToolExecution) {
      try {
        await this._lifecycleHooks.beforeToolExecution(context);
      } catch (error) {
        this._logger.error(
          { error: error.message, toolName: context.toolName },
          "beforeToolExecution hook failed"
        );
        throw error;
      }
    }
  }
  /**
   * Invoke afterToolExecution hook if defined.
   * Call this after tool execution completes (success or failure).
   */
  async invokeAfterToolExecution(result) {
    if (this._lifecycleHooks.afterToolExecution) {
      try {
        await this._lifecycleHooks.afterToolExecution(result);
      } catch (error) {
        this._logger.error(
          { error: error.message, toolName: result.toolName },
          "afterToolExecution hook failed"
        );
      }
    }
  }
  /**
   * Invoke beforeContextPrepare hook if defined.
   * Call this before preparing context for LLM.
   */
  async invokeBeforeContextPrepare() {
    if (this._lifecycleHooks.beforeContextPrepare) {
      try {
        await this._lifecycleHooks.beforeContextPrepare(this.name);
      } catch (error) {
        this._logger.error(
          { error: error.message },
          "beforeContextPrepare hook failed"
        );
      }
    }
  }
  /**
   * Invoke beforeCompaction hook if defined.
   * Call this before context compaction occurs.
   * Gives the agent a chance to save important data to memory.
   */
  async invokeBeforeCompaction(context) {
    if (this._lifecycleHooks.beforeCompaction) {
      try {
        await this._lifecycleHooks.beforeCompaction(context);
      } catch (error) {
        this._logger.error(
          {
            error: error.message,
            strategy: context.strategy,
            estimatedTokensToFree: context.estimatedTokensToFree
          },
          "beforeCompaction hook failed"
        );
      }
    }
  }
  /**
   * Invoke afterCompaction hook if defined.
   * Call this after context compaction occurs.
   */
  async invokeAfterCompaction(log, tokensFreed) {
    if (this._lifecycleHooks.afterCompaction) {
      try {
        await this._lifecycleHooks.afterCompaction(log, tokensFreed);
      } catch (error) {
        this._logger.error(
          { error: error.message, tokensFreed },
          "afterCompaction hook failed"
        );
      }
    }
  }
  /**
   * Invoke onError hook if defined.
   * Call this when the agent encounters an error.
   */
  async invokeOnError(error, phase) {
    if (this._lifecycleHooks.onError) {
      try {
        await this._lifecycleHooks.onError(error, { phase, agentId: this.name });
      } catch (hookError) {
        this._logger.error(
          { error: hookError.message, originalError: error.message, phase },
          "onError hook failed"
        );
      }
    }
  }
  // ===== Lifecycle =====
  get isDestroyed() {
    return this._isDestroyed;
  }
  /**
   * Register a cleanup callback
   */
  onCleanup(callback) {
    this._cleanupCallbacks.push(callback);
  }
  /**
   * Base cleanup for session and listeners.
   * Subclasses should call super.baseDestroy() in their destroy() method.
   */
  baseDestroy() {
    if (this._isDestroyed) {
      return;
    }
    this._isDestroyed = true;
    this._logger.debug("Agent destroy started");
    if (this._autoSaveInterval) {
      clearInterval(this._autoSaveInterval);
      this._autoSaveInterval = null;
    }
    if (this._ownsContext) {
      this._agentContext.destroy();
    }
    this._permissionManager.removeAllListeners();
    this.removeAllListeners();
  }
  /**
   * Run cleanup callbacks
   */
  async runCleanupCallbacks() {
    for (const callback of this._cleanupCallbacks) {
      try {
        await callback();
      } catch (error) {
        this._logger.error({ error: error.message }, "Cleanup callback error");
      }
    }
    this._cleanupCallbacks = [];
  }
};

// src/domain/entities/Tool.ts
var ToolCallState = /* @__PURE__ */ ((ToolCallState2) => {
  ToolCallState2["PENDING"] = "pending";
  ToolCallState2["EXECUTING"] = "executing";
  ToolCallState2["COMPLETED"] = "completed";
  ToolCallState2["FAILED"] = "failed";
  ToolCallState2["TIMEOUT"] = "timeout";
  return ToolCallState2;
})(ToolCallState || {});
function defaultDescribeCall(args, maxLength = 60) {
  if (!args || typeof args !== "object") {
    return "";
  }
  const priorityKeys = [
    "file_path",
    "path",
    "command",
    "query",
    "pattern",
    "url",
    "key",
    "name",
    "message",
    "content",
    "expression",
    "prompt"
  ];
  for (const key of priorityKeys) {
    if (key in args && args[key] != null) {
      const value = args[key];
      const str = typeof value === "string" ? value : JSON.stringify(value);
      return str.length > maxLength ? str.slice(0, maxLength - 3) + "..." : str;
    }
  }
  for (const [, value] of Object.entries(args)) {
    if (typeof value === "string" && value.length > 0) {
      return value.length > maxLength ? value.slice(0, maxLength - 3) + "..." : value;
    }
  }
  const firstEntry = Object.entries(args)[0];
  if (firstEntry) {
    const [key, value] = firstEntry;
    const str = typeof value === "string" ? value : JSON.stringify(value);
    if (str.length > maxLength) {
      return `${key}=${str.slice(0, maxLength - key.length - 4)}...`;
    }
    return `${key}=${str}`;
  }
  return "";
}
function getToolCallDescription(tool, args) {
  if (tool.describeCall) {
    try {
      return tool.describeCall(args);
    } catch {
    }
  }
  return defaultDescribeCall(args);
}

// src/capabilities/agents/ExecutionContext.ts
var ExecutionContext = class {
  // Execution metadata
  executionId;
  startTime;
  iteration = 0;
  // Tool tracking
  toolCalls = /* @__PURE__ */ new Map();
  toolResults = /* @__PURE__ */ new Map();
  // Control state
  paused = false;
  pauseReason;
  cancelled = false;
  cancelReason;
  // User data (for hooks to share state)
  metadata = /* @__PURE__ */ new Map();
  // History storage (memory-safe)
  config;
  iterations = [];
  iterationSummaries = [];
  // Metrics
  metrics = {
    totalDuration: 0,
    llmDuration: 0,
    toolDuration: 0,
    hookDuration: 0,
    iterationCount: 0,
    toolCallCount: 0,
    toolSuccessCount: 0,
    toolFailureCount: 0,
    toolTimeoutCount: 0,
    inputTokens: 0,
    outputTokens: 0,
    totalTokens: 0,
    errors: []
  };
  // Audit trail
  auditTrail = [];
  constructor(executionId, config = {}) {
    this.executionId = executionId;
    this.startTime = /* @__PURE__ */ new Date();
    this.config = {
      maxHistorySize: config.maxHistorySize || 10,
      historyMode: config.historyMode || "summary",
      maxAuditTrailSize: config.maxAuditTrailSize || 1e3
    };
  }
  /**
   * Add iteration to history (memory-safe)
   */
  addIteration(record2) {
    switch (this.config.historyMode) {
      case "none":
        break;
      case "summary":
        this.iterationSummaries.push({
          iteration: record2.iteration,
          tokens: record2.response.usage.total_tokens,
          toolCount: record2.toolCalls.length,
          duration: record2.endTime.getTime() - record2.startTime.getTime(),
          timestamp: record2.startTime
        });
        if (this.iterationSummaries.length > this.config.maxHistorySize) {
          this.iterationSummaries.shift();
        }
        break;
      case "full":
        this.iterations.push(record2);
        if (this.iterations.length > this.config.maxHistorySize) {
          this.iterations.shift();
        }
        break;
    }
  }
  /**
   * Get iteration history
   */
  getHistory() {
    return this.config.historyMode === "full" ? this.iterations : this.iterationSummaries;
  }
  /**
   * Add audit entry
   */
  audit(type, details, hookName, toolName) {
    this.auditTrail.push({
      timestamp: /* @__PURE__ */ new Date(),
      type,
      hookName,
      toolName,
      details
    });
    if (this.auditTrail.length > this.config.maxAuditTrailSize) {
      this.auditTrail.shift();
    }
  }
  /**
   * Get audit trail
   */
  getAuditTrail() {
    return this.auditTrail;
  }
  /**
   * Update metrics
   */
  updateMetrics(update) {
    Object.assign(this.metrics, update);
  }
  /**
   * Add tool call to tracking
   */
  addToolCall(toolCall) {
    this.toolCalls.set(toolCall.id, toolCall);
    this.metrics.toolCallCount++;
  }
  /**
   * Add tool result to tracking
   */
  addToolResult(result) {
    this.toolResults.set(result.tool_use_id, result);
    if (result.state === "completed" /* COMPLETED */) {
      this.metrics.toolSuccessCount++;
    } else if (result.state === "failed" /* FAILED */) {
      this.metrics.toolFailureCount++;
    } else if (result.state === "timeout" /* TIMEOUT */) {
      this.metrics.toolTimeoutCount++;
    }
  }
  /**
   * Check resource limits
   */
  checkLimits(limits) {
    if (!limits) return;
    if (limits.maxExecutionTime) {
      const elapsed = Date.now() - this.startTime.getTime();
      if (elapsed > limits.maxExecutionTime) {
        throw new Error(
          `Execution time limit exceeded: ${elapsed}ms > ${limits.maxExecutionTime}ms`
        );
      }
    }
    if (limits.maxToolCalls && this.toolCalls.size > limits.maxToolCalls) {
      throw new Error(
        `Tool call limit exceeded: ${this.toolCalls.size} > ${limits.maxToolCalls}`
      );
    }
    if (limits.maxContextSize) {
      const size = this.estimateSize();
      if (size > limits.maxContextSize) {
        throw new Error(
          `Context size limit exceeded: ${size} bytes > ${limits.maxContextSize} bytes`
        );
      }
    }
  }
  /**
   * Estimate memory usage (rough approximation)
   */
  estimateSize() {
    try {
      const data = {
        toolCalls: Array.from(this.toolCalls.values()),
        toolResults: Array.from(this.toolResults.values()),
        iterations: this.config.historyMode === "full" ? this.iterations : this.iterationSummaries,
        auditTrail: this.auditTrail
      };
      return JSON.stringify(data).length;
    } catch {
      return 0;
    }
  }
  /**
   * Cleanup resources and release memory
   * Clears all internal arrays and maps to allow garbage collection
   */
  cleanup() {
    const summary = {
      executionId: this.executionId,
      totalIterations: this.iteration,
      totalToolCalls: this.metrics.toolCallCount,
      totalDuration: Date.now() - this.startTime.getTime(),
      success: !this.cancelled && this.metrics.errors.length === 0
    };
    this.toolCalls.clear();
    this.toolResults.clear();
    this.metadata.clear();
    this.iterations.length = 0;
    this.iterationSummaries.length = 0;
    this.auditTrail.length = 0;
    this.metrics.errors.length = 0;
    this.metadata.set("execution_summary", summary);
  }
  /**
   * Get execution summary
   */
  getSummary() {
    return {
      executionId: this.executionId,
      startTime: this.startTime,
      currentIteration: this.iteration,
      paused: this.paused,
      cancelled: this.cancelled,
      metrics: { ...this.metrics },
      totalDuration: Date.now() - this.startTime.getTime()
    };
  }
};

// src/capabilities/agents/HookManager.ts
var HookManager = class {
  hooks = /* @__PURE__ */ new Map();
  timeout;
  parallel;
  // Per-hook error tracking: hookKey -> consecutive error count
  hookErrorCounts = /* @__PURE__ */ new Map();
  // Disabled hooks that exceeded error threshold
  disabledHooks = /* @__PURE__ */ new Set();
  maxConsecutiveErrors = 3;
  emitter;
  constructor(config = {}, emitter, errorHandling) {
    this.timeout = config.hookTimeout || 5e3;
    this.parallel = config.parallelHooks || false;
    this.emitter = emitter;
    this.maxConsecutiveErrors = errorHandling?.maxConsecutiveErrors || 3;
    this.registerFromConfig(config);
  }
  /**
   * Register hooks from configuration
   */
  registerFromConfig(config) {
    const hookNames = [
      "before:execution",
      "after:execution",
      "before:llm",
      "after:llm",
      "before:tool",
      "after:tool",
      "approve:tool",
      "pause:check"
    ];
    for (const name of hookNames) {
      const hook = config[name];
      if (hook) {
        this.register(name, hook);
      }
    }
  }
  /**
   * Register a hook
   */
  register(name, hook) {
    if (typeof hook !== "function") {
      throw new Error(`Hook must be a function, got: ${typeof hook}`);
    }
    if (!this.hooks.has(name)) {
      this.hooks.set(name, []);
    }
    const existing = this.hooks.get(name);
    if (existing.length >= 10) {
      throw new Error(`Too many hooks for ${name} (max: 10)`);
    }
    existing.push(hook);
  }
  /**
   * Unregister a specific hook function by reference.
   * Returns true if the hook was found and removed.
   */
  unregister(name, hook) {
    const hooks = this.hooks.get(name);
    if (!hooks) return false;
    const index = hooks.indexOf(hook);
    if (index === -1) return false;
    hooks.splice(index, 1);
    return true;
  }
  /**
   * Execute hooks for a given name
   */
  async executeHooks(name, context, defaultResult) {
    const hooks = this.hooks.get(name);
    if (!hooks || hooks.length === 0) {
      return defaultResult;
    }
    if (this.parallel && hooks.length > 1) {
      return this.executeHooksParallel(hooks, context, defaultResult);
    }
    return this.executeHooksSequential(hooks, context, defaultResult);
  }
  /**
   * Execute hooks sequentially
   */
  async executeHooksSequential(hooks, context, defaultResult) {
    let result = defaultResult;
    for (let i = 0; i < hooks.length; i++) {
      const hook = hooks[i];
      const hookKey = this.getHookKey(hook, i);
      const hookResult = await this.executeHookSafely(hook, context, hookKey);
      if (hookResult === null) {
        continue;
      }
      result = { ...result, ...hookResult };
      if (hookResult.skip === true) {
        break;
      }
    }
    return result;
  }
  /**
   * Execute hooks in parallel
   */
  async executeHooksParallel(hooks, context, defaultResult) {
    const results = await Promise.all(
      hooks.map((hook, i) => {
        const hookKey = this.getHookKey(hook, i);
        return this.executeHookSafely(hook, context, hookKey);
      })
    );
    const validResults = results.filter((r) => r !== null);
    return validResults.reduce(
      (acc, hookResult) => ({ ...acc, ...hookResult }),
      defaultResult
    );
  }
  /**
   * Generate unique key for a hook
   */
  getHookKey(hook, index) {
    return `${hook.name || "anonymous"}_${index}`;
  }
  /**
   * Execute single hook with error isolation and timeout (with per-hook error tracking)
   */
  async executeHookSafely(hook, context, hookKey) {
    const key = hookKey || hook.name || "anonymous";
    if (this.disabledHooks.has(key)) {
      return null;
    }
    const startTime = Date.now();
    try {
      const result = await Promise.race([
        hook(context),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("Hook timeout")), this.timeout)
        )
      ]);
      this.hookErrorCounts.delete(key);
      const duration = Date.now() - startTime;
      if (context.context?.updateMetrics) {
        context.context.updateMetrics({
          hookDuration: (context.context.metrics.hookDuration || 0) + duration
        });
      }
      return result;
    } catch (error) {
      const errorCount = (this.hookErrorCounts.get(key) || 0) + 1;
      this.hookErrorCounts.set(key, errorCount);
      this.emitter.emit("hook:error", {
        executionId: context.executionId,
        hookName: hook.name || "anonymous",
        error,
        consecutiveErrors: errorCount,
        timestamp: /* @__PURE__ */ new Date()
      });
      if (errorCount >= this.maxConsecutiveErrors) {
        this.disabledHooks.add(key);
        console.warn(
          `Hook "${key}" disabled after ${errorCount} consecutive failures. Last error: ${error.message}`
        );
      } else {
        console.warn(
          `Hook execution failed (${key}): ${error.message} (${errorCount}/${this.maxConsecutiveErrors} errors)`
        );
      }
      return null;
    }
  }
  /**
   * Check if there are any hooks registered
   */
  hasHooks(name) {
    const hooks = this.hooks.get(name);
    return !!hooks && hooks.length > 0;
  }
  /**
   * Get hook count
   */
  getHookCount(name) {
    if (name) {
      return this.hooks.get(name)?.length || 0;
    }
    return Array.from(this.hooks.values()).reduce((sum, arr) => sum + arr.length, 0);
  }
  /**
   * Clear all hooks and reset error tracking
   */
  clear() {
    this.hooks.clear();
    this.hookErrorCounts.clear();
    this.disabledHooks.clear();
  }
  /**
   * Re-enable a disabled hook
   */
  enableHook(hookKey) {
    this.disabledHooks.delete(hookKey);
    this.hookErrorCounts.delete(hookKey);
  }
  /**
   * Get list of disabled hooks
   */
  getDisabledHooks() {
    return Array.from(this.disabledHooks);
  }
};

// src/domain/entities/StreamState.ts
var StreamState = class {
  // Core identifiers
  responseId;
  model;
  createdAt;
  // Text accumulation: item_id -> text chunks
  textBuffers;
  // Tool call accumulation: tool_call_id -> buffer
  toolCallBuffers;
  // Completed tool calls
  completedToolCalls;
  // Tool execution results
  toolResults;
  // Metadata
  currentIteration;
  usage;
  status;
  startTime;
  endTime;
  // Statistics
  totalChunks;
  totalTextDeltas;
  totalToolCalls;
  constructor(responseId, model, createdAt) {
    this.responseId = responseId;
    this.model = model;
    this.createdAt = createdAt || Date.now();
    this.textBuffers = /* @__PURE__ */ new Map();
    this.toolCallBuffers = /* @__PURE__ */ new Map();
    this.completedToolCalls = [];
    this.toolResults = /* @__PURE__ */ new Map();
    this.currentIteration = 0;
    this.usage = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    };
    this.status = "in_progress";
    this.startTime = /* @__PURE__ */ new Date();
    this.totalChunks = 0;
    this.totalTextDeltas = 0;
    this.totalToolCalls = 0;
  }
  /**
   * Accumulate text delta for a specific item
   */
  accumulateTextDelta(itemId, delta) {
    if (!this.textBuffers.has(itemId)) {
      this.textBuffers.set(itemId, []);
    }
    this.textBuffers.get(itemId).push(delta);
    this.totalTextDeltas++;
    this.totalChunks++;
  }
  /**
   * Get complete accumulated text for an item
   */
  getCompleteText(itemId) {
    const chunks = this.textBuffers.get(itemId);
    return chunks ? chunks.join("") : "";
  }
  /**
   * Get all accumulated text (all items concatenated)
   */
  getAllText() {
    const allText = [];
    for (const chunks of this.textBuffers.values()) {
      allText.push(chunks.join(""));
    }
    return allText.join("");
  }
  /**
   * Start accumulating tool call arguments
   */
  startToolCall(toolCallId, toolName) {
    this.toolCallBuffers.set(toolCallId, {
      toolName,
      argumentChunks: [],
      isComplete: false,
      startTime: /* @__PURE__ */ new Date()
    });
  }
  /**
   * Accumulate tool argument delta
   */
  accumulateToolArguments(toolCallId, delta) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    if (!buffer) {
      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);
    }
    buffer.argumentChunks.push(delta);
    this.totalChunks++;
  }
  /**
   * Mark tool call arguments as complete
   */
  completeToolCall(toolCallId) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    if (!buffer) {
      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);
    }
    buffer.isComplete = true;
    this.totalToolCalls++;
  }
  /**
   * Get complete tool arguments (joined chunks)
   */
  getCompleteToolArguments(toolCallId) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    if (!buffer) {
      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);
    }
    return buffer.argumentChunks.join("");
  }
  /**
   * Check if tool call is complete
   */
  isToolCallComplete(toolCallId) {
    const buffer = this.toolCallBuffers.get(toolCallId);
    return buffer ? buffer.isComplete : false;
  }
  /**
   * Get tool name for a tool call
   */
  getToolName(toolCallId) {
    return this.toolCallBuffers.get(toolCallId)?.toolName;
  }
  /**
   * Add completed tool call
   */
  addCompletedToolCall(toolCall) {
    this.completedToolCalls.push(toolCall);
  }
  /**
   * Get all completed tool calls
   */
  getCompletedToolCalls() {
    return [...this.completedToolCalls];
  }
  /**
   * Store tool execution result
   */
  setToolResult(toolCallId, result) {
    this.toolResults.set(toolCallId, result);
  }
  /**
   * Get tool execution result
   */
  getToolResult(toolCallId) {
    return this.toolResults.get(toolCallId);
  }
  /**
   * Update token usage (replaces values, doesn't accumulate)
   */
  updateUsage(usage) {
    if (usage.input_tokens !== void 0) {
      this.usage.input_tokens = usage.input_tokens;
    }
    if (usage.output_tokens !== void 0) {
      this.usage.output_tokens = usage.output_tokens;
    }
    if (usage.total_tokens !== void 0) {
      this.usage.total_tokens = usage.total_tokens;
    } else {
      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;
    }
  }
  /**
   * Accumulate token usage (adds to existing values)
   */
  accumulateUsage(usage) {
    if (usage.input_tokens !== void 0) {
      this.usage.input_tokens += usage.input_tokens;
    }
    if (usage.output_tokens !== void 0) {
      this.usage.output_tokens += usage.output_tokens;
    }
    if (usage.total_tokens !== void 0) {
      this.usage.total_tokens += usage.total_tokens;
    } else {
      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;
    }
  }
  /**
   * Mark stream as complete
   */
  markComplete(status = "completed") {
    this.status = status;
    this.endTime = /* @__PURE__ */ new Date();
  }
  /**
   * Get duration in milliseconds
   */
  getDuration() {
    const end = this.endTime || /* @__PURE__ */ new Date();
    return end.getTime() - this.startTime.getTime();
  }
  /**
   * Increment iteration counter
   */
  incrementIteration() {
    this.currentIteration++;
  }
  /**
   * Get summary statistics
   */
  getStatistics() {
    return {
      responseId: this.responseId,
      model: this.model,
      status: this.status,
      iterations: this.currentIteration,
      totalChunks: this.totalChunks,
      totalTextDeltas: this.totalTextDeltas,
      totalToolCalls: this.totalToolCalls,
      textItemsCount: this.textBuffers.size,
      toolCallBuffersCount: this.toolCallBuffers.size,
      completedToolCallsCount: this.completedToolCalls.length,
      durationMs: this.getDuration(),
      usage: { ...this.usage }
    };
  }
  /**
   * Check if stream has any accumulated text
   */
  hasText() {
    return this.textBuffers.size > 0;
  }
  /**
   * Check if stream has any tool calls
   */
  hasToolCalls() {
    return this.toolCallBuffers.size > 0;
  }
  /**
   * Clear all buffers (for memory management)
   */
  clear() {
    this.textBuffers.clear();
    this.toolCallBuffers.clear();
    this.completedToolCalls = [];
    this.toolResults.clear();
  }
  /**
   * Create a snapshot for checkpointing (error recovery)
   */
  createSnapshot() {
    return {
      responseId: this.responseId,
      model: this.model,
      createdAt: this.createdAt,
      textBuffers: new Map(this.textBuffers),
      toolCallBuffers: new Map(this.toolCallBuffers),
      completedToolCalls: [...this.completedToolCalls],
      toolResults: new Map(this.toolResults),
      currentIteration: this.currentIteration,
      usage: { ...this.usage },
      status: this.status,
      startTime: this.startTime,
      endTime: this.endTime
    };
  }
};

// src/domain/interfaces/IDisposable.ts
function assertNotDestroyed(obj, operation) {
  if (obj.isDestroyed) {
    throw new Error(`Cannot ${operation}: instance has been destroyed`);
  }
}

// src/core/Agent.ts
init_Metrics();
init_constants();
init_StorageRegistry();
var Agent = class _Agent extends BaseAgent {
  // ===== Agent-specific State =====
  hookManager;
  executionContext = null;
  // Pause/resume/cancel state
  _paused = false;
  _cancelled = false;
  _pausePromise = null;
  _resumeCallback = null;
  _pauseResumeMutex = Promise.resolve();
  // ===== Static Factory =====
  /**
   * Create a new agent
   *
   * @example
   * ```typescript
   * const agent = Agent.create({
   *   connector: 'openai',  // or Connector instance
   *   model: 'gpt-4',
   *   userId: 'user-123',   // flows to all tool executions automatically
   *   instructions: 'You are a helpful assistant',
   *   tools: [myTool]
   * });
   * ```
   */
  static create(config) {
    return new _Agent(config);
  }
  /**
   * Resume an agent from a saved session
   *
   * @example
   * ```typescript
   * const agent = await Agent.resume('session-123', {
   *   connector: 'openai',
   *   model: 'gpt-4',
   *   session: { storage: myStorage }
   * });
   * ```
   */
  static async resume(sessionId, config) {
    const agent = new _Agent({
      ...config,
      session: {
        ...config.session,
        id: sessionId
      }
    });
    await agent.ensureSessionLoaded();
    return agent;
  }
  /**
   * Create an agent from a stored definition
   *
   * Loads agent configuration from storage and creates a new Agent instance.
   * The connector must be registered at runtime before calling this method.
   *
   * @param agentId - Agent identifier to load
   * @param storage - Storage backend to load from
   * @param overrides - Optional config overrides
   * @returns Agent instance, or null if not found
   */
  static async fromStorage(agentId, storage, overrides) {
    const s = storage ?? exports.StorageRegistry.get("agentDefinitions");
    if (!s) {
      throw new Error("No storage provided and no agentDefinitions configured in StorageRegistry");
    }
    const definition = await s.load(agentId);
    if (!definition) {
      return null;
    }
    const contextConfig = {
      model: definition.connector.model,
      agentId: definition.agentId,
      systemPrompt: definition.systemPrompt ?? definition.instructions
    };
    if (definition.features) {
      contextConfig.features = definition.features;
    }
    const config = {
      connector: definition.connector.name,
      model: definition.connector.model,
      instructions: definition.systemPrompt,
      context: contextConfig,
      ...definition.typeConfig,
      ...overrides
    };
    return new _Agent(config);
  }
  // ===== Constructor =====
  constructor(config) {
    super(config, "Agent");
    this._logger.debug({ model: this.model, connector: this.connector.name }, "Agent created");
    exports.metrics.increment("agent.created", 1, {
      model: this.model,
      connector: this.connector.name
    });
    if (config.instructions) {
      this._agentContext.systemPrompt = config.instructions;
      this._hasExplicitInstructions = true;
    }
    this._agentContext.tools.on("tool:registered", ({ name }) => {
      const permission = this._agentContext.tools.getPermission(name);
      if (permission) {
        this._permissionManager.setToolConfig(name, permission);
      }
    });
    this.hookManager = new HookManager(
      config.hooks || {},
      this,
      config.errorHandling
    );
    this._agentContext.setBeforeCompactionCallback(async (info) => {
      const status = info.budget.utilizationPercent >= 90 ? "critical" : info.budget.utilizationPercent >= 70 ? "warning" : "ok";
      const components = [];
      for (const plugin of this._agentContext.getPlugins()) {
        const order = {
          "in_context_memory": 1,
          "working_memory": 2
        };
        components.push({
          name: plugin.name,
          priority: order[plugin.name] ?? 10,
          compactable: plugin.isCompactable()
        });
      }
      await this.invokeBeforeCompaction({
        agentId: this.name,
        currentBudget: {
          total: info.budget.maxTokens,
          used: info.budget.totalUsed,
          available: info.budget.available,
          utilizationPercent: info.budget.utilizationPercent,
          status
        },
        strategy: info.strategy,
        components,
        estimatedTokensToFree: info.targetTokensToFree
      });
    });
    this.initializeSession(config.session);
  }
  // ===== Abstract Method Implementations =====
  getAgentType() {
    return "agent";
  }
  // ===== Context Access =====
  // Note: `context` getter is inherited from BaseAgent (returns _agentContext)
  /**
   * Check if context management is enabled.
   * Always returns true since AgentContext is always created by BaseAgent.
   */
  hasContext() {
    return true;
  }
  // getContextState() and restoreContextState() are inherited from BaseAgent
  // ===== Shared Execution Helpers =====
  /**
   * Prepare execution - shared setup for run() and stream()
   */
  async _prepareExecution(input, methodName) {
    assertNotDestroyed(this, `${methodName} agent`);
    await this.ensureSessionLoaded();
    const inputPreview = typeof input === "string" ? input.substring(0, 100) : `${input.length} messages`;
    this._logger.info({ inputPreview, toolCount: this._config.tools?.length || 0 }, `Agent ${methodName} started`);
    exports.metrics.increment(`agent.${methodName}.started`, 1, { model: this.model, connector: this.connector.name });
    const startTime = Date.now();
    const userContent = typeof input === "string" ? input : input.map((i) => JSON.stringify(i)).join("\n");
    this._agentContext.setCurrentInput(userContent);
    const executionId = `exec_${crypto2.randomUUID()}`;
    this.executionContext = new ExecutionContext(executionId, {
      maxHistorySize: 10,
      historyMode: this._config.historyMode || "summary",
      maxAuditTrailSize: 1e3
    });
    this._paused = false;
    this._cancelled = false;
    if (methodName === "stream") {
      this._pausePromise = null;
      this._resumeCallback = null;
    }
    if (typeof input === "string") {
      this._agentContext.addUserMessage(input);
    } else {
      this._agentContext.addInputItems(input);
    }
    this.emit("execution:start", {
      executionId,
      config: { model: this.model, maxIterations: this._config.maxIterations || 10 },
      timestamp: /* @__PURE__ */ new Date()
    });
    await this.hookManager.executeHooks("before:execution", {
      executionId,
      config: { model: this.model },
      timestamp: /* @__PURE__ */ new Date()
    }, void 0);
    return {
      executionId,
      startTime,
      maxIterations: this._config.maxIterations || AGENT_DEFAULTS.MAX_ITERATIONS
    };
  }
  /**
   * Check iteration preconditions - pause, cancel, limits, hooks
   */
  async _checkIterationPreconditions(executionId, iteration) {
    await this.checkPause();
    if (this._cancelled) {
      return { shouldExit: true, exitReason: "cancelled" };
    }
    if (this.executionContext) {
      this.executionContext.checkLimits(this._config.limits);
    }
    const pauseCheck = await this.hookManager.executeHooks("pause:check", {
      executionId,
      iteration,
      context: this.executionContext,
      timestamp: /* @__PURE__ */ new Date()
    }, { shouldPause: false });
    if (pauseCheck.shouldPause) {
      this.pause(pauseCheck.reason || "Hook requested pause");
      await this.checkPause();
    }
    if (this.executionContext) {
      this.executionContext.iteration = iteration;
    }
    this.emit("iteration:start", { executionId, iteration, timestamp: /* @__PURE__ */ new Date() });
    return { shouldExit: false };
  }
  /**
   * Record iteration metrics and store iteration record
   */
  _recordIterationMetrics(iteration, iterationStartTime, response, toolCalls, toolResults, prepared) {
    if (!this.executionContext) return;
    this.executionContext.addIteration({
      iteration,
      request: {
        model: this.model,
        input: prepared.input,
        instructions: this._config.instructions,
        tools: this.getEnabledToolDefinitions(),
        temperature: this._config.temperature
      },
      response,
      toolCalls,
      toolResults,
      startTime: new Date(iterationStartTime),
      endTime: /* @__PURE__ */ new Date()
    });
    this.executionContext.updateMetrics({
      iterationCount: iteration + 1,
      inputTokens: this.executionContext.metrics.inputTokens + (response.usage?.input_tokens || 0),
      outputTokens: this.executionContext.metrics.outputTokens + (response.usage?.output_tokens || 0),
      totalTokens: this.executionContext.metrics.totalTokens + (response.usage?.total_tokens || 0)
    });
  }
  /**
   * Finalize successful execution - hooks, events, metrics
   */
  async _finalizeExecution(executionId, startTime, response, methodName) {
    const totalDuration = this.executionContext ? Date.now() - this.executionContext.startTime.getTime() : Date.now() - startTime;
    if (this.executionContext) {
      this.executionContext.updateMetrics({ totalDuration });
    }
    await this.hookManager.executeHooks("after:execution", {
      executionId,
      response,
      context: this.executionContext,
      timestamp: /* @__PURE__ */ new Date(),
      duration: totalDuration
    }, void 0);
    this.emit("execution:complete", {
      executionId,
      response,
      timestamp: /* @__PURE__ */ new Date(),
      duration: totalDuration
    });
    const duration = Date.now() - startTime;
    this._logger.info({ duration }, `Agent ${methodName} completed`);
    exports.metrics.timing(`agent.${methodName}.duration`, duration, { model: this.model, connector: this.connector.name });
    exports.metrics.increment(`agent.${methodName}.completed`, 1, { model: this.model, connector: this.connector.name, status: "success" });
  }
  /**
   * Handle execution error - events, metrics, logging
   */
  _handleExecutionError(executionId, error, startTime, methodName) {
    this.emit("execution:error", { executionId, error, timestamp: /* @__PURE__ */ new Date() });
    this.executionContext?.metrics.errors.push({
      type: "execution_error",
      message: error.message,
      timestamp: /* @__PURE__ */ new Date()
    });
    const duration = Date.now() - startTime;
    this._logger.error({ error: error.message, duration }, `Agent ${methodName} failed`);
    exports.metrics.increment(`agent.${methodName}.completed`, 1, { model: this.model, connector: this.connector.name, status: "error" });
  }
  /**
   * Cleanup execution resources
   */
  _cleanupExecution(streamState) {
    streamState?.clear();
    this.executionContext?.cleanup();
  }
  /**
   * Emit iteration complete event (helper for run loop)
   */
  _emitIterationComplete(executionId, iteration, response, iterationStartTime) {
    this.emit("iteration:complete", {
      executionId,
      iteration,
      response,
      timestamp: /* @__PURE__ */ new Date(),
      duration: Date.now() - iterationStartTime
    });
  }
  // ===== Main API =====
  /**
   * Run the agent with input
   */
  async run(input) {
    const { executionId, startTime, maxIterations } = await this._prepareExecution(input, "run");
    let iteration = 0;
    let finalResponse = null;
    try {
      while (iteration < maxIterations) {
        const { shouldExit } = await this._checkIterationPreconditions(executionId, iteration);
        if (shouldExit) {
          throw new Error("Execution cancelled");
        }
        const iterationStartTime = Date.now();
        const prepared = await this._agentContext.prepare();
        const response = await this.generateWithHooks(prepared.input, iteration, executionId);
        const toolCalls = this.extractToolCalls(response.output);
        this._agentContext.addAssistantResponse(response.output);
        if (toolCalls.length > 0) {
          this.emit("tool:detected", { executionId, iteration, toolCalls, timestamp: /* @__PURE__ */ new Date() });
        }
        if (toolCalls.length === 0) {
          this._emitIterationComplete(executionId, iteration, response, iterationStartTime);
          finalResponse = response;
          break;
        }
        const toolResults = await this.executeToolsWithHooks(toolCalls, iteration, executionId);
        this._agentContext.addToolResults(toolResults);
        this._recordIterationMetrics(iteration, iterationStartTime, response, toolCalls, toolResults, prepared);
        this._emitIterationComplete(executionId, iteration, response, iterationStartTime);
        iteration++;
      }
      if (iteration >= maxIterations && !finalResponse) {
        this._logger.info({ maxIterations }, "Max iterations reached, generating wrap-up response");
        this._agentContext.addUserMessage(AGENT_DEFAULTS.MAX_ITERATIONS_MESSAGE);
        const prepared = await this._agentContext.prepare();
        const wrapUpResponse = await this._provider.generate({
          model: this.model,
          input: prepared.input,
          instructions: this._config.instructions,
          tools: [],
          // No tools - force text-only response
          temperature: this._config.temperature,
          vendorOptions: this._config.vendorOptions
        });
        this._agentContext.addAssistantResponse(wrapUpResponse.output);
        this.emit("execution:maxIterations", {
          executionId,
          iteration,
          maxIterations,
          timestamp: /* @__PURE__ */ new Date()
        });
        finalResponse = wrapUpResponse;
      }
      await this._agentContext.consolidate();
      await this._finalizeExecution(executionId, startTime, finalResponse, "run");
      return finalResponse;
    } catch (error) {
      this._handleExecutionError(executionId, error, startTime, "run");
      throw error;
    } finally {
      this._cleanupExecution();
    }
  }
  // ===== Stream-Specific Helpers =====
  /**
   * Build tool calls array from accumulated map
   */
  _buildToolCallsFromMap(toolCallsMap) {
    const toolCalls = [];
    for (const [toolCallId, buffer] of toolCallsMap) {
      toolCalls.push({
        id: toolCallId,
        type: "function",
        function: {
          name: buffer.name,
          arguments: buffer.args
        },
        blocking: true,
        state: "pending" /* PENDING */
      });
    }
    return toolCalls;
  }
  /**
   * Build and add streaming assistant message to context
   */
  _addStreamingAssistantMessage(streamState, toolCalls) {
    const assistantText = streamState.getAllText();
    const assistantContent = [];
    if (assistantText && assistantText.trim()) {
      assistantContent.push({
        type: "output_text" /* OUTPUT_TEXT */,
        text: assistantText
      });
    }
    for (const tc of toolCalls) {
      assistantContent.push({
        type: "tool_use" /* TOOL_USE */,
        id: tc.id,
        name: tc.function.name,
        arguments: tc.function.arguments
      });
    }
    const outputItem = {
      type: "message",
      role: "assistant" /* ASSISTANT */,
      content: assistantContent
    };
    this._agentContext.addAssistantResponse([outputItem]);
  }
  /**
   * Build placeholder response for streaming finalization
   */
  _buildPlaceholderResponse(executionId, startTime, streamState) {
    return {
      id: executionId,
      object: "response",
      created_at: Math.floor(startTime / 1e3),
      status: "completed",
      model: this.model,
      output: [],
      usage: streamState.usage
    };
  }
  /**
   * Stream response from the agent
   */
  async *stream(input) {
    const { executionId, startTime, maxIterations } = await this._prepareExecution(input, "stream");
    const globalStreamState = new StreamState(executionId, this.model);
    let iteration = 0;
    try {
      while (iteration < maxIterations) {
        iteration++;
        const { shouldExit } = await this._checkIterationPreconditions(executionId, iteration);
        if (shouldExit) {
          this.emit("execution:cancelled", { executionId, iteration, timestamp: /* @__PURE__ */ new Date() });
          break;
        }
        const prepared = await this._agentContext.prepare();
        const iterationStreamState = new StreamState(executionId, this.model);
        const toolCallsMap = /* @__PURE__ */ new Map();
        yield* this.streamGenerateWithHooks(
          prepared.input,
          iteration,
          executionId,
          iterationStreamState,
          toolCallsMap
        );
        globalStreamState.accumulateUsage(iterationStreamState.usage);
        const toolCalls = this._buildToolCallsFromMap(toolCallsMap);
        if (toolCalls.length === 0) {
          this._addStreamingAssistantMessage(iterationStreamState, []);
          yield {
            type: "response.iteration.complete" /* ITERATION_COMPLETE */,
            response_id: executionId,
            iteration,
            tool_calls_count: 0,
            has_more_iterations: false
          };
          yield {
            type: "response.complete" /* RESPONSE_COMPLETE */,
            response_id: executionId,
            status: "completed",
            usage: globalStreamState.usage,
            iterations: iteration,
            duration_ms: Date.now() - startTime
          };
          break;
        }
        const toolResults = [];
        for (const toolCall of toolCalls) {
          let parsedArgs;
          try {
            parsedArgs = JSON.parse(toolCall.function.arguments);
          } catch (error) {
            const errorMessage = `Invalid tool arguments JSON: ${error.message}`;
            const failedResult = {
              tool_use_id: toolCall.id,
              tool_name: toolCall.function.name,
              tool_args: {},
              content: { success: false, error: errorMessage },
              state: "failed" /* FAILED */,
              error: errorMessage
            };
            toolResults.push(failedResult);
            yield {
              type: "response.tool_execution.done" /* TOOL_EXECUTION_DONE */,
              response_id: executionId,
              tool_call_id: toolCall.id,
              tool_name: toolCall.function.name,
              result: failedResult.content,
              execution_time_ms: 0,
              error: errorMessage
            };
            continue;
          }
          yield {
            type: "response.tool_execution.start" /* TOOL_EXECUTION_START */,
            response_id: executionId,
            tool_call_id: toolCall.id,
            tool_name: toolCall.function.name,
            arguments: parsedArgs
          };
          const toolStartTime = Date.now();
          try {
            const result = await this.executeToolWithHooks(toolCall, iteration, executionId);
            toolResults.push(result);
            yield {
              type: "response.tool_execution.done" /* TOOL_EXECUTION_DONE */,
              response_id: executionId,
              tool_call_id: toolCall.id,
              tool_name: toolCall.function.name,
              result: result.content,
              execution_time_ms: Date.now() - toolStartTime
            };
          } catch (error) {
            yield {
              type: "response.tool_execution.done" /* TOOL_EXECUTION_DONE */,
              response_id: executionId,
              tool_call_id: toolCall.id,
              tool_name: toolCall.function.name,
              result: null,
              execution_time_ms: Date.now() - toolStartTime,
              error: error.message
            };
            const failureMode = this._config.errorHandling?.toolFailureMode || "continue";
            if (failureMode === "fail") {
              throw error;
            }
            toolResults.push({
              tool_use_id: toolCall.id,
              tool_name: toolCall.function.name,
              tool_args: parsedArgs,
              content: "",
              error: error.message,
              state: "failed" /* FAILED */
            });
          }
        }
        this._addStreamingAssistantMessage(iterationStreamState, toolCalls);
        this._agentContext.addToolResults(toolResults);
        yield {
          type: "response.iteration.complete" /* ITERATION_COMPLETE */,
          response_id: executionId,
          iteration,
          tool_calls_count: toolCalls.length,
          has_more_iterations: true
        };
        globalStreamState.incrementIteration();
        iterationStreamState.clear();
        toolCallsMap.clear();
      }
      if (iteration >= maxIterations) {
        this._logger.info({ maxIterations }, "Max iterations reached, streaming wrap-up response");
        this._agentContext.addUserMessage(AGENT_DEFAULTS.MAX_ITERATIONS_MESSAGE);
        const prepared = await this._agentContext.prepare();
        const wrapUpStreamState = new StreamState(executionId, this.model);
        for await (const event of this._provider.streamGenerate({
          model: this.model,
          input: prepared.input,
          instructions: this._config.instructions,
          tools: [],
          // No tools - force text-only response
          temperature: this._config.temperature,
          vendorOptions: this._config.vendorOptions
        })) {
          if (event.type === "response.output_text.delta" /* OUTPUT_TEXT_DELTA */) {
            wrapUpStreamState.accumulateTextDelta(event.item_id, event.delta);
          } else if (event.type === "response.complete" /* RESPONSE_COMPLETE */) {
            wrapUpStreamState.updateUsage(event.usage);
            continue;
          }
          yield event;
        }
        this._addStreamingAssistantMessage(wrapUpStreamState, []);
        globalStreamState.accumulateUsage(wrapUpStreamState.usage);
        this.emit("execution:maxIterations", {
          executionId,
          iteration,
          maxIterations,
          timestamp: /* @__PURE__ */ new Date()
        });
        yield {
          type: "response.complete" /* RESPONSE_COMPLETE */,
          response_id: executionId,
          status: "completed",
          // Now completed with wrap-up message
          usage: globalStreamState.usage,
          iterations: iteration + 1,
          // Include wrap-up iteration
          duration_ms: Date.now() - startTime
        };
        wrapUpStreamState.clear();
      }
      await this._agentContext.consolidate();
      const placeholderResponse = this._buildPlaceholderResponse(executionId, startTime, globalStreamState);
      await this._finalizeExecution(executionId, startTime, placeholderResponse, "stream");
    } catch (error) {
      this._handleExecutionError(executionId, error, startTime, "stream");
      yield {
        type: "response.error" /* ERROR */,
        response_id: executionId,
        error: {
          type: "execution_error",
          message: error.message
        },
        recoverable: false
      };
      throw error;
    } finally {
      this._cleanupExecution(globalStreamState);
    }
  }
  // ===== LLM Generation with Hooks =====
  /**
   * Generate LLM response with hooks
   */
  async generateWithHooks(input, iteration, executionId) {
    const llmStartTime = Date.now();
    let generateOptions = {
      model: this.model,
      input,
      instructions: this._config.instructions,
      tools: this.getEnabledToolDefinitions(),
      tool_choice: "auto",
      temperature: this._config.temperature,
      vendorOptions: this._config.vendorOptions
    };
    const beforeLLM = await this.hookManager.executeHooks("before:llm", {
      executionId,
      iteration,
      options: generateOptions,
      context: this.executionContext,
      timestamp: /* @__PURE__ */ new Date()
    }, {});
    if (beforeLLM.modified) {
      generateOptions = { ...generateOptions, ...beforeLLM.modified };
    }
    if (beforeLLM.skip) {
      throw new Error("LLM call skipped by hook");
    }
    this.emit("llm:request", {
      executionId,
      iteration,
      options: generateOptions,
      timestamp: /* @__PURE__ */ new Date()
    });
    try {
      const response = await this._provider.generate(generateOptions);
      const llmDuration = Date.now() - llmStartTime;
      this.executionContext?.updateMetrics({
        llmDuration: (this.executionContext.metrics.llmDuration || 0) + llmDuration
      });
      this.emit("llm:response", {
        executionId,
        iteration,
        response,
        timestamp: /* @__PURE__ */ new Date(),
        duration: llmDuration
      });
      await this.hookManager.executeHooks("after:llm", {
        executionId,
        iteration,
        response,
        context: this.executionContext,
        timestamp: /* @__PURE__ */ new Date(),
        duration: llmDuration
      }, {});
      return response;
    } catch (error) {
      this.emit("llm:error", {
        executionId,
        iteration,
        error,
        timestamp: /* @__PURE__ */ new Date()
      });
      throw error;
    }
  }
  /**
   * Stream LLM response with hooks
   */
  async *streamGenerateWithHooks(input, iteration, executionId, streamState, toolCallsMap) {
    const llmStartTime = Date.now();
    const generateOptions = {
      model: this.model,
      input,
      instructions: this._config.instructions,
      tools: this.getEnabledToolDefinitions(),
      tool_choice: "auto",
      temperature: this._config.temperature,
      vendorOptions: this._config.vendorOptions
    };
    await this.hookManager.executeHooks("before:llm", {
      executionId,
      iteration,
      options: generateOptions,
      context: this.executionContext,
      timestamp: /* @__PURE__ */ new Date()
    }, {});
    this.emit("llm:request", {
      executionId,
      iteration,
      model: this.model,
      timestamp: /* @__PURE__ */ new Date()
    });
    try {
      for await (const event of this._provider.streamGenerate(generateOptions)) {
        if (event.type === "response.output_text.delta" /* OUTPUT_TEXT_DELTA */) {
          streamState.accumulateTextDelta(event.item_id, event.delta);
        } else if (event.type === "response.tool_call.start" /* TOOL_CALL_START */) {
          streamState.startToolCall(event.tool_call_id, event.tool_name);
          toolCallsMap.set(event.tool_call_id, { name: event.tool_name, args: "" });
        } else if (event.type === "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */) {
          streamState.accumulateToolArguments(event.tool_call_id, event.delta);
          const buffer = toolCallsMap.get(event.tool_call_id);
          if (buffer) {
            buffer.args += event.delta;
          }
        } else if (isToolCallArgumentsDone(event)) {
          streamState.completeToolCall(event.tool_call_id);
          const buffer = toolCallsMap.get(event.tool_call_id);
          if (buffer) {
            buffer.args = event.arguments;
          }
        } else if (event.type === "response.complete" /* RESPONSE_COMPLETE */) {
          streamState.updateUsage(event.usage);
          continue;
        }
        yield event;
      }
      if (this.executionContext) {
        this.executionContext.metrics.llmDuration += Date.now() - llmStartTime;
        this.executionContext.metrics.inputTokens += streamState.usage.input_tokens;
        this.executionContext.metrics.outputTokens += streamState.usage.output_tokens;
        this.executionContext.metrics.totalTokens += streamState.usage.total_tokens;
      }
      const llmPlaceholderResponse = {
        id: executionId,
        object: "response",
        created_at: Math.floor(llmStartTime / 1e3),
        status: "completed",
        model: this.model,
        output: [],
        usage: streamState.usage
      };
      await this.hookManager.executeHooks("after:llm", {
        executionId,
        iteration,
        response: llmPlaceholderResponse,
        context: this.executionContext,
        timestamp: /* @__PURE__ */ new Date(),
        duration: Date.now() - llmStartTime
      }, {});
      this.emit("llm:response", {
        executionId,
        iteration,
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      this.emit("llm:error", {
        executionId,
        iteration,
        error,
        timestamp: /* @__PURE__ */ new Date()
      });
      throw error;
    }
  }
  // ===== Tool Execution =====
  /**
   * Extract tool calls from response output
   */
  extractToolCalls(output) {
    const toolCalls = [];
    const toolDefinitions = this.getEnabledToolDefinitions();
    const toolMap = /* @__PURE__ */ new Map();
    for (const tool of toolDefinitions) {
      if (tool.type === "function") {
        toolMap.set(tool.function.name, tool);
      }
    }
    for (const item of output) {
      if (item.type === "message" && item.role === "assistant" /* ASSISTANT */) {
        for (const content of item.content) {
          if (content.type === "tool_use" /* TOOL_USE */) {
            const toolDef = toolMap.get(content.name);
            const isBlocking = toolDef?.blocking !== false;
            const toolCall = {
              id: content.id,
              type: "function",
              function: {
                name: content.name,
                arguments: content.arguments
              },
              blocking: isBlocking,
              state: "pending" /* PENDING */
            };
            toolCalls.push(toolCall);
          }
        }
      }
    }
    return toolCalls;
  }
  /**
   * Execute tools with hooks
   */
  async executeToolsWithHooks(toolCalls, iteration, executionId) {
    const results = [];
    for (const toolCall of toolCalls) {
      this.executionContext?.addToolCall(toolCall);
      await this.checkPause();
      const beforeTool = await this.hookManager.executeHooks("before:tool", {
        executionId,
        iteration,
        toolCall,
        context: this.executionContext,
        timestamp: /* @__PURE__ */ new Date()
      }, {});
      if (beforeTool.skip) {
        this.executionContext?.audit("tool_skipped", { toolCall }, void 0, toolCall.function.name);
        let parsedArgs = {};
        try {
          parsedArgs = JSON.parse(toolCall.function.arguments);
        } catch {
        }
        const mockResult = {
          tool_use_id: toolCall.id,
          tool_name: toolCall.function.name,
          tool_args: parsedArgs,
          content: beforeTool.mockResult || "",
          state: "completed" /* COMPLETED */,
          executionTime: 0
        };
        results.push(mockResult);
        this.executionContext?.addToolResult(mockResult);
        continue;
      }
      if (beforeTool.modified) {
        Object.assign(toolCall, beforeTool.modified);
        this.executionContext?.audit("tool_modified", { modifications: beforeTool.modified }, void 0, toolCall.function.name);
      }
      try {
        const result = await this.executeToolWithHooks(toolCall, iteration, executionId);
        results.push(result);
        this.executionContext?.addToolResult(result);
      } catch (error) {
        let parsedArgs = {};
        try {
          parsedArgs = JSON.parse(toolCall.function.arguments);
        } catch {
        }
        const toolResult = {
          tool_use_id: toolCall.id,
          tool_name: toolCall.function.name,
          tool_args: parsedArgs,
          content: "",
          error: error.message,
          state: "failed" /* FAILED */
        };
        results.push(toolResult);
        this.executionContext?.addToolResult(toolResult);
        const failureMode = this._config.errorHandling?.toolFailureMode || "continue";
        if (failureMode === "fail") {
          throw error;
        }
      }
    }
    return results;
  }
  /**
   * Execute single tool with hooks
   */
  async executeToolWithHooks(toolCall, iteration, executionId) {
    const toolStartTime = Date.now();
    toolCall.state = "executing" /* EXECUTING */;
    toolCall.startTime = /* @__PURE__ */ new Date();
    const permissionApproved = await this.checkToolPermission(toolCall, iteration, executionId);
    if (!permissionApproved || this.hookManager.hasHooks("approve:tool")) {
      const approval = await this.hookManager.executeHooks("approve:tool", {
        executionId,
        iteration,
        toolCall,
        context: this.executionContext,
        timestamp: /* @__PURE__ */ new Date()
      }, { approved: permissionApproved });
      if (!approval.approved) {
        throw new Error(`Tool execution rejected: ${approval.reason || "No reason provided"}`);
      }
    }
    this.emit("tool:start", { executionId, iteration, toolCall, timestamp: /* @__PURE__ */ new Date() });
    try {
      const args = JSON.parse(toolCall.function.arguments);
      const result = await this._agentContext.tools.execute(toolCall.function.name, args);
      toolCall.state = "completed" /* COMPLETED */;
      toolCall.endTime = /* @__PURE__ */ new Date();
      let toolResult = {
        tool_use_id: toolCall.id,
        tool_name: toolCall.function.name,
        tool_args: args,
        content: result,
        state: "completed" /* COMPLETED */,
        executionTime: Date.now() - toolStartTime
      };
      const afterTool = await this.hookManager.executeHooks("after:tool", {
        executionId,
        iteration,
        toolCall,
        result: toolResult,
        context: this.executionContext,
        timestamp: /* @__PURE__ */ new Date()
      }, {});
      if (afterTool.modified) {
        toolResult = { ...toolResult, ...afterTool.modified };
      }
      if (this.executionContext) {
        this.executionContext.metrics.toolCallCount++;
        this.executionContext.metrics.toolSuccessCount++;
        this.executionContext.metrics.toolDuration += toolResult.executionTime || 0;
      }
      this.emit("tool:complete", { executionId, iteration, toolCall, result: toolResult, timestamp: /* @__PURE__ */ new Date() });
      return toolResult;
    } catch (error) {
      toolCall.state = "failed" /* FAILED */;
      toolCall.endTime = /* @__PURE__ */ new Date();
      toolCall.error = error.message;
      if (this.executionContext) {
        this.executionContext.metrics.toolFailureCount++;
      }
      if (error instanceof ToolTimeoutError) {
        this.emit("tool:timeout", {
          executionId,
          iteration,
          toolCall,
          timeout: error.timeoutMs,
          timestamp: /* @__PURE__ */ new Date()
        });
      } else {
        this.emit("tool:error", { executionId, iteration, toolCall, error, timestamp: /* @__PURE__ */ new Date() });
      }
      throw error;
    }
  }
  /**
   * Check tool permission before execution
   */
  async checkToolPermission(toolCall, iteration, executionId) {
    if (this._permissionManager.isBlocked(toolCall.function.name)) {
      this.executionContext?.audit("tool_blocked", { reason: "Tool is blocklisted" }, void 0, toolCall.function.name);
      throw new Error(`Tool "${toolCall.function.name}" is blocked and cannot be executed`);
    }
    if (this._permissionManager.isApproved(toolCall.function.name)) {
      return true;
    }
    const checkResult = this._permissionManager.checkPermission(toolCall.function.name);
    if (!checkResult.needsApproval) {
      return true;
    }
    let parsedArgs = {};
    try {
      parsedArgs = JSON.parse(toolCall.function.arguments);
    } catch {
    }
    const context = {
      toolCall,
      parsedArgs,
      config: checkResult.config || {},
      executionId,
      iteration,
      agentType: "agent"
    };
    const decision = await this._permissionManager.requestApproval(context);
    if (decision.approved) {
      this.executionContext?.audit("tool_permission_approved", {
        scope: decision.scope,
        approvedBy: decision.approvedBy
      }, void 0, toolCall.function.name);
      return true;
    }
    return false;
  }
  // ===== Pause/Resume/Cancel =====
  /**
   * Pause execution
   */
  pause(reason) {
    this._pauseResumeMutex = this._pauseResumeMutex.then(() => {
      if (this._paused) return;
      this._paused = true;
      this._pausePromise = new Promise((resolve4) => {
        this._resumeCallback = resolve4;
      });
      if (this.executionContext) {
        this.executionContext.paused = true;
        this.executionContext.pauseReason = reason;
        this.executionContext.audit("execution_paused", { reason });
      }
      this.emit("execution:paused", {
        executionId: this.executionContext?.executionId || "unknown",
        reason: reason || "Manual pause",
        timestamp: /* @__PURE__ */ new Date()
      });
    });
  }
  /**
   * Resume execution
   */
  resume() {
    this._pauseResumeMutex = this._pauseResumeMutex.then(() => {
      if (!this._paused) return;
      this._paused = false;
      if (this.executionContext) {
        this.executionContext.paused = false;
        this.executionContext.pauseReason = void 0;
        this.executionContext.audit("execution_resumed", {});
      }
      if (this._resumeCallback) {
        this._resumeCallback();
        this._resumeCallback = null;
      }
      this._pausePromise = null;
      this.emit("execution:resumed", {
        executionId: this.executionContext?.executionId || "unknown",
        timestamp: /* @__PURE__ */ new Date()
      });
    });
  }
  /**
   * Cancel execution
   */
  cancel(reason) {
    this._cancelled = true;
    if (this.executionContext) {
      this.executionContext.cancelled = true;
      this.executionContext.cancelReason = reason;
    }
    if (this._paused) {
      this._paused = false;
      if (this._resumeCallback) {
        this._resumeCallback();
        this._resumeCallback = null;
      }
      this._pausePromise = null;
    }
    this.emit("execution:cancelled", {
      executionId: this.executionContext?.executionId || "unknown",
      reason: reason || "Manual cancellation",
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  /**
   * Check if paused and wait
   */
  async checkPause() {
    if (this._paused && this._pausePromise) {
      await this._pausePromise;
    }
  }
  // ===== Tool Management =====
  // Note: addTool, removeTool, listTools, setTools are inherited from BaseAgent
  // ===== Permission Convenience Methods =====
  approveToolForSession(toolName) {
    this._permissionManager.approveForSession(toolName);
  }
  revokeToolApproval(toolName) {
    this._permissionManager.revoke(toolName);
  }
  getApprovedTools() {
    return this._permissionManager.getApprovedTools();
  }
  toolNeedsApproval(toolName) {
    return this._permissionManager.checkPermission(toolName).needsApproval;
  }
  toolIsBlocked(toolName) {
    return this._permissionManager.isBlocked(toolName);
  }
  allowlistTool(toolName) {
    this._permissionManager.allowlistAdd(toolName);
  }
  blocklistTool(toolName) {
    this._permissionManager.blocklistAdd(toolName);
  }
  // ===== Configuration Methods =====
  setModel(model) {
    this.model = model;
    this._config.model = model;
  }
  getTemperature() {
    return this._config.temperature;
  }
  setTemperature(temperature) {
    this._config.temperature = temperature;
  }
  // ===== Definition Persistence =====
  async saveDefinition(storage, metadata) {
    const s = storage ?? exports.StorageRegistry.get("agentDefinitions");
    if (!s) {
      throw new Error("No storage provided and no agentDefinitions configured in StorageRegistry");
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const definition = {
      version: 1,
      agentId: this._agentContext.agentId,
      name: this._agentContext.agentId,
      agentType: "agent",
      createdAt: now,
      updatedAt: now,
      connector: {
        name: this.connector.name,
        model: this.model
      },
      systemPrompt: this._agentContext.systemPrompt,
      instructions: this._config.instructions,
      features: this._agentContext.features,
      metadata,
      typeConfig: {
        temperature: this._config.temperature,
        maxIterations: this._config.maxIterations,
        vendorOptions: this._config.vendorOptions
      }
    };
    await s.save(definition);
  }
  // ===== Introspection =====
  getExecutionContext() {
    return this.executionContext;
  }
  /**
   * Alias for getExecutionContext() for backward compatibility
   */
  getContext() {
    return this.executionContext;
  }
  getMetrics() {
    return this.executionContext?.metrics || null;
  }
  getSummary() {
    return this.executionContext?.getSummary() || null;
  }
  getAuditTrail() {
    return this.executionContext?.getAuditTrail() || [];
  }
  getProviderCircuitBreakerMetrics() {
    if ("getCircuitBreakerMetrics" in this._provider) {
      return this._provider.getCircuitBreakerMetrics();
    }
    return null;
  }
  getToolCircuitBreakerStates() {
    return this._agentContext.tools.getCircuitBreakerStates();
  }
  getToolCircuitBreakerMetrics(toolName) {
    return this._agentContext.tools.getToolCircuitBreakerMetrics(toolName);
  }
  resetToolCircuitBreaker(toolName) {
    this._agentContext.tools.resetToolCircuitBreaker(toolName);
    this._logger.info({ toolName }, "Tool circuit breaker reset by user");
  }
  isRunning() {
    return this.executionContext !== null && !this._cancelled;
  }
  isPaused() {
    return this._paused;
  }
  isCancelled() {
    return this._cancelled;
  }
  /**
   * Clear conversation history, resetting the context for a fresh interaction.
   * Plugins (working memory, in-context memory, etc.) are NOT affected.
   */
  clearConversation(reason) {
    this._agentContext.clearConversation(reason);
    this._logger.info({ reason }, "Conversation cleared");
  }
  // ===== Hook Management =====
  /**
   * Register a hook on the agent. Can be called after creation.
   */
  registerHook(name, hook) {
    this.hookManager.register(name, hook);
  }
  /**
   * Unregister a previously registered hook by reference.
   */
  unregisterHook(name, hook) {
    return this.hookManager.unregister(name, hook);
  }
  // ===== Cleanup =====
  destroy() {
    if (this._isDestroyed) {
      return;
    }
    this._logger.debug("Agent destroy started");
    try {
      this.cancel("Agent destroyed");
    } catch {
    }
    this.executionContext?.cleanup();
    this.executionContext = null;
    for (const callback of this._cleanupCallbacks) {
      try {
        callback();
      } catch (error) {
        this._logger.error({ error: error.message }, "Cleanup callback error");
      }
    }
    this._cleanupCallbacks = [];
    this.baseDestroy();
    exports.metrics.increment("agent.destroyed", 1, {
      model: this.model,
      connector: this.connector.name
    });
    this._logger.debug("Agent destroyed");
  }
};

// src/domain/entities/Task.ts
var TERMINAL_TASK_STATUSES = ["completed", "failed", "skipped", "cancelled"];
function isTerminalStatus(status) {
  return TERMINAL_TASK_STATUSES.includes(status);
}
function createTask(input) {
  const now = Date.now();
  const id = input.id ?? `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  return {
    id,
    name: input.name,
    description: input.description,
    status: "pending",
    dependsOn: input.dependsOn ?? [],
    externalDependency: input.externalDependency,
    condition: input.condition,
    execution: input.execution,
    suggestedTools: input.suggestedTools,
    validation: input.validation,
    expectedOutput: input.expectedOutput,
    attempts: 0,
    maxAttempts: input.maxAttempts ?? 3,
    createdAt: now,
    lastUpdatedAt: now,
    metadata: input.metadata
  };
}
function createPlan(input) {
  const now = Date.now();
  const id = `plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const tasks = input.tasks.map((taskInput) => createTask(taskInput));
  const nameToId = /* @__PURE__ */ new Map();
  for (const task of tasks) {
    nameToId.set(task.name, task.id);
  }
  for (let i = 0; i < tasks.length; i++) {
    const taskInput = input.tasks[i];
    const task = tasks[i];
    if (taskInput.dependsOn && taskInput.dependsOn.length > 0) {
      task.dependsOn = taskInput.dependsOn.map((dep) => {
        if (dep.startsWith("task-")) {
          return dep;
        }
        const resolvedId = nameToId.get(dep);
        if (!resolvedId) {
          throw new Error(`Task dependency "${dep}" not found in plan`);
        }
        return resolvedId;
      });
    }
  }
  if (!input.skipCycleCheck) {
    const cycle = detectDependencyCycle(tasks);
    if (cycle) {
      const cycleNames = cycle.map((taskId) => {
        const task = tasks.find((t) => t.id === taskId);
        return task ? task.name : taskId;
      });
      throw new DependencyCycleError(cycleNames, id);
    }
  }
  return {
    id,
    goal: input.goal,
    context: input.context,
    tasks,
    concurrency: input.concurrency,
    allowDynamicTasks: input.allowDynamicTasks ?? true,
    status: "pending",
    createdAt: now,
    lastUpdatedAt: now,
    metadata: input.metadata
  };
}
function canTaskExecute(task, allTasks) {
  if (task.status !== "pending") {
    return false;
  }
  if (task.dependsOn.length > 0) {
    for (const depId of task.dependsOn) {
      const depTask = allTasks.find((t) => t.id === depId);
      if (!depTask || depTask.status !== "completed") {
        return false;
      }
    }
  }
  return true;
}
function getNextExecutableTasks(plan) {
  const executable = plan.tasks.filter((task) => canTaskExecute(task, plan.tasks));
  if (executable.length === 0) {
    return [];
  }
  if (!plan.concurrency) {
    return [executable[0]];
  }
  const runningCount = plan.tasks.filter((t) => t.status === "in_progress").length;
  const availableSlots = plan.concurrency.maxParallelTasks - runningCount;
  if (availableSlots <= 0) {
    return [];
  }
  const parallelTasks = executable.filter((task) => task.execution?.parallel === true);
  if (parallelTasks.length === 0) {
    return [executable[0]];
  }
  let sortedTasks = [...parallelTasks];
  if (plan.concurrency.strategy === "priority") {
    sortedTasks.sort((a, b) => (b.execution?.priority ?? 0) - (a.execution?.priority ?? 0));
  }
  return sortedTasks.slice(0, availableSlots);
}
async function evaluateCondition(condition, memory) {
  const value = await memory.get(condition.memoryKey);
  switch (condition.operator) {
    case "exists":
      return value !== void 0;
    case "not_exists":
      return value === void 0;
    case "equals":
      return value === condition.value;
    case "contains":
      if (Array.isArray(value)) {
        return value.includes(condition.value);
      }
      if (typeof value === "string" && typeof condition.value === "string") {
        return value.includes(condition.value);
      }
      return false;
    case "truthy":
      return !!value;
    case "greater_than":
      if (typeof value === "number" && typeof condition.value === "number") {
        return value > condition.value;
      }
      return false;
    case "less_than":
      if (typeof value === "number" && typeof condition.value === "number") {
        return value < condition.value;
      }
      return false;
    default:
      return false;
  }
}
function updateTaskStatus(task, status) {
  const now = Date.now();
  const updated = {
    ...task,
    status,
    lastUpdatedAt: now
  };
  if (status === "in_progress") {
    if (!updated.startedAt) {
      updated.startedAt = now;
    }
    updated.attempts += 1;
  }
  if ((status === "completed" || status === "failed") && !updated.completedAt) {
    updated.completedAt = now;
  }
  return updated;
}
function isTaskBlocked(task, allTasks) {
  if (task.dependsOn.length === 0) {
    return false;
  }
  for (const depId of task.dependsOn) {
    const depTask = allTasks.find((t) => t.id === depId);
    if (!depTask) {
      return true;
    }
    if (depTask.status !== "completed") {
      return true;
    }
  }
  return false;
}
function getTaskDependencies(task, allTasks) {
  if (task.dependsOn.length === 0) {
    return [];
  }
  return task.dependsOn.map((depId) => allTasks.find((t) => t.id === depId)).filter((t) => t !== void 0);
}
function resolveDependencies(taskInputs, tasks) {
  const nameToId = /* @__PURE__ */ new Map();
  for (const task of tasks) {
    nameToId.set(task.name, task.id);
  }
  for (const input of taskInputs) {
    if (input.dependsOn && input.dependsOn.length > 0) {
      input.dependsOn = input.dependsOn.map((dep) => {
        if (dep.startsWith("task-")) {
          return dep;
        }
        const resolvedId = nameToId.get(dep);
        if (!resolvedId) {
          throw new Error(`Task dependency "${dep}" not found`);
        }
        return resolvedId;
      });
    }
  }
}
function detectDependencyCycle(tasks) {
  const visited = /* @__PURE__ */ new Set();
  const recStack = /* @__PURE__ */ new Set();
  const taskMap = new Map(tasks.map((t) => [t.id, t]));
  function dfs(taskId, path6) {
    if (recStack.has(taskId)) {
      const cycleStart = path6.indexOf(taskId);
      return [...path6.slice(cycleStart), taskId];
    }
    if (visited.has(taskId)) {
      return null;
    }
    visited.add(taskId);
    recStack.add(taskId);
    const task = taskMap.get(taskId);
    if (task) {
      for (const depId of task.dependsOn) {
        const cycle = dfs(depId, [...path6, taskId]);
        if (cycle) {
          return cycle;
        }
      }
    }
    recStack.delete(taskId);
    return null;
  }
  for (const task of tasks) {
    if (!visited.has(task.id)) {
      const cycle = dfs(task.id, []);
      if (cycle) {
        return cycle;
      }
    }
  }
  return null;
}

// src/domain/entities/Routine.ts
function createRoutineDefinition(input) {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const id = input.id ?? `routine-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const taskNames = new Set(input.tasks.map((t) => t.name));
  const taskIds = new Set(input.tasks.filter((t) => t.id).map((t) => t.id));
  for (const task of input.tasks) {
    if (task.dependsOn) {
      for (const dep of task.dependsOn) {
        if (!taskNames.has(dep) && !taskIds.has(dep)) {
          throw new Error(
            `Routine "${input.name}": task "${task.name}" depends on unknown task "${dep}"`
          );
        }
      }
    }
  }
  createPlan({
    goal: input.name,
    tasks: input.tasks
  });
  return {
    id,
    name: input.name,
    description: input.description,
    version: input.version,
    tasks: input.tasks,
    requiredTools: input.requiredTools,
    requiredPlugins: input.requiredPlugins,
    instructions: input.instructions,
    concurrency: input.concurrency,
    allowDynamicTasks: input.allowDynamicTasks ?? false,
    tags: input.tags,
    author: input.author,
    createdAt: now,
    updatedAt: now,
    metadata: input.metadata
  };
}
function createRoutineExecution(definition) {
  const now = Date.now();
  const executionId = `rexec-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const plan = createPlan({
    goal: definition.name,
    context: definition.description,
    tasks: definition.tasks,
    concurrency: definition.concurrency,
    allowDynamicTasks: definition.allowDynamicTasks
  });
  return {
    id: executionId,
    routineId: definition.id,
    plan,
    status: "pending",
    progress: 0,
    lastUpdatedAt: now
  };
}
function getRoutineProgress(execution) {
  const { tasks } = execution.plan;
  if (tasks.length === 0) return 100;
  const completed = tasks.filter((t) => isTerminalStatus(t.status)).length;
  return Math.round(completed / tasks.length * 100);
}

// src/utils/jsonExtractor.ts
function extractJSON(text) {
  if (!text || typeof text !== "string") {
    return {
      success: false,
      error: "Input is empty or not a string"
    };
  }
  const trimmedText = text.trim();
  const codeBlockResult = extractFromCodeBlock(trimmedText);
  if (codeBlockResult.success) {
    return codeBlockResult;
  }
  const inlineResult = extractInlineJSON(trimmedText);
  if (inlineResult.success) {
    return inlineResult;
  }
  try {
    const data = JSON.parse(trimmedText);
    return {
      success: true,
      data,
      rawJson: trimmedText,
      method: "raw"
    };
  } catch (e) {
    return {
      success: false,
      error: `Could not extract JSON from text: ${e instanceof Error ? e.message : String(e)}`
    };
  }
}
function extractFromCodeBlock(text) {
  const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)```/g;
  let match;
  while ((match = codeBlockRegex.exec(text)) !== null) {
    const content = match[1];
    if (content) {
      const trimmed = content.trim();
      try {
        const data = JSON.parse(trimmed);
        return {
          success: true,
          data,
          rawJson: trimmed,
          method: "code_block"
        };
      } catch {
        continue;
      }
    }
  }
  return { success: false };
}
function extractInlineJSON(text) {
  const objectMatch = findJSONObject(text);
  if (objectMatch) {
    try {
      const data = JSON.parse(objectMatch);
      return {
        success: true,
        data,
        rawJson: objectMatch,
        method: "inline"
      };
    } catch {
    }
  }
  const arrayMatch = findJSONArray(text);
  if (arrayMatch) {
    try {
      const data = JSON.parse(arrayMatch);
      return {
        success: true,
        data,
        rawJson: arrayMatch,
        method: "inline"
      };
    } catch {
    }
  }
  return { success: false };
}
function findJSONObject(text) {
  const startIndex = text.indexOf("{");
  if (startIndex === -1) return null;
  let depth = 0;
  let inString = false;
  let escaped = false;
  for (let i = startIndex; i < text.length; i++) {
    const char = text[i];
    if (escaped) {
      escaped = false;
      continue;
    }
    if (char === "\\" && inString) {
      escaped = true;
      continue;
    }
    if (char === '"') {
      inString = !inString;
      continue;
    }
    if (inString) continue;
    if (char === "{") {
      depth++;
    } else if (char === "}") {
      depth--;
      if (depth === 0) {
        return text.slice(startIndex, i + 1);
      }
    }
  }
  return null;
}
function findJSONArray(text) {
  const startIndex = text.indexOf("[");
  if (startIndex === -1) return null;
  let depth = 0;
  let inString = false;
  let escaped = false;
  for (let i = startIndex; i < text.length; i++) {
    const char = text[i];
    if (escaped) {
      escaped = false;
      continue;
    }
    if (char === "\\" && inString) {
      escaped = true;
      continue;
    }
    if (char === '"') {
      inString = !inString;
      continue;
    }
    if (inString) continue;
    if (char === "[") {
      depth++;
    } else if (char === "]") {
      depth--;
      if (depth === 0) {
        return text.slice(startIndex, i + 1);
      }
    }
  }
  return null;
}
function extractJSONField(text, field, defaultValue) {
  const result = extractJSON(text);
  if (result.success && result.data && field in result.data) {
    return result.data[field];
  }
  return defaultValue;
}
function extractNumber(text, patterns = [
  /(\d{1,3})%?\s*(?:complete|score|percent)/i,
  /(?:score|completion|rating)[:\s]+(\d{1,3})/i,
  /(\d{1,3})\s*(?:out of|\/)\s*100/i
], defaultValue = 0) {
  const jsonResult = extractJSON(text);
  if (jsonResult.success && jsonResult.data) {
    const scoreFields = ["score", "completionScore", "completion_score", "rating", "percent", "value"];
    for (const field of scoreFields) {
      if (field in jsonResult.data && typeof jsonResult.data[field] === "number") {
        return jsonResult.data[field];
      }
    }
  }
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      const num = parseInt(match[1], 10);
      if (!isNaN(num)) {
        return num;
      }
    }
  }
  return defaultValue;
}

// src/core/routineRunner.ts
init_Logger();
function defaultSystemPrompt(definition) {
  const parts = [];
  if (definition.instructions) {
    parts.push(definition.instructions);
  }
  parts.push(
    `You are executing a routine called "${definition.name}".`,
    "",
    "Between tasks, your conversation history is cleared but your memory persists.",
    "Use these strategies to pass information between tasks:",
    "- Use context_set for small key results that subsequent tasks need immediately (visible in context, no retrieval needed).",
    '- Use memory_store with tier="findings" for larger data that may be needed later.',
    "- Use memory_retrieve to access data stored by previous tasks.",
    "",
    "When you have completed the current task, stop and let the system know you are done.",
    "Store your key results in memory before finishing."
  );
  return parts.join("\n");
}
function defaultTaskPrompt(task) {
  const parts = [];
  parts.push(`## Current Task: ${task.name}`, "");
  parts.push(task.description, "");
  if (task.expectedOutput) {
    parts.push(`**Expected output:** ${task.expectedOutput}`, "");
  }
  if (task.suggestedTools && task.suggestedTools.length > 0) {
    parts.push(`**Suggested tools:** ${task.suggestedTools.join(", ")}`, "");
  }
  const criteria = task.validation?.completionCriteria;
  if (criteria && criteria.length > 0) {
    parts.push("### Completion Criteria");
    parts.push("When you are done, ensure the following are met:");
    for (const c of criteria) {
      parts.push(`- ${c}`);
    }
    parts.push("");
  }
  parts.push("Store your key results in memory before finishing.");
  return parts.join("\n");
}
function defaultValidationPrompt(task, context) {
  const criteria = task.validation?.completionCriteria ?? [];
  const criteriaList = criteria.length > 0 ? criteria.map((c, i) => `${i + 1}. ${c}`).join("\n") : "The task was completed as described.";
  const parts = [
    `Evaluate if the task "${task.name}" was completed successfully.`,
    "",
    `Task description: ${task.description}`,
    "",
    "Completion criteria:",
    criteriaList,
    "",
    "--- EVIDENCE ---",
    "",
    "Agent response (final text output):",
    context.responseText || "(no text output)",
    "",
    "Tool calls made during this task:",
    context.toolCallLog
  ];
  if (context.inContextMemory) {
    parts.push("", "In-context memory (current state):", context.inContextMemory);
  }
  if (context.workingMemoryIndex) {
    parts.push("", "Working memory index (stored data):", context.workingMemoryIndex);
  }
  parts.push(
    "",
    "--- END EVIDENCE ---",
    "",
    "Use the evidence above to verify each criterion. Check tool call results, not just the agent's claims.",
    "",
    "Return a JSON object with the following structure:",
    "```json",
    '{ "isComplete": boolean, "completionScore": number (0-100), "explanation": "..." }',
    "```",
    "",
    "Be strict: only mark isComplete=true if all criteria are clearly met based on the evidence."
  );
  return parts.join("\n");
}
function formatToolCallLog(conversation) {
  const calls = [];
  for (const item of conversation) {
    if (!("content" in item) || !Array.isArray(item.content)) continue;
    const msg = item;
    for (const c of msg.content) {
      if (c.type === "tool_use" /* TOOL_USE */) {
        let argsStr;
        try {
          const parsed = JSON.parse(c.arguments);
          argsStr = JSON.stringify(parsed, null, 2);
          if (argsStr.length > 500) argsStr = argsStr.slice(0, 500) + "... (truncated)";
        } catch {
          argsStr = c.arguments;
        }
        calls.push(`CALL: ${c.name}(${argsStr})`);
      } else if (c.type === "tool_result" /* TOOL_RESULT */) {
        let resultStr = typeof c.content === "string" ? c.content : JSON.stringify(c.content);
        if (resultStr.length > 500) resultStr = resultStr.slice(0, 500) + "... (truncated)";
        const prefix = c.error ? "ERROR" : "RESULT";
        calls.push(`  ${prefix}: ${resultStr}`);
      }
    }
  }
  return calls.length > 0 ? calls.join("\n") : "(no tool calls)";
}
async function collectValidationContext(agent, responseText) {
  const icmPlugin = agent.context.getPlugin("in_context_memory");
  const inContextMemory = icmPlugin ? await icmPlugin.getContent() : null;
  const wmPlugin = agent.context.memory;
  const workingMemoryIndex = wmPlugin ? await wmPlugin.getContent() : null;
  const conversation = agent.context.getConversation();
  const toolCallLog = formatToolCallLog(conversation);
  return {
    responseText,
    inContextMemory,
    workingMemoryIndex,
    toolCallLog
  };
}
async function validateTaskCompletion(agent, task, responseText, validationPromptBuilder) {
  const hasExplicitValidation = task.validation?.skipReflection === false && task.validation?.completionCriteria && task.validation.completionCriteria.length > 0;
  if (!hasExplicitValidation) {
    return {
      isComplete: true,
      completionScore: 100,
      explanation: "Auto-passed (LLM validation not enabled)",
      requiresUserApproval: false
    };
  }
  const validationContext = await collectValidationContext(agent, responseText);
  const prompt = validationPromptBuilder(task, validationContext);
  const response = await agent.runDirect(prompt, {
    instructions: "You are a task completion evaluator. Return only JSON.",
    temperature: 0.1
  });
  const text = response.output_text ?? "";
  const extracted = extractJSON(text);
  if (!extracted.success || !extracted.data) {
    return {
      isComplete: false,
      completionScore: 0,
      explanation: `Failed to parse validation response: ${extracted.error ?? "unknown error"}`,
      requiresUserApproval: false
    };
  }
  const { isComplete, completionScore, explanation } = extracted.data;
  const minScore = task.validation?.minCompletionScore ?? 80;
  return {
    isComplete: isComplete && completionScore >= minScore,
    completionScore,
    explanation,
    requiresUserApproval: false
  };
}
async function executeRoutine(options) {
  const {
    definition,
    agent: existingAgent,
    connector,
    model,
    tools: extraTools,
    onTaskStarted,
    onTaskComplete,
    onTaskFailed,
    onTaskValidation,
    hooks,
    prompts
  } = options;
  if (!existingAgent && (!connector || !model)) {
    throw new Error("executeRoutine requires either `agent` or both `connector` and `model`");
  }
  const ownsAgent = !existingAgent;
  const log = exports.logger.child({ routine: definition.name });
  const execution = createRoutineExecution(definition);
  execution.status = "running";
  execution.startedAt = Date.now();
  execution.lastUpdatedAt = Date.now();
  const buildSystemPrompt = prompts?.system ?? defaultSystemPrompt;
  const buildTaskPrompt = prompts?.task ?? defaultTaskPrompt;
  const buildValidationPrompt = prompts?.validation ?? defaultValidationPrompt;
  let agent;
  const registeredHooks = [];
  if (existingAgent) {
    agent = existingAgent;
    if (hooks) {
      const hookNames = [
        "before:execution",
        "after:execution",
        "before:llm",
        "after:llm",
        "before:tool",
        "after:tool",
        "approve:tool",
        "pause:check"
      ];
      for (const name of hookNames) {
        const hook = hooks[name];
        if (hook) {
          agent.registerHook(name, hook);
          registeredHooks.push({ name, hook });
        }
      }
    }
  } else {
    const allTools = [...extraTools ?? []];
    if (definition.requiredTools && definition.requiredTools.length > 0) {
      const availableToolNames = new Set(allTools.map((t) => t.definition.function.name));
      const missing = definition.requiredTools.filter((name) => !availableToolNames.has(name));
      if (missing.length > 0) {
        execution.status = "failed";
        execution.error = `Missing required tools: ${missing.join(", ")}`;
        execution.completedAt = Date.now();
        execution.lastUpdatedAt = Date.now();
        return execution;
      }
    }
    agent = Agent.create({
      connector,
      model,
      tools: allTools,
      instructions: buildSystemPrompt(definition),
      hooks,
      context: {
        model,
        features: {
          workingMemory: true,
          inContextMemory: true
        }
      }
    });
  }
  if (definition.requiredPlugins && definition.requiredPlugins.length > 0) {
    const missing = definition.requiredPlugins.filter(
      (name) => !agent.context.hasPlugin(name)
    );
    if (missing.length > 0) {
      if (ownsAgent) agent.destroy();
      execution.status = "failed";
      execution.error = `Missing required plugins: ${missing.join(", ")}`;
      execution.completedAt = Date.now();
      execution.lastUpdatedAt = Date.now();
      return execution;
    }
  }
  const failureMode = definition.concurrency?.failureMode ?? "fail-fast";
  try {
    let nextTasks = getNextExecutableTasks(execution.plan);
    while (nextTasks.length > 0) {
      const task = nextTasks[0];
      const taskIndex = execution.plan.tasks.findIndex((t) => t.id === task.id);
      log.info({ taskName: task.name, taskId: task.id }, "Starting task");
      execution.plan.tasks[taskIndex] = updateTaskStatus(task, "in_progress");
      execution.lastUpdatedAt = Date.now();
      onTaskStarted?.(execution.plan.tasks[taskIndex], execution);
      let taskCompleted = false;
      const getTask = () => execution.plan.tasks[taskIndex];
      while (!taskCompleted) {
        try {
          const taskPrompt = buildTaskPrompt(getTask());
          const response = await agent.run(taskPrompt);
          const responseText = response.output_text ?? "";
          const validationResult = await validateTaskCompletion(
            agent,
            getTask(),
            responseText,
            buildValidationPrompt
          );
          onTaskValidation?.(getTask(), validationResult, execution);
          if (validationResult.isComplete) {
            execution.plan.tasks[taskIndex] = updateTaskStatus(getTask(), "completed");
            execution.plan.tasks[taskIndex].result = {
              success: true,
              output: responseText,
              validationScore: validationResult.completionScore,
              validationExplanation: validationResult.explanation
            };
            taskCompleted = true;
            log.info(
              { taskName: getTask().name, score: validationResult.completionScore },
              "Task completed"
            );
            execution.progress = getRoutineProgress(execution);
            execution.lastUpdatedAt = Date.now();
            onTaskComplete?.(execution.plan.tasks[taskIndex], execution);
          } else {
            log.warn(
              {
                taskName: getTask().name,
                score: validationResult.completionScore,
                attempt: getTask().attempts,
                maxAttempts: getTask().maxAttempts
              },
              "Task validation failed"
            );
            if (getTask().attempts >= getTask().maxAttempts) {
              execution.plan.tasks[taskIndex] = updateTaskStatus(getTask(), "failed");
              execution.plan.tasks[taskIndex].result = {
                success: false,
                error: validationResult.explanation,
                validationScore: validationResult.completionScore,
                validationExplanation: validationResult.explanation
              };
              break;
            }
            execution.plan.tasks[taskIndex] = updateTaskStatus(getTask(), "in_progress");
          }
        } catch (error) {
          const errorMessage = error.message;
          log.error({ taskName: getTask().name, error: errorMessage }, "Task execution error");
          if (getTask().attempts >= getTask().maxAttempts) {
            execution.plan.tasks[taskIndex] = updateTaskStatus(getTask(), "failed");
            execution.plan.tasks[taskIndex].result = {
              success: false,
              error: errorMessage
            };
            break;
          }
          execution.plan.tasks[taskIndex] = updateTaskStatus(getTask(), "in_progress");
        }
      }
      if (!taskCompleted) {
        execution.progress = getRoutineProgress(execution);
        execution.lastUpdatedAt = Date.now();
        onTaskFailed?.(execution.plan.tasks[taskIndex], execution);
        if (failureMode === "fail-fast") {
          execution.status = "failed";
          execution.error = `Task "${getTask().name}" failed after ${getTask().attempts} attempt(s)`;
          execution.completedAt = Date.now();
          execution.lastUpdatedAt = Date.now();
          break;
        }
      }
      agent.clearConversation("task-boundary");
      nextTasks = getNextExecutableTasks(execution.plan);
    }
    if (execution.status === "running") {
      const allTerminal = execution.plan.tasks.every((t) => isTerminalStatus(t.status));
      const allCompleted = execution.plan.tasks.every((t) => t.status === "completed");
      if (allCompleted) {
        execution.status = "completed";
      } else if (allTerminal) {
        execution.status = "failed";
        execution.error = "Not all tasks completed successfully";
      } else {
        execution.status = "failed";
        execution.error = "Execution stalled: remaining tasks are blocked by incomplete dependencies";
      }
      execution.completedAt = Date.now();
      execution.lastUpdatedAt = Date.now();
      execution.progress = getRoutineProgress(execution);
    }
    log.info(
      { status: execution.status, progress: execution.progress },
      "Routine execution finished"
    );
    return execution;
  } finally {
    for (const { name, hook } of registeredHooks) {
      try {
        agent.unregisterHook(name, hook);
      } catch {
      }
    }
    if (ownsAgent) {
      agent.destroy();
    }
  }
}

// src/core/index.ts
init_constants();
(class {
  static DEFAULT_PATHS = [
    "./oneringai.config.json",
    path2.join(os2.homedir(), ".oneringai", "config.json")
  ];
  /**
   * Load configuration from file
   */
  static async load(path6) {
    const configPath = path6 ? path2.resolve(path6) : await this.findConfig();
    if (!configPath) {
      throw new Error("Configuration file not found. Searched: " + this.DEFAULT_PATHS.join(", "));
    }
    try {
      const content = await fs19.promises.readFile(configPath, "utf-8");
      let config = JSON.parse(content);
      config = this.interpolateEnvVars(config);
      this.validate(config);
      return config;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new Error(`Invalid JSON in configuration file '${configPath}': ${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Load configuration synchronously
   */
  static loadSync(path6) {
    const configPath = path6 ? path2.resolve(path6) : this.findConfigSync();
    if (!configPath) {
      throw new Error("Configuration file not found. Searched: " + this.DEFAULT_PATHS.join(", "));
    }
    try {
      const fs20 = __require("fs");
      const content = fs20.readFileSync(configPath, "utf-8");
      let config = JSON.parse(content);
      config = this.interpolateEnvVars(config);
      this.validate(config);
      return config;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new Error(`Invalid JSON in configuration file '${configPath}': ${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Find configuration file in default paths
   */
  static async findConfig() {
    for (const path6 of this.DEFAULT_PATHS) {
      try {
        await fs19.promises.access(path2.resolve(path6));
        return path2.resolve(path6);
      } catch {
      }
    }
    return null;
  }
  /**
   * Find configuration file synchronously
   */
  static findConfigSync() {
    const fs20 = __require("fs");
    for (const path6 of this.DEFAULT_PATHS) {
      try {
        fs20.accessSync(path2.resolve(path6));
        return path2.resolve(path6);
      } catch {
      }
    }
    return null;
  }
  /**
   * Interpolate environment variables in configuration
   * Replaces ${ENV_VAR} with process.env.ENV_VAR
   */
  static interpolateEnvVars(config) {
    const jsonString = JSON.stringify(config);
    const interpolated = jsonString.replace(/\$\{([^}]+)\}/g, (match, envVar) => {
      const value = process.env[envVar];
      if (value === void 0) {
        console.warn(`Warning: Environment variable '${envVar}' is not set`);
        return match;
      }
      return value;
    });
    return JSON.parse(interpolated);
  }
  /**
   * Basic validation of configuration structure
   */
  static validate(config) {
    if (typeof config !== "object" || config === null) {
      throw new Error("Configuration must be an object");
    }
    if (config.mcp) {
      if (!Array.isArray(config.mcp.servers)) {
        throw new Error('MCP configuration must have a "servers" array');
      }
      for (const server of config.mcp.servers) {
        if (!server.name) {
          throw new Error('Each MCP server must have a "name" field');
        }
        if (!server.transport) {
          throw new Error(`MCP server '${server.name}' must have a "transport" field`);
        }
        if (!server.transportConfig) {
          throw new Error(`MCP server '${server.name}' must have a "transportConfig" field`);
        }
      }
    }
  }
});
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = z4mini__namespace.safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = z__namespace.custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = z__namespace.union([z__namespace.string(), z__namespace.number().int()]);
var CursorSchema = z__namespace.string();
z__namespace.looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: z__namespace.union([z__namespace.number(), z__namespace.null()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: z__namespace.number().optional()
});
var TaskMetadataSchema = z__namespace.object({
  ttl: z__namespace.number().optional()
});
var RelatedTaskMetadataSchema = z__namespace.object({
  taskId: z__namespace.string()
});
var RequestMetaSchema = z__namespace.looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = z__namespace.object({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
var isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
var RequestSchema = z__namespace.object({
  method: z__namespace.string(),
  params: BaseRequestParamsSchema.loose().optional()
});
var NotificationsParamsSchema = z__namespace.object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var NotificationSchema = z__namespace.object({
  method: z__namespace.string(),
  params: NotificationsParamsSchema.loose().optional()
});
var ResultSchema = z__namespace.looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestIdSchema = z__namespace.union([z__namespace.string(), z__namespace.number().int()]);
var JSONRPCRequestSchema = z__namespace.object({
  jsonrpc: z__namespace.literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
var JSONRPCNotificationSchema = z__namespace.object({
  jsonrpc: z__namespace.literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
var JSONRPCResultResponseSchema = z__namespace.object({
  jsonrpc: z__namespace.literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = z__namespace.object({
  jsonrpc: z__namespace.literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: z__namespace.object({
    /**
     * The error type that occurred.
     */
    code: z__namespace.number().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: z__namespace.string(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: z__namespace.unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = z__namespace.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
z__namespace.union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: z__namespace.string().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = z__namespace.object({
  /**
   * URL or data URI for the icon.
   */
  src: z__namespace.string(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: z__namespace.string().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: z__namespace.array(z__namespace.string()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: z__namespace.enum(["light", "dark"]).optional()
});
var IconsSchema = z__namespace.object({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: z__namespace.array(IconSchema).optional()
});
var BaseMetadataSchema = z__namespace.object({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: z__namespace.string(),
  /**
   * Intended for UI and end-user contexts — optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: z__namespace.string().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: z__namespace.string(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: z__namespace.string().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: z__namespace.string().optional()
});
var FormElicitationCapabilitySchema = z__namespace.intersection(z__namespace.object({
  applyDefaults: z__namespace.boolean().optional()
}), z__namespace.record(z__namespace.string(), z__namespace.unknown()));
var ElicitationCapabilitySchema = z__namespace.preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, z__namespace.intersection(z__namespace.object({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()));
var ClientTasksCapabilitySchema = z__namespace.looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: z__namespace.looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: z__namespace.looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: z__namespace.looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ServerTasksCapabilitySchema = z__namespace.looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: z__namespace.looseObject({
    /**
     * Task support for tool requests.
     */
    tools: z__namespace.looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ClientCapabilitiesSchema = z__namespace.object({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: z__namespace.record(z__namespace.string(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: z__namespace.object({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: z__namespace.object({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: z__namespace.boolean().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: z__namespace.string(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = z__namespace.object({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: z__namespace.record(z__namespace.string(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: z__namespace.object({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: z__namespace.boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: z__namespace.object({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: z__namespace.boolean().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: z__namespace.boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: z__namespace.object({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: z__namespace.boolean().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: z__namespace.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: z__namespace.string().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
var PingRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("ping"),
  params: BaseRequestParamsSchema.optional()
});
var ProgressSchema = z__namespace.object({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: z__namespace.number(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: z__namespace.optional(z__namespace.number()),
  /**
   * An optional message describing the current progress.
   */
  message: z__namespace.optional(z__namespace.string())
});
var ProgressNotificationParamsSchema = z__namespace.object({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
var TaskStatusSchema = z__namespace.enum(["working", "input_required", "completed", "failed", "cancelled"]);
var TaskSchema = z__namespace.object({
  taskId: z__namespace.string(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: z__namespace.union([z__namespace.number(), z__namespace.null()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: z__namespace.string(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: z__namespace.string(),
  pollInterval: z__namespace.optional(z__namespace.number()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: z__namespace.optional(z__namespace.string())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: z__namespace.string()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: z__namespace.string()
  })
});
ResultSchema.loose();
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: z__namespace.literal("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: z__namespace.array(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: z__namespace.string()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = z__namespace.object({
  /**
   * The URI of this resource.
   */
  uri: z__namespace.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z__namespace.optional(z__namespace.string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: z__namespace.string()
});
var Base64Schema = z__namespace.string().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var RoleSchema = z__namespace.enum(["user", "assistant"]);
var AnnotationsSchema = z__namespace.object({
  /**
   * Intended audience(s) for the resource.
   */
  audience: z__namespace.array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: z__namespace.number().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: z__namespace.iso.datetime({ offset: true }).optional()
});
var ResourceSchema = z__namespace.object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: z__namespace.string(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: z__namespace.optional(z__namespace.string()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: z__namespace.optional(z__namespace.string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.optional(z__namespace.looseObject({}))
});
var ResourceTemplateSchema = z__namespace.object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: z__namespace.string(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: z__namespace.optional(z__namespace.string()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: z__namespace.optional(z__namespace.string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.optional(z__namespace.looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: z__namespace.literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: z__namespace.array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: z__namespace.literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: z__namespace.array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: z__namespace.string()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: z__namespace.array(z__namespace.union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: z__namespace.string()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = z__namespace.object({
  /**
   * The name of the argument.
   */
  name: z__namespace.string(),
  /**
   * A human-readable description of the argument.
   */
  description: z__namespace.optional(z__namespace.string()),
  /**
   * Whether this argument must be provided.
   */
  required: z__namespace.optional(z__namespace.boolean())
});
var PromptSchema = z__namespace.object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: z__namespace.optional(z__namespace.string()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: z__namespace.optional(z__namespace.array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.optional(z__namespace.looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: z__namespace.literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: z__namespace.array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: z__namespace.string(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: z__namespace.record(z__namespace.string(), z__namespace.string()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = z__namespace.object({
  type: z__namespace.literal("text"),
  /**
   * The text content of the message.
   */
  text: z__namespace.string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var ImageContentSchema = z__namespace.object({
  type: z__namespace.literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: z__namespace.string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var AudioContentSchema = z__namespace.object({
  type: z__namespace.literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: z__namespace.string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var ToolUseContentSchema = z__namespace.object({
  type: z__namespace.literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: z__namespace.string(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: z__namespace.string(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: z__namespace.record(z__namespace.string(), z__namespace.unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var EmbeddedResourceSchema = z__namespace.object({
  type: z__namespace.literal("resource"),
  resource: z__namespace.union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: z__namespace.literal("resource_link")
});
var ContentBlockSchema = z__namespace.union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = z__namespace.object({
  role: RoleSchema,
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: z__namespace.string().optional(),
  messages: z__namespace.array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ToolAnnotationsSchema = z__namespace.object({
  /**
   * A human-readable title for the tool.
   */
  title: z__namespace.string().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: z__namespace.boolean().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: z__namespace.boolean().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: z__namespace.boolean().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: z__namespace.boolean().optional()
});
var ToolExecutionSchema = z__namespace.object({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: z__namespace.enum(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = z__namespace.object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: z__namespace.string().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: z__namespace.object({
    type: z__namespace.literal("object"),
    properties: z__namespace.record(z__namespace.string(), AssertObjectSchema).optional(),
    required: z__namespace.array(z__namespace.string()).optional()
  }).catchall(z__namespace.unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: z__namespace.object({
    type: z__namespace.literal("object"),
    properties: z__namespace.record(z__namespace.string(), AssertObjectSchema).optional(),
    required: z__namespace.array(z__namespace.string()).optional()
  }).catchall(z__namespace.unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: z__namespace.literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: z__namespace.array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: z__namespace.array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: z__namespace.boolean().optional()
});
CallToolResultSchema.or(ResultSchema.extend({
  toolResult: z__namespace.unknown()
}));
var CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: z__namespace.string(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var CallToolRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ListChangedOptionsBaseSchema = z__namespace.object({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: z__namespace.boolean().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: z__namespace.number().int().nonnegative().default(300)
});
var LoggingLevelSchema = z__namespace.enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: z__namespace.string().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: z__namespace.unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = z__namespace.object({
  /**
   * A hint for a model name.
   */
  name: z__namespace.string().optional()
});
var ModelPreferencesSchema = z__namespace.object({
  /**
   * Optional hints to use for model selection.
   */
  hints: z__namespace.array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: z__namespace.number().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: z__namespace.number().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: z__namespace.number().min(0).max(1).optional()
});
var ToolChoiceSchema = z__namespace.object({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: z__namespace.enum(["auto", "required", "none"]).optional()
});
var ToolResultContentSchema = z__namespace.object({
  type: z__namespace.literal("tool_result"),
  toolUseId: z__namespace.string().describe("The unique identifier for the corresponding tool call."),
  content: z__namespace.array(ContentBlockSchema).default([]),
  structuredContent: z__namespace.object({}).loose().optional(),
  isError: z__namespace.boolean().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var SamplingContentSchema = z__namespace.discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = z__namespace.discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = z__namespace.object({
  role: RoleSchema,
  content: z__namespace.union([SamplingMessageContentBlockSchema, z__namespace.array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: z__namespace.array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: z__namespace.string().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: z__namespace.enum(["none", "thisServer", "allServers"]).optional(),
  temperature: z__namespace.number().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: z__namespace.number().int(),
  stopSequences: z__namespace.array(z__namespace.string()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: z__namespace.array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: z__namespace.string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: z__namespace.optional(z__namespace.enum(["endTurn", "stopSequence", "maxTokens"]).or(z__namespace.string())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: z__namespace.string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: z__namespace.optional(z__namespace.enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(z__namespace.string())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: z__namespace.union([SamplingMessageContentBlockSchema, z__namespace.array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = z__namespace.object({
  type: z__namespace.literal("boolean"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  default: z__namespace.boolean().optional()
});
var StringSchemaSchema = z__namespace.object({
  type: z__namespace.literal("string"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  minLength: z__namespace.number().optional(),
  maxLength: z__namespace.number().optional(),
  format: z__namespace.enum(["email", "uri", "date", "date-time"]).optional(),
  default: z__namespace.string().optional()
});
var NumberSchemaSchema = z__namespace.object({
  type: z__namespace.enum(["number", "integer"]),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  minimum: z__namespace.number().optional(),
  maximum: z__namespace.number().optional(),
  default: z__namespace.number().optional()
});
var UntitledSingleSelectEnumSchemaSchema = z__namespace.object({
  type: z__namespace.literal("string"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  enum: z__namespace.array(z__namespace.string()),
  default: z__namespace.string().optional()
});
var TitledSingleSelectEnumSchemaSchema = z__namespace.object({
  type: z__namespace.literal("string"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  oneOf: z__namespace.array(z__namespace.object({
    const: z__namespace.string(),
    title: z__namespace.string()
  })),
  default: z__namespace.string().optional()
});
var LegacyTitledEnumSchemaSchema = z__namespace.object({
  type: z__namespace.literal("string"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  enum: z__namespace.array(z__namespace.string()),
  enumNames: z__namespace.array(z__namespace.string()).optional(),
  default: z__namespace.string().optional()
});
var SingleSelectEnumSchemaSchema = z__namespace.union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = z__namespace.object({
  type: z__namespace.literal("array"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  minItems: z__namespace.number().optional(),
  maxItems: z__namespace.number().optional(),
  items: z__namespace.object({
    type: z__namespace.literal("string"),
    enum: z__namespace.array(z__namespace.string())
  }),
  default: z__namespace.array(z__namespace.string()).optional()
});
var TitledMultiSelectEnumSchemaSchema = z__namespace.object({
  type: z__namespace.literal("array"),
  title: z__namespace.string().optional(),
  description: z__namespace.string().optional(),
  minItems: z__namespace.number().optional(),
  maxItems: z__namespace.number().optional(),
  items: z__namespace.object({
    anyOf: z__namespace.array(z__namespace.object({
      const: z__namespace.string(),
      title: z__namespace.string()
    }))
  }),
  default: z__namespace.array(z__namespace.string()).optional()
});
var MultiSelectEnumSchemaSchema = z__namespace.union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = z__namespace.union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = z__namespace.union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: z__namespace.literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: z__namespace.string(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: z__namespace.object({
    type: z__namespace.literal("object"),
    properties: z__namespace.record(z__namespace.string(), PrimitiveSchemaDefinitionSchema),
    required: z__namespace.array(z__namespace.string()).optional()
  })
});
var ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: z__namespace.literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: z__namespace.string(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: z__namespace.string(),
  /**
   * The URL that the user should navigate to.
   */
  url: z__namespace.string().url()
});
var ElicitRequestParamsSchema = z__namespace.union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: z__namespace.string()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: z__namespace.enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: z__namespace.preprocess((val) => val === null ? void 0 : val, z__namespace.record(z__namespace.string(), z__namespace.union([z__namespace.string(), z__namespace.number(), z__namespace.boolean(), z__namespace.array(z__namespace.string())])).optional())
});
var ResourceTemplateReferenceSchema = z__namespace.object({
  type: z__namespace.literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: z__namespace.string()
});
var PromptReferenceSchema = z__namespace.object({
  type: z__namespace.literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: z__namespace.string()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: z__namespace.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: z__namespace.object({
    /**
     * The name of the argument
     */
    name: z__namespace.string(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: z__namespace.string()
  }),
  context: z__namespace.object({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: z__namespace.record(z__namespace.string(), z__namespace.string()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: z__namespace.looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: z__namespace.array(z__namespace.string()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: z__namespace.optional(z__namespace.number().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: z__namespace.optional(z__namespace.boolean())
  })
});
var RootSchema = z__namespace.object({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: z__namespace.string().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: z__namespace.string().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: z__namespace.record(z__namespace.string(), z__namespace.unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: z__namespace.literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: z__namespace.array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: z__namespace.literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
z__namespace.union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
z__namespace.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
z__namespace.union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
z__namespace.union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
z__namespace.union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
z__namespace.union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport) {
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    }
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error) => {
      _onerror?.(error);
      this._onerror(error);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    for (const controller of this._requestHandlerAbortControllers.values()) {
      controller.abort();
    }
    this._requestHandlerAbortControllers.clear();
    const error = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    this.onerror?.(error);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request, extra) {
    const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error) => this._onerror(new Error(`Failed to enqueue error response: ${error}`)));
      } else {
        capturedTransport?.send(errorResponse).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted) {
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        }
        const requestOptions = { ...options, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: error.message ?? "Internal error",
          ...error["data"] !== void 0 && { data: error["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse);
      }
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options);
        yield { type: "result", result };
      } catch (error) {
        yield {
          type: "error",
          error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve4) => setTimeout(resolve4, pollInterval));
        options?.signal?.throwIfAborted();
      }
    } catch (error) {
      yield {
        type: "error",
        error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve4, reject) => {
      const earlyReject = (error) => {
        reject(error);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options?.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...request.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => this._onerror(new Error(`Failed to send cancellation: ${error2}`)));
        const error = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (options?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve4(parseResult.data);
          }
        } catch (error) {
          reject(error);
        }
      });
      options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve4, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve4, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
};
function isPlainObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === void 0)
      continue;
    const baseValue = result[k];
    if (isPlainObject(baseValue) && isPlainObject(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv());
var import_ajv_formats = __toESM(require_dist());
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
var ExperimentalClientTasks = class {
  constructor(_client) {
    this._client = _client;
  }
  /**
   * Calls a tool and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to tool execution, allowing you to
   * observe intermediate task status updates for long-running tool calls.
   * Automatically validates structured output if the tool has an outputSchema.
   *
   * @example
   * ```typescript
   * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Tool execution started:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Tool status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Tool result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Tool error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @param params - Tool call parameters (name and arguments)
   * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      // We check if the tool is known to be a task during auto-configuration, but assume
      // the caller knows what they're doing if they pass this explicitly
      task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : void 0)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error) {
            if (error instanceof McpError) {
              yield { type: "error", error };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._client.requestStream(request, resultSchema, options);
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== void 0) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== void 0;
  const hasUrlCapability = capabilities.url !== void 0;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
var Client = class extends Protocol {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
    this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
    this._listChangedDebounceTimers = /* @__PURE__ */ new Map();
    this._capabilities = options?.capabilities ?? {};
    this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
    if (options?.listChanged) {
      this._pendingListChangedConfig = options.listChanged;
    }
  }
  /**
   * Set up handlers for list changed notifications based on config and server capabilities.
   * This should only be called after initialization when server capabilities are known.
   * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
   * @internal
   */
  _setupListChangedHandlers(config) {
    if (config.tools && this._serverCapabilities?.tools?.listChanged) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config.prompts && this._serverCapabilities?.prompts?.listChanged) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config.resources && this._serverCapabilities?.resources?.listChanged) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce client-side validation for elicitation.
   */
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse2(ElicitRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse2(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : void 0;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if (this._capabilities.elicitation?.form?.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {
            }
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse2(CreateMessageRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const hasTools = params.tools || params.toolChoice;
        const resultSchema = hasTools ? CreateMessageResultWithToolsSchema : CreateMessageResultSchema;
        const validationResult = safeParse2(resultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapability(capability, method) {
    if (!this._serverCapabilities?.[capability]) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = void 0;
      }
    } catch (error) {
      void this.close();
      throw error;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!this._serverCapabilities?.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
    }
  }
  assertTaskCapability(method) {
    assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  /**
   * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
   *
   * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
   */
  async callTool(params, resultSchema = CallToolResultSchema, options) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  /**
   * Check if a tool requires task-based execution.
   * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
   */
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  /**
   * Cache validators for tool output schemas.
   * Called after listTools() to pre-compile validators for better performance.
   */
  cacheToolMetadata(tools) {
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = tool.execution?.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  /**
   * Get cached validator for a tool
   */
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  /**
   * Set up a single list changed handler.
   * @internal
   */
  _setupListChangedHandler(listType, notificationSchema, options, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items = await fetcher();
        onChanged(null, items);
      } catch (e) {
        const error = e instanceof Error ? e : new Error(String(e));
        onChanged(error, null);
      }
    };
    const handler = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf("\n");
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + "\n";
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var DEFAULT_INHERITED_ENV_VARS = process2__default.default.platform === "win32" ? [
  "APPDATA",
  "HOMEDRIVE",
  "HOMEPATH",
  "LOCALAPPDATA",
  "PATH",
  "PROCESSOR_ARCHITECTURE",
  "SYSTEMDRIVE",
  "SYSTEMROOT",
  "TEMP",
  "USERNAME",
  "USERPROFILE",
  "PROGRAMFILES"
] : (
  /* list inspired by the default env inheritance of sudo */
  ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
);
function getDefaultEnvironment() {
  const env = {};
  for (const key of DEFAULT_INHERITED_ENV_VARS) {
    const value = process2__default.default.env[key];
    if (value === void 0) {
      continue;
    }
    if (value.startsWith("()")) {
      continue;
    }
    env[key] = value;
  }
  return env;
}
var StdioClientTransport = class {
  constructor(server) {
    this._readBuffer = new ReadBuffer();
    this._stderrStream = null;
    this._serverParams = server;
    if (server.stderr === "pipe" || server.stderr === "overlapped") {
      this._stderrStream = new stream.PassThrough();
    }
  }
  /**
   * Starts the server process and prepares to communicate with it.
   */
  async start() {
    if (this._process) {
      throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return new Promise((resolve4, reject) => {
      this._process = spawn__default.default(this._serverParams.command, this._serverParams.args ?? [], {
        // merge default env with server env because mcp server needs some env vars
        env: {
          ...getDefaultEnvironment(),
          ...this._serverParams.env
        },
        stdio: ["pipe", "pipe", this._serverParams.stderr ?? "inherit"],
        shell: false,
        windowsHide: process2__default.default.platform === "win32" && isElectron(),
        cwd: this._serverParams.cwd
      });
      this._process.on("error", (error) => {
        reject(error);
        this.onerror?.(error);
      });
      this._process.on("spawn", () => {
        resolve4();
      });
      this._process.on("close", (_code) => {
        this._process = void 0;
        this.onclose?.();
      });
      this._process.stdin?.on("error", (error) => {
        this.onerror?.(error);
      });
      this._process.stdout?.on("data", (chunk) => {
        this._readBuffer.append(chunk);
        this.processReadBuffer();
      });
      this._process.stdout?.on("error", (error) => {
        this.onerror?.(error);
      });
      if (this._stderrStream && this._process.stderr) {
        this._process.stderr.pipe(this._stderrStream);
      }
    });
  }
  /**
   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
   *
   * If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to
   * attach listeners before the start method is invoked. This prevents loss of any early
   * error output emitted by the child process.
   */
  get stderr() {
    if (this._stderrStream) {
      return this._stderrStream;
    }
    return this._process?.stderr ?? null;
  }
  /**
   * The child process pid spawned by this transport.
   *
   * This is only available after the transport has been started.
   */
  get pid() {
    return this._process?.pid ?? null;
  }
  processReadBuffer() {
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        this.onmessage?.(message);
      } catch (error) {
        this.onerror?.(error);
      }
    }
  }
  async close() {
    if (this._process) {
      const processToClose = this._process;
      this._process = void 0;
      const closePromise = new Promise((resolve4) => {
        processToClose.once("close", () => {
          resolve4();
        });
      });
      try {
        processToClose.stdin?.end();
      } catch {
      }
      await Promise.race([closePromise, new Promise((resolve4) => setTimeout(resolve4, 2e3).unref())]);
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGTERM");
        } catch {
        }
        await Promise.race([closePromise, new Promise((resolve4) => setTimeout(resolve4, 2e3).unref())]);
      }
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGKILL");
        } catch {
        }
      }
    }
    this._readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve4) => {
      if (!this._process?.stdin) {
        throw new Error("Not connected");
      }
      const json = serializeMessage(message);
      if (this._process.stdin.write(json)) {
        resolve4();
      } else {
        this._process.stdin.once("drain", resolve4);
      }
    });
  }
};
function isElectron() {
  return "type" in process2__default.default;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/transport.js
function normalizeHeaders(headers) {
  if (!headers)
    return {};
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return { ...headers };
}
function createFetchWithInit(baseFetch = fetch, baseInit) {
  if (!baseInit) {
    return baseFetch;
  }
  return async (url2, init) => {
    const mergedInit = {
      ...baseInit,
      ...init,
      // Headers need special handling - merge instead of replace
      headers: init?.headers ? { ...normalizeHeaders(baseInit.headers), ...normalizeHeaders(init.headers) } : baseInit.headers
    };
    return baseFetch(url2, mergedInit);
  };
}

// node_modules/pkce-challenge/dist/index.node.js
var crypto4;
crypto4 = globalThis.crypto?.webcrypto ?? // Node.js [18-16] REPL
globalThis.crypto ?? // Node.js >18
import('crypto').then((m) => m.webcrypto);
async function getRandomValues(size) {
  return (await crypto4).getRandomValues(new Uint8Array(size));
}
async function random(size) {
  const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;
  let result = "";
  while (result.length < size) {
    const randomBytes4 = await getRandomValues(size - result.length);
    for (const randomByte of randomBytes4) {
      if (randomByte < evenDistCutoff) {
        result += mask[randomByte % mask.length];
      }
    }
  }
  return result;
}
async function generateVerifier(length) {
  return await random(length);
}
async function generateChallenge(code_verifier) {
  const buffer = await (await crypto4).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
  return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
  if (!length)
    length = 43;
  if (length < 43 || length > 128) {
    throw `Expected a length between 43 and 128. Received ${length}.`;
  }
  const verifier = await generateVerifier(length);
  const challenge = await generateChallenge(verifier);
  return {
    code_verifier: verifier,
    code_challenge: challenge
  };
}
var SafeUrlSchema = z__namespace.url().superRefine((val, ctx) => {
  if (!URL.canParse(val)) {
    ctx.addIssue({
      code: z__namespace.ZodIssueCode.custom,
      message: "URL must be parseable",
      fatal: true
    });
    return z__namespace.NEVER;
  }
}).refine((url2) => {
  const u = new URL(url2);
  return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
var OAuthProtectedResourceMetadataSchema = z__namespace.looseObject({
  resource: z__namespace.string().url(),
  authorization_servers: z__namespace.array(SafeUrlSchema).optional(),
  jwks_uri: z__namespace.string().url().optional(),
  scopes_supported: z__namespace.array(z__namespace.string()).optional(),
  bearer_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  resource_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  resource_name: z__namespace.string().optional(),
  resource_documentation: z__namespace.string().optional(),
  resource_policy_uri: z__namespace.string().url().optional(),
  resource_tos_uri: z__namespace.string().url().optional(),
  tls_client_certificate_bound_access_tokens: z__namespace.boolean().optional(),
  authorization_details_types_supported: z__namespace.array(z__namespace.string()).optional(),
  dpop_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  dpop_bound_access_tokens_required: z__namespace.boolean().optional()
});
var OAuthMetadataSchema = z__namespace.looseObject({
  issuer: z__namespace.string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: z__namespace.array(z__namespace.string()).optional(),
  response_types_supported: z__namespace.array(z__namespace.string()),
  response_modes_supported: z__namespace.array(z__namespace.string()).optional(),
  grant_types_supported: z__namespace.array(z__namespace.string()).optional(),
  token_endpoint_auth_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  service_documentation: SafeUrlSchema.optional(),
  revocation_endpoint: SafeUrlSchema.optional(),
  revocation_endpoint_auth_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  introspection_endpoint: z__namespace.string().optional(),
  introspection_endpoint_auth_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  code_challenge_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  client_id_metadata_document_supported: z__namespace.boolean().optional()
});
var OpenIdProviderMetadataSchema = z__namespace.looseObject({
  issuer: z__namespace.string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  userinfo_endpoint: SafeUrlSchema.optional(),
  jwks_uri: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: z__namespace.array(z__namespace.string()).optional(),
  response_types_supported: z__namespace.array(z__namespace.string()),
  response_modes_supported: z__namespace.array(z__namespace.string()).optional(),
  grant_types_supported: z__namespace.array(z__namespace.string()).optional(),
  acr_values_supported: z__namespace.array(z__namespace.string()).optional(),
  subject_types_supported: z__namespace.array(z__namespace.string()),
  id_token_signing_alg_values_supported: z__namespace.array(z__namespace.string()),
  id_token_encryption_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  id_token_encryption_enc_values_supported: z__namespace.array(z__namespace.string()).optional(),
  userinfo_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  userinfo_encryption_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  userinfo_encryption_enc_values_supported: z__namespace.array(z__namespace.string()).optional(),
  request_object_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  request_object_encryption_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  request_object_encryption_enc_values_supported: z__namespace.array(z__namespace.string()).optional(),
  token_endpoint_auth_methods_supported: z__namespace.array(z__namespace.string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: z__namespace.array(z__namespace.string()).optional(),
  display_values_supported: z__namespace.array(z__namespace.string()).optional(),
  claim_types_supported: z__namespace.array(z__namespace.string()).optional(),
  claims_supported: z__namespace.array(z__namespace.string()).optional(),
  service_documentation: z__namespace.string().optional(),
  claims_locales_supported: z__namespace.array(z__namespace.string()).optional(),
  ui_locales_supported: z__namespace.array(z__namespace.string()).optional(),
  claims_parameter_supported: z__namespace.boolean().optional(),
  request_parameter_supported: z__namespace.boolean().optional(),
  request_uri_parameter_supported: z__namespace.boolean().optional(),
  require_request_uri_registration: z__namespace.boolean().optional(),
  op_policy_uri: SafeUrlSchema.optional(),
  op_tos_uri: SafeUrlSchema.optional(),
  client_id_metadata_document_supported: z__namespace.boolean().optional()
});
var OpenIdProviderDiscoveryMetadataSchema = z__namespace.object({
  ...OpenIdProviderMetadataSchema.shape,
  ...OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
  }).shape
});
var OAuthTokensSchema = z__namespace.object({
  access_token: z__namespace.string(),
  id_token: z__namespace.string().optional(),
  // Optional for OAuth 2.1, but necessary in OpenID Connect
  token_type: z__namespace.string(),
  expires_in: z__namespace.coerce.number().optional(),
  scope: z__namespace.string().optional(),
  refresh_token: z__namespace.string().optional()
}).strip();
var OAuthErrorResponseSchema = z__namespace.object({
  error: z__namespace.string(),
  error_description: z__namespace.string().optional(),
  error_uri: z__namespace.string().optional()
});
var OptionalSafeUrlSchema = SafeUrlSchema.optional().or(z__namespace.literal("").transform(() => void 0));
var OAuthClientMetadataSchema = z__namespace.object({
  redirect_uris: z__namespace.array(SafeUrlSchema),
  token_endpoint_auth_method: z__namespace.string().optional(),
  grant_types: z__namespace.array(z__namespace.string()).optional(),
  response_types: z__namespace.array(z__namespace.string()).optional(),
  client_name: z__namespace.string().optional(),
  client_uri: SafeUrlSchema.optional(),
  logo_uri: OptionalSafeUrlSchema,
  scope: z__namespace.string().optional(),
  contacts: z__namespace.array(z__namespace.string()).optional(),
  tos_uri: OptionalSafeUrlSchema,
  policy_uri: z__namespace.string().optional(),
  jwks_uri: SafeUrlSchema.optional(),
  jwks: z__namespace.any().optional(),
  software_id: z__namespace.string().optional(),
  software_version: z__namespace.string().optional(),
  software_statement: z__namespace.string().optional()
}).strip();
var OAuthClientInformationSchema = z__namespace.object({
  client_id: z__namespace.string(),
  client_secret: z__namespace.string().optional(),
  client_id_issued_at: z__namespace.number().optional(),
  client_secret_expires_at: z__namespace.number().optional()
}).strip();
var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
z__namespace.object({
  error: z__namespace.string(),
  error_description: z__namespace.string().optional()
}).strip();
z__namespace.object({
  token: z__namespace.string(),
  token_type_hint: z__namespace.string().optional()
}).strip();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
function resourceUrlFromServerUrl(url2) {
  const resourceURL = typeof url2 === "string" ? new URL(url2) : new URL(url2.href);
  resourceURL.hash = "";
  return resourceURL;
}
function checkResourceAllowed({ requestedResource, configuredResource }) {
  const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
  const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
  if (requested.origin !== configured.origin) {
    return false;
  }
  if (requested.pathname.length < configured.pathname.length) {
    return false;
  }
  const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
  const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
  return requestedPath.startsWith(configuredPath);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js
var OAuthError = class extends Error {
  constructor(message, errorUri) {
    super(message);
    this.errorUri = errorUri;
    this.name = this.constructor.name;
  }
  /**
   * Converts the error to a standard OAuth error response object
   */
  toResponseObject() {
    const response = {
      error: this.errorCode,
      error_description: this.message
    };
    if (this.errorUri) {
      response.error_uri = this.errorUri;
    }
    return response;
  }
  get errorCode() {
    return this.constructor.errorCode;
  }
};
var InvalidRequestError = class extends OAuthError {
};
InvalidRequestError.errorCode = "invalid_request";
var InvalidClientError = class extends OAuthError {
};
InvalidClientError.errorCode = "invalid_client";
var InvalidGrantError = class extends OAuthError {
};
InvalidGrantError.errorCode = "invalid_grant";
var UnauthorizedClientError = class extends OAuthError {
};
UnauthorizedClientError.errorCode = "unauthorized_client";
var UnsupportedGrantTypeError = class extends OAuthError {
};
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
var InvalidScopeError = class extends OAuthError {
};
InvalidScopeError.errorCode = "invalid_scope";
var AccessDeniedError = class extends OAuthError {
};
AccessDeniedError.errorCode = "access_denied";
var ServerError = class extends OAuthError {
};
ServerError.errorCode = "server_error";
var TemporarilyUnavailableError = class extends OAuthError {
};
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
var UnsupportedResponseTypeError = class extends OAuthError {
};
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
var UnsupportedTokenTypeError = class extends OAuthError {
};
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
var InvalidTokenError = class extends OAuthError {
};
InvalidTokenError.errorCode = "invalid_token";
var MethodNotAllowedError = class extends OAuthError {
};
MethodNotAllowedError.errorCode = "method_not_allowed";
var TooManyRequestsError = class extends OAuthError {
};
TooManyRequestsError.errorCode = "too_many_requests";
var InvalidClientMetadataError = class extends OAuthError {
};
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
var InsufficientScopeError = class extends OAuthError {
};
InsufficientScopeError.errorCode = "insufficient_scope";
var InvalidTargetError = class extends OAuthError {
};
InvalidTargetError.errorCode = "invalid_target";
var OAUTH_ERRORS = {
  [InvalidRequestError.errorCode]: InvalidRequestError,
  [InvalidClientError.errorCode]: InvalidClientError,
  [InvalidGrantError.errorCode]: InvalidGrantError,
  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
  [InvalidScopeError.errorCode]: InvalidScopeError,
  [AccessDeniedError.errorCode]: AccessDeniedError,
  [ServerError.errorCode]: ServerError,
  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
  [InvalidTokenError.errorCode]: InvalidTokenError,
  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
  [TooManyRequestsError.errorCode]: TooManyRequestsError,
  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
  [InsufficientScopeError.errorCode]: InsufficientScopeError,
  [InvalidTargetError.errorCode]: InvalidTargetError
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
var UnauthorizedError = class extends Error {
  constructor(message) {
    super(message ?? "Unauthorized");
  }
};
function isClientAuthMethod(method) {
  return ["client_secret_basic", "client_secret_post", "none"].includes(method);
}
var AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
var AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
function selectClientAuthMethod(clientInformation, supportedMethods) {
  const hasClientSecret = clientInformation.client_secret !== void 0;
  if (supportedMethods.length === 0) {
    return hasClientSecret ? "client_secret_post" : "none";
  }
  if ("token_endpoint_auth_method" in clientInformation && clientInformation.token_endpoint_auth_method && isClientAuthMethod(clientInformation.token_endpoint_auth_method) && supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {
    return clientInformation.token_endpoint_auth_method;
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
    return "client_secret_basic";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
    return "client_secret_post";
  }
  if (supportedMethods.includes("none")) {
    return "none";
  }
  return hasClientSecret ? "client_secret_post" : "none";
}
function applyClientAuthentication(method, clientInformation, headers, params) {
  const { client_id, client_secret } = clientInformation;
  switch (method) {
    case "client_secret_basic":
      applyBasicAuth(client_id, client_secret, headers);
      return;
    case "client_secret_post":
      applyPostAuth(client_id, client_secret, params);
      return;
    case "none":
      applyPublicAuth(client_id, params);
      return;
    default:
      throw new Error(`Unsupported client authentication method: ${method}`);
  }
}
function applyBasicAuth(clientId, clientSecret, headers) {
  if (!clientSecret) {
    throw new Error("client_secret_basic authentication requires a client_secret");
  }
  const credentials = btoa(`${clientId}:${clientSecret}`);
  headers.set("Authorization", `Basic ${credentials}`);
}
function applyPostAuth(clientId, clientSecret, params) {
  params.set("client_id", clientId);
  if (clientSecret) {
    params.set("client_secret", clientSecret);
  }
}
function applyPublicAuth(clientId, params) {
  params.set("client_id", clientId);
}
async function parseErrorResponse(input) {
  const statusCode = input instanceof Response ? input.status : void 0;
  const body = input instanceof Response ? await input.text() : input;
  try {
    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
    const { error, error_description, error_uri } = result;
    const errorClass = OAUTH_ERRORS[error] || ServerError;
    return new errorClass(error_description || "", error_uri);
  } catch (error) {
    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
    return new ServerError(errorMessage);
  }
}
async function auth(provider, options) {
  try {
    return await authInternal(provider, options);
  } catch (error) {
    if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {
      await provider.invalidateCredentials?.("all");
      return await authInternal(provider, options);
    } else if (error instanceof InvalidGrantError) {
      await provider.invalidateCredentials?.("tokens");
      return await authInternal(provider, options);
    }
    throw error;
  }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
  let resourceMetadata;
  let authorizationServerUrl;
  try {
    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
      authorizationServerUrl = resourceMetadata.authorization_servers[0];
    }
  } catch {
  }
  if (!authorizationServerUrl) {
    authorizationServerUrl = new URL("/", serverUrl);
  }
  const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
  const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
    fetchFn
  });
  let clientInformation = await Promise.resolve(provider.clientInformation());
  if (!clientInformation) {
    if (authorizationCode !== void 0) {
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    }
    const supportsUrlBasedClientId = metadata?.client_id_metadata_document_supported === true;
    const clientMetadataUrl = provider.clientMetadataUrl;
    if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {
      throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);
    }
    const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;
    if (shouldUseUrlBasedClientId) {
      clientInformation = {
        client_id: clientMetadataUrl
      };
      await provider.saveClientInformation?.(clientInformation);
    } else {
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata,
        clientMetadata: provider.clientMetadata,
        fetchFn
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
  }
  const nonInteractiveFlow = !provider.redirectUrl;
  if (authorizationCode !== void 0 || nonInteractiveFlow) {
    const tokens2 = await fetchToken(provider, authorizationServerUrl, {
      metadata,
      resource,
      authorizationCode,
      fetchFn
    });
    await provider.saveTokens(tokens2);
    return "AUTHORIZED";
  }
  const tokens = await provider.tokens();
  if (tokens?.refresh_token) {
    try {
      const newTokens = await refreshAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        refreshToken: tokens.refresh_token,
        resource,
        addClientAuthentication: provider.addClientAuthentication,
        fetchFn
      });
      await provider.saveTokens(newTokens);
      return "AUTHORIZED";
    } catch (error) {
      if (!(error instanceof OAuthError) || error instanceof ServerError) ; else {
        throw error;
      }
    }
  }
  const state = provider.state ? await provider.state() : void 0;
  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
    metadata,
    clientInformation,
    state,
    redirectUrl: provider.redirectUrl,
    scope: scope || resourceMetadata?.scopes_supported?.join(" ") || provider.clientMetadata.scope,
    resource
  });
  await provider.saveCodeVerifier(codeVerifier);
  await provider.redirectToAuthorization(authorizationUrl);
  return "REDIRECT";
}
function isHttpsUrl(value) {
  if (!value)
    return false;
  try {
    const url2 = new URL(value);
    return url2.protocol === "https:" && url2.pathname !== "/";
  } catch {
    return false;
  }
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
  const defaultResource = resourceUrlFromServerUrl(serverUrl);
  if (provider.validateResourceURL) {
    return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);
  }
  if (!resourceMetadata) {
    return void 0;
  }
  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
  }
  return new URL(resourceMetadata.resource);
}
function extractWWWAuthenticateParams(res) {
  const authenticateHeader = res.headers.get("WWW-Authenticate");
  if (!authenticateHeader) {
    return {};
  }
  const [type, scheme] = authenticateHeader.split(" ");
  if (type.toLowerCase() !== "bearer" || !scheme) {
    return {};
  }
  const resourceMetadataMatch = extractFieldFromWwwAuth(res, "resource_metadata") || void 0;
  let resourceMetadataUrl;
  if (resourceMetadataMatch) {
    try {
      resourceMetadataUrl = new URL(resourceMetadataMatch);
    } catch {
    }
  }
  const scope = extractFieldFromWwwAuth(res, "scope") || void 0;
  const error = extractFieldFromWwwAuth(res, "error") || void 0;
  return {
    resourceMetadataUrl,
    scope,
    error
  };
}
function extractFieldFromWwwAuth(response, fieldName) {
  const wwwAuthHeader = response.headers.get("WWW-Authenticate");
  if (!wwwAuthHeader) {
    return null;
  }
  const pattern = new RegExp(`${fieldName}=(?:"([^"]+)"|([^\\s,]+))`);
  const match = wwwAuthHeader.match(pattern);
  if (match) {
    return match[1] || match[2];
  }
  return null;
}
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
  const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
    protocolVersion: opts?.protocolVersion,
    metadataUrl: opts?.resourceMetadataUrl
  });
  if (!response || response.status === 404) {
    await response?.body?.cancel();
    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
  }
  if (!response.ok) {
    await response.body?.cancel();
    throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
  }
  return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
async function fetchWithCorsRetry(url2, headers, fetchFn = fetch) {
  try {
    return await fetchFn(url2, { headers });
  } catch (error) {
    if (error instanceof TypeError) {
      if (headers) {
        return fetchWithCorsRetry(url2, void 0, fetchFn);
      } else {
        return void 0;
      }
    }
    throw error;
  }
}
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
async function tryMetadataDiscovery(url2, protocolVersion, fetchFn = fetch) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion
  };
  return await fetchWithCorsRetry(url2, headers, fetchFn);
}
function shouldAttemptFallback(response, pathname) {
  return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
  const issuer = new URL(serverUrl);
  const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;
  let url2;
  if (opts?.metadataUrl) {
    url2 = new URL(opts.metadataUrl);
  } else {
    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
    url2 = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);
    url2.search = issuer.search;
  }
  let response = await tryMetadataDiscovery(url2, protocolVersion, fetchFn);
  if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {
    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
  }
  return response;
}
function buildDiscoveryUrls(authorizationServerUrl) {
  const url2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url2.pathname !== "/";
  const urlsToTry = [];
  if (!hasPath) {
    urlsToTry.push({
      url: new URL("/.well-known/oauth-authorization-server", url2.origin),
      type: "oauth"
    });
    urlsToTry.push({
      url: new URL(`/.well-known/openid-configuration`, url2.origin),
      type: "oidc"
    });
    return urlsToTry;
  }
  let pathname = url2.pathname;
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  urlsToTry.push({
    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url2.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL(`/.well-known/openid-configuration${pathname}`, url2.origin),
    type: "oidc"
  });
  urlsToTry.push({
    url: new URL(`${pathname}/.well-known/openid-configuration`, url2.origin),
    type: "oidc"
  });
  return urlsToTry;
}
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion,
    Accept: "application/json"
  };
  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
  for (const { url: endpointUrl, type } of urlsToTry) {
    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
    if (!response) {
      continue;
    }
    if (!response.ok) {
      await response.body?.cancel();
      if (response.status >= 400 && response.status < 500) {
        continue;
      }
      throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
    }
    if (type === "oauth") {
      return OAuthMetadataSchema.parse(await response.json());
    } else {
      return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
  }
  return void 0;
}
async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
  let authorizationUrl;
  if (metadata) {
    authorizationUrl = new URL(metadata.authorization_endpoint);
    if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
      throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
    }
    if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
      throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    }
  } else {
    authorizationUrl = new URL("/authorize", authorizationServerUrl);
  }
  const challenge = await pkceChallenge();
  const codeVerifier = challenge.code_verifier;
  const codeChallenge = challenge.code_challenge;
  authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
  authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
  authorizationUrl.searchParams.set("code_challenge", codeChallenge);
  authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
  authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
  if (state) {
    authorizationUrl.searchParams.set("state", state);
  }
  if (scope) {
    authorizationUrl.searchParams.set("scope", scope);
  }
  if (scope?.includes("offline_access")) {
    authorizationUrl.searchParams.append("prompt", "consent");
  }
  if (resource) {
    authorizationUrl.searchParams.set("resource", resource.href);
  }
  return { authorizationUrl, codeVerifier };
}
function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {
  return new URLSearchParams({
    grant_type: "authorization_code",
    code: authorizationCode,
    code_verifier: codeVerifier,
    redirect_uri: String(redirectUri)
  });
}
async function executeTokenRequest(authorizationServerUrl, { metadata, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {
  const tokenUrl = metadata?.token_endpoint ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  });
  if (resource) {
    tokenRequestParams.set("resource", resource.href);
  }
  if (addClientAuthentication) {
    await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata);
  } else if (clientInformation) {
    const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);
  }
  const response = await (fetchFn ?? fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: tokenRequestParams
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse(await response.json());
}
async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
  const tokenRequestParams = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: refreshToken
  });
  const tokens = await executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation,
    addClientAuthentication,
    resource,
    fetchFn
  });
  return { refresh_token: refreshToken, ...tokens };
}
async function fetchToken(provider, authorizationServerUrl, { metadata, resource, authorizationCode, fetchFn } = {}) {
  const scope = provider.clientMetadata.scope;
  let tokenRequestParams;
  if (provider.prepareTokenRequest) {
    tokenRequestParams = await provider.prepareTokenRequest(scope);
  }
  if (!tokenRequestParams) {
    if (!authorizationCode) {
      throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");
    }
    if (!provider.redirectUrl) {
      throw new Error("redirectUrl is required for authorization_code flow");
    }
    const codeVerifier = await provider.codeVerifier();
    tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);
  }
  const clientInformation = await provider.clientInformation();
  return executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation: clientInformation ?? void 0,
    addClientAuthentication: provider.addClientAuthentication,
    resource,
    fetchFn
  });
}
async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
  let registrationUrl;
  if (metadata) {
    if (!metadata.registration_endpoint) {
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    }
    registrationUrl = new URL(metadata.registration_endpoint);
  } else {
    registrationUrl = new URL("/register", authorizationServerUrl);
  }
  const response = await (fetchFn ?? fetch)(registrationUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(clientMetadata)
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthClientInformationFullSchema.parse(await response.json());
}

// node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
  initialReconnectionDelay: 1e3,
  maxReconnectionDelay: 3e4,
  reconnectionDelayGrowFactor: 1.5,
  maxRetries: 2
};
var StreamableHTTPError = class extends Error {
  constructor(code, message) {
    super(`Streamable HTTP error: ${message}`);
    this.code = code;
  }
};
var StreamableHTTPClientTransport = class {
  constructor(url2, opts) {
    this._hasCompletedAuthFlow = false;
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._requestInit = opts?.requestInit;
    this._authProvider = opts?.authProvider;
    this._fetch = opts?.fetch;
    this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
    this._sessionId = opts?.sessionId;
    this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
  }
  async _authThenStart() {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuthSse({ resumptionToken: void 0 });
  }
  async _commonHeaders() {
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._sessionId) {
      headers["mcp-session-id"] = this._sessionId;
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders(this._requestInit?.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  async _startOrAuthSse(options) {
    const { resumptionToken } = options;
    try {
      const headers = await this._commonHeaders();
      headers.set("Accept", "text/event-stream");
      if (resumptionToken) {
        headers.set("last-event-id", resumptionToken);
      }
      const response = await (this._fetch ?? fetch)(this._url, {
        method: "GET",
        headers,
        signal: this._abortController?.signal
      });
      if (!response.ok) {
        await response.body?.cancel();
        if (response.status === 401 && this._authProvider) {
          return await this._authThenStart();
        }
        if (response.status === 405) {
          return;
        }
        throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
      }
      this._handleSseStream(response.body, options, true);
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  /**
   * Calculates the next reconnection delay using  backoff algorithm
   *
   * @param attempt Current reconnection attempt count for the specific stream
   * @returns Time to wait in milliseconds before next reconnection attempt
   */
  _getNextReconnectionDelay(attempt) {
    if (this._serverRetryMs !== void 0) {
      return this._serverRetryMs;
    }
    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
  }
  /**
   * Schedule a reconnection attempt using server-provided retry interval or backoff
   *
   * @param lastEventId The ID of the last received event for resumability
   * @param attemptCount Current reconnection attempt count for this specific stream
   */
  _scheduleReconnection(options, attemptCount = 0) {
    const maxRetries = this._reconnectionOptions.maxRetries;
    if (attemptCount >= maxRetries) {
      this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
      return;
    }
    const delay = this._getNextReconnectionDelay(attemptCount);
    this._reconnectionTimeout = setTimeout(() => {
      this._startOrAuthSse(options).catch((error) => {
        this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
        this._scheduleReconnection(options, attemptCount + 1);
      });
    }, delay);
  }
  _handleSseStream(stream, options, isReconnectable) {
    if (!stream) {
      return;
    }
    const { onresumptiontoken, replayMessageId } = options;
    let lastEventId;
    let hasPrimingEvent = false;
    let receivedResponse = false;
    const processStream = async () => {
      try {
        const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream({
          onRetry: (retryMs) => {
            this._serverRetryMs = retryMs;
          }
        })).getReader();
        while (true) {
          const { value: event, done } = await reader.read();
          if (done) {
            break;
          }
          if (event.id) {
            lastEventId = event.id;
            hasPrimingEvent = true;
            onresumptiontoken?.(event.id);
          }
          if (!event.data) {
            continue;
          }
          if (!event.event || event.event === "message") {
            try {
              const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
              if (isJSONRPCResultResponse(message)) {
                receivedResponse = true;
                if (replayMessageId !== void 0) {
                  message.id = replayMessageId;
                }
              }
              this.onmessage?.(message);
            } catch (error) {
              this.onerror?.(error);
            }
          }
        }
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          this._scheduleReconnection({
            resumptionToken: lastEventId,
            onresumptiontoken,
            replayMessageId
          }, 0);
        }
      } catch (error) {
        this.onerror?.(new Error(`SSE stream disconnected: ${error}`));
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          try {
            this._scheduleReconnection({
              resumptionToken: lastEventId,
              onresumptiontoken,
              replayMessageId
            }, 0);
          } catch (error2) {
            this.onerror?.(new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
          }
        }
      }
    };
    processStream();
  }
  async start() {
    if (this._abortController) {
      throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    this._abortController = new AbortController();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    if (this._reconnectionTimeout) {
      clearTimeout(this._reconnectionTimeout);
      this._reconnectionTimeout = void 0;
    }
    this._abortController?.abort();
    this.onclose?.();
  }
  async send(message, options) {
    try {
      const { resumptionToken, onresumptiontoken } = options || {};
      if (resumptionToken) {
        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => this.onerror?.(err));
        return;
      }
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      headers.set("accept", "application/json, text/event-stream");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      const sessionId = response.headers.get("mcp-session-id");
      if (sessionId) {
        this._sessionId = sessionId;
      }
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          if (this._hasCompletedAuthFlow) {
            throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
          }
          const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          this._hasCompletedAuthFlow = true;
          return this.send(message);
        }
        if (response.status === 403 && this._authProvider) {
          const { resourceMetadataUrl, scope, error } = extractWWWAuthenticateParams(response);
          if (error === "insufficient_scope") {
            const wwwAuthHeader = response.headers.get("WWW-Authenticate");
            if (this._lastUpscopingHeader === wwwAuthHeader) {
              throw new StreamableHTTPError(403, "Server returned 403 after trying upscoping");
            }
            if (scope) {
              this._scope = scope;
            }
            if (resourceMetadataUrl) {
              this._resourceMetadataUrl = resourceMetadataUrl;
            }
            this._lastUpscopingHeader = wwwAuthHeader ?? void 0;
            const result = await auth(this._authProvider, {
              serverUrl: this._url,
              resourceMetadataUrl: this._resourceMetadataUrl,
              scope: this._scope,
              fetchFn: this._fetch
            });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
        }
        throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);
      }
      this._hasCompletedAuthFlow = false;
      this._lastUpscopingHeader = void 0;
      if (response.status === 202) {
        await response.body?.cancel();
        if (isInitializedNotification(message)) {
          this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => this.onerror?.(err));
        }
        return;
      }
      const messages = Array.isArray(message) ? message : [message];
      const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
      const contentType = response.headers.get("content-type");
      if (hasRequests) {
        if (contentType?.includes("text/event-stream")) {
          this._handleSseStream(response.body, { onresumptiontoken }, false);
        } else if (contentType?.includes("application/json")) {
          const data = await response.json();
          const responseMessages = Array.isArray(data) ? data.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data)];
          for (const msg of responseMessages) {
            this.onmessage?.(msg);
          }
        } else {
          await response.body?.cancel();
          throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
        }
      } else {
        await response.body?.cancel();
      }
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  get sessionId() {
    return this._sessionId;
  }
  /**
   * Terminates the current session by sending a DELETE request to the server.
   *
   * Clients that no longer need a particular session
   * (e.g., because the user is leaving the client application) SHOULD send an
   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
   * terminate the session.
   *
   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
   * the server does not allow clients to terminate sessions.
   */
  async terminateSession() {
    if (!this._sessionId) {
      return;
    }
    try {
      const headers = await this._commonHeaders();
      const init = {
        ...this._requestInit,
        method: "DELETE",
        headers,
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      await response.body?.cancel();
      if (!response.ok && response.status !== 405) {
        throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
      }
      this._sessionId = void 0;
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  setProtocolVersion(version) {
    this._protocolVersion = version;
  }
  get protocolVersion() {
    return this._protocolVersion;
  }
  /**
   * Resume an SSE stream from a previous event ID.
   * Opens a GET SSE connection with Last-Event-ID header to replay missed events.
   *
   * @param lastEventId The event ID to resume from
   * @param options Optional callback to receive new resumption tokens
   */
  async resumeStream(lastEventId, options) {
    await this._startOrAuthSse({
      resumptionToken: lastEventId,
      onresumptiontoken: options?.onresumptiontoken
    });
  }
};

// src/domain/errors/MCPError.ts
var MCPError = class extends Error {
  constructor(message, serverName, cause) {
    super(message);
    this.serverName = serverName;
    this.cause = cause;
    this.name = "MCPError";
    if (cause) {
      this.stack = `${this.stack}
Caused by: ${cause.stack}`;
    }
  }
};
var MCPConnectionError = class extends MCPError {
  constructor(message, serverName, cause) {
    super(message, serverName, cause);
    this.name = "MCPConnectionError";
  }
};
var MCPTimeoutError = class extends MCPError {
  constructor(message, timeoutMs, serverName, cause) {
    super(message, serverName, cause);
    this.timeoutMs = timeoutMs;
    this.name = "MCPTimeoutError";
  }
};
var MCPProtocolError = class extends MCPError {
  constructor(message, serverName, cause) {
    super(message, serverName, cause);
    this.name = "MCPProtocolError";
  }
};
var MCPToolError = class extends MCPError {
  constructor(message, toolName, serverName, cause) {
    super(message, serverName, cause);
    this.toolName = toolName;
    this.name = "MCPToolError";
  }
};
var MCPResourceError = class extends MCPError {
  constructor(message, resourceUri, serverName, cause) {
    super(message, serverName, cause);
    this.resourceUri = resourceUri;
    this.name = "MCPResourceError";
  }
};

// src/domain/entities/MCPConfig.ts
function applyServerDefaults(config, defaults) {
  return {
    name: config.name,
    displayName: config.displayName,
    description: config.description,
    transport: config.transport,
    transportConfig: config.transportConfig,
    autoConnect: config.autoConnect ?? defaults?.autoConnect ?? false,
    autoReconnect: config.autoReconnect ?? defaults?.autoReconnect ?? true,
    reconnectIntervalMs: config.reconnectIntervalMs ?? defaults?.reconnectIntervalMs ?? 5e3,
    maxReconnectAttempts: config.maxReconnectAttempts ?? defaults?.maxReconnectAttempts ?? 10,
    requestTimeoutMs: config.requestTimeoutMs ?? defaults?.requestTimeoutMs ?? 3e4,
    healthCheckIntervalMs: config.healthCheckIntervalMs ?? defaults?.healthCheckIntervalMs ?? 6e4,
    toolNamespace: config.toolNamespace ?? `mcp:${config.name}`,
    permissions: config.permissions,
    connectorBindings: config.connectorBindings
  };
}

// src/utils/sanitize.ts
function sanitizeToolName(name) {
  let result = name.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^[_-]+|[_-]+$/g, "");
  if (/^[0-9]/.test(result)) {
    result = `n_${result}`;
  }
  return result || "unnamed";
}

// src/infrastructure/mcp/adapters/MCPToolAdapter.ts
function createMCPToolAdapter(tool, client, namespace) {
  const fullName = sanitizeToolName(`${namespace}:${tool.name}`);
  return {
    definition: {
      type: "function",
      function: {
        name: fullName,
        description: tool.description || `MCP tool '${tool.name}' from server '${client.name}'`,
        parameters: tool.inputSchema
      }
    },
    async execute(args) {
      try {
        const result = await client.callTool(tool.name, args);
        if (result.content?.length === 1 && result.content[0]?.type === "text") {
          return result.content[0].text ?? "";
        }
        return result;
      } catch (error) {
        if (error instanceof MCPToolError) {
          throw error;
        }
        throw new MCPToolError(
          `Failed to execute MCP tool '${tool.name}'`,
          tool.name,
          client.name,
          error
        );
      }
    },
    describeCall(args) {
      const commonKeys = [
        "file_path",
        "path",
        "uri",
        "url",
        "query",
        "message",
        "name",
        "id",
        "key"
      ];
      for (const key of commonKeys) {
        if (key in args && typeof args[key] === "string") {
          return args[key];
        }
      }
      for (const value of Object.values(args)) {
        if (typeof value === "string" && value.length > 0) {
          return value.length > 60 ? `${value.substring(0, 60)}...` : value;
        }
      }
      return tool.name;
    }
  };
}
function createMCPToolAdapters(tools, client, namespace) {
  return tools.map((tool) => createMCPToolAdapter(tool, client, namespace));
}

// src/core/mcp/MCPClient.ts
var MCPClient = class extends eventemitter3.EventEmitter {
  name;
  config;
  client = null;
  transport = null;
  _state = "disconnected";
  _capabilities;
  _tools = [];
  reconnectAttempts = 0;
  reconnectTimer;
  healthCheckTimer;
  subscribedResources = /* @__PURE__ */ new Set();
  registeredToolNames = /* @__PURE__ */ new Set();
  _isDestroyed = false;
  constructor(config, defaults) {
    super();
    this.name = config.name;
    this.config = applyServerDefaults(config, defaults);
  }
  // Getters
  get state() {
    return this._state;
  }
  get capabilities() {
    return this._capabilities;
  }
  get tools() {
    return this._tools;
  }
  // Lifecycle methods
  async connect() {
    if (this._state === "connected" || this._state === "connecting") {
      return;
    }
    this._state = "connecting";
    this.emit("connecting");
    try {
      this.transport = this.createTransport();
      this.client = new Client(
        {
          name: "@everworker/oneringai",
          version: "0.2.0"
        },
        {
          capabilities: {
            // Request all capabilities (empty object means we support all)
          }
        }
      );
      await this.client.connect(this.transport);
      this._capabilities = {};
      this._state = "connected";
      this.reconnectAttempts = 0;
      await this.refreshTools();
      this.emit("connected");
      this.startHealthCheck();
    } catch (error) {
      this.stopHealthCheck();
      if (this.client) {
        try {
          await this.client.close();
        } catch {
        }
        this.client = null;
      }
      this.transport = null;
      this._tools = [];
      this._capabilities = void 0;
      this._state = "failed";
      const mcpError = new MCPConnectionError(
        `Failed to connect to MCP server '${this.name}'`,
        this.name,
        error
      );
      this.emit("failed", mcpError);
      this.emit("error", mcpError);
      if (this.config.autoReconnect) {
        this.scheduleReconnect();
      } else {
        throw mcpError;
      }
    }
  }
  async disconnect() {
    this.stopHealthCheck();
    this.stopReconnect();
    if (this.client && this.transport) {
      try {
        await this.client.close();
      } catch (error) {
      }
    }
    this.client = null;
    this.transport = null;
    this._state = "disconnected";
    this._tools = [];
    this.emit("disconnected");
  }
  async reconnect() {
    await this.disconnect();
    await this.connect();
  }
  isConnected() {
    return this._state === "connected";
  }
  async ping() {
    if (!this.client || !this.isConnected()) {
      return false;
    }
    try {
      await this.client.ping();
      return true;
    } catch (error) {
      return false;
    }
  }
  // Tool methods
  async listTools() {
    this.ensureConnected();
    try {
      const response = await this.client.request({ method: "tools/list" }, ListToolsResultSchema);
      this._tools = response.tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema
      }));
      return this._tools;
    } catch (error) {
      throw new MCPError(`Failed to list tools from server '${this.name}'`, this.name, error);
    }
  }
  async callTool(name, args) {
    this.ensureConnected();
    this.emit("tool:called", name, args);
    try {
      const response = await this.client.request(
        {
          method: "tools/call",
          params: {
            name,
            arguments: args
          }
        },
        CallToolResultSchema
      );
      const result = {
        content: response.content.map((item) => ({
          type: item.type,
          text: "text" in item ? item.text : void 0,
          data: "data" in item ? item.data : void 0,
          mimeType: "mimeType" in item ? item.mimeType : void 0,
          uri: "uri" in item ? item.uri : void 0
        })),
        isError: response.isError
      };
      this.emit("tool:result", name, result);
      if (result.isError) {
        const errorText = result.content.find((c) => c.type === "text")?.text || "Unknown error";
        throw new MCPToolError(errorText, name, this.name);
      }
      return result;
    } catch (error) {
      if (error instanceof MCPToolError) {
        throw error;
      }
      throw new MCPToolError(
        `Failed to call tool '${name}' on server '${this.name}'`,
        name,
        this.name,
        error
      );
    }
  }
  registerTools(toolManager) {
    this.registerToolsSelective(toolManager);
  }
  /**
   * Register specific tools with a ToolManager (selective registration)
   * @param toolManager - ToolManager to register with
   * @param toolNames - Optional array of tool names to register (original MCP names, not namespaced).
   *                    If not provided, registers all tools.
   */
  registerToolsSelective(toolManager, toolNames) {
    if (this._tools.length === 0) {
      return;
    }
    const toolsToRegister = toolNames ? this._tools.filter((t) => toolNames.includes(t.name)) : this._tools;
    if (toolsToRegister.length === 0) {
      return;
    }
    const toolFunctions = createMCPToolAdapters(toolsToRegister, this, this.config.toolNamespace);
    for (const toolFn of toolFunctions) {
      const toolName = toolFn.definition.function.name;
      toolManager.register(toolFn, {
        namespace: this.config.toolNamespace,
        enabled: true,
        permission: this.config.permissions ? {
          scope: this.config.permissions.defaultScope,
          riskLevel: this.config.permissions.defaultRiskLevel
        } : void 0
      });
      this.registeredToolNames.add(toolName);
    }
  }
  unregisterTools(toolManager) {
    for (const toolName of this.registeredToolNames) {
      toolManager.unregister(toolName);
    }
    this.registeredToolNames.clear();
  }
  // Resource methods
  async listResources() {
    this.ensureConnected();
    try {
      const response = await this.client.request({ method: "resources/list" }, ListResourcesResultSchema);
      return response.resources.map((resource) => ({
        uri: resource.uri,
        name: resource.name,
        description: resource.description,
        mimeType: resource.mimeType
      }));
    } catch (error) {
      throw new MCPError(
        `Failed to list resources from server '${this.name}'`,
        this.name,
        error
      );
    }
  }
  async readResource(uri) {
    this.ensureConnected();
    try {
      const response = await this.client.request(
        {
          method: "resources/read",
          params: { uri }
        },
        ReadResourceResultSchema
      );
      const content = response.contents?.[0];
      if (!content) {
        throw new MCPError(`No content returned for resource '${uri}'`, this.name);
      }
      return {
        uri: content.uri,
        mimeType: content.mimeType,
        text: "text" in content ? content.text : void 0,
        blob: "blob" in content ? content.blob : void 0
      };
    } catch (error) {
      throw new MCPError(
        `Failed to read resource '${uri}' from server '${this.name}'`,
        this.name,
        error
      );
    }
  }
  async subscribeResource(uri) {
    this.ensureConnected();
    if (!this._capabilities?.resources?.subscribe) {
      throw new MCPError(`Server '${this.name}' does not support resource subscriptions`, this.name);
    }
    try {
      await this.client.request(
        {
          method: "resources/subscribe",
          params: { uri }
        },
        {}
        // No specific schema for subscription acknowledgment
      );
      this.subscribedResources.add(uri);
    } catch (error) {
      throw new MCPError(
        `Failed to subscribe to resource '${uri}' on server '${this.name}'`,
        this.name,
        error
      );
    }
  }
  async unsubscribeResource(uri) {
    this.ensureConnected();
    try {
      await this.client.request(
        {
          method: "resources/unsubscribe",
          params: { uri }
        },
        {}
        // No specific schema for unsubscribe acknowledgment
      );
      this.subscribedResources.delete(uri);
    } catch (error) {
      throw new MCPError(
        `Failed to unsubscribe from resource '${uri}' on server '${this.name}'`,
        this.name,
        error
      );
    }
  }
  // Prompt methods
  async listPrompts() {
    this.ensureConnected();
    try {
      const response = await this.client.request({ method: "prompts/list" }, ListPromptsResultSchema);
      return response.prompts.map((prompt) => ({
        name: prompt.name,
        description: prompt.description,
        arguments: prompt.arguments
      }));
    } catch (error) {
      throw new MCPError(`Failed to list prompts from server '${this.name}'`, this.name, error);
    }
  }
  async getPrompt(name, args) {
    this.ensureConnected();
    try {
      const response = await this.client.request(
        {
          method: "prompts/get",
          params: {
            name,
            arguments: args
          }
        },
        GetPromptResultSchema
      );
      return {
        description: response.description,
        messages: response.messages.map((msg) => ({
          role: msg.role,
          content: {
            type: msg.content.type,
            text: "text" in msg.content ? msg.content.text : void 0,
            data: "data" in msg.content ? msg.content.data : void 0,
            mimeType: "mimeType" in msg.content ? msg.content.mimeType : void 0,
            uri: "uri" in msg.content ? msg.content.uri : void 0
          }
        }))
      };
    } catch (error) {
      throw new MCPError(
        `Failed to get prompt '${name}' from server '${this.name}'`,
        this.name,
        error
      );
    }
  }
  // State management
  getState() {
    return {
      name: this.name,
      state: this._state,
      capabilities: this._capabilities,
      subscribedResources: Array.from(this.subscribedResources),
      lastConnectedAt: this._state === "connected" ? Date.now() : void 0,
      connectionAttempts: this.reconnectAttempts
    };
  }
  loadState(state) {
    this.subscribedResources = new Set(state.subscribedResources);
    this.reconnectAttempts = state.connectionAttempts;
  }
  /**
   * Check if the MCPClient instance has been destroyed
   */
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed) return;
    this._isDestroyed = true;
    this.stopHealthCheck();
    this.stopReconnect();
    if (this.client) {
      this.client.close().catch(() => {
      });
      this.client = null;
    }
    this.transport = null;
    this._tools = [];
    this._capabilities = void 0;
    this._state = "disconnected";
    this.subscribedResources.clear();
    this.registeredToolNames.clear();
    this.removeAllListeners();
  }
  // Private helper methods
  createTransport() {
    const { transport, transportConfig } = this.config;
    if (transport === "stdio") {
      const stdioConfig = transportConfig;
      return new StdioClientTransport({
        command: stdioConfig.command,
        args: stdioConfig.args,
        env: stdioConfig.env
      });
    }
    if (transport === "http" || transport === "https") {
      const httpConfig = transportConfig;
      const headers = { ...httpConfig.headers };
      if (httpConfig.token) {
        headers["Authorization"] = `Bearer ${httpConfig.token}`;
      }
      return new StreamableHTTPClientTransport(new URL(httpConfig.url), {
        sessionId: httpConfig.sessionId,
        requestInit: {
          headers,
          ...httpConfig.timeoutMs && { signal: AbortSignal.timeout(httpConfig.timeoutMs) }
        },
        reconnectionOptions: httpConfig.reconnection ? {
          maxReconnectionDelay: httpConfig.reconnection.maxReconnectionDelay ?? 3e4,
          initialReconnectionDelay: httpConfig.reconnection.initialReconnectionDelay ?? 1e3,
          reconnectionDelayGrowFactor: httpConfig.reconnection.reconnectionDelayGrowFactor ?? 1.5,
          maxRetries: httpConfig.reconnection.maxRetries ?? 2
        } : void 0
      });
    }
    throw new MCPError(`Transport '${transport}' not supported`, this.name);
  }
  ensureConnected() {
    if (!this.client || !this.isConnected()) {
      throw new MCPConnectionError(`MCP server '${this.name}' is not connected`, this.name);
    }
  }
  async refreshTools() {
    try {
      await this.listTools();
    } catch (error) {
      this.emit("error", error);
    }
  }
  startHealthCheck() {
    if (this.config.healthCheckIntervalMs <= 0) {
      return;
    }
    this.healthCheckTimer = setInterval(async () => {
      const alive = await this.ping();
      if (!alive && this._state === "connected") {
        this.emit("error", new MCPConnectionError(`Health check failed for server '${this.name}'`, this.name));
        if (this.config.autoReconnect) {
          await this.reconnect();
        }
      }
    }, this.config.healthCheckIntervalMs);
  }
  stopHealthCheck() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = void 0;
    }
  }
  scheduleReconnect() {
    if (this.reconnectAttempts >= this.config.maxReconnectAttempts) {
      this.emit("error", new MCPConnectionError(`Max reconnect attempts reached for server '${this.name}'`, this.name));
      return;
    }
    this.reconnectAttempts++;
    this._state = "reconnecting";
    this.emit("reconnecting", this.reconnectAttempts);
    const delay = this.config.reconnectIntervalMs * Math.pow(2, this.reconnectAttempts - 1);
    this.reconnectTimer = setTimeout(async () => {
      try {
        await this.connect();
      } catch (error) {
      }
    }, delay);
  }
  stopReconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = void 0;
    }
  }
};
var MCPRegistry = class {
  static clients = /* @__PURE__ */ new Map();
  /**
   * Create and register an MCP client
   */
  static create(config, defaults) {
    if (this.clients.has(config.name)) {
      throw new MCPError(`MCP server '${config.name}' is already registered`);
    }
    const client = new MCPClient(config, defaults);
    this.clients.set(config.name, client);
    return client;
  }
  /**
   * Get a registered MCP client
   */
  static get(name) {
    const client = this.clients.get(name);
    if (!client) {
      throw new MCPError(`MCP server '${name}' not found in registry`);
    }
    return client;
  }
  /**
   * Check if an MCP client is registered
   */
  static has(name) {
    return this.clients.has(name);
  }
  /**
   * List all registered MCP client names
   */
  static list() {
    return Array.from(this.clients.keys());
  }
  /**
   * Get info about a registered MCP client
   */
  static getInfo(name) {
    const client = this.get(name);
    return {
      name: client.name,
      state: client.state,
      connected: client.isConnected(),
      toolCount: client.tools.length
    };
  }
  /**
   * Get info about all registered MCP clients
   */
  static getAllInfo() {
    return Array.from(this.clients.keys()).map((name) => this.getInfo(name));
  }
  /**
   * Create multiple clients from MCP configuration
   */
  static createFromConfig(config) {
    const clients = [];
    for (const serverConfig of config.servers) {
      const client = this.create(serverConfig, config.defaults);
      clients.push(client);
    }
    return clients;
  }
  /**
   * Load MCP configuration from file and create clients
   */
  static async loadFromConfigFile(path6) {
    try {
      const configPath = path2.resolve(path6);
      const content = await fs19.promises.readFile(configPath, "utf-8");
      const config = JSON.parse(content);
      if (!config.mcp) {
        throw new MCPError("Configuration file does not contain MCP section");
      }
      const interpolatedConfig = this.interpolateEnvVars(config.mcp);
      return this.createFromConfig(interpolatedConfig);
    } catch (error) {
      if (error instanceof MCPError) {
        throw error;
      }
      throw new MCPError(`Failed to load MCP configuration from '${path6}'`, void 0, error);
    }
  }
  /**
   * Connect all servers with autoConnect enabled
   */
  static async connectAll() {
    const connectPromises = [];
    for (const client of this.clients.values()) {
      if (!client.isConnected()) {
        connectPromises.push(client.connect());
      }
    }
    await Promise.all(connectPromises);
  }
  /**
   * Disconnect all servers
   */
  static async disconnectAll() {
    const disconnectPromises = [];
    for (const client of this.clients.values()) {
      if (client.isConnected()) {
        disconnectPromises.push(client.disconnect());
      }
    }
    await Promise.all(disconnectPromises);
  }
  /**
   * Remove and destroy a specific client from the registry
   * @param name - Name of the MCP server to remove
   * @returns true if the server was found and removed, false otherwise
   */
  static remove(name) {
    const client = this.clients.get(name);
    if (!client) {
      return false;
    }
    client.destroy();
    this.clients.delete(name);
    return true;
  }
  /**
   * Destroy all clients and clear registry
   */
  static destroyAll() {
    for (const client of this.clients.values()) {
      client.destroy();
    }
    this.clients.clear();
  }
  /**
   * Clear the registry (for testing)
   */
  static clear() {
    this.destroyAll();
  }
  /**
   * Interpolate environment variables in configuration
   * Replaces ${ENV_VAR} with process.env.ENV_VAR
   */
  static interpolateEnvVars(config) {
    const jsonString = JSON.stringify(config);
    const interpolated = jsonString.replace(/\$\{([^}]+)\}/g, (_match, envVar) => {
      const value = process.env[envVar];
      if (value === void 0) {
        throw new MCPError(`Environment variable '${envVar}' is not set`);
      }
      return value;
    });
    return JSON.parse(interpolated);
  }
};

// src/core/TextToSpeech.ts
init_Connector();

// src/infrastructure/providers/base/BaseMediaProvider.ts
init_CircuitBreaker();
init_Logger();
init_Metrics();
var BaseMediaProvider = class extends BaseProvider {
  circuitBreaker;
  logger;
  _isObservabilityInitialized = false;
  constructor(config) {
    super(config);
    this.logger = exports.logger.child({
      component: "MediaProvider",
      provider: "unknown"
    });
  }
  /**
   * Auto-initialize observability on first use (lazy initialization)
   * This is called automatically by executeWithCircuitBreaker()
   * @internal
   */
  ensureObservabilityInitialized() {
    if (this._isObservabilityInitialized) {
      return;
    }
    const providerName = this.name || "unknown";
    const cbConfig = this.config.circuitBreaker || exports.DEFAULT_CIRCUIT_BREAKER_CONFIG;
    this.circuitBreaker = new exports.CircuitBreaker(
      `media-provider:${providerName}`,
      cbConfig
    );
    this.logger = exports.logger.child({
      component: "MediaProvider",
      provider: providerName
    });
    this.circuitBreaker.on("opened", (data) => {
      this.logger.warn(data, "Circuit breaker opened");
      exports.metrics.increment("circuit_breaker.opened", 1, {
        breaker: data.name,
        provider: providerName
      });
    });
    this.circuitBreaker.on("closed", (data) => {
      this.logger.info(data, "Circuit breaker closed");
      exports.metrics.increment("circuit_breaker.closed", 1, {
        breaker: data.name,
        provider: providerName
      });
    });
    this._isObservabilityInitialized = true;
  }
  /**
   * Execute operation with circuit breaker protection
   * Automatically records metrics and handles errors
   *
   * @param operation - The async operation to execute
   * @param operationName - Name of the operation for metrics (e.g., 'image.generate', 'audio.synthesize')
   * @param metadata - Additional metadata to log/record
   */
  async executeWithCircuitBreaker(operation, operationName, metadata) {
    this.ensureObservabilityInitialized();
    const startTime = Date.now();
    const metricLabels = {
      provider: this.name,
      operation: operationName,
      ...metadata
    };
    try {
      const result = await this.circuitBreaker.execute(operation);
      const duration = Date.now() - startTime;
      exports.metrics.histogram(`${operationName}.duration`, duration, metricLabels);
      exports.metrics.increment(`${operationName}.success`, 1, metricLabels);
      this.logger.debug(
        { operation: operationName, duration, ...metadata },
        "Operation completed successfully"
      );
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      exports.metrics.increment(`${operationName}.error`, 1, {
        ...metricLabels,
        error: error instanceof Error ? error.name : "unknown"
      });
      this.logger.error(
        {
          operation: operationName,
          duration,
          error: error instanceof Error ? error.message : String(error),
          ...metadata
        },
        "Operation failed"
      );
      throw error;
    }
  }
  /**
   * Log operation start with context
   * Useful for logging before async operations
   */
  logOperationStart(operation, context) {
    this.ensureObservabilityInitialized();
    this.logger.info({ operation, ...context }, `${operation} started`);
  }
  /**
   * Log operation completion with context
   */
  logOperationComplete(operation, context) {
    this.ensureObservabilityInitialized();
    this.logger.info({ operation, ...context }, `${operation} completed`);
  }
};

// src/domain/entities/SharedVoices.ts
var OPENAI_VOICES = [
  { id: "alloy", name: "Alloy", language: "multi", gender: "neutral", isDefault: true },
  { id: "ash", name: "Ash", language: "multi", gender: "male" },
  { id: "ballad", name: "Ballad", language: "multi", gender: "male" },
  { id: "coral", name: "Coral", language: "multi", gender: "female" },
  { id: "echo", name: "Echo", language: "multi", gender: "male" },
  { id: "fable", name: "Fable", language: "multi", gender: "neutral", accent: "british" },
  { id: "nova", name: "Nova", language: "multi", gender: "female" },
  { id: "onyx", name: "Onyx", language: "multi", gender: "male" },
  { id: "sage", name: "Sage", language: "multi", gender: "female" },
  { id: "shimmer", name: "Shimmer", language: "multi", gender: "female" },
  { id: "verse", name: "Verse", language: "multi", gender: "neutral" },
  { id: "marin", name: "Marin", language: "multi", gender: "female" },
  { id: "cedar", name: "Cedar", language: "multi", gender: "male" }
];
var GEMINI_VOICES = [
  // Default voice
  { id: "Kore", name: "Kore", language: "multi", gender: "female", isDefault: true },
  // Primary voices
  { id: "Puck", name: "Puck", language: "multi", gender: "neutral" },
  { id: "Charon", name: "Charon", language: "multi", gender: "male" },
  { id: "Fenrir", name: "Fenrir", language: "multi", gender: "male" },
  { id: "Zephyr", name: "Zephyr", language: "multi", gender: "neutral" },
  { id: "Leda", name: "Leda", language: "multi", gender: "female" },
  { id: "Orus", name: "Orus", language: "multi", gender: "male" },
  { id: "Aoede", name: "Aoede", language: "multi", gender: "female" },
  // Extended voices (celestial/astronomical naming)
  { id: "Callirrhoe", name: "Callirrhoe", language: "multi", gender: "female" },
  { id: "Autonoe", name: "Autonoe", language: "multi", gender: "female" },
  { id: "Enceladus", name: "Enceladus", language: "multi", gender: "male" },
  { id: "Iapetus", name: "Iapetus", language: "multi", gender: "male" },
  { id: "Umbriel", name: "Umbriel", language: "multi", gender: "neutral" },
  { id: "Algieba", name: "Algieba", language: "multi", gender: "male" },
  { id: "Despina", name: "Despina", language: "multi", gender: "female" },
  { id: "Erinome", name: "Erinome", language: "multi", gender: "female" },
  { id: "Algenib", name: "Algenib", language: "multi", gender: "male" },
  { id: "Rasalgethi", name: "Rasalgethi", language: "multi", gender: "male" },
  { id: "Laomedeia", name: "Laomedeia", language: "multi", gender: "female" },
  { id: "Achernar", name: "Achernar", language: "multi", gender: "male" },
  { id: "Alnilam", name: "Alnilam", language: "multi", gender: "male" },
  { id: "Schedar", name: "Schedar", language: "multi", gender: "female" },
  { id: "Gacrux", name: "Gacrux", language: "multi", gender: "male" },
  { id: "Pulcherrima", name: "Pulcherrima", language: "multi", gender: "female" },
  { id: "Achird", name: "Achird", language: "multi", gender: "male" },
  { id: "Zubenelgenubi", name: "Zubenelgenubi", language: "multi", gender: "male" },
  { id: "Vindemiatrix", name: "Vindemiatrix", language: "multi", gender: "female" },
  { id: "Sadachbia", name: "Sadachbia", language: "multi", gender: "male" },
  { id: "Sadaltager", name: "Sadaltager", language: "multi", gender: "male" },
  { id: "Sulafat", name: "Sulafat", language: "multi", gender: "female" }
];
var GEMINI_TTS_LANGUAGES = [
  "ar-EG",
  // Arabic (Egyptian)
  "bn",
  // Bengali
  "de-DE",
  // German (Germany)
  "en-US",
  // English (US)
  "en-IN",
  // English (India)
  "es",
  // Spanish
  "fr-FR",
  // French (France)
  "hi",
  // Hindi
  "id",
  // Indonesian
  "it",
  // Italian
  "ja",
  // Japanese
  "ko",
  // Korean
  "mr",
  // Marathi
  "nl",
  // Dutch
  "pl",
  // Polish
  "pt-BR",
  // Portuguese (Brazil)
  "ro",
  // Romanian
  "ru",
  // Russian
  "ta",
  // Tamil
  "te",
  // Telugu
  "th",
  // Thai
  "tr",
  // Turkish
  "uk",
  // Ukrainian
  "vi"
  // Vietnamese
];
var COMMON_LANGUAGES = {
  /**
   * Languages supported by OpenAI TTS models (50+)
   * Source: https://platform.openai.com/docs/guides/text-to-speech
   */
  OPENAI_TTS: [
    "en",
    "es",
    "fr",
    "de",
    "it",
    "pt",
    "pl",
    "ru",
    "ja",
    "ko",
    "zh",
    "ar",
    "hi",
    "nl",
    "sv",
    "tr",
    "af",
    "hy",
    "az",
    "be",
    "bs",
    "bg",
    "ca",
    "hr",
    "cs",
    "da",
    "et",
    "fi",
    "gl",
    "el",
    "he",
    "hu",
    "is",
    "id",
    "lv",
    "lt",
    "mk",
    "ms",
    "mi",
    "ne",
    "no",
    "fa",
    "ro",
    "sr",
    "sk",
    "sl",
    "sw",
    "tl",
    "ta",
    "th",
    "uk",
    "ur",
    "vi",
    "cy"
  ]};
var AUDIO_FORMATS = {
  /**
   * OpenAI TTS output formats
   * Source: https://platform.openai.com/docs/guides/text-to-speech
   */
  OPENAI_TTS: ["mp3", "opus", "aac", "flac", "wav", "pcm"],
  /**
   * Common STT input formats (widely supported)
   */
  STT_INPUT: ["mp3", "mp4", "mpeg", "mpga", "m4a", "wav", "webm", "flac", "ogg"]
};

// src/infrastructure/providers/openai/OpenAITTSProvider.ts
var OpenAITTSProvider = class extends BaseMediaProvider {
  name = "openai-tts";
  vendor = "openai";
  capabilities = {
    text: false,
    images: false,
    videos: false,
    audio: true,
    features: {
      textToSpeech: true
    }
  };
  client;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new OpenAI3__default.default({
      apiKey: config.auth.apiKey,
      baseURL: config.baseURL,
      organization: config.organization,
      timeout: config.timeout ?? 6e4,
      maxRetries: config.maxRetries ?? 2
    });
  }
  /**
   * Synthesize speech from text
   */
  async synthesize(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          const format = this.mapFormat(options.format);
          const requestParams = {
            model: options.model,
            input: options.input,
            voice: options.voice,
            response_format: format,
            speed: options.speed
          };
          if (options.vendorOptions?.instructions) {
            requestParams.instructions = options.vendorOptions.instructions;
          }
          this.logOperationStart("tts.synthesize", {
            model: options.model,
            voice: options.voice,
            inputLength: options.input.length
          });
          const response = await this.client.audio.speech.create(requestParams);
          const arrayBuffer = await response.arrayBuffer();
          const audio = Buffer.from(arrayBuffer);
          this.logOperationComplete("tts.synthesize", {
            model: options.model,
            audioSize: audio.length
          });
          return {
            audio,
            format: options.format || "mp3",
            charactersUsed: options.input.length
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "tts.synthesize",
      { model: options.model, voice: options.voice }
    );
  }
  /**
   * List available voices (returns static list for OpenAI)
   */
  async listVoices() {
    return OPENAI_VOICES;
  }
  /**
   * Map semantic audio format to OpenAI format
   */
  mapFormat(format) {
    switch (format) {
      case "mp3":
        return "mp3";
      case "opus":
        return "opus";
      case "aac":
        return "aac";
      case "flac":
        return "flac";
      case "wav":
        return "wav";
      case "pcm":
        return "pcm";
      default:
        return "mp3";
    }
  }
  /**
   * Handle OpenAI API errors
   */
  handleError(error) {
    if (error instanceof OpenAI3__default.default.APIError) {
      const status = error.status;
      const message = error.message || "Unknown OpenAI API error";
      if (status === 401) {
        throw new ProviderAuthError("openai", "Invalid API key");
      }
      if (status === 429) {
        throw new ProviderRateLimitError("openai");
      }
      if (status === 400) {
        throw new ProviderError("openai", `Bad request: ${message}`);
      }
      throw new ProviderError("openai", message);
    }
    throw error;
  }
};
var OpenAISTTProvider = class extends BaseMediaProvider {
  name = "openai-stt";
  vendor = "openai";
  capabilities = {
    text: false,
    images: false,
    videos: false,
    audio: true,
    features: {
      speechToText: true
    }
  };
  client;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new OpenAI3__default.default({
      apiKey: config.auth.apiKey,
      baseURL: config.baseURL,
      organization: config.organization,
      timeout: config.timeout ?? 12e4,
      // 2 minutes for audio processing
      maxRetries: config.maxRetries ?? 2
    });
  }
  /**
   * Transcribe audio to text
   */
  async transcribe(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("stt.transcribe", {
            model: options.model,
            language: options.language,
            format: options.outputFormat
          });
          const audioFile = await this.prepareAudioFile(options.audio);
          const requestParams = {
            model: options.model,
            file: audioFile,
            language: options.language,
            prompt: options.prompt,
            temperature: options.temperature
          };
          if (options.outputFormat) {
            requestParams.response_format = this.mapOutputFormat(options.outputFormat);
          } else if (options.includeTimestamps) {
            requestParams.response_format = "verbose_json";
          }
          if (options.includeTimestamps && options.timestampGranularity) {
            requestParams.timestamp_granularities = [options.timestampGranularity];
          }
          if (options.model.includes("diarize") && options.vendorOptions?.max_speakers) {
            requestParams.max_speakers = options.vendorOptions.max_speakers;
          }
          const response = await this.client.audio.transcriptions.create(
            requestParams
          );
          this.logOperationComplete("stt.transcribe", {
            model: options.model,
            textLength: typeof response === "string" ? response.length : response.text?.length || 0
          });
          return this.convertResponse(response);
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "stt.transcribe",
      { model: options.model }
    );
  }
  /**
   * Translate audio to English text
   */
  async translate(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("stt.translate", {
            model: options.model
          });
          const audioFile = await this.prepareAudioFile(options.audio);
          const requestParams = {
            model: options.model,
            file: audioFile,
            prompt: options.prompt,
            temperature: options.temperature
          };
          if (options.outputFormat) {
            requestParams.response_format = this.mapOutputFormat(options.outputFormat);
          }
          const response = await this.client.audio.translations.create(
            requestParams
          );
          this.logOperationComplete("stt.translate", {
            model: options.model,
            textLength: typeof response === "string" ? response.length : response.text?.length || 0
          });
          return this.convertResponse(response);
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "stt.translate",
      { model: options.model }
    );
  }
  /**
   * Prepare audio file for API request
   * Handles both Buffer and file path inputs
   */
  async prepareAudioFile(audio) {
    if (Buffer.isBuffer(audio)) {
      return new File([new Uint8Array(audio)], "audio.wav", { type: "audio/wav" });
    } else if (typeof audio === "string") {
      return fs19__namespace.createReadStream(audio);
    } else {
      throw new Error("Invalid audio input: must be Buffer or file path");
    }
  }
  /**
   * Map semantic output format to OpenAI format
   */
  mapOutputFormat(format) {
    switch (format) {
      case "json":
        return "json";
      case "text":
        return "text";
      case "srt":
        return "srt";
      case "vtt":
        return "vtt";
      case "verbose_json":
        return "verbose_json";
      default:
        return "json";
    }
  }
  /**
   * Convert OpenAI response to our standard format
   */
  convertResponse(response) {
    if (typeof response === "string") {
      return { text: response };
    }
    const extResponse = response;
    const result = {
      text: response.text,
      language: extResponse.language,
      durationSeconds: extResponse.duration
    };
    if (response.words) {
      result.words = response.words.map((w) => ({
        word: w.word,
        start: w.start,
        end: w.end
      }));
    }
    if (response.segments) {
      result.segments = response.segments.map((s) => ({
        id: s.id,
        text: s.text,
        start: s.start,
        end: s.end,
        tokens: s.tokens
      }));
    }
    return result;
  }
  /**
   * Handle OpenAI API errors
   */
  handleError(error) {
    if (error instanceof OpenAI3__default.default.APIError) {
      const status = error.status;
      const message = error.message || "Unknown OpenAI API error";
      if (status === 401) {
        throw new ProviderAuthError("openai", "Invalid API key");
      }
      if (status === 429) {
        throw new ProviderRateLimitError("openai");
      }
      if (status === 400) {
        throw new ProviderError("openai", `Bad request: ${message}`);
      }
      if (status === 413) {
        throw new ProviderError("openai", "Audio file too large (max 25MB)");
      }
      throw new ProviderError("openai", message);
    }
    throw error;
  }
};
var GoogleTTSProvider = class extends BaseMediaProvider {
  name = "google-tts";
  vendor = "google";
  capabilities = {
    text: false,
    images: false,
    videos: false,
    audio: true,
    features: {
      textToSpeech: true
    }
  };
  client;
  constructor(config) {
    super(config);
    this.client = new genai.GoogleGenAI({
      apiKey: config.apiKey
    });
  }
  /**
   * Synthesize speech from text using Gemini TTS
   */
  async synthesize(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("tts.synthesize", {
            model: options.model,
            voice: options.voice,
            inputLength: options.input.length
          });
          const result = await this.client.models.generateContent({
            model: options.model,
            contents: [
              {
                parts: [{ text: options.input }]
              }
            ],
            config: {
              responseModalities: ["AUDIO"],
              speechConfig: {
                voiceConfig: {
                  prebuiltVoiceConfig: {
                    voiceName: options.voice || "Kore"
                  }
                }
              }
            }
          });
          const audioData = this.extractAudioData(result);
          if (!audioData) {
            throw new ProviderError("google", "No audio data in response");
          }
          this.logOperationComplete("tts.synthesize", {
            model: options.model,
            audioSize: audioData.length
          });
          return {
            audio: audioData,
            format: "wav",
            // Gemini outputs PCM 24kHz 16-bit, we convert to WAV
            charactersUsed: options.input.length
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "tts.synthesize",
      { model: options.model, voice: options.voice }
    );
  }
  /**
   * List available voices (returns static list for Google)
   */
  async listVoices() {
    return GEMINI_VOICES;
  }
  /**
   * Extract audio data from Gemini response
   * Gemini returns raw PCM data (24kHz, 16-bit, mono), we wrap it in WAV format
   */
  extractAudioData(result) {
    const candidates = result.candidates;
    if (!candidates || candidates.length === 0) {
      return null;
    }
    const content = candidates[0]?.content;
    if (!content?.parts || content.parts.length === 0) {
      return null;
    }
    for (const part of content.parts) {
      if (part.inlineData?.data) {
        const rawPcm = Buffer.from(part.inlineData.data, "base64");
        return this.pcmToWav(rawPcm, 24e3, 1, 16);
      }
    }
    return null;
  }
  /**
   * Convert raw PCM data to WAV format
   * @param pcmData - Raw PCM data buffer
   * @param sampleRate - Sample rate in Hz (default 24000 for Gemini)
   * @param channels - Number of channels (default 1 for mono)
   * @param bitsPerSample - Bits per sample (default 16)
   */
  pcmToWav(pcmData, sampleRate = 24e3, channels = 1, bitsPerSample = 16) {
    const byteRate = sampleRate * channels * bitsPerSample / 8;
    const blockAlign = channels * bitsPerSample / 8;
    const dataSize = pcmData.length;
    const headerSize = 44;
    const fileSize = headerSize + dataSize;
    const header = Buffer.alloc(headerSize);
    header.write("RIFF", 0);
    header.writeUInt32LE(fileSize - 8, 4);
    header.write("WAVE", 8);
    header.write("fmt ", 12);
    header.writeUInt32LE(16, 16);
    header.writeUInt16LE(1, 20);
    header.writeUInt16LE(channels, 22);
    header.writeUInt32LE(sampleRate, 24);
    header.writeUInt32LE(byteRate, 28);
    header.writeUInt16LE(blockAlign, 32);
    header.writeUInt16LE(bitsPerSample, 34);
    header.write("data", 36);
    header.writeUInt32LE(dataSize, 40);
    return Buffer.concat([header, pcmData]);
  }
  /**
   * Handle Google API errors
   */
  handleError(error) {
    const message = error.message || "Unknown Google API error";
    const status = error.status || error.code;
    if (status === 401 || message.includes("API key not valid")) {
      throw new ProviderAuthError("google", "Invalid API key");
    }
    if (status === 429 || message.includes("Resource exhausted")) {
      throw new ProviderRateLimitError("google", message);
    }
    if (status === 400) {
      throw new ProviderError("google", `Bad request: ${message}`);
    }
    throw new ProviderError("google", message);
  }
};

// src/core/createAudioProvider.ts
function createTTSProvider(connector) {
  const vendor = connector.vendor;
  switch (vendor) {
    case Vendor.OpenAI:
      return new OpenAITTSProvider(extractOpenAIConfig(connector));
    case Vendor.Google:
      return new GoogleTTSProvider(extractGoogleConfig(connector));
    default:
      throw new Error(
        `No TTS provider available for vendor: ${vendor}. Supported vendors: ${Vendor.OpenAI}, ${Vendor.Google}`
      );
  }
}
function createSTTProvider(connector) {
  const vendor = connector.vendor;
  switch (vendor) {
    case Vendor.OpenAI:
      return new OpenAISTTProvider(extractOpenAIConfig(connector));
    case Vendor.Groq:
      throw new Error(`Groq STT provider not yet implemented`);
    case Vendor.Google:
      throw new Error(`Google STT provider not yet implemented`);
    default:
      throw new Error(
        `No STT provider available for vendor: ${vendor}. Supported vendors: ${Vendor.OpenAI}, ${Vendor.Groq}`
      );
  }
}
function extractOpenAIConfig(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("OpenAI requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    baseURL: connector.baseURL,
    organization: options.organization,
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}
function extractGoogleConfig(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("Google requires API key authentication");
  }
  return {
    apiKey: auth2.apiKey
  };
}

// src/domain/entities/RegistryUtils.ts
function createRegistryHelpers(registry) {
  return {
    /**
     * Get model information by name
     */
    getInfo: (modelName) => {
      return registry[modelName];
    },
    /**
     * Get all active models for a specific vendor
     */
    getByVendor: (vendor) => {
      return Object.values(registry).filter(
        (model) => model.provider === vendor && model.isActive
      );
    },
    /**
     * Get all currently active models (across all vendors)
     */
    getActive: () => {
      return Object.values(registry).filter((model) => model.isActive);
    },
    /**
     * Get all models (including inactive/deprecated)
     */
    getAll: () => {
      return Object.values(registry);
    },
    /**
     * Check if model exists in registry
     */
    has: (modelName) => {
      return modelName in registry;
    }
  };
}

// src/domain/entities/TTSModel.ts
var TTS_MODELS = {
  [Vendor.OpenAI]: {
    /** NEW: Instruction-steerable TTS with emotional control */
    GPT_4O_MINI_TTS: "gpt-4o-mini-tts",
    /** Fast, low-latency TTS */
    TTS_1: "tts-1",
    /** High-definition TTS */
    TTS_1_HD: "tts-1-hd"
  },
  [Vendor.Google]: {
    /** Gemini 2.5 Flash TTS (optimized for low latency) */
    GEMINI_2_5_FLASH_TTS: "gemini-2.5-flash-preview-tts",
    /** Gemini 2.5 Pro TTS (optimized for quality) */
    GEMINI_2_5_PRO_TTS: "gemini-2.5-pro-preview-tts"
  }
};
var OPENAI_TTS_BASE = {
  voices: OPENAI_VOICES,
  formats: AUDIO_FORMATS.OPENAI_TTS,
  languages: COMMON_LANGUAGES.OPENAI_TTS,
  speed: { supported: true, min: 0.25, max: 4, default: 1 }
};
var TTS_MODEL_REGISTRY = {
  // ======================== OpenAI ========================
  "gpt-4o-mini-tts": {
    name: "gpt-4o-mini-tts",
    displayName: "GPT-4o Mini TTS",
    provider: Vendor.OpenAI,
    description: "Instruction-steerable TTS with emotional control via prompts",
    isActive: true,
    releaseDate: "2025-03-01",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/text-to-speech",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...OPENAI_TTS_BASE,
      features: {
        streaming: false,
        // Not implementing streaming in v1
        ssml: false,
        emotions: true,
        // Via instruction steering
        voiceCloning: true,
        wordTimestamps: false,
        instructionSteering: true
      },
      limits: { maxInputLength: 2e3 },
      vendorOptions: {
        instructions: {
          type: "string",
          description: 'Natural language instructions for voice style (e.g., "speak like a calm meditation guide")'
        }
      }
    },
    pricing: { per1kCharacters: 0.015, currency: "USD" }
  },
  "tts-1": {
    name: "tts-1",
    displayName: "TTS-1",
    provider: Vendor.OpenAI,
    description: "Fast, low-latency text-to-speech optimized for real-time use",
    isActive: true,
    releaseDate: "2023-11-06",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/text-to-speech",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...OPENAI_TTS_BASE,
      features: {
        streaming: false,
        // Not implementing streaming in v1
        ssml: false,
        emotions: false,
        voiceCloning: false,
        wordTimestamps: false
      },
      limits: { maxInputLength: 4096 }
    },
    pricing: { per1kCharacters: 0.015, currency: "USD" }
  },
  "tts-1-hd": {
    name: "tts-1-hd",
    displayName: "TTS-1 HD",
    provider: Vendor.OpenAI,
    description: "High-definition text-to-speech with improved audio quality",
    isActive: true,
    releaseDate: "2023-11-06",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/text-to-speech",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...OPENAI_TTS_BASE,
      features: {
        streaming: false,
        // Not implementing streaming in v1
        ssml: false,
        emotions: false,
        voiceCloning: false,
        wordTimestamps: false
      },
      limits: { maxInputLength: 4096 }
    },
    pricing: { per1kCharacters: 0.03, currency: "USD" }
  },
  // ======================== Google ========================
  "gemini-2.5-flash-preview-tts": {
    name: "gemini-2.5-flash-preview-tts",
    displayName: "Gemini 2.5 Flash TTS",
    provider: Vendor.Google,
    description: "Google Gemini 2.5 Flash TTS - optimized for low latency",
    isActive: true,
    releaseDate: "2025-01-01",
    sources: {
      documentation: "https://ai.google.dev/gemini-api/docs/speech-generation",
      pricing: "https://ai.google.dev/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      voices: GEMINI_VOICES,
      formats: ["wav"],
      // PCM output, 24kHz 16-bit mono
      languages: [...GEMINI_TTS_LANGUAGES],
      speed: { supported: false },
      // Speed not directly configurable
      features: {
        streaming: false,
        // Not implementing streaming in v1
        ssml: false,
        emotions: true,
        // Supports affective dialogue
        voiceCloning: false,
        wordTimestamps: false
      },
      limits: { maxInputLength: 32e3 }
      // 32k tokens
    }
  },
  "gemini-2.5-pro-preview-tts": {
    name: "gemini-2.5-pro-preview-tts",
    displayName: "Gemini 2.5 Pro TTS",
    provider: Vendor.Google,
    description: "Google Gemini 2.5 Pro TTS - optimized for quality",
    isActive: true,
    releaseDate: "2025-01-01",
    sources: {
      documentation: "https://ai.google.dev/gemini-api/docs/speech-generation",
      pricing: "https://ai.google.dev/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      voices: GEMINI_VOICES,
      formats: ["wav"],
      // PCM output, 24kHz 16-bit mono
      languages: [...GEMINI_TTS_LANGUAGES],
      speed: { supported: false },
      // Speed not directly configurable
      features: {
        streaming: false,
        // Not implementing streaming in v1
        ssml: false,
        emotions: true,
        // Supports affective dialogue
        voiceCloning: false,
        wordTimestamps: false
      },
      limits: { maxInputLength: 32e3 }
      // 32k tokens
    }
  }
};
var helpers = createRegistryHelpers(TTS_MODEL_REGISTRY);
var getTTSModelInfo = helpers.getInfo;
var getTTSModelsByVendor = helpers.getByVendor;
var getActiveTTSModels = helpers.getActive;
function getTTSModelsWithFeature(feature) {
  return Object.values(TTS_MODEL_REGISTRY).filter(
    (model) => model.isActive && model.capabilities.features[feature]
  );
}
function calculateTTSCost(modelName, characterCount) {
  const model = getTTSModelInfo(modelName);
  if (!model?.pricing) return null;
  return characterCount / 1e3 * model.pricing.per1kCharacters;
}
var TextToSpeech = class _TextToSpeech {
  provider;
  config;
  /**
   * Create a new TextToSpeech instance
   */
  static create(config) {
    return new _TextToSpeech(config);
  }
  constructor(config) {
    const connector = typeof config.connector === "string" ? exports.Connector.get(config.connector) : config.connector;
    this.provider = createTTSProvider(connector);
    this.config = config;
  }
  // ======================== Synthesis Methods ========================
  /**
   * Synthesize speech from text
   *
   * @param text - Text to synthesize
   * @param options - Optional synthesis parameters
   * @returns Audio data and metadata
   */
  async synthesize(text, options) {
    const fullOptions = {
      model: this.config.model ?? this.getDefaultModel(),
      input: text,
      voice: options?.voice ?? this.config.voice ?? this.getDefaultVoice(),
      format: options?.format ?? this.config.format,
      speed: options?.speed ?? this.config.speed,
      vendorOptions: options?.vendorOptions
    };
    return this.provider.synthesize(fullOptions);
  }
  /**
   * Synthesize speech and save to file
   *
   * @param text - Text to synthesize
   * @param filePath - Output file path
   * @param options - Optional synthesis parameters
   */
  async toFile(text, filePath, options) {
    const response = await this.synthesize(text, options);
    await fs18__namespace.writeFile(filePath, response.audio);
  }
  // ======================== Introspection Methods ========================
  /**
   * Get model information for current or specified model
   */
  getModelInfo(model) {
    const targetModel = model ?? this.config.model ?? this.getDefaultModel();
    const info = getTTSModelInfo(targetModel);
    if (!info) {
      throw new Error(`Unknown TTS model: ${targetModel}`);
    }
    return info;
  }
  /**
   * Get model capabilities
   */
  getModelCapabilities(model) {
    return this.getModelInfo(model).capabilities;
  }
  /**
   * List all available voices for current model
   * For dynamic voice providers (e.g., ElevenLabs), fetches from API
   * For static providers (e.g., OpenAI), returns from registry
   */
  async listVoices(model) {
    if (this.provider.listVoices) {
      return this.provider.listVoices();
    }
    const caps = this.getModelCapabilities(model);
    return caps.voices;
  }
  /**
   * List all available models for this provider's vendor
   */
  listAvailableModels() {
    const vendor = this.provider.vendor;
    if (!vendor) {
      return [];
    }
    return getTTSModelsByVendor(vendor);
  }
  /**
   * Check if a specific feature is supported by the model
   */
  supportsFeature(feature, model) {
    const caps = this.getModelCapabilities(model);
    return Boolean(caps.features[feature]);
  }
  /**
   * Get supported audio formats for the model
   */
  getSupportedFormats(model) {
    return this.getModelCapabilities(model).formats;
  }
  /**
   * Get supported languages for the model
   */
  getSupportedLanguages(model) {
    return this.getModelCapabilities(model).languages;
  }
  /**
   * Check if speed control is supported
   */
  supportsSpeedControl(model) {
    return this.getModelCapabilities(model).speed.supported;
  }
  // ======================== Configuration Methods ========================
  /**
   * Update default model
   */
  setModel(model) {
    this.config.model = model;
  }
  /**
   * Update default voice
   */
  setVoice(voice) {
    this.config.voice = voice;
  }
  /**
   * Update default format
   */
  setFormat(format) {
    this.config.format = format;
  }
  /**
   * Update default speed
   */
  setSpeed(speed) {
    this.config.speed = speed;
  }
  // ======================== Private Methods ========================
  /**
   * Get default model (first active model for vendor)
   */
  getDefaultModel() {
    const models = this.listAvailableModels();
    const firstModel = models[0];
    if (!firstModel) {
      throw new Error("No TTS models available for this provider");
    }
    return firstModel.name;
  }
  /**
   * Get default voice (first or default-marked voice)
   */
  getDefaultVoice() {
    const caps = this.getModelInfo().capabilities;
    const defaultVoice = caps.voices.find((v) => v.isDefault);
    return defaultVoice?.id ?? caps.voices[0]?.id ?? "alloy";
  }
};

// src/core/SpeechToText.ts
init_Connector();

// src/domain/entities/STTModel.ts
var STT_MODELS = {
  [Vendor.OpenAI]: {
    /** NEW: GPT-4o based transcription */
    GPT_4O_TRANSCRIBE: "gpt-4o-transcribe",
    /** NEW: GPT-4o with speaker diarization */
    GPT_4O_TRANSCRIBE_DIARIZE: "gpt-4o-transcribe-diarize",
    /** Classic Whisper */
    WHISPER_1: "whisper-1"
  },
  [Vendor.Groq]: {
    /** Ultra-fast Whisper on Groq LPUs */
    WHISPER_LARGE_V3: "whisper-large-v3",
    /** Faster English-only variant */
    DISTIL_WHISPER: "distil-whisper-large-v3-en"
  }
};
var WHISPER_BASE_CAPABILITIES = {
  inputFormats: AUDIO_FORMATS.STT_INPUT,
  outputFormats: ["json", "text", "srt", "vtt", "verbose_json"],
  languages: [],
  // Auto-detect, 50+ languages
  timestamps: { supported: true, granularities: ["word", "segment"] }
};
var STT_MODEL_REGISTRY = {
  // ======================== OpenAI ========================
  "gpt-4o-transcribe": {
    name: "gpt-4o-transcribe",
    displayName: "GPT-4o Transcribe",
    provider: Vendor.OpenAI,
    description: "GPT-4o based transcription with superior accuracy and context understanding",
    isActive: true,
    releaseDate: "2025-04-01",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/speech-to-text",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...WHISPER_BASE_CAPABILITIES,
      features: {
        translation: true,
        diarization: false,
        streaming: false,
        // Not implementing streaming in v1
        punctuation: true,
        profanityFilter: false
      },
      limits: { maxFileSizeMB: 25, maxDurationSeconds: 7200 }
    },
    pricing: { perMinute: 6e-3, currency: "USD" }
  },
  "gpt-4o-transcribe-diarize": {
    name: "gpt-4o-transcribe-diarize",
    displayName: "GPT-4o Transcribe + Diarization",
    provider: Vendor.OpenAI,
    description: "GPT-4o transcription with speaker identification",
    isActive: true,
    releaseDate: "2025-04-01",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/speech-to-text",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...WHISPER_BASE_CAPABILITIES,
      outputFormats: ["json", "verbose_json"],
      features: {
        translation: true,
        diarization: true,
        // Built-in speaker identification
        streaming: false,
        punctuation: true,
        profanityFilter: false
      },
      limits: { maxFileSizeMB: 25, maxDurationSeconds: 7200 },
      vendorOptions: {
        max_speakers: {
          type: "number",
          description: "Maximum number of speakers to detect",
          min: 2,
          max: 10,
          default: 4
        }
      }
    },
    pricing: { perMinute: 0.012, currency: "USD" }
    // 2x for diarization
  },
  "whisper-1": {
    name: "whisper-1",
    displayName: "Whisper",
    provider: Vendor.OpenAI,
    description: "OpenAI's general-purpose speech recognition model",
    isActive: true,
    releaseDate: "2023-03-01",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/speech-to-text",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...WHISPER_BASE_CAPABILITIES,
      inputFormats: ["mp3", "mp4", "mpeg", "mpga", "m4a", "wav", "webm"],
      features: {
        translation: true,
        diarization: false,
        streaming: false,
        punctuation: true,
        profanityFilter: false
      },
      limits: { maxFileSizeMB: 25 }
    },
    pricing: { perMinute: 6e-3, currency: "USD" }
  },
  // ======================== Groq ========================
  "whisper-large-v3": {
    name: "whisper-large-v3",
    displayName: "Whisper Large v3 (Groq)",
    provider: Vendor.Groq,
    description: "Ultra-fast Whisper on Groq LPUs - 12x cheaper than OpenAI",
    isActive: true,
    releaseDate: "2024-04-01",
    sources: {
      documentation: "https://console.groq.com/docs/speech-text",
      pricing: "https://groq.com/pricing/",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      ...WHISPER_BASE_CAPABILITIES,
      timestamps: { supported: true, granularities: ["segment"] },
      outputFormats: ["json", "text", "verbose_json"],
      features: {
        translation: true,
        diarization: false,
        streaming: false,
        punctuation: true,
        profanityFilter: false
      },
      limits: { maxFileSizeMB: 25 }
    },
    pricing: { perMinute: 5e-4, currency: "USD" }
    // 12x cheaper!
  },
  "distil-whisper-large-v3-en": {
    name: "distil-whisper-large-v3-en",
    displayName: "Distil Whisper (Groq)",
    provider: Vendor.Groq,
    description: "Faster English-only Whisper variant on Groq",
    isActive: true,
    releaseDate: "2024-04-01",
    sources: {
      documentation: "https://console.groq.com/docs/speech-text",
      pricing: "https://groq.com/pricing/",
      lastVerified: "2026-01-24"
    },
    capabilities: {
      inputFormats: AUDIO_FORMATS.STT_INPUT,
      outputFormats: ["json", "text", "verbose_json"],
      languages: ["en"],
      // English only
      timestamps: { supported: true, granularities: ["segment"] },
      features: {
        translation: false,
        diarization: false,
        streaming: false,
        punctuation: true,
        profanityFilter: false
      },
      limits: { maxFileSizeMB: 25 }
    },
    pricing: { perMinute: 33e-5, currency: "USD" }
  }
};
var helpers2 = createRegistryHelpers(STT_MODEL_REGISTRY);
var getSTTModelInfo = helpers2.getInfo;
var getSTTModelsByVendor = helpers2.getByVendor;
var getActiveSTTModels = helpers2.getActive;
function getSTTModelsWithFeature(feature) {
  return Object.values(STT_MODEL_REGISTRY).filter(
    (model) => model.isActive && model.capabilities.features[feature]
  );
}
function calculateSTTCost(modelName, durationSeconds) {
  const model = getSTTModelInfo(modelName);
  if (!model?.pricing) return null;
  return durationSeconds / 60 * model.pricing.perMinute;
}
var SpeechToText = class _SpeechToText {
  provider;
  config;
  /**
   * Create a new SpeechToText instance
   */
  static create(config) {
    return new _SpeechToText(config);
  }
  constructor(config) {
    const connector = typeof config.connector === "string" ? exports.Connector.get(config.connector) : config.connector;
    this.provider = createSTTProvider(connector);
    this.config = config;
  }
  // ======================== Transcription Methods ========================
  /**
   * Transcribe audio to text
   *
   * @param audio - Audio data as Buffer or file path
   * @param options - Optional transcription parameters
   * @returns Transcription result with text and metadata
   */
  async transcribe(audio, options) {
    const fullOptions = {
      model: this.config.model ?? this.getDefaultModel(),
      audio,
      language: options?.language ?? this.config.language,
      outputFormat: options?.outputFormat,
      includeTimestamps: options?.includeTimestamps,
      timestampGranularity: options?.timestampGranularity,
      prompt: options?.prompt,
      temperature: options?.temperature ?? this.config.temperature,
      vendorOptions: options?.vendorOptions
    };
    return this.provider.transcribe(fullOptions);
  }
  /**
   * Transcribe audio file by path
   *
   * @param filePath - Path to audio file
   * @param options - Optional transcription parameters
   */
  async transcribeFile(filePath, options) {
    const audio = await fs18__namespace.readFile(filePath);
    return this.transcribe(audio, options);
  }
  /**
   * Transcribe audio with word or segment timestamps
   *
   * @param audio - Audio data as Buffer or file path
   * @param granularity - Timestamp granularity ('word' or 'segment')
   * @param options - Optional transcription parameters
   */
  async transcribeWithTimestamps(audio, granularity = "segment", options) {
    return this.transcribe(audio, {
      ...options,
      outputFormat: "verbose_json",
      includeTimestamps: true,
      timestampGranularity: granularity
    });
  }
  /**
   * Translate audio to English text
   * Note: Only supported by some models (e.g., Whisper)
   *
   * @param audio - Audio data as Buffer or file path
   * @param options - Optional transcription parameters
   */
  async translate(audio, options) {
    if (!this.provider.translate) {
      throw new Error("Translation not supported by this provider");
    }
    const fullOptions = {
      model: this.config.model ?? this.getDefaultModel(),
      audio,
      outputFormat: options?.outputFormat,
      prompt: options?.prompt,
      temperature: options?.temperature ?? this.config.temperature,
      vendorOptions: options?.vendorOptions
    };
    return this.provider.translate(fullOptions);
  }
  // ======================== Introspection Methods ========================
  /**
   * Get model information for current or specified model
   */
  getModelInfo(model) {
    const targetModel = model ?? this.config.model ?? this.getDefaultModel();
    const info = getSTTModelInfo(targetModel);
    if (!info) {
      throw new Error(`Unknown STT model: ${targetModel}`);
    }
    return info;
  }
  /**
   * Get model capabilities
   */
  getModelCapabilities(model) {
    return this.getModelInfo(model).capabilities;
  }
  /**
   * List all available models for this provider's vendor
   */
  listAvailableModels() {
    const vendor = this.provider.vendor;
    if (!vendor) {
      return [];
    }
    return getSTTModelsByVendor(vendor);
  }
  /**
   * Check if a specific feature is supported by the model
   */
  supportsFeature(feature, model) {
    const caps = this.getModelCapabilities(model);
    return Boolean(caps.features[feature]);
  }
  /**
   * Get supported input audio formats
   */
  getSupportedInputFormats(model) {
    return this.getModelCapabilities(model).inputFormats;
  }
  /**
   * Get supported output formats
   */
  getSupportedOutputFormats(model) {
    return this.getModelCapabilities(model).outputFormats;
  }
  /**
   * Get supported languages (empty array = auto-detect all)
   */
  getSupportedLanguages(model) {
    return this.getModelCapabilities(model).languages;
  }
  /**
   * Check if timestamps are supported
   */
  supportsTimestamps(model) {
    return this.getModelCapabilities(model).timestamps.supported;
  }
  /**
   * Check if translation is supported
   */
  supportsTranslation(model) {
    return this.supportsFeature("translation", model);
  }
  /**
   * Check if speaker diarization is supported
   */
  supportsDiarization(model) {
    return this.supportsFeature("diarization", model);
  }
  /**
   * Get timestamp granularities supported
   */
  getTimestampGranularities(model) {
    return this.getModelCapabilities(model).timestamps.granularities;
  }
  // ======================== Configuration Methods ========================
  /**
   * Update default model
   */
  setModel(model) {
    this.config.model = model;
  }
  /**
   * Update default language
   */
  setLanguage(language) {
    this.config.language = language;
  }
  /**
   * Update default temperature
   */
  setTemperature(temperature) {
    this.config.temperature = temperature;
  }
  // ======================== Private Methods ========================
  /**
   * Get default model (first active model for vendor)
   */
  getDefaultModel() {
    const models = this.listAvailableModels();
    const firstModel = models[0];
    if (!firstModel) {
      throw new Error("No STT models available for this provider");
    }
    return firstModel.name;
  }
};
var OpenAIImageProvider = class extends BaseMediaProvider {
  name = "openai-image";
  vendor = "openai";
  capabilities = {
    text: false,
    images: true,
    videos: false,
    audio: false,
    features: {
      imageGeneration: true,
      imageEditing: true
    }
  };
  client;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new OpenAI3__default.default({
      apiKey: config.auth.apiKey,
      baseURL: config.baseURL,
      organization: config.organization,
      timeout: config.timeout,
      maxRetries: config.maxRetries
    });
  }
  /**
   * Generate images from a text prompt
   */
  async generateImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.generate", {
            model: options.model,
            size: options.size,
            quality: options.quality,
            n: options.n
          });
          const isGptImage = options.model === "gpt-image-1";
          const params = {
            model: options.model,
            prompt: options.prompt,
            size: options.size,
            quality: options.quality,
            style: options.style,
            n: options.n || 1
          };
          if (!isGptImage) {
            params.response_format = options.response_format || "b64_json";
          }
          const response = await this.client.images.generate(params);
          const data = response.data || [];
          this.logOperationComplete("image.generate", {
            model: options.model,
            imagesGenerated: data.length
          });
          return {
            created: response.created,
            data: data.map((img) => ({
              url: img.url,
              b64_json: img.b64_json,
              revised_prompt: img.revised_prompt
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.generate",
      { model: options.model }
    );
  }
  /**
   * Edit an existing image with a prompt
   * Supported by: gpt-image-1, dall-e-2
   */
  async editImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.edit", {
            model: options.model,
            size: options.size,
            n: options.n
          });
          const image = this.prepareImageInput(options.image);
          const mask = options.mask ? this.prepareImageInput(options.mask) : void 0;
          const isGptImage = options.model === "gpt-image-1";
          const params = {
            model: options.model,
            image,
            prompt: options.prompt,
            mask,
            size: options.size,
            n: options.n || 1
          };
          if (!isGptImage) {
            params.response_format = options.response_format || "b64_json";
          }
          const response = await this.client.images.edit(params);
          const data = response.data || [];
          this.logOperationComplete("image.edit", {
            model: options.model,
            imagesGenerated: data.length
          });
          return {
            created: response.created,
            data: data.map((img) => ({
              url: img.url,
              b64_json: img.b64_json,
              revised_prompt: img.revised_prompt
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.edit",
      { model: options.model }
    );
  }
  /**
   * Create variations of an existing image
   * Supported by: dall-e-2 only
   */
  async createVariation(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.variation", {
            model: options.model,
            size: options.size,
            n: options.n
          });
          const image = this.prepareImageInput(options.image);
          const response = await this.client.images.createVariation({
            model: options.model,
            image,
            size: options.size,
            n: options.n || 1,
            response_format: options.response_format || "b64_json"
          });
          const data = response.data || [];
          this.logOperationComplete("image.variation", {
            model: options.model,
            imagesGenerated: data.length
          });
          return {
            created: response.created,
            data: data.map((img) => ({
              url: img.url,
              b64_json: img.b64_json,
              revised_prompt: img.revised_prompt
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.variation",
      { model: options.model }
    );
  }
  /**
   * List available image models
   */
  async listModels() {
    return ["gpt-image-1", "dall-e-3", "dall-e-2"];
  }
  /**
   * Prepare image input (Buffer or file path) for OpenAI API
   */
  prepareImageInput(image) {
    if (Buffer.isBuffer(image)) {
      return new File([new Uint8Array(image)], "image.png", { type: "image/png" });
    }
    return fs19__namespace.createReadStream(image);
  }
  /**
   * Handle OpenAI API errors
   */
  handleError(error) {
    const message = error.message || "Unknown OpenAI API error";
    const status = error.status;
    if (status === 401) {
      throw new ProviderAuthError("openai", "Invalid API key");
    }
    if (status === 429) {
      throw new ProviderRateLimitError("openai", message);
    }
    if (status === 400) {
      if (message.includes("safety system")) {
        throw new ProviderError("openai", `Content policy violation: ${message}`);
      }
      throw new ProviderError("openai", `Bad request: ${message}`);
    }
    throw new ProviderError("openai", message);
  }
};
var GoogleImageProvider = class extends BaseMediaProvider {
  name = "google-image";
  vendor = "google";
  capabilities = {
    text: false,
    images: true,
    videos: false,
    audio: false,
    features: {
      imageGeneration: true,
      imageEditing: true
    }
  };
  client;
  constructor(config) {
    super(config);
    this.client = new genai.GoogleGenAI({
      apiKey: config.apiKey
    });
  }
  /**
   * Generate images from a text prompt using Google Imagen
   */
  async generateImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.generate", {
            model: options.model,
            n: options.n
          });
          const googleOptions = options;
          const response = await this.client.models.generateImages({
            model: options.model,
            prompt: options.prompt,
            config: {
              numberOfImages: options.n || 1,
              negativePrompt: googleOptions.negativePrompt,
              aspectRatio: googleOptions.aspectRatio,
              seed: googleOptions.seed,
              outputMimeType: googleOptions.outputMimeType,
              includeRaiReason: googleOptions.includeRaiReason
            }
          });
          const images = response.generatedImages || [];
          this.logOperationComplete("image.generate", {
            model: options.model,
            imagesGenerated: images.length
          });
          return {
            created: Math.floor(Date.now() / 1e3),
            data: images.map((img) => ({
              b64_json: img.image?.imageBytes
              // Google doesn't provide URLs, only base64
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.generate",
      { model: options.model }
    );
  }
  /**
   * Edit an existing image using Imagen capability model
   * Uses imagen-3.0-capability-001
   */
  async editImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.edit", {
            model: options.model,
            n: options.n
          });
          const referenceImage = await this.prepareReferenceImage(options.image);
          const response = await this.client.models.editImage({
            model: options.model || "imagen-3.0-capability-001",
            prompt: options.prompt,
            referenceImages: [referenceImage],
            config: {
              numberOfImages: options.n || 1
            }
          });
          const images = response.generatedImages || [];
          this.logOperationComplete("image.edit", {
            model: options.model,
            imagesGenerated: images.length
          });
          return {
            created: Math.floor(Date.now() / 1e3),
            data: images.map((img) => ({
              b64_json: img.image?.imageBytes
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.edit",
      { model: options.model }
    );
  }
  /**
   * List available image models
   */
  async listModels() {
    return [
      "imagen-4.0-generate-001",
      "imagen-4.0-ultra-generate-001",
      "imagen-4.0-fast-generate-001"
    ];
  }
  /**
   * Prepare a reference image for Google's editImage API
   */
  async prepareReferenceImage(image) {
    let imageBytes;
    if (Buffer.isBuffer(image)) {
      imageBytes = image.toString("base64");
    } else {
      const fs20 = await import('fs');
      const buffer = fs20.readFileSync(image);
      imageBytes = buffer.toString("base64");
    }
    return {
      referenceImage: {
        image: {
          imageBytes
        }
      },
      referenceType: "REFERENCE_TYPE_SUBJECT"
    };
  }
  /**
   * Handle Google API errors
   */
  handleError(error) {
    const message = error.message || "Unknown Google API error";
    const status = error.status || error.code;
    if (status === 401 || message.includes("API key not valid")) {
      throw new ProviderAuthError("google", "Invalid API key");
    }
    if (status === 429 || message.includes("Resource exhausted")) {
      throw new ProviderRateLimitError("google", message);
    }
    if (status === 400) {
      if (message.includes("SAFETY") || message.includes("blocked") || message.includes("Responsible AI")) {
        throw new ProviderError("google", `Content policy violation: ${message}`);
      }
      throw new ProviderError("google", `Bad request: ${message}`);
    }
    throw new ProviderError("google", message);
  }
};
var GROK_API_BASE_URL = "https://api.x.ai/v1";
var GrokImageProvider = class extends BaseMediaProvider {
  name = "grok-image";
  vendor = "grok";
  capabilities = {
    text: false,
    images: true,
    videos: false,
    audio: false,
    features: {
      imageGeneration: true,
      imageEditing: true
    }
  };
  client;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new OpenAI3__default.default({
      apiKey: config.auth.apiKey,
      baseURL: config.baseURL || GROK_API_BASE_URL,
      timeout: config.timeout,
      maxRetries: config.maxRetries
    });
  }
  /**
   * Generate images from a text prompt
   */
  async generateImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.generate", {
            model: options.model,
            size: options.size,
            quality: options.quality,
            n: options.n
          });
          const params = {
            model: options.model || "grok-imagine-image",
            prompt: options.prompt,
            n: options.n || 1,
            response_format: options.response_format || "b64_json"
          };
          if (options.aspectRatio) {
            params.aspect_ratio = options.aspectRatio;
          }
          const response = await this.client.images.generate(params);
          const data = response.data || [];
          this.logOperationComplete("image.generate", {
            model: options.model,
            imagesGenerated: data.length
          });
          return {
            created: response.created,
            data: data.map((img) => ({
              url: img.url,
              b64_json: img.b64_json,
              revised_prompt: img.revised_prompt
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.generate",
      { model: options.model }
    );
  }
  /**
   * Edit an existing image with a prompt
   */
  async editImage(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("image.edit", {
            model: options.model,
            size: options.size,
            n: options.n
          });
          const image = this.prepareImageInput(options.image);
          const mask = options.mask ? this.prepareImageInput(options.mask) : void 0;
          const params = {
            model: options.model || "grok-imagine-image",
            image,
            prompt: options.prompt,
            mask,
            size: options.size,
            n: options.n || 1,
            response_format: options.response_format || "b64_json"
          };
          const response = await this.client.images.edit(params);
          const data = response.data || [];
          this.logOperationComplete("image.edit", {
            model: options.model,
            imagesGenerated: data.length
          });
          return {
            created: response.created,
            data: data.map((img) => ({
              url: img.url,
              b64_json: img.b64_json,
              revised_prompt: img.revised_prompt
            }))
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "image.edit",
      { model: options.model }
    );
  }
  /**
   * List available image models
   */
  async listModels() {
    return ["grok-imagine-image"];
  }
  /**
   * Prepare image input (Buffer or file path) for API
   */
  prepareImageInput(image) {
    if (Buffer.isBuffer(image)) {
      return new File([new Uint8Array(image)], "image.png", { type: "image/png" });
    }
    return fs19__namespace.createReadStream(image);
  }
  /**
   * Handle API errors
   */
  handleError(error) {
    const message = error.message || "Unknown Grok API error";
    const status = error.status;
    if (status === 401) {
      throw new ProviderAuthError("grok", "Invalid API key");
    }
    if (status === 429) {
      throw new ProviderRateLimitError("grok", message);
    }
    if (status === 400) {
      if (message.includes("safety") || message.includes("policy")) {
        throw new ProviderError("grok", `Content policy violation: ${message}`);
      }
      throw new ProviderError("grok", `Bad request: ${message}`);
    }
    throw new ProviderError("grok", message);
  }
};

// src/core/createImageProvider.ts
function createImageProvider(connector) {
  const vendor = connector.vendor;
  switch (vendor) {
    case Vendor.OpenAI:
      return new OpenAIImageProvider(extractOpenAIConfig2(connector));
    case Vendor.Google:
      return new GoogleImageProvider(extractGoogleConfig2(connector));
    case Vendor.Grok:
      return new GrokImageProvider(extractGrokConfig(connector));
    default:
      throw new Error(
        `No Image provider available for vendor: ${vendor}. Supported vendors: ${Vendor.OpenAI}, ${Vendor.Google}, ${Vendor.Grok}`
      );
  }
}
function extractOpenAIConfig2(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("OpenAI requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    baseURL: connector.baseURL,
    organization: options.organization,
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}
function extractGoogleConfig2(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("Google requires API key authentication");
  }
  return {
    apiKey: auth2.apiKey
  };
}
function extractGrokConfig(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("Grok requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    baseURL: connector.baseURL,
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}

// src/core/tool-execution/plugins/LoggingPlugin.ts
init_Logger();
var LoggingPlugin = class {
  name = "logging";
  priority = 5;
  // Run very early to capture full execution
  logger;
  level;
  errorLevel;
  logArgs;
  logResult;
  maxLogLength;
  constructor(options = {}) {
    const baseLogger = options.logger ?? exports.logger;
    this.logger = baseLogger.child({ component: options.component ?? "ToolExecution" });
    this.level = options.level ?? "debug";
    this.errorLevel = options.errorLevel ?? "error";
    this.logArgs = options.logArgs ?? true;
    this.logResult = options.logResult ?? true;
    this.maxLogLength = options.maxLogLength ?? 200;
  }
  async beforeExecute(ctx) {
    const logData = {
      executionId: ctx.executionId,
      tool: ctx.toolName
    };
    if (this.logArgs) {
      logData.args = this.summarize(ctx.args);
    }
    this.log(this.level, logData, `Tool ${ctx.toolName} starting`);
  }
  async afterExecute(ctx, result) {
    const duration = Date.now() - ctx.startTime;
    const logData = {
      executionId: ctx.executionId,
      tool: ctx.toolName,
      durationMs: duration
    };
    if (this.logResult) {
      logData.result = this.summarize(result);
    }
    this.log(this.level, logData, `Tool ${ctx.toolName} completed in ${duration}ms`);
    return result;
  }
  async onError(ctx, error) {
    const duration = Date.now() - ctx.startTime;
    const logData = {
      executionId: ctx.executionId,
      tool: ctx.toolName,
      durationMs: duration,
      error: error.message,
      errorName: error.name
    };
    this.log(this.errorLevel, logData, `Tool ${ctx.toolName} failed after ${duration}ms: ${error.message}`);
    return void 0;
  }
  /**
   * Log a message at the specified level.
   */
  log(level, data, message) {
    switch (level) {
      case "trace":
        this.logger.trace(data, message);
        break;
      case "debug":
        this.logger.debug(data, message);
        break;
      case "info":
        this.logger.info(data, message);
        break;
      case "warn":
        this.logger.warn(data, message);
        break;
      case "error":
        this.logger.error(data, message);
        break;
    }
  }
  /**
   * Summarize a value for logging, truncating if necessary.
   */
  summarize(value) {
    if (value === null || value === void 0) {
      return value;
    }
    if (typeof value === "string") {
      return value.length > this.maxLogLength ? value.slice(0, this.maxLogLength) + "..." : value;
    }
    if (typeof value !== "object") {
      return value;
    }
    if (Array.isArray(value)) {
      return { type: "array", length: value.length };
    }
    const obj = value;
    if ("success" in obj) {
      const summary = { success: obj.success };
      if ("error" in obj) summary.error = obj.error;
      if ("count" in obj) summary.count = obj.count;
      if ("results" in obj && Array.isArray(obj.results)) {
        summary.resultCount = obj.results.length;
      }
      return summary;
    }
    const keys = Object.keys(obj);
    return { type: "object", keys: keys.slice(0, 5), keyCount: keys.length };
  }
};

// src/core/ErrorHandler.ts
init_Logger();
init_Metrics();
var DEFAULT_RETRYABLE_PATTERNS = [
  "ECONNRESET",
  "ECONNREFUSED",
  "ETIMEDOUT",
  "ENOTFOUND",
  "EAI_AGAIN",
  "rate limit",
  "Rate limit",
  "429",
  "500",
  "502",
  "503",
  "504",
  "timeout",
  "Timeout"
];
var ErrorHandler = class extends eventemitter3.EventEmitter {
  config;
  logger;
  constructor(config = {}) {
    super();
    const isProduction = process.env.NODE_ENV === "production";
    this.config = {
      logErrors: config.logErrors ?? true,
      includeStackTrace: config.includeStackTrace ?? !isProduction,
      transformError: config.transformError ?? ((e) => e),
      retryablePatterns: config.retryablePatterns ?? DEFAULT_RETRYABLE_PATTERNS,
      maxRetries: config.maxRetries ?? 3,
      baseRetryDelayMs: config.baseRetryDelayMs ?? 100,
      maxRetryDelayMs: config.maxRetryDelayMs ?? 5e3
    };
    this.logger = exports.logger.child({ component: "ErrorHandler" });
  }
  /**
   * Handle an error with context.
   * Logs the error, emits events, and records metrics.
   *
   * @param error - The error to handle
   * @param context - Context information about where/how the error occurred
   */
  handle(error, context) {
    const transformed = this.config.transformError(error, context);
    const recoverable = this.isRecoverable(transformed);
    if (this.config.logErrors) {
      this.logError(transformed, context, recoverable);
    }
    this.recordMetrics(transformed, context, recoverable);
    this.emit("error", { error: transformed, context, recoverable });
    if (!recoverable) {
      this.emit("error:fatal", { error: transformed, context });
    }
  }
  /**
   * Execute a function with automatic retry on retryable errors.
   *
   * @param fn - The function to execute
   * @param context - Context for error handling
   * @returns The result of the function
   * @throws The last error if all retries are exhausted
   */
  async executeWithRetry(fn, context) {
    let lastError;
    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        const isLastAttempt = attempt === this.config.maxRetries;
        const shouldRetry = !isLastAttempt && this.isRetryable(lastError);
        if (!shouldRetry) {
          this.handle(lastError, context);
          throw lastError;
        }
        const delay = this.calculateRetryDelay(attempt);
        this.emit("error:retrying", {
          error: lastError,
          context,
          attempt,
          delayMs: delay
        });
        if (this.config.logErrors) {
          this.logger.warn(
            {
              error: lastError.message,
              attempt,
              maxAttempts: this.config.maxRetries,
              delayMs: delay,
              ...this.contextToLogFields(context)
            },
            `Retrying after error (attempt ${attempt}/${this.config.maxRetries})`
          );
        }
        await this.delay(delay);
      }
    }
    throw lastError;
  }
  /**
   * Wrap a function with error handling (no retry).
   * Useful for wrapping methods that already have their own retry logic.
   *
   * @param fn - The function to wrap
   * @param contextFactory - Factory to create context from function arguments
   * @returns A wrapped function with error handling
   */
  wrap(fn, contextFactory) {
    return async (...args) => {
      try {
        return await fn(...args);
      } catch (error) {
        this.handle(error, contextFactory(...args));
        throw error;
      }
    };
  }
  /**
   * Check if an error is recoverable (can be retried or handled gracefully).
   */
  isRecoverable(error) {
    if (this.isRetryable(error)) {
      return true;
    }
    const recoverableTypes = [
      "RateLimitError",
      "TimeoutError",
      "NetworkError",
      "ConnectionError"
    ];
    return recoverableTypes.some(
      (type) => error.name === type || error.constructor.name === type
    );
  }
  /**
   * Check if an error should be retried.
   */
  isRetryable(error) {
    const errorString = `${error.name} ${error.message}`;
    return this.config.retryablePatterns.some(
      (pattern) => errorString.includes(pattern)
    );
  }
  /**
   * Add a retryable pattern.
   */
  addRetryablePattern(pattern) {
    if (!this.config.retryablePatterns.includes(pattern)) {
      this.config.retryablePatterns.push(pattern);
    }
  }
  /**
   * Remove a retryable pattern.
   */
  removeRetryablePattern(pattern) {
    const index = this.config.retryablePatterns.indexOf(pattern);
    if (index !== -1) {
      this.config.retryablePatterns.splice(index, 1);
    }
  }
  /**
   * Get current configuration (read-only).
   */
  getConfig() {
    return { ...this.config };
  }
  // ===== Private Helpers =====
  logError(error, context, recoverable) {
    const level = recoverable ? "warn" : "error";
    const logData = {
      error: error.message,
      errorName: error.name,
      recoverable,
      ...this.contextToLogFields(context)
    };
    if (this.config.includeStackTrace && error.stack) {
      logData.stack = error.stack;
    }
    this.logger[level](logData, `Error in ${context.operation}`);
  }
  contextToLogFields(context) {
    return {
      agentType: context.agentType,
      agentId: context.agentId,
      operation: context.operation,
      ...context.metadata || {}
    };
  }
  recordMetrics(error, context, recoverable) {
    exports.metrics.increment("error.handled", 1, {
      agentType: context.agentType,
      operation: context.operation,
      errorType: error.name,
      recoverable: String(recoverable)
    });
  }
  calculateRetryDelay(attempt) {
    const exponentialDelay = this.config.baseRetryDelayMs * Math.pow(2, attempt - 1);
    const jitter = exponentialDelay * (0.8 + Math.random() * 0.4);
    return Math.min(jitter, this.config.maxRetryDelayMs);
  }
  delay(ms) {
    return new Promise((resolve4) => setTimeout(resolve4, ms));
  }
};
var globalErrorHandler = new ErrorHandler();

// src/capabilities/images/ImageGeneration.ts
init_Connector();

// src/domain/entities/ImageModel.ts
var IMAGE_MODELS = {
  [Vendor.OpenAI]: {
    /** GPT-Image-1: Latest OpenAI image model with best quality */
    GPT_IMAGE_1: "gpt-image-1",
    /** DALL-E 3: High quality image generation */
    DALL_E_3: "dall-e-3",
    /** DALL-E 2: Fast, supports editing and variations */
    DALL_E_2: "dall-e-2"
  },
  [Vendor.Google]: {
    /** Imagen 4.0: Latest Google image generation model */
    IMAGEN_4_GENERATE: "imagen-4.0-generate-001",
    /** Imagen 4.0 Ultra: Highest quality */
    IMAGEN_4_ULTRA: "imagen-4.0-ultra-generate-001",
    /** Imagen 4.0 Fast: Optimized for speed */
    IMAGEN_4_FAST: "imagen-4.0-fast-generate-001"
  },
  [Vendor.Grok]: {
    /** Grok Imagine Image: xAI image generation with editing support */
    GROK_IMAGINE_IMAGE: "grok-imagine-image",
    /** Grok 2 Image: xAI image generation (text-only input) */
    GROK_2_IMAGE_1212: "grok-2-image-1212"
  }
};
var IMAGE_MODEL_REGISTRY = {
  // ======================== OpenAI ========================
  "gpt-image-1": {
    name: "gpt-image-1",
    displayName: "GPT-Image-1",
    provider: Vendor.OpenAI,
    description: "OpenAI latest image generation model with best quality and features",
    isActive: true,
    releaseDate: "2025-04-01",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/images",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["1024x1024", "1024x1536", "1536x1024", "auto"],
      maxImagesPerRequest: 10,
      outputFormats: ["png", "webp", "jpeg"],
      features: {
        generation: true,
        editing: true,
        variations: false,
        styleControl: false,
        qualityControl: true,
        transparency: true,
        promptRevision: false
      },
      limits: { maxPromptLength: 32e3 },
      vendorOptions: {
        quality: {
          type: "enum",
          label: "Quality",
          description: "Image quality level",
          enum: ["auto", "low", "medium", "high"],
          default: "auto",
          controlType: "select"
        },
        background: {
          type: "enum",
          label: "Background",
          description: "Background transparency",
          enum: ["auto", "transparent", "opaque"],
          default: "auto",
          controlType: "select"
        },
        output_format: {
          type: "enum",
          label: "Output Format",
          description: "Image file format",
          enum: ["png", "jpeg", "webp"],
          default: "png",
          controlType: "select"
        },
        output_compression: {
          type: "number",
          label: "Compression",
          description: "Compression level for JPEG/WebP (0-100)",
          min: 0,
          max: 100,
          default: 75,
          controlType: "slider"
        },
        moderation: {
          type: "enum",
          label: "Moderation",
          description: "Content moderation strictness",
          enum: ["auto", "low"],
          default: "auto",
          controlType: "radio"
        }
      }
    },
    pricing: {
      perImageStandard: 0.011,
      perImageHD: 0.042,
      currency: "USD"
    }
  },
  "dall-e-3": {
    name: "dall-e-3",
    displayName: "DALL-E 3",
    provider: Vendor.OpenAI,
    description: "High quality image generation with prompt revision",
    isActive: true,
    releaseDate: "2023-11-06",
    deprecationDate: "2026-05-12",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/images",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["1024x1024", "1024x1792", "1792x1024"],
      maxImagesPerRequest: 1,
      outputFormats: ["png", "url"],
      features: {
        generation: true,
        editing: false,
        variations: false,
        styleControl: true,
        qualityControl: true,
        transparency: false,
        promptRevision: true
      },
      limits: { maxPromptLength: 4e3 },
      vendorOptions: {
        quality: {
          type: "enum",
          label: "Quality",
          description: "Image quality: standard or HD",
          enum: ["standard", "hd"],
          default: "standard",
          controlType: "radio"
        },
        style: {
          type: "enum",
          label: "Style",
          description: "Image style: vivid (hyper-real) or natural",
          enum: ["vivid", "natural"],
          default: "vivid",
          controlType: "radio"
        }
      }
    },
    pricing: {
      perImageStandard: 0.04,
      perImageHD: 0.08,
      currency: "USD"
    }
  },
  "dall-e-2": {
    name: "dall-e-2",
    displayName: "DALL-E 2",
    provider: Vendor.OpenAI,
    description: "Fast image generation with editing and variation support",
    isActive: true,
    releaseDate: "2022-11-03",
    deprecationDate: "2026-05-12",
    sources: {
      documentation: "https://platform.openai.com/docs/guides/images",
      pricing: "https://openai.com/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["256x256", "512x512", "1024x1024"],
      maxImagesPerRequest: 10,
      outputFormats: ["png", "url"],
      features: {
        generation: true,
        editing: true,
        variations: true,
        styleControl: false,
        qualityControl: false,
        transparency: false,
        promptRevision: false
      },
      limits: { maxPromptLength: 1e3 },
      vendorOptions: {}
    },
    pricing: {
      perImage: 0.02,
      currency: "USD"
    }
  },
  // ======================== Google ========================
  "imagen-4.0-generate-001": {
    name: "imagen-4.0-generate-001",
    displayName: "Imagen 4.0 Generate",
    provider: Vendor.Google,
    description: "Google Imagen 4.0 - standard quality image generation",
    isActive: true,
    releaseDate: "2025-06-01",
    sources: {
      documentation: "https://ai.google.dev/gemini-api/docs/imagen",
      pricing: "https://ai.google.dev/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["1024x1024"],
      aspectRatios: ["1:1", "3:4", "4:3", "9:16", "16:9"],
      maxImagesPerRequest: 4,
      outputFormats: ["png", "jpeg"],
      features: {
        generation: true,
        editing: false,
        variations: false,
        styleControl: false,
        qualityControl: false,
        transparency: false,
        promptRevision: false
      },
      limits: { maxPromptLength: 480 },
      vendorOptions: {
        aspectRatio: {
          type: "enum",
          label: "Aspect Ratio",
          description: "Output image proportions",
          enum: ["1:1", "3:4", "4:3", "16:9", "9:16"],
          default: "1:1",
          controlType: "select"
        },
        sampleImageSize: {
          type: "enum",
          label: "Resolution",
          description: "Output image resolution",
          enum: ["1K", "2K"],
          default: "1K",
          controlType: "radio"
        },
        outputMimeType: {
          type: "enum",
          label: "Output Format",
          description: "Image file format",
          enum: ["image/png", "image/jpeg"],
          default: "image/png",
          controlType: "select"
        },
        negativePrompt: {
          type: "string",
          label: "Negative Prompt",
          description: "Elements to avoid in the generated image",
          controlType: "textarea"
        },
        personGeneration: {
          type: "enum",
          label: "Person Generation",
          description: "Controls whether people can appear in images",
          enum: ["dont_allow", "allow_adult", "allow_all"],
          default: "allow_adult",
          controlType: "select"
        },
        safetyFilterLevel: {
          type: "enum",
          label: "Safety Filter",
          description: "Content safety filtering threshold",
          enum: ["block_none", "block_only_high", "block_medium_and_above", "block_low_and_above"],
          default: "block_medium_and_above",
          controlType: "select"
        },
        enhancePrompt: {
          type: "boolean",
          label: "Enhance Prompt",
          description: "Use LLM-based prompt rewriting for better quality",
          default: true,
          controlType: "checkbox"
        },
        seed: {
          type: "number",
          label: "Seed",
          description: "Random seed for reproducible generation (1-2147483647)",
          min: 1,
          max: 2147483647,
          controlType: "text"
        },
        addWatermark: {
          type: "boolean",
          label: "Add Watermark",
          description: "Add invisible SynthID watermark",
          default: true,
          controlType: "checkbox"
        },
        language: {
          type: "enum",
          label: "Prompt Language",
          description: "Language of the input prompt",
          enum: ["auto", "en", "zh", "zh-CN", "zh-TW", "hi", "ja", "ko", "pt", "es"],
          default: "en",
          controlType: "select"
        }
      }
    },
    pricing: {
      perImage: 0.04,
      currency: "USD"
    }
  },
  "imagen-4.0-ultra-generate-001": {
    name: "imagen-4.0-ultra-generate-001",
    displayName: "Imagen 4.0 Ultra",
    provider: Vendor.Google,
    description: "Google Imagen 4.0 Ultra - highest quality image generation",
    isActive: true,
    releaseDate: "2025-06-01",
    sources: {
      documentation: "https://ai.google.dev/gemini-api/docs/imagen",
      pricing: "https://ai.google.dev/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["1024x1024"],
      aspectRatios: ["1:1", "3:4", "4:3", "9:16", "16:9"],
      maxImagesPerRequest: 4,
      outputFormats: ["png", "jpeg"],
      features: {
        generation: true,
        editing: false,
        variations: false,
        styleControl: false,
        qualityControl: true,
        transparency: false,
        promptRevision: false
      },
      limits: { maxPromptLength: 480 },
      vendorOptions: {
        aspectRatio: {
          type: "enum",
          label: "Aspect Ratio",
          description: "Output image proportions",
          enum: ["1:1", "3:4", "4:3", "16:9", "9:16"],
          default: "1:1",
          controlType: "select"
        },
        sampleImageSize: {
          type: "enum",
          label: "Resolution",
          description: "Output image resolution",
          enum: ["1K", "2K"],
          default: "1K",
          controlType: "radio"
        },
        outputMimeType: {
          type: "enum",
          label: "Output Format",
          description: "Image file format",
          enum: ["image/png", "image/jpeg"],
          default: "image/png",
          controlType: "select"
        },
        negativePrompt: {
          type: "string",
          label: "Negative Prompt",
          description: "Elements to avoid in the generated image",
          controlType: "textarea"
        },
        personGeneration: {
          type: "enum",
          label: "Person Generation",
          description: "Controls whether people can appear in images",
          enum: ["dont_allow", "allow_adult", "allow_all"],
          default: "allow_adult",
          controlType: "select"
        },
        safetyFilterLevel: {
          type: "enum",
          label: "Safety Filter",
          description: "Content safety filtering threshold",
          enum: ["block_none", "block_only_high", "block_medium_and_above", "block_low_and_above"],
          default: "block_medium_and_above",
          controlType: "select"
        },
        enhancePrompt: {
          type: "boolean",
          label: "Enhance Prompt",
          description: "Use LLM-based prompt rewriting for better quality",
          default: true,
          controlType: "checkbox"
        },
        seed: {
          type: "number",
          label: "Seed",
          description: "Random seed for reproducible generation (1-2147483647)",
          min: 1,
          max: 2147483647,
          controlType: "text"
        },
        addWatermark: {
          type: "boolean",
          label: "Add Watermark",
          description: "Add invisible SynthID watermark",
          default: true,
          controlType: "checkbox"
        },
        language: {
          type: "enum",
          label: "Prompt Language",
          description: "Language of the input prompt",
          enum: ["auto", "en", "zh", "zh-CN", "zh-TW", "hi", "ja", "ko", "pt", "es"],
          default: "en",
          controlType: "select"
        }
      }
    },
    pricing: {
      perImage: 0.08,
      currency: "USD"
    }
  },
  "imagen-4.0-fast-generate-001": {
    name: "imagen-4.0-fast-generate-001",
    displayName: "Imagen 4.0 Fast",
    provider: Vendor.Google,
    description: "Google Imagen 4.0 Fast - optimized for speed",
    isActive: true,
    releaseDate: "2025-06-01",
    sources: {
      documentation: "https://ai.google.dev/gemini-api/docs/imagen",
      pricing: "https://ai.google.dev/pricing",
      lastVerified: "2026-01-25"
    },
    capabilities: {
      sizes: ["1024x1024"],
      aspectRatios: ["1:1", "3:4", "4:3", "9:16", "16:9"],
      maxImagesPerRequest: 4,
      outputFormats: ["png", "jpeg"],
      features: {
        generation: true,
        editing: false,
        variations: false,
        styleControl: false,
        qualityControl: false,
        transparency: false,
        promptRevision: false
      },
      limits: { maxPromptLength: 480 },
      vendorOptions: {
        aspectRatio: {
          type: "enum",
          label: "Aspect Ratio",
          description: "Output image proportions",
          enum: ["1:1", "3:4", "4:3", "16:9", "9:16"],
          default: "1:1",
          controlType: "select"
        },
        sampleImageSize: {
          type: "enum",
          label: "Resolution",
          description: "Output image resolution",
          enum: ["1K", "2K"],
          default: "1K",
          controlType: "radio"
        },
        outputMimeType: {
          type: "enum",
          label: "Output Format",
          description: "Image file format",
          enum: ["image/png", "image/jpeg"],
          default: "image/png",
          controlType: "select"
        },
        negativePrompt: {
          type: "string",
          label: "Negative Prompt",
          description: "Elements to avoid in the generated image",
          controlType: "textarea"
        },
        personGeneration: {
          type: "enum",
          label: "Person Generation",
          description: "Controls whether people can appear in images",
          enum: ["dont_allow", "allow_adult", "allow_all"],
          default: "allow_adult",
          controlType: "select"
        },
        safetyFilterLevel: {
          type: "enum",
          label: "Safety Filter",
          description: "Content safety filtering threshold",
          enum: ["block_none", "block_only_high", "block_medium_and_above", "block_low_and_above"],
          default: "block_medium_and_above",
          controlType: "select"
        },
        enhancePrompt: {
          type: "boolean",
          label: "Enhance Prompt",
          description: "Use LLM-based prompt rewriting for better quality",
          default: true,
          controlType: "checkbox"
        },
        seed: {
          type: "number",
          label: "Seed",
          description: "Random seed for reproducible generation (1-2147483647)",
          min: 1,
          max: 2147483647,
          controlType: "text"
        },
        addWatermark: {
          type: "boolean",
          label: "Add Watermark",
          description: "Add invisible SynthID watermark",
          default: true,
          controlType: "checkbox"
        },
        language: {
          type: "enum",
          label: "Prompt Language",
          description: "Language of the input prompt",
          enum: ["auto", "en", "zh", "zh-CN", "zh-TW", "hi", "ja", "ko", "pt", "es"],
          default: "en",
          controlType: "select"
        }
      }
    },
    pricing: {
      perImage: 0.02,
      currency: "USD"
    }
  },
  // ======================== xAI Grok ========================
  "grok-imagine-image": {
    name: "grok-imagine-image",
    displayName: "Grok Imagine Image",
    provider: Vendor.Grok,
    description: "xAI Grok Imagine image generation with aspect ratio control and editing support",
    isActive: true,
    releaseDate: "2025-01-01",
    sources: {
      documentation: "https://docs.x.ai/docs/guides/image-generation",
      pricing: "https://docs.x.ai/docs/models",
      lastVerified: "2026-02-01"
    },
    capabilities: {
      sizes: ["1024x1024"],
      aspectRatios: ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3"],
      maxImagesPerRequest: 10,
      outputFormats: ["png", "jpeg"],
      features: {
        generation: true,
        editing: true,
        variations: false,
        styleControl: false,
        qualityControl: false,
        // quality not supported by xAI API
        transparency: false,
        promptRevision: true
      },
      limits: { maxPromptLength: 4096 },
      vendorOptions: {
        n: {
          type: "number",
          label: "Number of Images",
          description: "Number of images to generate (1-10)",
          min: 1,
          max: 10,
          default: 1,
          controlType: "slider"
        },
        response_format: {
          type: "enum",
          label: "Response Format",
          description: "Format of the returned image",
          enum: ["url", "b64_json"],
          default: "url",
          controlType: "radio"
        }
      }
    },
    pricing: {
      perImage: 0.02,
      currency: "USD"
    }
  },
  "grok-2-image-1212": {
    name: "grok-2-image-1212",
    displayName: "Grok 2 Image",
    provider: Vendor.Grok,
    description: "xAI Grok 2 image generation (text-only input, no editing)",
    isActive: true,
    releaseDate: "2024-12-12",
    sources: {
      documentation: "https://docs.x.ai/docs/guides/image-generation",
      pricing: "https://docs.x.ai/docs/models",
      lastVerified: "2026-02-01"
    },
    capabilities: {
      sizes: ["1024x1024"],
      aspectRatios: ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3"],
      maxImagesPerRequest: 10,
      outputFormats: ["png", "jpeg"],
      features: {
        generation: true,
        editing: false,
        variations: false,
        styleControl: false,
        qualityControl: false,
        // quality not supported by xAI API
        transparency: false,
        promptRevision: false
      },
      limits: { maxPromptLength: 4096 },
      vendorOptions: {
        n: {
          type: "number",
          label: "Number of Images",
          description: "Number of images to generate (1-10)",
          min: 1,
          max: 10,
          default: 1,
          controlType: "slider"
        },
        response_format: {
          type: "enum",
          label: "Response Format",
          description: "Format of the returned image",
          enum: ["url", "b64_json"],
          default: "url",
          controlType: "radio"
        }
      }
    },
    pricing: {
      perImage: 0.07,
      currency: "USD"
    }
  }
};
var helpers3 = createRegistryHelpers(IMAGE_MODEL_REGISTRY);
var getImageModelInfo = helpers3.getInfo;
var getImageModelsByVendor = helpers3.getByVendor;
var getActiveImageModels = helpers3.getActive;
function getImageModelsWithFeature(feature) {
  return Object.values(IMAGE_MODEL_REGISTRY).filter(
    (model) => model.isActive && model.capabilities.features[feature]
  );
}
function calculateImageCost(modelName, imageCount, quality = "standard") {
  const model = getImageModelInfo(modelName);
  if (!model?.pricing) return null;
  if (model.pricing.perImage) {
    return imageCount * model.pricing.perImage;
  }
  const pricePerImage = quality === "hd" ? model.pricing.perImageHD : model.pricing.perImageStandard;
  if (!pricePerImage) return null;
  return imageCount * pricePerImage;
}

// src/capabilities/images/ImageGeneration.ts
var ImageGeneration = class _ImageGeneration {
  provider;
  connector;
  defaultModel;
  constructor(connector) {
    this.connector = connector;
    this.provider = createImageProvider(connector);
    this.defaultModel = this.getDefaultModel();
  }
  /**
   * Create an ImageGeneration instance
   */
  static create(options) {
    const connector = typeof options.connector === "string" ? exports.Connector.get(options.connector) : options.connector;
    if (!connector) {
      throw new Error(`Connector not found: ${options.connector}`);
    }
    return new _ImageGeneration(connector);
  }
  /**
   * Generate images from a text prompt
   */
  async generate(options) {
    const fullOptions = {
      model: options.model || this.defaultModel,
      prompt: options.prompt,
      size: options.size,
      quality: options.quality,
      style: options.style,
      n: options.n,
      response_format: options.response_format || "b64_json"
    };
    return this.provider.generateImage(fullOptions);
  }
  /**
   * Edit an existing image
   * Note: Not all models/vendors support this
   */
  async edit(options) {
    if (!this.provider.editImage) {
      throw new Error(`Image editing not supported by ${this.provider.name}`);
    }
    const fullOptions = {
      ...options,
      model: options.model || this.getEditModel()
    };
    return this.provider.editImage(fullOptions);
  }
  /**
   * Create variations of an existing image
   * Note: Only DALL-E 2 supports this
   */
  async createVariation(options) {
    if (!this.provider.createVariation) {
      throw new Error(`Image variations not supported by ${this.provider.name}`);
    }
    const fullOptions = {
      ...options,
      model: options.model || "dall-e-2"
      // Only DALL-E 2 supports variations
    };
    return this.provider.createVariation(fullOptions);
  }
  /**
   * List available models for this provider
   */
  async listModels() {
    if (this.provider.listModels) {
      return this.provider.listModels();
    }
    const vendor = this.connector.vendor;
    if (vendor && IMAGE_MODELS[vendor]) {
      return Object.values(IMAGE_MODELS[vendor]);
    }
    return [];
  }
  /**
   * Get information about a specific model
   */
  getModelInfo(modelName) {
    return getImageModelInfo(modelName);
  }
  /**
   * Get the underlying provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   * Get the current connector
   */
  getConnector() {
    return this.connector;
  }
  /**
   * Get the default model for this vendor
   */
  getDefaultModel() {
    const vendor = this.connector.vendor;
    switch (vendor) {
      case Vendor.OpenAI:
        return IMAGE_MODELS[Vendor.OpenAI].DALL_E_3;
      case Vendor.Google:
        return IMAGE_MODELS[Vendor.Google].IMAGEN_4_GENERATE;
      case Vendor.Grok:
        return IMAGE_MODELS[Vendor.Grok].GROK_IMAGINE_IMAGE;
      default:
        throw new Error(`No default image model for vendor: ${vendor}`);
    }
  }
  /**
   * Get the default edit model for this vendor
   */
  getEditModel() {
    const vendor = this.connector.vendor;
    switch (vendor) {
      case Vendor.OpenAI:
        return IMAGE_MODELS[Vendor.OpenAI].GPT_IMAGE_1;
      case Vendor.Google:
        return IMAGE_MODELS[Vendor.Google].IMAGEN_4_GENERATE;
      case Vendor.Grok:
        return IMAGE_MODELS[Vendor.Grok].GROK_IMAGINE_IMAGE;
      default:
        throw new Error(`No edit model for vendor: ${vendor}`);
    }
  }
};

// src/capabilities/video/VideoGeneration.ts
init_Connector();
var OpenAISoraProvider = class extends BaseMediaProvider {
  name = "openai-video";
  vendor = "openai";
  capabilities = {
    text: false,
    images: false,
    videos: true,
    audio: false,
    features: {
      videoGeneration: true,
      imageToVideo: true,
      videoExtension: true
    }
  };
  client;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new OpenAI3__default.default({
      apiKey: config.auth.apiKey,
      baseURL: config.baseURL,
      organization: config.organization,
      timeout: config.timeout,
      maxRetries: config.maxRetries
    });
  }
  /**
   * Generate a video from a text prompt
   */
  async generateVideo(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.generate", {
            model: options.model,
            duration: options.duration,
            resolution: options.resolution
          });
          const model = options.model || "sora-2";
          const seconds = this.durationToSeconds(options.duration || 4);
          const params = {
            prompt: options.prompt,
            model,
            seconds
          };
          if (options.resolution) {
            params.size = this.resolutionToSize(options.resolution);
          } else if (options.aspectRatio) {
            params.size = this.aspectRatioToSize(options.aspectRatio);
          }
          if (options.image) {
            params.input_reference = await this.prepareImageInput(options.image);
          }
          const response = await this.client.videos.create(params);
          this.logOperationComplete("video.generate", {
            model,
            jobId: response.id,
            status: response.status
          });
          return this.mapResponse(response);
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.generate",
      { model: options.model }
    );
  }
  /**
   * Get the status of a video generation job
   */
  async getVideoStatus(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.status", { jobId });
          const response = await this.client.videos.retrieve(jobId);
          this.logOperationComplete("video.status", {
            jobId,
            status: response.status,
            progress: response.progress
          });
          return this.mapResponse(response);
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.status",
      { jobId }
    );
  }
  /**
   * Download a completed video
   */
  async downloadVideo(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.download", { jobId });
          const statusResponse = await this.getVideoStatus(jobId);
          if (statusResponse.status !== "completed") {
            throw new ProviderError("openai", `Video not ready. Status: ${statusResponse.status}`);
          }
          const response = await this.client.videos.downloadContent(jobId, { variant: "video" });
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          this.logOperationComplete("video.download", {
            jobId,
            size: buffer.length
          });
          return buffer;
        } catch (error) {
          if (error instanceof ProviderError) throw error;
          this.handleError(error);
          throw error;
        }
      },
      "video.download",
      { jobId }
    );
  }
  /**
   * Extend/remix an existing video
   * Note: OpenAI SDK uses 'remix' instead of 'extend'
   */
  async extendVideo(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.extend", {
            model: options.model,
            extendDuration: options.extendDuration,
            direction: options.direction
          });
          let videoId;
          if (typeof options.video === "string" && !options.video.startsWith("http")) {
            videoId = options.video;
          } else {
            throw new ProviderError(
              "openai",
              "Video extension requires a video ID. Upload the video first or provide the job ID."
            );
          }
          const prompt = options.prompt || "Extend this video seamlessly";
          const response = await this.client.videos.remix(videoId, { prompt });
          this.logOperationComplete("video.extend", {
            jobId: response.id,
            status: response.status
          });
          return this.mapResponse(response);
        } catch (error) {
          if (error instanceof ProviderError) throw error;
          this.handleError(error);
          throw error;
        }
      },
      "video.extend",
      { model: options.model }
    );
  }
  /**
   * List available video models
   */
  async listModels() {
    return ["sora-2", "sora-2-pro"];
  }
  /**
   * Cancel/delete a pending job
   */
  async cancelJob(jobId) {
    try {
      const response = await this.client.videos.delete(jobId);
      return response.deleted;
    } catch {
      return false;
    }
  }
  /**
   * Map OpenAI SDK Video response to our VideoResponse format
   */
  mapResponse(response) {
    const result = {
      jobId: response.id,
      status: this.mapStatus(response.status),
      created: response.created_at,
      progress: response.progress
    };
    if (response.status === "completed") {
      result.video = {
        duration: this.secondsStringToNumber(response.seconds),
        resolution: response.size,
        format: "mp4"
      };
    }
    if (response.status === "failed" && response.error) {
      result.error = response.error.message || "Video generation failed";
    }
    return result;
  }
  /**
   * Map OpenAI status to our status type
   */
  mapStatus(status) {
    switch (status) {
      case "queued":
      case "pending":
        return "pending";
      case "in_progress":
      case "processing":
        return "processing";
      case "completed":
      case "succeeded":
        return "completed";
      case "failed":
      case "cancelled":
        return "failed";
      default:
        return "pending";
    }
  }
  /**
   * Convert duration number to SDK's seconds string format
   */
  durationToSeconds(duration) {
    if (duration <= 4) return "4";
    if (duration <= 8) return "8";
    return "12";
  }
  /**
   * Convert seconds string back to number
   */
  secondsStringToNumber(seconds) {
    return parseInt(seconds, 10) || 4;
  }
  /**
   * Map resolution string to SDK's size format
   */
  resolutionToSize(resolution) {
    const validSizes = ["720x1280", "1280x720", "1024x1792", "1792x1024"];
    if (validSizes.includes(resolution)) {
      return resolution;
    }
    return "720x1280";
  }
  /**
   * Map aspect ratio to SDK's size format
   */
  aspectRatioToSize(aspectRatio) {
    const map = {
      "16:9": "1280x720",
      "9:16": "720x1280",
      "9:16-tall": "1024x1792",
      "16:9-tall": "1792x1024"
    };
    return map[aspectRatio] || "720x1280";
  }
  /**
   * Prepare image input for API (input_reference)
   */
  async prepareImageInput(image) {
    if (Buffer.isBuffer(image)) {
      return new File([new Uint8Array(image)], "input.png", { type: "image/png" });
    }
    if (!image.startsWith("http")) {
      const fs20 = await import('fs');
      const data = fs20.readFileSync(image);
      return new File([new Uint8Array(data)], "input.png", { type: "image/png" });
    }
    const response = await fetch(image);
    const arrayBuffer = await response.arrayBuffer();
    return new File([new Uint8Array(arrayBuffer)], "input.png", { type: "image/png" });
  }
  /**
   * Handle OpenAI API errors
   */
  handleError(error) {
    const message = error.message || "Unknown OpenAI API error";
    const status = error.status;
    if (status === 401) {
      throw new ProviderAuthError("openai", "Invalid API key");
    }
    if (status === 429) {
      throw new ProviderRateLimitError("openai", message);
    }
    if (status === 400) {
      if (message.includes("safety") || message.includes("policy")) {
        throw new ProviderError("openai", `Content policy violation: ${message}`);
      }
      throw new ProviderError("openai", `Bad request: ${message}`);
    }
    throw new ProviderError("openai", message);
  }
};
var GoogleVeoProvider = class extends BaseMediaProvider {
  name = "google-video";
  vendor = "google";
  capabilities = {
    text: false,
    images: false,
    videos: true,
    audio: false,
    features: {
      videoGeneration: true,
      imageToVideo: true,
      videoExtension: true
    }
  };
  client;
  pendingOperations = /* @__PURE__ */ new Map();
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.client = new genai.GoogleGenAI({
      apiKey: config.auth.apiKey
    });
  }
  /**
   * Generate a video from a text prompt
   */
  async generateVideo(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.generate", {
            model: options.model,
            duration: options.duration,
            resolution: options.resolution
          });
          const model = options.model || "veo-3.1-generate-preview";
          const googleOptions = options.vendorOptions || {};
          const config = {};
          if (options.aspectRatio) {
            config.aspectRatio = options.aspectRatio;
          }
          if (options.resolution) {
            config.resolution = options.resolution;
          }
          if (options.duration) {
            config.durationSeconds = options.duration;
          }
          if (options.seed !== void 0) {
            config.seed = options.seed;
          }
          if (googleOptions.negativePrompt) {
            config.negativePrompt = googleOptions.negativePrompt;
          }
          if (googleOptions.personGeneration) {
            config.personGeneration = googleOptions.personGeneration;
          }
          if (googleOptions.safetyFilterLevel) {
            config.safetyFilterLevel = googleOptions.safetyFilterLevel;
          }
          const request = {
            model,
            prompt: options.prompt,
            config
          };
          if (options.image) {
            request.image = await this.prepareImageInput(options.image);
          }
          if (googleOptions.lastFrame) {
            request.lastFrame = await this.prepareImageInput(googleOptions.lastFrame);
          }
          const operation = await this.client.models.generateVideos(request);
          const jobId = this.extractJobId(operation);
          this.pendingOperations.set(jobId, operation);
          this.logOperationComplete("video.generate", {
            model,
            jobId,
            status: "pending"
          });
          return {
            jobId,
            status: "pending",
            created: Math.floor(Date.now() / 1e3)
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.generate",
      { model: options.model }
    );
  }
  /**
   * Get the status of a video generation job
   */
  async getVideoStatus(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.status", { jobId });
          let operation = this.pendingOperations.get(jobId);
          if (!operation) {
            try {
              operation = await this.client.operations.getVideosOperation({
                operation: { name: jobId }
              });
            } catch {
              throw new ProviderError("google", `Video job not found: ${jobId}`);
            }
          }
          operation = await this.client.operations.getVideosOperation({
            operation
          });
          this.pendingOperations.set(jobId, operation);
          const response = this.mapResponse(jobId, operation);
          this.logOperationComplete("video.status", {
            jobId,
            status: response.status
          });
          return response;
        } catch (error) {
          if (error instanceof ProviderError) throw error;
          this.handleError(error);
          throw error;
        }
      },
      "video.status",
      { jobId }
    );
  }
  /**
   * Download a completed video
   */
  async downloadVideo(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.download", { jobId });
          const status = await this.getVideoStatus(jobId);
          if (status.status !== "completed") {
            throw new ProviderError("google", `Video not ready. Status: ${status.status}`);
          }
          const operation = this.pendingOperations.get(jobId);
          if (!operation?.response?.generatedVideos?.[0]?.video) {
            throw new ProviderError("google", "No video available for download");
          }
          const video = operation.response.generatedVideos[0].video;
          let buffer;
          if (video.videoBytes) {
            buffer = Buffer.from(video.videoBytes, "base64");
          } else if (video.uri) {
            const fs20 = await import('fs/promises');
            const os3 = await import('os');
            const path6 = await import('path');
            const tempDir = os3.tmpdir();
            const tempFile = path6.join(tempDir, `veo-${Date.now()}.mp4`);
            try {
              await this.client.files.download({
                file: { video },
                // Pass as GeneratedVideo
                downloadPath: tempFile
              });
              buffer = await fs20.readFile(tempFile);
              await fs20.unlink(tempFile).catch(() => {
              });
            } catch (downloadError) {
              await fs20.unlink(tempFile).catch(() => {
              });
              throw new ProviderError(
                "google",
                `Failed to download video: ${downloadError.message}`
              );
            }
          } else {
            throw new ProviderError(
              "google",
              "No videoBytes or uri available for download"
            );
          }
          this.logOperationComplete("video.download", {
            jobId,
            size: buffer.length
          });
          this.pendingOperations.delete(jobId);
          return buffer;
        } catch (error) {
          if (error instanceof ProviderError) throw error;
          this.handleError(error);
          throw error;
        }
      },
      "video.download",
      { jobId }
    );
  }
  /**
   * Extend an existing video (Veo 3.1 supports this)
   */
  async extendVideo(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.extend", {
            model: options.model,
            extendDuration: options.extendDuration
          });
          const model = options.model || "veo-3.1-generate-preview";
          const request = {
            model,
            prompt: options.prompt || "Continue the video seamlessly",
            config: {
              durationSeconds: String(options.extendDuration)
            }
          };
          if (Buffer.isBuffer(options.video)) {
            request.image = {
              imageBytes: options.video.toString("base64")
            };
          } else {
            request.video = { uri: options.video };
          }
          const operation = await this.client.models.generateVideos(request);
          const jobId = this.extractJobId(operation);
          this.pendingOperations.set(jobId, operation);
          this.logOperationComplete("video.extend", {
            jobId,
            status: "pending"
          });
          return {
            jobId,
            status: "pending",
            created: Math.floor(Date.now() / 1e3)
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.extend",
      { model: options.model }
    );
  }
  /**
   * List available video models
   */
  async listModels() {
    return [
      "veo-2.0-generate-001",
      "veo-3.1-fast-generate-preview",
      "veo-3.1-generate-preview"
    ];
  }
  /**
   * Wait for video completion with polling
   */
  async waitForCompletion(jobId, timeoutMs = 6e5) {
    const startTime = Date.now();
    const pollInterval = 1e4;
    while (Date.now() - startTime < timeoutMs) {
      const status = await this.getVideoStatus(jobId);
      if (status.status === "completed" || status.status === "failed") {
        return status;
      }
      await new Promise((resolve4) => setTimeout(resolve4, pollInterval));
    }
    throw new ProviderError("google", `Video generation timed out after ${timeoutMs}ms`);
  }
  /**
   * Extract job ID from operation
   */
  extractJobId(operation) {
    if (operation.name) {
      return operation.name;
    }
    return `veo-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Prepare image input for API
   */
  async prepareImageInput(image) {
    if (Buffer.isBuffer(image)) {
      return {
        imageBytes: image.toString("base64")
      };
    }
    if (image.startsWith("http://") || image.startsWith("https://")) {
      return { imageUri: image };
    }
    const fs20 = await import('fs/promises');
    const data = await fs20.readFile(image);
    return {
      imageBytes: data.toString("base64")
    };
  }
  /**
   * Map operation to VideoResponse
   */
  mapResponse(jobId, operation) {
    const result = {
      jobId,
      status: this.mapStatus(operation),
      created: Math.floor(Date.now() / 1e3)
    };
    if (operation.done && operation.response?.generatedVideos?.[0]) {
      const video = operation.response.generatedVideos[0];
      result.video = {
        duration: video.video?.duration,
        format: "mp4"
      };
      if (video.video?.uri) {
        result.video.url = video.video.uri;
      }
    }
    if (operation.error) {
      result.error = operation.error.message || "Video generation failed";
      result.status = "failed";
    }
    return result;
  }
  /**
   * Map operation status to our status type
   */
  mapStatus(operation) {
    if (operation.error) {
      return "failed";
    }
    if (operation.done) {
      return "completed";
    }
    if (operation.metadata?.state === "ACTIVE" || operation.metadata?.state === "PROCESSING") {
      return "processing";
    }
    return "pending";
  }
  /**
   * Handle Google API errors
   */
  handleError(error) {
    const message = error.message || "Unknown Google API error";
    const status = error.status || error.code;
    if (status === 401 || status === 403 || message.includes("API key")) {
      throw new ProviderAuthError("google", "Invalid API key");
    }
    if (status === 429 || message.includes("quota") || message.includes("rate")) {
      throw new ProviderRateLimitError("google", message);
    }
    if (status === 400) {
      if (message.includes("safety") || message.includes("blocked")) {
        throw new ProviderError("google", `Content policy violation: ${message}`);
      }
      throw new ProviderError("google", `Bad request: ${message}`);
    }
    throw new ProviderError("google", message);
  }
};

// src/infrastructure/providers/grok/GrokImagineProvider.ts
var GROK_API_BASE_URL2 = "https://api.x.ai/v1";
var GrokImagineProvider = class extends BaseMediaProvider {
  name = "grok-video";
  vendor = "grok";
  capabilities = {
    text: false,
    images: false,
    videos: true,
    audio: false,
    features: {
      videoGeneration: true,
      imageToVideo: true
    }
  };
  apiKey;
  baseURL;
  timeout;
  constructor(config) {
    super({ apiKey: config.auth.apiKey, ...config });
    this.apiKey = config.auth.apiKey;
    this.baseURL = config.baseURL || GROK_API_BASE_URL2;
    this.timeout = config.timeout || 6e4;
  }
  /**
   * Generate a video from a text prompt
   */
  async generateVideo(options) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.generate", {
            model: options.model,
            duration: options.duration,
            resolution: options.resolution,
            aspectRatio: options.aspectRatio
          });
          const request = {
            prompt: options.prompt,
            model: options.model || "grok-imagine-video",
            duration: options.duration || 6
          };
          if (options.aspectRatio) {
            request.aspect_ratio = options.aspectRatio;
          }
          if (options.resolution) {
            request.resolution = options.resolution;
          }
          if (options.image) {
            const imageUrl = await this.prepareImageUrl(options.image);
            request.image = { url: imageUrl };
          }
          const response = await this.makeRequest(
            "POST",
            "/videos/generations",
            request
          );
          this.logOperationComplete("video.generate", {
            model: options.model,
            jobId: response.request_id
          });
          return {
            jobId: response.request_id,
            status: "pending",
            created: Date.now()
          };
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.generate",
      { model: options.model }
    );
  }
  /**
   * Get the status of a video generation job
   */
  async getVideoStatus(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.status", { jobId });
          const response = await this.makeRequest(
            "GET",
            `/videos/${jobId}`
          );
          this.logOperationComplete("video.status", {
            jobId,
            status: response.video ? "done" : response.status || "pending",
            hasVideo: !!response.video?.url
          });
          return this.mapStatusResponse(response, jobId);
        } catch (error) {
          this.handleError(error);
          throw error;
        }
      },
      "video.status",
      { jobId }
    );
  }
  /**
   * Download a completed video
   */
  async downloadVideo(jobId) {
    return this.executeWithCircuitBreaker(
      async () => {
        try {
          this.logOperationStart("video.download", { jobId });
          const statusResponse = await this.getVideoStatus(jobId);
          if (statusResponse.status !== "completed") {
            throw new ProviderError("grok", `Video not ready. Status: ${statusResponse.status}`);
          }
          if (!statusResponse.video?.url) {
            throw new ProviderError("grok", "No video URL available");
          }
          const response = await fetch(statusResponse.video.url);
          if (!response.ok) {
            throw new ProviderError("grok", `Failed to download video: ${response.statusText}`);
          }
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          this.logOperationComplete("video.download", {
            jobId,
            size: buffer.length
          });
          return buffer;
        } catch (error) {
          if (error instanceof ProviderError) throw error;
          this.handleError(error);
          throw error;
        }
      },
      "video.download",
      { jobId }
    );
  }
  /**
   * List available video models
   */
  async listModels() {
    return ["grok-imagine-video"];
  }
  /**
   * Cancel a pending video generation job
   */
  async cancelJob(jobId) {
    try {
      await this.makeRequest("DELETE", `/videos/${jobId}`);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Make HTTP request to xAI API
   */
  async makeRequest(method, endpoint, body) {
    const url2 = `${this.baseURL}${endpoint}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const headers = {
        "Authorization": `Bearer ${this.apiKey}`,
        "Accept": "application/json"
      };
      if (body) {
        headers["Content-Type"] = "application/json";
      }
      const response = await fetch(url2, {
        method,
        headers,
        body: body ? JSON.stringify(body) : void 0,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        const errorMessage = errorBody.error?.message || errorBody.message || errorBody.detail || JSON.stringify(errorBody) || `HTTP ${response.status}`;
        const error = new Error(errorMessage);
        error.status = response.status;
        error.body = errorBody;
        throw error;
      }
      return response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
  /**
   * Map xAI status response to our VideoResponse format
   *
   * xAI API response format:
   * - Pending: { status: 'pending' }
   * - Complete: { video: { url, duration, respect_moderation }, model: string }
   *   (no 'status' field when complete)
   */
  mapStatusResponse(response, jobId) {
    let status;
    if (response.video) {
      if (response.video.respect_moderation === false) {
        status = "failed";
      } else if (response.video.url) {
        status = "completed";
      } else {
        status = "failed";
      }
    } else {
      status = "processing";
    }
    const result = {
      jobId,
      status,
      created: Date.now()
    };
    if (status === "completed" && response.video) {
      result.video = {
        url: response.video.url,
        duration: response.video.duration,
        format: "mp4"
      };
    }
    if (response.video?.respect_moderation === false) {
      result.error = "Video blocked by content moderation";
    }
    return result;
  }
  /**
   * Prepare image URL for image-to-video
   * xAI expects image.url - can be http(s) URL or data URL
   */
  async prepareImageUrl(image) {
    if (Buffer.isBuffer(image)) {
      const base642 = image.toString("base64");
      return `data:image/png;base64,${base642}`;
    }
    if (image.startsWith("http") || image.startsWith("data:")) {
      return image;
    }
    const fs20 = await import('fs');
    const data = fs20.readFileSync(image);
    const base64 = data.toString("base64");
    const ext = image.split(".").pop()?.toLowerCase() || "png";
    const mimeType = ext === "jpg" || ext === "jpeg" ? "image/jpeg" : `image/${ext}`;
    return `data:${mimeType};base64,${base64}`;
  }
  /**
   * Handle API errors
   */
  handleError(error) {
    const message = error.message || "Unknown Grok API error";
    const status = error.status;
    if (status === 401) {
      throw new ProviderAuthError("grok", "Invalid API key");
    }
    if (status === 429) {
      throw new ProviderRateLimitError("grok", message);
    }
    if (status === 400) {
      if (message.includes("safety") || message.includes("policy") || message.includes("moderation")) {
        throw new ProviderError("grok", `Content policy violation: ${message}`);
      }
      throw new ProviderError("grok", `Bad request: ${message}`);
    }
    if (status === 422) {
      throw new ProviderError("grok", `Validation error: ${message}`);
    }
    if (status === 404) {
      throw new ProviderError("grok", `Not found: ${message}`);
    }
    throw new ProviderError("grok", message);
  }
};

// src/core/createVideoProvider.ts
function createVideoProvider(connector) {
  const vendor = connector.vendor;
  switch (vendor) {
    case Vendor.OpenAI:
      return new OpenAISoraProvider(extractOpenAIConfig3(connector));
    case Vendor.Google:
      return new GoogleVeoProvider(extractGoogleConfig3(connector));
    case Vendor.Grok:
      return new GrokImagineProvider(extractGrokConfig2(connector));
    default:
      throw new Error(
        `Video generation not supported for vendor: ${vendor}. Supported vendors: ${Vendor.OpenAI}, ${Vendor.Google}, ${Vendor.Grok}`
      );
  }
}
function extractOpenAIConfig3(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("OpenAI requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    baseURL: connector.baseURL,
    organization: options.organization,
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}
function extractGoogleConfig3(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("Google requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}
function extractGrokConfig2(connector) {
  const auth2 = connector.config.auth;
  if (auth2.type !== "api_key") {
    throw new Error("Grok requires API key authentication");
  }
  const options = connector.getOptions();
  return {
    auth: {
      type: "api_key",
      apiKey: auth2.apiKey
    },
    baseURL: connector.baseURL,
    timeout: options.timeout,
    maxRetries: options.maxRetries
  };
}

// src/domain/entities/VideoModel.ts
var VIDEO_MODELS = {
  [Vendor.OpenAI]: {
    SORA_2: "sora-2",
    SORA_2_PRO: "sora-2-pro"
  },
  [Vendor.Google]: {
    // Gemini API (ai.google.dev) model names - use with API key
    VEO_2: "veo-2.0-generate-001",
    VEO_3_1_FAST: "veo-3.1-fast-generate-preview",
    VEO_3_1: "veo-3.1-generate-preview"
  },
  [Vendor.Grok]: {
    // xAI Grok Imagine video generation
    GROK_IMAGINE_VIDEO: "grok-imagine-video"
  }
};
var OPENAI_SOURCES = {
  documentation: "https://platform.openai.com/docs/guides/video-generation",
  apiReference: "https://platform.openai.com/docs/api-reference/videos",
  lastVerified: "2026-01-25"
};
var GOOGLE_SOURCES = {
  documentation: "https://docs.cloud.google.com/vertex-ai/generative-ai/docs/video/overview",
  apiReference: "https://docs.cloud.google.com/vertex-ai/generative-ai/docs/model-reference/veo-video-generation",
  lastVerified: "2026-01-25"
};
var GROK_SOURCES = {
  documentation: "https://docs.x.ai/docs/guides/video-generations",
  apiReference: "https://docs.x.ai/api",
  lastVerified: "2026-01-31"
};
var VIDEO_MODEL_REGISTRY = {
  // ============================================================================
  // OpenAI Sora Models
  // ============================================================================
  "sora-2": {
    name: "sora-2",
    displayName: "Sora 2",
    provider: Vendor.OpenAI,
    isActive: true,
    sources: OPENAI_SOURCES,
    capabilities: {
      durations: [4, 8, 12],
      resolutions: ["720x1280", "1280x720", "1024x1792", "1792x1024"],
      maxFps: 30,
      audio: true,
      imageToVideo: true,
      videoExtension: true,
      frameControl: false,
      features: {
        upscaling: false,
        styleControl: false,
        negativePrompt: false,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.15,
      currency: "USD"
    }
  },
  "sora-2-pro": {
    name: "sora-2-pro",
    displayName: "Sora 2 Pro",
    provider: Vendor.OpenAI,
    isActive: true,
    sources: OPENAI_SOURCES,
    capabilities: {
      durations: [4, 8, 12],
      resolutions: ["720x1280", "1280x720", "1024x1792", "1792x1024", "1920x1080", "1080x1920"],
      maxFps: 30,
      audio: true,
      imageToVideo: true,
      videoExtension: true,
      frameControl: true,
      features: {
        upscaling: true,
        styleControl: true,
        negativePrompt: false,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.4,
      currency: "USD"
    }
  },
  // ============================================================================
  // Google Veo Models
  // ============================================================================
  "veo-2.0-generate-001": {
    name: "veo-2.0-generate-001",
    displayName: "Veo 2.0",
    provider: Vendor.Google,
    isActive: true,
    sources: GOOGLE_SOURCES,
    capabilities: {
      durations: [5, 6, 7, 8],
      resolutions: [],
      // Veo 2.0 uses aspectRatio only, no resolution control
      aspectRatios: ["16:9", "9:16"],
      maxFps: 24,
      audio: false,
      imageToVideo: true,
      videoExtension: false,
      frameControl: true,
      features: {
        upscaling: false,
        styleControl: false,
        negativePrompt: true,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.03,
      currency: "USD"
    }
  },
  "veo-3.1-fast-generate-preview": {
    name: "veo-3.1-fast-generate-preview",
    displayName: "Veo 3.1 Fast",
    provider: Vendor.Google,
    isActive: true,
    sources: GOOGLE_SOURCES,
    capabilities: {
      durations: [4, 6, 8],
      resolutions: ["720p"],
      // Fast model only supports 720p
      aspectRatios: ["16:9", "9:16"],
      maxFps: 24,
      audio: true,
      imageToVideo: true,
      videoExtension: false,
      frameControl: false,
      features: {
        upscaling: false,
        styleControl: false,
        negativePrompt: true,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.75,
      currency: "USD"
    }
  },
  "veo-3.1-generate-preview": {
    name: "veo-3.1-generate-preview",
    displayName: "Veo 3.1",
    provider: Vendor.Google,
    isActive: true,
    sources: GOOGLE_SOURCES,
    capabilities: {
      durations: [4, 6, 8],
      resolutions: ["720p", "1080p", "4k"],
      // 1080p and 4k require 8s duration
      aspectRatios: ["16:9", "9:16"],
      maxFps: 30,
      audio: true,
      imageToVideo: true,
      videoExtension: true,
      frameControl: true,
      features: {
        upscaling: true,
        styleControl: true,
        negativePrompt: true,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.75,
      currency: "USD"
    }
  },
  // ============================================================================
  // xAI Grok Imagine Models
  // ============================================================================
  "grok-imagine-video": {
    name: "grok-imagine-video",
    displayName: "Grok Imagine Video",
    provider: Vendor.Grok,
    isActive: true,
    sources: GROK_SOURCES,
    capabilities: {
      durations: [1, 5, 8, 10, 15],
      resolutions: ["480p", "720p"],
      aspectRatios: ["16:9", "4:3", "1:1", "9:16", "3:4", "3:2", "2:3"],
      maxFps: 24,
      audio: true,
      imageToVideo: true,
      videoExtension: false,
      frameControl: false,
      features: {
        upscaling: false,
        styleControl: false,
        negativePrompt: false,
        seed: true
      }
    },
    pricing: {
      perSecond: 0.05,
      currency: "USD"
    }
  }
};
var helpers4 = createRegistryHelpers(VIDEO_MODEL_REGISTRY);
var getVideoModelInfo = helpers4.getInfo;
var getVideoModelsByVendor = helpers4.getByVendor;
var getActiveVideoModels = helpers4.getActive;
function getVideoModelsWithFeature(feature) {
  return Object.values(VIDEO_MODEL_REGISTRY).filter(
    (model) => model.isActive && model.capabilities.features[feature]
  );
}
function getVideoModelsWithAudio() {
  return Object.values(VIDEO_MODEL_REGISTRY).filter((model) => model.isActive && model.capabilities.audio);
}
function calculateVideoCost(modelName, durationSeconds) {
  const model = VIDEO_MODEL_REGISTRY[modelName];
  if (!model || !model.pricing) {
    return null;
  }
  return model.pricing.perSecond * durationSeconds;
}

// src/capabilities/video/VideoGeneration.ts
var VideoGeneration = class _VideoGeneration {
  provider;
  connector;
  defaultModel;
  constructor(connector) {
    this.connector = connector;
    this.provider = createVideoProvider(connector);
    this.defaultModel = this.getDefaultModel();
  }
  /**
   * Create a VideoGeneration instance
   */
  static create(options) {
    const connector = typeof options.connector === "string" ? exports.Connector.get(options.connector) : options.connector;
    if (!connector) {
      throw new Error(`Connector not found: ${options.connector}`);
    }
    return new _VideoGeneration(connector);
  }
  /**
   * Generate a video from a text prompt
   * Returns a job that can be polled for completion
   */
  async generate(options) {
    const fullOptions = {
      model: options.model || this.defaultModel,
      prompt: options.prompt,
      duration: options.duration,
      resolution: options.resolution,
      aspectRatio: options.aspectRatio,
      image: options.image,
      seed: options.seed,
      vendorOptions: options.vendorOptions
    };
    return this.provider.generateVideo(fullOptions);
  }
  /**
   * Get the status of a video generation job
   */
  async getStatus(jobId) {
    return this.provider.getVideoStatus(jobId);
  }
  /**
   * Wait for a video generation job to complete
   */
  async waitForCompletion(jobId, timeoutMs = 6e5) {
    const startTime = Date.now();
    const pollInterval = 1e4;
    while (Date.now() - startTime < timeoutMs) {
      const status = await this.provider.getVideoStatus(jobId);
      if (status.status === "completed") {
        return status;
      }
      if (status.status === "failed") {
        throw new ProviderError(
          this.connector.vendor || "unknown",
          `Video generation failed: ${status.error || "Unknown error"}`
        );
      }
      await new Promise((resolve4) => setTimeout(resolve4, pollInterval));
    }
    throw new ProviderError(
      this.connector.vendor || "unknown",
      `Video generation timed out after ${timeoutMs}ms`
    );
  }
  /**
   * Download a completed video
   */
  async download(jobId) {
    if (!this.provider.downloadVideo) {
      throw new Error(`Video download not supported by ${this.provider.name}`);
    }
    return this.provider.downloadVideo(jobId);
  }
  /**
   * Generate and wait for completion in one call
   */
  async generateAndWait(options, timeoutMs = 6e5) {
    const job = await this.generate(options);
    return this.waitForCompletion(job.jobId, timeoutMs);
  }
  /**
   * Extend an existing video
   * Note: Not all models/vendors support this
   */
  async extend(options) {
    if (!this.provider.extendVideo) {
      throw new Error(`Video extension not supported by ${this.provider.name}`);
    }
    const fullOptions = {
      ...options,
      model: options.model || this.getExtendModel()
    };
    return this.provider.extendVideo(fullOptions);
  }
  /**
   * Cancel a pending video generation job
   */
  async cancel(jobId) {
    if (!this.provider.cancelJob) {
      throw new Error(`Job cancellation not supported by ${this.provider.name}`);
    }
    return this.provider.cancelJob(jobId);
  }
  /**
   * List available models for this provider
   */
  async listModels() {
    if (this.provider.listModels) {
      return this.provider.listModels();
    }
    const vendor = this.connector.vendor;
    if (vendor && VIDEO_MODELS[vendor]) {
      return Object.values(VIDEO_MODELS[vendor]);
    }
    return [];
  }
  /**
   * Get information about a specific model
   */
  getModelInfo(modelName) {
    return getVideoModelInfo(modelName);
  }
  /**
   * Get the underlying provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   * Get the current connector
   */
  getConnector() {
    return this.connector;
  }
  /**
   * Get the default model for this vendor
   */
  getDefaultModel() {
    const vendor = this.connector.vendor;
    switch (vendor) {
      case Vendor.OpenAI:
        return VIDEO_MODELS[Vendor.OpenAI].SORA_2;
      case Vendor.Google:
        return VIDEO_MODELS[Vendor.Google].VEO_3_1;
      case Vendor.Grok:
        return VIDEO_MODELS[Vendor.Grok].GROK_IMAGINE_VIDEO;
      default:
        throw new Error(`No default video model for vendor: ${vendor}`);
    }
  }
  /**
   * Get the model that supports video extension
   */
  getExtendModel() {
    const vendor = this.connector.vendor;
    switch (vendor) {
      case Vendor.OpenAI:
        return VIDEO_MODELS[Vendor.OpenAI].SORA_2;
      case Vendor.Google:
        return VIDEO_MODELS[Vendor.Google].VEO_3_1;
      default:
        throw new Error(`No extend model for vendor: ${vendor}`);
    }
  }
};

// src/capabilities/search/SearchProvider.ts
init_Connector();

// src/capabilities/shared/types.ts
function buildQueryString(params) {
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== void 0 && value !== null) {
      searchParams.append(key, String(value));
    }
  }
  return searchParams.toString();
}
function toConnectorOptions(options) {
  const { body, queryParams, ...rest } = options;
  const connectorOptions = {
    ...rest
  };
  if (body) {
    connectorOptions.body = JSON.stringify(body);
    connectorOptions.headers = {
      "Content-Type": "application/json",
      ...rest.headers
    };
  }
  return connectorOptions;
}
function buildEndpointWithQuery(endpoint, queryParams) {
  if (!queryParams || Object.keys(queryParams).length === 0) {
    return endpoint;
  }
  const queryString = buildQueryString(queryParams);
  const separator = endpoint.includes("?") ? "&" : "?";
  return `${endpoint}${separator}${queryString}`;
}
function resolveConnector(connectorOrName) {
  const { Connector: ConnectorClass } = (init_Connector(), __toCommonJS(Connector_exports));
  if (typeof connectorOrName === "string") {
    return ConnectorClass.get(connectorOrName);
  }
  return connectorOrName;
}
function findConnectorByServiceTypes(serviceTypes) {
  const { Connector: ConnectorClass } = (init_Connector(), __toCommonJS(Connector_exports));
  const allConnectors = ConnectorClass.list();
  for (const serviceType of serviceTypes) {
    for (const name of allConnectors) {
      try {
        const connector = ConnectorClass.get(name);
        if (connector?.serviceType === serviceType) {
          return connector;
        }
      } catch {
      }
    }
  }
  return null;
}
function listConnectorsByServiceTypes(serviceTypes) {
  const { Connector: ConnectorClass } = (init_Connector(), __toCommonJS(Connector_exports));
  const allConnectors = ConnectorClass.list();
  const matching = [];
  for (const name of allConnectors) {
    try {
      const connector = ConnectorClass.get(name);
      if (connector?.serviceType && serviceTypes.includes(connector.serviceType)) {
        matching.push(name);
      }
    } catch {
    }
  }
  return matching;
}

// src/capabilities/search/providers/SerperProvider.ts
var SerperProvider = class {
  constructor(connector) {
    this.connector = connector;
  }
  name = "serper";
  async search(query, options = {}) {
    const numResults = Math.min(options.numResults || 10, 100);
    try {
      const fetchOptions = toConnectorOptions({
        method: "POST",
        body: {
          q: query,
          num: numResults,
          ...options.country && { gl: options.country },
          ...options.language && { hl: options.language },
          ...options.vendorOptions
        }
      });
      const response = await this.connector.fetchJSON("/search", fetchOptions);
      if (!response.organic || !Array.isArray(response.organic)) {
        throw new Error("Invalid response from Serper API");
      }
      const results = response.organic.slice(0, numResults).map((result, index) => ({
        title: result.title || "Untitled",
        url: result.link || "",
        snippet: result.snippet || "",
        position: index + 1
      }));
      return {
        success: true,
        query,
        provider: this.name,
        results,
        count: results.length
      };
    } catch (error) {
      return {
        success: false,
        query,
        provider: this.name,
        results: [],
        count: 0,
        error: error.message || "Unknown error"
      };
    }
  }
};

// src/capabilities/search/providers/BraveProvider.ts
var BraveProvider = class {
  constructor(connector) {
    this.connector = connector;
  }
  name = "brave";
  async search(query, options = {}) {
    const numResults = Math.min(options.numResults || 10, 20);
    try {
      const queryParams = {
        q: query,
        count: numResults,
        ...options.country && { country: options.country },
        ...options.language && { search_lang: options.language },
        ...options.vendorOptions
      };
      const queryString = buildQueryString(queryParams);
      const response = await this.connector.fetchJSON(`/web/search?${queryString}`, {
        method: "GET"
      });
      if (!response.web?.results || !Array.isArray(response.web.results)) {
        throw new Error("Invalid response from Brave API");
      }
      const results = response.web.results.slice(0, numResults).map((result, index) => ({
        title: result.title || "Untitled",
        url: result.url || "",
        snippet: result.description || "",
        position: index + 1
      }));
      return {
        success: true,
        query,
        provider: this.name,
        results,
        count: results.length
      };
    } catch (error) {
      return {
        success: false,
        query,
        provider: this.name,
        results: [],
        count: 0,
        error: error.message || "Unknown error"
      };
    }
  }
};

// src/capabilities/search/providers/TavilyProvider.ts
var TavilyProvider = class {
  constructor(connector) {
    this.connector = connector;
  }
  name = "tavily";
  async search(query, options = {}) {
    const numResults = Math.min(options.numResults || 10, 20);
    try {
      const auth2 = this.connector.config.auth;
      const apiKey = auth2.type === "api_key" ? auth2.apiKey : "";
      const fetchOptions = toConnectorOptions({
        method: "POST",
        body: {
          api_key: apiKey,
          query,
          max_results: numResults,
          search_depth: options.vendorOptions?.search_depth || "basic",
          include_answer: options.vendorOptions?.include_answer || false,
          include_raw_content: options.vendorOptions?.include_raw_content || false,
          ...options.vendorOptions
        }
      });
      const response = await this.connector.fetchJSON("/search", fetchOptions);
      if (!response.results || !Array.isArray(response.results)) {
        throw new Error("Invalid response from Tavily API");
      }
      const results = response.results.slice(0, numResults).map((result, index) => ({
        title: result.title || "Untitled",
        url: result.url || "",
        snippet: result.content || "",
        position: index + 1
      }));
      return {
        success: true,
        query,
        provider: this.name,
        results,
        count: results.length
      };
    } catch (error) {
      return {
        success: false,
        query,
        provider: this.name,
        results: [],
        count: 0,
        error: error.message || "Unknown error"
      };
    }
  }
};

// src/capabilities/search/providers/RapidAPIProvider.ts
init_Logger();
var rapidapiLogger = exports.logger.child({ component: "RapidAPIProvider" });
var RapidAPIProvider = class {
  constructor(connector) {
    this.connector = connector;
  }
  name = "rapidapi";
  async search(query, options = {}) {
    const numResults = Math.min(options.numResults || 10, 100);
    rapidapiLogger.debug({ query, numResults, options }, "RapidAPI search started");
    try {
      const queryParams = {
        q: query,
        num: numResults,
        start: 0,
        fetch_ai_overviews: false,
        deduplicate: false,
        return_organic_result_video_thumbnail: false,
        nfpr: 0,
        ...options.country && { gl: options.country },
        ...options.language && { hl: options.language },
        ...options.vendorOptions
      };
      const baseURL = this.connector.baseURL;
      const host = baseURL ? new URL(baseURL).host : "real-time-web-search.p.rapidapi.com";
      rapidapiLogger.debug({ baseURL, host }, "Using RapidAPI host");
      let apiKey = "";
      try {
        apiKey = this.connector.getApiKey();
        rapidapiLogger.debug({ hasApiKey: !!apiKey, keyLength: apiKey?.length }, "Got API key");
      } catch (e) {
        rapidapiLogger.error({ error: e.message }, "Failed to get API key");
        throw new Error("RapidAPI provider requires API key authentication");
      }
      const queryString = buildQueryString(queryParams);
      const requestUrl = `/search?${queryString}`;
      rapidapiLogger.debug({ requestUrl, method: "GET" }, "Making RapidAPI request");
      const response = await this.connector.fetchJSON(requestUrl, {
        method: "GET",
        headers: {
          "X-RapidAPI-Key": apiKey,
          "X-RapidAPI-Host": host
        }
      });
      rapidapiLogger.debug({
        hasResponse: !!response,
        hasData: !!response?.data,
        dataKeys: response?.data ? Object.keys(response.data) : [],
        hasOrganicResults: !!(response?.data?.organic_results || response?.data?.organic),
        organicResultsCount: (response?.data?.organic_results || response?.data?.organic || []).length
      }, "RapidAPI response received");
      const organicResults = response.data?.organic_results || response.data?.organic || response.organic_results || response.organic || [];
      if (!Array.isArray(organicResults)) {
        rapidapiLogger.error({
          responseType: typeof organicResults,
          response: JSON.stringify(response).slice(0, 500)
        }, "Invalid response format - organic is not an array");
        throw new Error("Invalid response from RapidAPI Search");
      }
      const results = organicResults.slice(0, numResults).map((result, index) => ({
        title: result.title || "Untitled",
        url: result.link || result.url || "",
        snippet: result.snippet || result.description || "",
        position: index + 1
      }));
      rapidapiLogger.debug({
        success: true,
        resultCount: results.length,
        firstTitle: results[0]?.title
      }, "RapidAPI search completed successfully");
      return {
        success: true,
        query,
        provider: this.name,
        results,
        count: results.length
      };
    } catch (error) {
      rapidapiLogger.error({
        error: error.message,
        stack: error.stack
      }, "RapidAPI search failed");
      return {
        success: false,
        query,
        provider: this.name,
        results: [],
        count: 0,
        error: error.message || "Unknown error"
      };
    }
  }
};

// src/capabilities/search/SearchProvider.ts
var SearchProvider = class {
  /**
   * Create a search provider from a connector
   * @param config - Provider configuration
   * @returns Search provider instance
   */
  static create(config) {
    const connector = typeof config.connector === "string" ? exports.Connector.get(config.connector) : config.connector;
    if (!connector) {
      throw new Error(
        `Connector not found: ${typeof config.connector === "string" ? config.connector : "unknown"}`
      );
    }
    const serviceType = connector.serviceType;
    switch (serviceType) {
      case "serper":
        return new SerperProvider(connector);
      case "brave-search":
        return new BraveProvider(connector);
      case "tavily":
        return new TavilyProvider(connector);
      case "rapidapi-search":
        return new RapidAPIProvider(connector);
      default:
        throw new Error(
          `Unknown search service type: ${serviceType}. Supported: serper, brave-search, tavily, rapidapi-search`
        );
    }
  }
};

// src/capabilities/scrape/ScrapeProvider.ts
var providerRegistry = /* @__PURE__ */ new Map();
function registerScrapeProvider(serviceType, providerClass) {
  providerRegistry.set(serviceType, providerClass);
}
function getRegisteredScrapeProviders() {
  return Array.from(providerRegistry.keys());
}
var ScrapeProvider = class _ScrapeProvider {
  /**
   * Create a scrape provider from a connector
   *
   * @param config - Provider configuration
   * @returns Scrape provider instance
   * @throws Error if connector not found or service type not supported
   *
   * @example
   * ```typescript
   * const scraper = ScrapeProvider.create({ connector: 'jina-main' });
   * const result = await scraper.scrape('https://example.com');
   * ```
   */
  static create(config) {
    const connector = resolveConnector(config.connector);
    const serviceType = connector.serviceType;
    if (!serviceType) {
      throw new Error(
        `Connector '${connector.name}' has no serviceType. Set serviceType when creating the connector.`
      );
    }
    const ProviderClass = providerRegistry.get(serviceType);
    if (!ProviderClass) {
      const registered = getRegisteredScrapeProviders();
      throw new Error(
        `No scrape provider registered for service type '${serviceType}'. Registered providers: ${registered.length > 0 ? registered.join(", ") : "none"}. Make sure to import the provider module.`
      );
    }
    return new ProviderClass(connector);
  }
  /**
   * Check if a service type has a registered provider
   */
  static hasProvider(serviceType) {
    return providerRegistry.has(serviceType);
  }
  /**
   * List all registered provider service types
   */
  static listProviders() {
    return getRegisteredScrapeProviders();
  }
  /**
   * Create a scrape provider with fallback chain
   *
   * Returns a provider that will try each connector in order until one succeeds.
   *
   * @param config - Fallback configuration
   * @returns Scrape provider with fallback support
   *
   * @example
   * ```typescript
   * const scraper = ScrapeProvider.createWithFallback({
   *   primary: 'jina-main',
   *   fallbacks: ['firecrawl-backup', 'scrapingbee'],
   * });
   * // Will try jina first, then firecrawl, then scrapingbee
   * const result = await scraper.scrape('https://example.com');
   * ```
   */
  static createWithFallback(config) {
    const providers = [];
    providers.push(_ScrapeProvider.create({ connector: config.primary }));
    if (config.fallbacks) {
      for (const fallback of config.fallbacks) {
        try {
          providers.push(_ScrapeProvider.create({ connector: fallback }));
        } catch {
        }
      }
    }
    return new FallbackScrapeProvider(providers);
  }
};
var FallbackScrapeProvider = class {
  constructor(providers) {
    this.providers = providers;
    if (providers.length === 0) {
      throw new Error("At least one provider required for fallback chain");
    }
    this.connector = providers[0].connector;
  }
  name = "fallback";
  connector;
  async scrape(url2, options) {
    let lastError;
    const attemptedProviders = [];
    for (const provider of this.providers) {
      attemptedProviders.push(provider.name);
      try {
        const result = await provider.scrape(url2, options);
        if (result.success) {
          return {
            ...result,
            provider: `fallback(${provider.name})`
          };
        }
        lastError = result.error;
      } catch (error) {
        lastError = error.message;
      }
    }
    return {
      success: false,
      url: url2,
      provider: "fallback",
      error: `All providers failed. Tried: ${attemptedProviders.join(" -> ")}. Last error: ${lastError}`
    };
  }
  supportsFeature(feature) {
    return this.providers.some((p) => p.supportsFeature?.(feature));
  }
};

// src/capabilities/scrape/providers/ZenRowsProvider.ts
var ZenRowsProvider = class {
  constructor(connector) {
    this.connector = connector;
  }
  name = "zenrows";
  /**
   * Scrape a URL using ZenRows API
   *
   * By default, enables JS rendering and premium proxies for guaranteed results.
   */
  async scrape(url2, options = {}) {
    const startTime = Date.now();
    try {
      const apiKey = this.getApiKey();
      const zenrowsOpts = options.vendorOptions;
      const queryParams = {
        url: url2,
        apikey: apiKey,
        // Default to JS rendering and premium proxy for guaranteed results
        js_render: zenrowsOpts?.jsRender ?? true,
        premium_proxy: zenrowsOpts?.premiumProxy ?? true
      };
      if (options.waitForSelector || zenrowsOpts?.waitFor) {
        queryParams.wait_for = options.waitForSelector || zenrowsOpts?.waitFor || "";
      }
      if (zenrowsOpts?.wait) {
        queryParams.wait = zenrowsOpts.wait;
      }
      if (options.includeMarkdown || zenrowsOpts?.outputFormat === "markdown") {
        queryParams.response_type = "markdown";
      }
      if (options.includeScreenshot || zenrowsOpts?.screenshot) {
        queryParams.screenshot = true;
        if (zenrowsOpts?.screenshotFullpage) {
          queryParams.screenshot_fullpage = true;
        }
      }
      if (zenrowsOpts?.autoparse) {
        queryParams.autoparse = true;
      }
      if (zenrowsOpts?.cssExtractor) {
        queryParams.css_extractor = zenrowsOpts.cssExtractor;
      }
      if (zenrowsOpts?.blockResources) {
        queryParams.block_resources = zenrowsOpts.blockResources;
      }
      if (zenrowsOpts?.sessionId) {
        queryParams.session_id = zenrowsOpts.sessionId;
      }
      if (zenrowsOpts?.device) {
        queryParams.device = zenrowsOpts.device;
      }
      if (zenrowsOpts?.originalStatus) {
        queryParams.original_status = true;
      }
      if (zenrowsOpts?.proxyCountry) {
        queryParams.proxy_country = zenrowsOpts.proxyCountry;
      }
      if (zenrowsOpts?.jsInstructions) {
        queryParams.js_instructions = zenrowsOpts.jsInstructions;
      }
      if (options.headers && zenrowsOpts?.customHeaders !== false) {
        queryParams.custom_headers = true;
      }
      const endpoint = `/?${buildQueryString(queryParams)}`;
      const response = await this.connector.fetch(endpoint, {
        method: "GET",
        headers: options.headers,
        timeout: options.timeout || 6e4
        // ZenRows can take longer with JS rendering
      });
      const headers = Object.fromEntries(response.headers.entries());
      const finalUrl = headers["zr-final-url"] || url2;
      const statusCode = parseInt(headers["zr-status"] || "200", 10);
      if (!response.ok) {
        const errorText = await response.text();
        return {
          success: false,
          url: url2,
          provider: this.name,
          error: `ZenRows API error (${response.status}): ${errorText}`,
          statusCode: response.status,
          durationMs: Date.now() - startTime
        };
      }
      const contentType = headers["content-type"] || "";
      const isMarkdown = queryParams.response_type === "markdown";
      const isScreenshot = queryParams.screenshot;
      let result;
      if (isScreenshot && !isMarkdown) {
        const base64 = await response.text();
        result = {
          title: "",
          content: "",
          screenshot: base64
        };
      } else {
        const content = await response.text();
        let title = "";
        if (!isMarkdown && contentType.includes("text/html")) {
          const titleMatch = content.match(/<title[^>]*>([^<]+)<\/title>/i);
          title = titleMatch?.[1]?.trim() ?? "";
        } else if (isMarkdown) {
          const headingMatch = content.match(/^#\s+(.+)$/m);
          title = headingMatch?.[1]?.trim() ?? "";
        }
        result = {
          title,
          content: isMarkdown ? content : this.extractText(content),
          html: options.includeHtml && !isMarkdown ? content : void 0,
          markdown: isMarkdown ? content : void 0
        };
        if (options.includeLinks && !isMarkdown) {
          result.links = this.extractLinks(content, finalUrl);
        }
        if (!isMarkdown) {
          result.metadata = this.extractMetadata(content);
        }
      }
      return {
        success: true,
        url: url2,
        finalUrl,
        provider: this.name,
        result,
        statusCode,
        durationMs: Date.now() - startTime,
        requiredJS: queryParams.js_render === true
      };
    } catch (error) {
      return {
        success: false,
        url: url2,
        provider: this.name,
        error: error.message || "Unknown error",
        durationMs: Date.now() - startTime
      };
    }
  }
  /**
   * Check if this provider supports a feature
   */
  supportsFeature(feature) {
    const supported = [
      "javascript",
      "markdown",
      "screenshot",
      "links",
      "metadata",
      "proxy",
      "stealth",
      "dynamic"
    ];
    return supported.includes(feature);
  }
  /**
   * Get API key from connector
   */
  getApiKey() {
    return this.connector.getApiKey();
  }
  /**
   * Extract text content from HTML
   */
  extractText(html) {
    let text = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "");
    text = text.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "");
    text = text.replace(/<[^>]+>/g, " ");
    text = text.replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    text = text.replace(/\s+/g, " ").trim();
    return text;
  }
  /**
   * Extract links from HTML
   */
  extractLinks(html, baseUrl) {
    const links = [];
    const linkRegex = /<a[^>]+href=["']([^"']+)["'][^>]*>([^<]*)<\/a>/gi;
    let match;
    while ((match = linkRegex.exec(html)) !== null) {
      try {
        const href = match[1];
        const text = match[2]?.trim() ?? "";
        if (!href) continue;
        const absoluteUrl = new URL(href, baseUrl).href;
        if (!absoluteUrl.startsWith("javascript:") && !absoluteUrl.startsWith("mailto:")) {
          links.push({ url: absoluteUrl, text: text || absoluteUrl });
        }
      } catch {
      }
    }
    return links;
  }
  /**
   * Extract metadata from HTML
   */
  extractMetadata(html) {
    const metadata = {};
    const metaRegex = /<meta[^>]+(?:name|property)=["']([^"']+)["'][^>]+content=["']([^"']+)["']/gi;
    let match;
    while ((match = metaRegex.exec(html)) !== null) {
      const name = match[1]?.toLowerCase();
      const content = match[2];
      if (!name || !content) continue;
      if (name === "description" || name === "og:description") {
        metadata.description = metadata.description || content;
      } else if (name === "author") {
        metadata.author = content;
      } else if (name === "og:site_name") {
        metadata.siteName = content;
      } else if (name === "og:image") {
        metadata.ogImage = content;
      } else if (name === "article:published_time") {
        metadata.publishedDate = content;
      }
    }
    const faviconMatch = html.match(/<link[^>]+rel=["'](?:shortcut )?icon["'][^>]+href=["']([^"']+)["']/i);
    if (faviconMatch) {
      metadata.favicon = faviconMatch[1];
    }
    return Object.keys(metadata).length > 0 ? metadata : void 0;
  }
};
registerScrapeProvider("zenrows", ZenRowsProvider);

// src/capabilities/documents/DocumentReader.ts
init_constants();

// src/capabilities/documents/FormatDetector.ts
var EXTENSION_MAP = {
  // Office
  ".docx": { format: "docx", family: "office", mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" },
  ".pptx": { format: "pptx", family: "office", mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation" },
  ".odt": { format: "odt", family: "office", mimeType: "application/vnd.oasis.opendocument.text" },
  ".odp": { format: "odp", family: "office", mimeType: "application/vnd.oasis.opendocument.presentation" },
  ".ods": { format: "ods", family: "office", mimeType: "application/vnd.oasis.opendocument.spreadsheet" },
  ".rtf": { format: "rtf", family: "office", mimeType: "application/rtf" },
  // Spreadsheet
  ".xlsx": { format: "xlsx", family: "spreadsheet", mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" },
  ".csv": { format: "csv", family: "spreadsheet", mimeType: "text/csv" },
  // PDF
  ".pdf": { format: "pdf", family: "pdf", mimeType: "application/pdf" },
  // HTML
  ".html": { format: "html", family: "html", mimeType: "text/html" },
  ".htm": { format: "html", family: "html", mimeType: "text/html" },
  // Text
  ".txt": { format: "txt", family: "text", mimeType: "text/plain" },
  ".md": { format: "md", family: "text", mimeType: "text/markdown" },
  ".json": { format: "json", family: "text", mimeType: "application/json" },
  ".xml": { format: "xml", family: "text", mimeType: "application/xml" },
  ".yaml": { format: "yaml", family: "text", mimeType: "application/yaml" },
  ".yml": { format: "yml", family: "text", mimeType: "application/yaml" },
  // Image
  ".png": { format: "png", family: "image", mimeType: "image/png" },
  ".jpg": { format: "jpg", family: "image", mimeType: "image/jpeg" },
  ".jpeg": { format: "jpeg", family: "image", mimeType: "image/jpeg" },
  ".gif": { format: "gif", family: "image", mimeType: "image/gif" },
  ".webp": { format: "webp", family: "image", mimeType: "image/webp" },
  ".svg": { format: "svg", family: "image", mimeType: "image/svg+xml" }
};
var MIME_MAP = {
  "application/pdf": { format: "pdf", family: "pdf" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { format: "docx", family: "office" },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { format: "pptx", family: "office" },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { format: "xlsx", family: "spreadsheet" },
  "application/vnd.oasis.opendocument.text": { format: "odt", family: "office" },
  "application/vnd.oasis.opendocument.presentation": { format: "odp", family: "office" },
  "application/vnd.oasis.opendocument.spreadsheet": { format: "ods", family: "office" },
  "application/rtf": { format: "rtf", family: "office" },
  "text/rtf": { format: "rtf", family: "office" },
  "text/csv": { format: "csv", family: "spreadsheet" },
  "application/csv": { format: "csv", family: "spreadsheet" }
};
var BINARY_DOCUMENT_EXTENSIONS = /* @__PURE__ */ new Set([
  ".docx",
  ".pptx",
  ".xlsx",
  ".odt",
  ".odp",
  ".ods",
  ".pdf",
  ".png",
  ".jpg",
  ".jpeg",
  ".gif",
  ".webp"
]);
var FormatDetector = class _FormatDetector {
  /**
   * Detect format from filename and optional buffer
   */
  static detect(filename, _buffer) {
    const ext = _FormatDetector.getExtension(filename);
    const entry = EXTENSION_MAP[ext];
    if (!entry) {
      return {
        format: "txt",
        family: "text",
        mimeType: "text/plain",
        confidence: "low"
      };
    }
    return {
      format: entry.format,
      family: entry.family,
      mimeType: entry.mimeType,
      confidence: "high"
    };
  }
  /**
   * Check if an extension is a supported document format
   * Used by readFile to detect when to use DocumentReader
   */
  static isDocumentFormat(ext) {
    const normalizedExt = ext.startsWith(".") ? ext.toLowerCase() : `.${ext.toLowerCase()}`;
    return normalizedExt in EXTENSION_MAP;
  }
  /**
   * Check if an extension is a binary document format
   * (i.e., cannot be read as UTF-8)
   */
  static isBinaryDocumentFormat(ext) {
    const normalizedExt = ext.startsWith(".") ? ext.toLowerCase() : `.${ext.toLowerCase()}`;
    return BINARY_DOCUMENT_EXTENSIONS.has(normalizedExt);
  }
  /**
   * Check if a Content-Type header indicates a document format
   * Used by webFetch to detect downloadable documents
   */
  static isDocumentMimeType(contentType) {
    const mime = (contentType.split(";")[0] ?? "").trim().toLowerCase();
    return mime in MIME_MAP;
  }
  /**
   * Detect format from Content-Type header
   */
  static detectFromMimeType(contentType) {
    const mime = (contentType.split(";")[0] ?? "").trim().toLowerCase();
    const entry = MIME_MAP[mime];
    if (!entry) return null;
    const extEntry = Object.values(EXTENSION_MAP).find(
      (e) => e.format === entry.format
    );
    return {
      format: entry.format,
      family: entry.family,
      mimeType: extEntry?.mimeType || mime,
      confidence: "high"
    };
  }
  /**
   * Get all supported document extensions
   */
  static getSupportedExtensions() {
    return Object.keys(EXTENSION_MAP);
  }
  /**
   * Get the normalized extension from a filename
   */
  static getExtension(filename) {
    const lastDot = filename.lastIndexOf(".");
    if (lastDot === -1 || lastDot === filename.length - 1) return "";
    return filename.slice(lastDot).toLowerCase();
  }
};

// src/capabilities/documents/DocumentReader.ts
var DocumentReader = class _DocumentReader {
  handlers;
  config;
  constructor(config = {}) {
    this.config = config;
    this.handlers = config.handlers ? new Map(config.handlers) : /* @__PURE__ */ new Map();
  }
  /**
   * Create a new DocumentReader instance
   */
  static create(config = {}) {
    const reader = new _DocumentReader(config);
    reader.registerDefaultHandlers();
    return reader;
  }
  /**
   * Register all default format handlers (lazy-loaded)
   */
  registerDefaultHandlers() {
  }
  /**
   * Register a custom format handler
   */
  registerHandler(family, handler) {
    this.handlers.set(family, handler);
  }
  /**
   * Read a document from any source
   */
  async read(source, options = {}) {
    const startTime = Date.now();
    const warnings = [];
    const mergedOptions = {
      ...this.config.defaults,
      ...options,
      formatOptions: {
        ...this.config.defaults?.formatOptions,
        ...options.formatOptions
      },
      imageFilter: {
        ...this.config.defaults?.imageFilter,
        ...options.imageFilter
      }
    };
    try {
      const { buffer, filename } = await this.resolveSource(
        typeof source === "string" ? this.parseStringSource(source) : source
      );
      const detection = FormatDetector.detect(filename, buffer);
      const handler = await this.getHandler(detection.family);
      if (!handler) {
        throw new UnsupportedFormatError(detection.format, detection.family);
      }
      let pieces = await handler.handle(buffer, filename, detection.format, mergedOptions);
      if (mergedOptions.extractImages !== false) {
        pieces = this.filterImages(pieces, mergedOptions.imageFilter);
      } else {
        pieces = pieces.filter((p) => p.type !== "image");
      }
      const transformerContext = {
        filename,
        format: detection.format,
        family: detection.family,
        options: mergedOptions
      };
      pieces = await this.runTransformers(pieces, transformerContext, mergedOptions);
      const metadata = this.assembleMetadata(pieces, filename, detection, startTime);
      return {
        success: true,
        pieces,
        metadata,
        warnings
      };
    } catch (error) {
      if (error instanceof DocumentReadError || error instanceof UnsupportedFormatError) {
        throw error;
      }
      throw new DocumentReadError(
        typeof source === "string" ? source : "path" in source ? source.path : "filename" in source ? source.filename : "unknown",
        error instanceof Error ? error.message : String(error),
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Parse a string source (auto-detect path vs URL)
   */
  parseStringSource(source) {
    if (source.startsWith("http://") || source.startsWith("https://")) {
      return { type: "url", url: source };
    }
    return { type: "file", path: source };
  }
  /**
   * Resolve any source to a buffer and filename
   */
  async resolveSource(source) {
    switch (source.type) {
      case "file": {
        const buffer = await fs18.readFile(source.path);
        const filename = source.path.split("/").pop() || source.path;
        return { buffer, filename };
      }
      case "url": {
        const maxSize = this.config.maxDownloadSizeBytes ?? DOCUMENT_DEFAULTS.MAX_DOWNLOAD_SIZE_BYTES;
        const timeout = this.config.downloadTimeoutMs ?? DOCUMENT_DEFAULTS.DOWNLOAD_TIMEOUT_MS;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(source.url, {
            headers: {
              ...source.headers,
              "User-Agent": "OneRingAI-DocumentReader/1.0"
            },
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const contentLength = response.headers.get("content-length");
          if (contentLength && parseInt(contentLength, 10) > maxSize) {
            throw new Error(`File too large: ${contentLength} bytes (max: ${maxSize})`);
          }
          const arrayBuffer = await response.arrayBuffer();
          if (arrayBuffer.byteLength > maxSize) {
            throw new Error(`Downloaded file too large: ${arrayBuffer.byteLength} bytes (max: ${maxSize})`);
          }
          const filename = this.extractFilenameFromURL(source.url, response);
          return { buffer: Buffer.from(arrayBuffer), filename };
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === "AbortError") {
            throw new Error(`Download timed out after ${timeout}ms`);
          }
          throw error;
        }
      }
      case "buffer": {
        const buffer = Buffer.isBuffer(source.buffer) ? source.buffer : Buffer.from(source.buffer);
        return { buffer, filename: source.filename };
      }
      case "blob": {
        const arrayBuffer = await source.blob.arrayBuffer();
        return { buffer: Buffer.from(arrayBuffer), filename: source.filename };
      }
    }
  }
  /**
   * Extract filename from URL and response headers
   */
  extractFilenameFromURL(url2, response) {
    const disposition = response.headers.get("content-disposition");
    if (disposition) {
      const match = disposition.match(/filename[^;=\n]*=(['"]?)([^'"\n;]*)\1/);
      if (match?.[2]) return match[2];
    }
    try {
      const pathname = new URL(url2).pathname;
      const basename = pathname.split("/").pop();
      if (basename && basename.includes(".")) return basename;
    } catch {
    }
    return "document";
  }
  /**
   * Get the handler for a format family, loading defaults lazily
   */
  async getHandler(family) {
    if (this.handlers.has(family)) {
      return this.handlers.get(family);
    }
    try {
      const { getDefaultHandlers: getDefaultHandlers2 } = await Promise.resolve().then(() => (init_handlers(), handlers_exports));
      const defaults = getDefaultHandlers2();
      const handler = defaults.get(family);
      if (handler) {
        this.handlers.set(family, handler);
        return handler;
      }
    } catch {
    }
    return null;
  }
  /**
   * Filter images based on options
   */
  filterImages(pieces, filterOptions) {
    const minWidth = filterOptions?.minWidth ?? DOCUMENT_DEFAULTS.IMAGE_FILTER.MIN_WIDTH;
    const minHeight = filterOptions?.minHeight ?? DOCUMENT_DEFAULTS.IMAGE_FILTER.MIN_HEIGHT;
    const minSizeBytes = filterOptions?.minSizeBytes ?? DOCUMENT_DEFAULTS.IMAGE_FILTER.MIN_SIZE_BYTES;
    const maxImages = filterOptions?.maxImages ?? DOCUMENT_DEFAULTS.MAX_EXTRACTED_IMAGES;
    const excludePatterns = filterOptions?.excludePatterns ?? [];
    let imageCount = 0;
    return pieces.filter((piece) => {
      if (piece.type !== "image") return true;
      const img = piece;
      if (img.width !== void 0 && img.width < minWidth) return false;
      if (img.height !== void 0 && img.height < minHeight) return false;
      if (img.metadata.sizeBytes < minSizeBytes) return false;
      const label = img.metadata.label || "";
      if (excludePatterns.some((p) => p.test(label))) return false;
      imageCount++;
      if (imageCount > maxImages) return false;
      return true;
    });
  }
  /**
   * Run the transformer pipeline
   */
  async runTransformers(pieces, context, options) {
    const transformers = [];
    if (!options.skipDefaultTransformers) {
      try {
        const { getDefaultTransformers: getDefaultTransformers2 } = await Promise.resolve().then(() => (init_transformers(), transformers_exports));
        transformers.push(...getDefaultTransformers2());
      } catch {
      }
    }
    if (options.transformers) {
      transformers.push(...options.transformers);
    }
    transformers.sort((a, b) => (a.priority ?? 100) - (b.priority ?? 100));
    let result = pieces;
    for (const transformer of transformers) {
      if (transformer.appliesTo.length === 0 || transformer.appliesTo.includes(context.format)) {
        result = await transformer.transform(result, context);
      }
    }
    return result;
  }
  /**
   * Assemble metadata from pieces
   */
  assembleMetadata(pieces, filename, detection, startTime) {
    const textPieces = pieces.filter((p) => p.type === "text");
    const imagePieces = pieces.filter((p) => p.type === "image");
    const totalSizeBytes = pieces.reduce((sum, p) => sum + p.metadata.sizeBytes, 0);
    const estimatedTokens = pieces.reduce((sum, p) => sum + p.metadata.estimatedTokens, 0);
    return {
      filename,
      format: detection.format,
      family: detection.family,
      mimeType: detection.mimeType,
      totalPieces: pieces.length,
      totalTextPieces: textPieces.length,
      totalImagePieces: imagePieces.length,
      totalSizeBytes,
      estimatedTokens,
      processingTimeMs: Date.now() - startTime
    };
  }
};
function mergeTextPieces(pieces) {
  return pieces.filter((p) => p.type === "text").map((p) => p.content).join("\n\n");
}

// src/capabilities/documents/index.ts
init_handlers();
init_transformers();

// src/utils/documentContentBridge.ts
function documentToContent(result, options = {}) {
  const {
    imageDetail = "auto",
    imageFilter,
    maxImages = 20,
    mergeAdjacentText = true
  } = options;
  const minWidth = imageFilter?.minWidth ?? 0;
  const minHeight = imageFilter?.minHeight ?? 0;
  const minSizeBytes = imageFilter?.minSizeBytes ?? 0;
  const excludePatterns = imageFilter?.excludePatterns ?? [];
  const contents = [];
  let imageCount = 0;
  let pendingText = [];
  const flushText = () => {
    if (pendingText.length > 0) {
      const text = {
        type: "input_text" /* INPUT_TEXT */,
        text: pendingText.join("\n\n")
      };
      contents.push(text);
      pendingText = [];
    }
  };
  for (const piece of result.pieces) {
    if (piece.type === "text") {
      if (mergeAdjacentText) {
        pendingText.push(piece.content);
      } else {
        const text = {
          type: "input_text" /* INPUT_TEXT */,
          text: piece.content
        };
        contents.push(text);
      }
    } else if (piece.type === "image") {
      if (piece.width !== void 0 && piece.width < minWidth) continue;
      if (piece.height !== void 0 && piece.height < minHeight) continue;
      if (piece.metadata.sizeBytes < minSizeBytes) continue;
      const label = piece.metadata.label || "";
      if (excludePatterns.some((p) => p.test(label))) continue;
      imageCount++;
      if (imageCount > maxImages) continue;
      flushText();
      const imageContent = {
        type: "input_image_url" /* INPUT_IMAGE_URL */,
        image_url: {
          url: `data:${piece.mimeType};base64,${piece.base64}`,
          detail: imageDetail
        }
      };
      contents.push(imageContent);
    }
  }
  flushText();
  return contents;
}
async function readDocumentAsContent(source, options = {}) {
  const {
    imageDetail,
    maxImages,
    mergeAdjacentText,
    // imageFilter is shared between both
    ...readOptions
  } = options;
  const contentOptions = {
    imageDetail,
    imageFilter: options.imageFilter,
    maxImages,
    mergeAdjacentText
  };
  const reader = DocumentReader.create();
  const result = await reader.read(source, readOptions);
  if (!result.success) {
    return [
      {
        type: "input_text" /* INPUT_TEXT */,
        text: `[Document read error: ${result.error || "Unknown error"}]`
      }
    ];
  }
  return documentToContent(result, contentOptions);
}

// src/domain/interfaces/IContextStorage.ts
var CONTEXT_SESSION_FORMAT_VERSION = 1;

// src/domain/interfaces/IAgentDefinitionStorage.ts
var AGENT_DEFINITION_FORMAT_VERSION = 1;
var WorkingMemory = class extends eventemitter3.EventEmitter {
  storage;
  config;
  priorityCalculator;
  priorityContext;
  _isDestroyed = false;
  /**
   * Create a WorkingMemory instance
   *
   * @param storage - Storage backend for memory entries
   * @param config - Memory configuration (limits, etc.)
   * @param priorityCalculator - Strategy for computing effective priority (default: static)
   */
  constructor(storage, config = DEFAULT_MEMORY_CONFIG, priorityCalculator = staticPriorityCalculator) {
    super();
    this.storage = storage;
    this.config = config;
    this.priorityCalculator = priorityCalculator;
    this.priorityContext = {};
  }
  /**
   * Set the priority calculator (for switching strategies at runtime)
   */
  setPriorityCalculator(calculator) {
    this.priorityCalculator = calculator;
  }
  /**
   * Update priority context (e.g., task states for TaskAgent)
   */
  setPriorityContext(context) {
    this.priorityContext = context;
  }
  /**
   * Get the current priority context
   */
  getPriorityContext() {
    return this.priorityContext;
  }
  /**
   * Compute effective priority for an entry using the current calculator
   */
  computeEffectivePriority(entry) {
    return this.priorityCalculator(entry, this.priorityContext);
  }
  /**
   * Get all entries with their computed effective priorities
   * This is a performance optimization to avoid repeated getAll() + map() calls
   */
  async getEntriesWithPriority() {
    const entries = await this.storage.getAll();
    return entries.map((entry) => ({
      entry,
      effectivePriority: this.computeEffectivePriority(entry)
    }));
  }
  /**
   * Get evictable entries sorted by eviction priority
   * Filters out pinned and critical entries, sorts by priority then by strategy
   */
  getEvictableEntries(entriesWithPriority, strategy) {
    return entriesWithPriority.filter(({ entry, effectivePriority }) => {
      if (entry.pinned) return false;
      if (effectivePriority === "critical") return false;
      return true;
    }).sort((a, b) => {
      const priorityDiff = MEMORY_PRIORITY_VALUES[a.effectivePriority] - MEMORY_PRIORITY_VALUES[b.effectivePriority];
      if (priorityDiff !== 0) return priorityDiff;
      if (strategy === "lru") {
        return a.entry.lastAccessedAt - b.entry.lastAccessedAt;
      } else {
        return b.entry.sizeBytes - a.entry.sizeBytes;
      }
    });
  }
  /**
   * Store a value in working memory
   *
   * @param key - Unique key for the entry
   * @param description - Short description for the index (max 150 chars)
   * @param value - The data to store
   * @param options - Optional scope, priority, and pinned settings
   */
  async store(key, description, value, options) {
    const input = {
      key,
      description,
      value,
      scope: options?.scope ?? "session",
      priority: options?.priority,
      pinned: options?.pinned
    };
    const entry = createMemoryEntry(input, this.config);
    const currentSize = await this.storage.getTotalSize();
    const existing = await this.storage.get(key);
    const existingSize = existing?.sizeBytes ?? 0;
    const newTotalSize = currentSize - existingSize + entry.sizeBytes;
    const limit = this.getLimit();
    if (newTotalSize > limit) {
      throw new Error(`Memory limit exceeded: ${newTotalSize} bytes > ${limit} bytes`);
    }
    const utilization = newTotalSize / limit * 100;
    if (utilization > this.config.softLimitPercent) {
      this.emit("limit_warning", { utilizationPercent: utilization });
    }
    await this.storage.set(key, entry);
    this.emit("stored", { key, description, scope: entry.scope });
    await this.enforceEntryCountLimit();
  }
  /**
   * Enforce the maxIndexEntries limit by evicting excess entries
   * Only evicts if entry count exceeds the configured limit
   */
  async enforceEntryCountLimit() {
    const maxEntries = this.getMaxIndexEntries();
    if (!maxEntries) return;
    const entries = await this.storage.getAll();
    const excessCount = entries.length - maxEntries;
    if (excessCount > 0) {
      const evictedKeys = await this.evict(excessCount, "lru");
      if (evictedKeys.length > 0) ;
    }
  }
  /**
   * Get the configured max index entries limit
   */
  getMaxIndexEntries() {
    return this.config.maxIndexEntries;
  }
  /**
   * Store a value scoped to specific tasks
   * Convenience method for task-aware memory
   */
  async storeForTasks(key, description, value, taskIds, options) {
    await this.store(key, description, value, {
      scope: { type: "task", taskIds },
      priority: options?.priority,
      pinned: options?.pinned
    });
  }
  /**
   * Store a value scoped to the entire plan
   * Convenience method for plan-scoped memory
   */
  async storeForPlan(key, description, value, options) {
    await this.store(key, description, value, {
      scope: { type: "plan" },
      priority: options?.priority,
      pinned: options?.pinned
    });
  }
  /**
   * Retrieve a value from working memory
   *
   * Note: Access stats update is not strictly atomic. Under very high concurrency,
   * accessCount may be slightly inaccurate. This is acceptable for memory management
   * purposes where exact counts are not critical.
   */
  async retrieve(key) {
    const entry = await this.storage.get(key);
    if (!entry) {
      return void 0;
    }
    const value = entry.value;
    const freshEntry = await this.storage.get(key);
    if (freshEntry) {
      freshEntry.lastAccessedAt = Date.now();
      freshEntry.accessCount += 1;
      await this.storage.set(key, freshEntry);
    }
    this.emit("retrieved", { key });
    return value;
  }
  /**
   * Retrieve multiple values
   */
  async retrieveMany(keys) {
    const result = {};
    for (const key of keys) {
      const value = await this.retrieve(key);
      if (value !== void 0) {
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * Delete a value from working memory
   */
  async delete(key) {
    await this.storage.delete(key);
    this.emit("deleted", { key });
  }
  /**
   * Check if key exists
   */
  async has(key) {
    return this.storage.has(key);
  }
  /**
   * Promote an entry to persistent scope
   * Works with both simple and task-aware scopes
   */
  async persist(key) {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    const isPersistent = isSimpleScope(entry.scope) ? entry.scope === "persistent" : isTaskAwareScope(entry.scope) && entry.scope.type === "persistent";
    if (!isPersistent) {
      entry.scope = { type: "persistent" };
      await this.storage.set(key, entry);
    }
  }
  /**
   * Pin an entry (never evicted)
   */
  async pin(key) {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    if (!entry.pinned) {
      entry.pinned = true;
      entry.basePriority = "critical";
      await this.storage.set(key, entry);
    }
  }
  /**
   * Unpin an entry
   */
  async unpin(key, newPriority = "normal") {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    if (entry.pinned) {
      entry.pinned = false;
      entry.basePriority = newPriority;
      await this.storage.set(key, entry);
    }
  }
  /**
   * Set the base priority of an entry
   */
  async setPriority(key, priority) {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    entry.basePriority = priority;
    await this.storage.set(key, entry);
  }
  /**
   * Update the scope of an entry without re-storing the value
   */
  async updateScope(key, scope) {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    entry.scope = scope;
    await this.storage.set(key, entry);
  }
  /**
   * Add task IDs to an existing task-scoped entry
   * If entry is not task-scoped, converts it to task-scoped
   */
  async addTasksToScope(key, taskIds) {
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    if (isTaskAwareScope(entry.scope) && entry.scope.type === "task") {
      const existingIds = new Set(entry.scope.taskIds);
      for (const id of taskIds) {
        existingIds.add(id);
      }
      entry.scope = { type: "task", taskIds: Array.from(existingIds) };
    } else {
      entry.scope = { type: "task", taskIds };
    }
    await this.storage.set(key, entry);
  }
  /**
   * Clear all entries of a specific scope
   */
  async clearScope(scope) {
    await this.storage.clearScope(scope);
  }
  /**
   * Clear all entries
   */
  async clear() {
    await this.storage.clear();
  }
  /**
   * Get memory index with computed effective priorities
   * Respects maxIndexEntries limit for context display
   */
  async getIndex() {
    const entriesWithPriority = await this.getEntriesWithPriority();
    const totalSizeBytes = await this.storage.getTotalSize();
    const limitBytes = this.getLimit();
    const totalEntryCount = entriesWithPriority.length;
    const sortedEntries = [...entriesWithPriority].sort((a, b) => {
      if (a.entry.pinned && !b.entry.pinned) return -1;
      if (!a.entry.pinned && b.entry.pinned) return 1;
      const priorityDiff = MEMORY_PRIORITY_VALUES[b.effectivePriority] - MEMORY_PRIORITY_VALUES[a.effectivePriority];
      if (priorityDiff !== 0) return priorityDiff;
      return b.entry.lastAccessedAt - a.entry.lastAccessedAt;
    });
    const maxEntries = this.config.maxIndexEntries;
    const displayEntries = maxEntries ? sortedEntries.slice(0, maxEntries) : sortedEntries;
    const omittedCount = sortedEntries.length - displayEntries.length;
    const indexEntries = displayEntries.map(({ entry, effectivePriority }) => ({
      key: entry.key,
      description: entry.description,
      size: formatSizeHuman(entry.sizeBytes),
      scope: entry.scope,
      effectivePriority,
      pinned: entry.pinned
    }));
    return {
      entries: indexEntries,
      totalSizeBytes,
      totalSizeHuman: formatSizeHuman(totalSizeBytes),
      limitBytes,
      limitHuman: formatSizeHuman(limitBytes),
      utilizationPercent: totalSizeBytes / limitBytes * 100,
      totalEntryCount,
      omittedCount
    };
  }
  /**
   * Format index for context injection
   */
  async formatIndex() {
    const index = await this.getIndex();
    return formatMemoryIndex(index);
  }
  /**
   * Evict entries using specified strategy
   *
   * Eviction order:
   * 1. Never evict pinned entries
   * 2. Evict low priority first, then normal, then high (never critical)
   * 3. Within same priority, use strategy (LRU or largest size)
   *
   * @param count - Number of entries to evict
   * @param strategy - Eviction strategy ('lru' or 'size')
   * @returns Keys of evicted entries
   */
  async evict(count, strategy = "lru") {
    const entriesWithPriority = await this.getEntriesWithPriority();
    const evictable = this.getEvictableEntries(entriesWithPriority, strategy);
    const toEvict = evictable.slice(0, count);
    const evictedKeys = [];
    for (const { entry } of toEvict) {
      await this.storage.delete(entry.key);
      evictedKeys.push(entry.key);
    }
    if (evictedKeys.length > 0) {
      this.emit("evicted", { keys: evictedKeys, reason: strategy });
    }
    return evictedKeys;
  }
  /**
   * Evict entries using priority-aware LRU algorithm
   * @deprecated Use evict(count, 'lru') instead
   */
  async evictLRU(count) {
    return this.evict(count, "lru");
  }
  /**
   * Evict largest entries first (priority-aware)
   * @deprecated Use evict(count, 'size') instead
   */
  async evictBySize(count) {
    return this.evict(count, "size");
  }
  /**
   * Handle task completion - detect and notify about stale entries
   *
   * Call this when a task completes to:
   * 1. Update priority context with new task state
   * 2. Detect entries that became stale
   * 3. Emit event to notify LLM about stale entries
   *
   * @param taskId - The completed task ID
   * @param taskStates - Current task states map
   * @returns Information about stale entries
   */
  async onTaskComplete(taskId, taskStates) {
    this.priorityContext.taskStates = taskStates;
    const entries = await this.storage.getAll();
    const staleEntries = detectStaleEntries(entries, taskId, taskStates);
    if (staleEntries.length > 0) {
      this.emit("stale_entries", { entries: staleEntries });
    }
    return staleEntries;
  }
  /**
   * Evict entries for completed tasks
   *
   * Removes entries that were scoped only to completed tasks.
   * Use after onTaskComplete() if you want automatic cleanup.
   *
   * @param taskStates - Current task states map
   * @returns Keys of evicted entries
   */
  async evictCompletedTaskEntries(taskStates) {
    const entries = await this.storage.getAll();
    const evictedKeys = [];
    for (const entry of entries) {
      if (entry.pinned) continue;
      if (!isTaskAwareScope(entry.scope) || entry.scope.type !== "task") continue;
      const allTerminal = entry.scope.taskIds.every((taskId) => {
        const status = taskStates.get(taskId);
        return status ? isTerminalMemoryStatus(status) : false;
      });
      if (allTerminal) {
        await this.storage.delete(entry.key);
        evictedKeys.push(entry.key);
      }
    }
    if (evictedKeys.length > 0) {
      this.emit("evicted", { keys: evictedKeys, reason: "task_completed" });
    }
    return evictedKeys;
  }
  /**
   * Get limited memory access for tools
   *
   * This provides a simplified interface for tools to interact with memory
   * without exposing the full WorkingMemory API.
   */
  getAccess() {
    return {
      get: async (key) => this.retrieve(key),
      set: async (key, description, value, options) => this.store(key, description, value, options),
      delete: async (key) => this.delete(key),
      has: async (key) => this.has(key),
      list: async () => {
        const index = await this.getIndex();
        return index.entries.map((e) => ({
          key: e.key,
          description: e.description,
          effectivePriority: e.effectivePriority,
          pinned: e.pinned
        }));
      }
    };
  }
  // ============================================================================
  // HIERARCHICAL MEMORY HELPERS
  // ============================================================================
  /**
   * Store raw data (low priority, first to be evicted)
   *
   * Use this for original/unprocessed data that should be summarized.
   * Raw data is automatically evicted first when memory pressure is high.
   *
   * @param key - Key without tier prefix (prefix is added automatically)
   * @param description - Brief description for the index
   * @param value - The raw data to store
   * @param options - Optional scope and task IDs
   */
  async storeRaw(key, description, value, options) {
    const fullKey = addTierPrefix(key, "raw");
    const scope = options?.taskIds ? { type: "task", taskIds: options.taskIds } : options?.scope ?? "session";
    await this.store(fullKey, description, value, {
      scope,
      priority: TIER_PRIORITIES.raw
    });
  }
  /**
   * Store a summary derived from raw data (normal priority)
   *
   * Use this for processed/summarized data that extracts key information.
   * Links back to source data for cleanup tracking.
   *
   * @param key - Key without tier prefix (prefix is added automatically)
   * @param description - Brief description for the index
   * @param value - The summary data
   * @param derivedFrom - Key(s) this summary was derived from
   * @param options - Optional scope and task IDs
   */
  async storeSummary(key, description, value, derivedFrom, options) {
    const fullKey = addTierPrefix(key, "summary");
    const sourceKeys = Array.isArray(derivedFrom) ? derivedFrom : [derivedFrom];
    const scope = options?.taskIds ? { type: "task", taskIds: options.taskIds } : options?.scope ?? { type: "plan" };
    await this.store(fullKey, description, value, {
      scope,
      priority: TIER_PRIORITIES.summary
    });
    for (const sourceKey of sourceKeys) {
      try {
        const sourceEntry = await this.storage.get(sourceKey);
        if (sourceEntry) {
          const metadata = sourceEntry.value?.metadata;
          const existingDerivedTo = metadata?.derivedTo ?? [];
          if (!existingDerivedTo.includes(fullKey)) {
          }
        }
      } catch {
      }
    }
  }
  /**
   * Store final findings (high priority, kept longest)
   *
   * Use this for conclusions, insights, or final results that should be preserved.
   * These are the last to be evicted and typically span the entire plan.
   *
   * @param key - Key without tier prefix (prefix is added automatically)
   * @param description - Brief description for the index
   * @param value - The findings data
   * @param derivedFrom - Optional key(s) these findings were derived from
   * @param options - Optional scope, task IDs, and pinned flag
   */
  async storeFindings(key, description, value, _derivedFrom, options) {
    const fullKey = addTierPrefix(key, "findings");
    const scope = options?.scope ?? { type: "plan" };
    await this.store(fullKey, description, value, {
      scope,
      priority: TIER_PRIORITIES.findings,
      pinned: options?.pinned
    });
  }
  /**
   * Clean up raw data after summary/findings are created
   *
   * Call this after creating summaries to free up memory used by raw data.
   * Only deletes entries in the 'raw' tier.
   *
   * @param derivedFromKeys - Keys to delete (typically from derivedFrom metadata)
   * @returns Number of entries deleted
   */
  async cleanupRawData(derivedFromKeys) {
    let deletedCount = 0;
    for (const key of derivedFromKeys) {
      const tier = getTierFromKey(key);
      if (tier === "raw") {
        const exists = await this.has(key);
        if (exists) {
          await this.delete(key);
          deletedCount++;
        }
      }
    }
    return deletedCount;
  }
  /**
   * Get all entries by tier
   *
   * @param tier - The tier to filter by
   * @returns Array of entries in that tier
   */
  async getByTier(tier) {
    const entries = await this.storage.getAll();
    const prefix = TIER_KEY_PREFIXES[tier];
    return entries.filter((e) => e.key.startsWith(prefix));
  }
  /**
   * Promote an entry to a higher tier
   *
   * Changes the key prefix and updates priority.
   * Use this when raw data becomes more valuable (e.g., frequently accessed).
   *
   * @param key - Current key (with tier prefix)
   * @param toTier - Target tier to promote to
   * @returns New key with updated prefix
   */
  async promote(key, toTier) {
    const currentTier = getTierFromKey(key);
    if (currentTier === toTier) {
      return key;
    }
    const entry = await this.storage.get(key);
    if (!entry) {
      throw new Error(`Key "${key}" not found in memory`);
    }
    const newKey = addTierPrefix(key, toTier);
    const newPriority = TIER_PRIORITIES[toTier];
    await this.store(newKey, entry.description, entry.value, {
      scope: entry.scope,
      priority: newPriority,
      pinned: entry.pinned
    });
    await this.delete(key);
    return newKey;
  }
  /**
   * Get tier statistics
   *
   * @returns Count and size by tier
   */
  async getTierStats() {
    const entries = await this.storage.getAll();
    const stats = {
      raw: { count: 0, sizeBytes: 0 },
      summary: { count: 0, sizeBytes: 0 },
      findings: { count: 0, sizeBytes: 0 }
    };
    for (const entry of entries) {
      const tier = getTierFromKey(entry.key);
      if (tier) {
        stats[tier].count++;
        stats[tier].sizeBytes += entry.sizeBytes;
      }
    }
    return stats;
  }
  /**
   * Get statistics about memory usage
   */
  async getStats() {
    const entriesWithPriority = await this.getEntriesWithPriority();
    const totalSizeBytes = await this.storage.getTotalSize();
    const limit = this.getLimit();
    const byPriority = {
      critical: 0,
      high: 0,
      normal: 0,
      low: 0
    };
    let pinnedCount = 0;
    for (const { entry, effectivePriority } of entriesWithPriority) {
      byPriority[effectivePriority]++;
      if (entry.pinned) pinnedCount++;
    }
    return {
      totalEntries: entriesWithPriority.length,
      totalSizeBytes,
      utilizationPercent: totalSizeBytes / limit * 100,
      byPriority,
      pinnedCount
    };
  }
  /**
   * Get the configured memory limit
   */
  getLimit() {
    return this.config.maxSizeBytes ?? 25 * 1024 * 1024;
  }
  /**
   * Check if the WorkingMemory instance has been destroyed
   */
  get isDestroyed() {
    return this._isDestroyed;
  }
  /**
   * Destroy the WorkingMemory instance
   * Removes all event listeners and clears internal state
   */
  destroy() {
    if (this._isDestroyed) return;
    this._isDestroyed = true;
    this.removeAllListeners();
    this.priorityContext = {};
  }
  // ============================================================================
  // Serialization (for session persistence)
  // ============================================================================
  /**
   * Serialize all memory entries for persistence
   *
   * Returns a serializable representation of all memory entries
   * that can be saved to storage and restored later.
   *
   * @returns Serialized memory state
   */
  async serialize() {
    const entries = await this.storage.getAll();
    const serializedEntries = entries.map((entry) => ({
      key: entry.key,
      description: entry.description,
      value: entry.value,
      scope: entry.scope,
      sizeBytes: entry.sizeBytes,
      basePriority: entry.basePriority,
      pinned: entry.pinned
      // Note: createdAt, lastAccessedAt, accessCount are not persisted
      // They will be reset on restore (entries start fresh)
    }));
    return {
      version: 1,
      entries: serializedEntries
    };
  }
  /**
   * Restore memory entries from serialized state
   *
   * Clears existing memory and repopulates from the serialized state.
   * Timestamps are reset to current time.
   *
   * @param state - Previously serialized memory state
   */
  async restore(state) {
    if (state.version !== 1) {
      throw new Error(`Unsupported memory serialization version: ${state.version}`);
    }
    await this.storage.clear();
    const now = Date.now();
    for (const entry of state.entries) {
      const fullEntry = {
        key: entry.key,
        description: entry.description,
        value: entry.value,
        scope: entry.scope,
        sizeBytes: entry.sizeBytes,
        basePriority: entry.basePriority ?? "normal",
        pinned: entry.pinned ?? false,
        createdAt: now,
        lastAccessedAt: now,
        accessCount: 0
      };
      await this.storage.set(entry.key, fullEntry);
    }
  }
};

// src/capabilities/taskAgent/ExternalDependencyHandler.ts
init_BackoffStrategy();
var ExternalDependencyHandler = class extends eventemitter3.EventEmitter {
  activePolls = /* @__PURE__ */ new Map();
  activeScheduled = /* @__PURE__ */ new Map();
  cancelledPolls = /* @__PURE__ */ new Set();
  // Track cancelled polls
  tools;
  constructor(tools = []) {
    super();
    this.tools = new Map(tools.map((t) => [t.definition.function.name, t]));
  }
  /**
   * Start handling a task's external dependency
   */
  async startWaiting(task) {
    if (!task.externalDependency) {
      return;
    }
    const dep = task.externalDependency;
    switch (dep.type) {
      case "webhook":
        break;
      case "poll":
        this.startPolling(task);
        break;
      case "scheduled":
        this.scheduleTask(task);
        break;
    }
  }
  /**
   * Stop waiting on a task's external dependency
   */
  stopWaiting(task) {
    if (!task.externalDependency) {
      return;
    }
    this.cancelledPolls.add(task.id);
    const pollTimer = this.activePolls.get(task.id);
    if (pollTimer) {
      clearTimeout(pollTimer);
      this.activePolls.delete(task.id);
    }
    const scheduleTimer = this.activeScheduled.get(task.id);
    if (scheduleTimer) {
      clearTimeout(scheduleTimer);
      this.activeScheduled.delete(task.id);
    }
  }
  /**
   * Trigger a webhook
   */
  async triggerWebhook(webhookId, data) {
    this.emit("webhook:received", { webhookId, data });
  }
  /**
   * Complete a manual task
   */
  async completeManual(taskId, data) {
    this.emit("manual:completed", { taskId, data });
  }
  /**
   * Start polling for a task with exponential backoff
   */
  startPolling(task) {
    const dep = task.externalDependency;
    const pollConfig = dep.pollConfig;
    const backoffConfig = {
      strategy: "exponential",
      initialDelayMs: pollConfig.intervalMs,
      maxDelayMs: pollConfig.intervalMs * 4,
      // Cap at 4x initial interval
      jitter: true,
      jitterFactor: 0.1
      // ±10% jitter to prevent thundering herd
    };
    this.cancelledPolls.delete(task.id);
    (async () => {
      let attempts = 0;
      while (attempts < pollConfig.maxAttempts) {
        if (this.cancelledPolls.has(task.id)) {
          this.cancelledPolls.delete(task.id);
          return;
        }
        attempts++;
        try {
          const tool = this.tools.get(pollConfig.toolName);
          if (!tool) {
            console.error(`Poll tool ${pollConfig.toolName} not found`);
            return;
          }
          const result = await tool.execute(pollConfig.toolArgs);
          if (result) {
            this.emit("poll:success", { taskId: task.id, data: result });
            return;
          }
        } catch (error) {
          console.error(`Poll error for task ${task.id}:`, error);
        }
        if (attempts >= pollConfig.maxAttempts) {
          this.emit("poll:timeout", { taskId: task.id });
          return;
        }
        const delay = calculateBackoff(attempts, backoffConfig);
        await new Promise((resolve4) => {
          const timer = setTimeout(resolve4, delay);
          this.activePolls.set(task.id, timer);
        });
        if (this.cancelledPolls.has(task.id)) {
          this.cancelledPolls.delete(task.id);
          return;
        }
      }
    })();
  }
  /**
   * Schedule a task to trigger at a specific time
   */
  scheduleTask(task) {
    const dep = task.externalDependency;
    const scheduledAt = dep.scheduledAt;
    const delay = scheduledAt - Date.now();
    if (delay <= 0) {
      this.emit("scheduled:triggered", { taskId: task.id });
      return;
    }
    const timer = setTimeout(() => {
      this.emit("scheduled:triggered", { taskId: task.id });
      this.activeScheduled.delete(task.id);
    }, delay);
    this.activeScheduled.set(task.id, timer);
  }
  /**
   * Cleanup all active dependencies
   */
  cleanup() {
    for (const taskId of this.activePolls.keys()) {
      this.cancelledPolls.add(taskId);
    }
    for (const timer of this.activePolls.values()) {
      clearTimeout(timer);
    }
    this.activePolls.clear();
    for (const timer of this.activeScheduled.values()) {
      clearTimeout(timer);
    }
    this.activeScheduled.clear();
  }
  /**
   * Update available tools
   */
  updateTools(tools) {
    this.tools = new Map(tools.map((t) => [t.definition.function.name, t]));
  }
};

// src/capabilities/taskAgent/CheckpointManager.ts
var DEFAULT_CHECKPOINT_STRATEGY = {
  afterToolCalls: 1,
  afterLLMCalls: 1,
  intervalMs: 3e4,
  // 30 seconds
  beforeExternalWait: true,
  mode: "async"
};
var CheckpointManager = class {
  storage;
  strategy;
  toolCallsSinceCheckpoint = 0;
  llmCallsSinceCheckpoint = 0;
  intervalTimer;
  pendingCheckpoints = /* @__PURE__ */ new Set();
  currentState = null;
  constructor(storage, strategy = DEFAULT_CHECKPOINT_STRATEGY) {
    this.storage = storage;
    this.strategy = strategy;
    if (this.strategy.intervalMs) {
      this.intervalTimer = setInterval(() => {
        this.checkIntervalCheckpoint();
      }, this.strategy.intervalMs);
    }
  }
  /**
   * Set the current agent state (for interval checkpointing)
   */
  setCurrentState(state) {
    this.currentState = state;
  }
  /**
   * Record a tool call (may trigger checkpoint)
   */
  async onToolCall(state) {
    this.toolCallsSinceCheckpoint++;
    if (this.strategy.afterToolCalls && this.toolCallsSinceCheckpoint >= this.strategy.afterToolCalls) {
      await this.checkpoint(state, "tool_calls");
    }
  }
  /**
   * Record an LLM call (may trigger checkpoint)
   */
  async onLLMCall(state) {
    this.llmCallsSinceCheckpoint++;
    if (this.strategy.afterLLMCalls && this.llmCallsSinceCheckpoint >= this.strategy.afterLLMCalls) {
      await this.checkpoint(state, "llm_calls");
    }
  }
  /**
   * Force a checkpoint
   */
  async checkpoint(state, reason) {
    const checkpointPromise = this.doCheckpoint(state, reason);
    if (this.strategy.mode === "sync") {
      await checkpointPromise;
    } else {
      this.pendingCheckpoints.add(checkpointPromise);
      checkpointPromise.finally(() => {
        this.pendingCheckpoints.delete(checkpointPromise);
      });
    }
  }
  /**
   * Perform the actual checkpoint
   */
  async doCheckpoint(state, _reason) {
    try {
      await this.storage.agent.save(state);
      await this.storage.plan.savePlan(state.plan);
      this.toolCallsSinceCheckpoint = 0;
      this.llmCallsSinceCheckpoint = 0;
    } catch (error) {
      console.error(`Checkpoint failed (${_reason}):`, error);
    }
  }
  /**
   * Check if interval-based checkpoint is needed
   */
  checkIntervalCheckpoint() {
    if (this.currentState) {
      this.checkpoint(this.currentState, "interval");
    }
  }
  /**
   * Wait for all pending checkpoints to complete
   */
  async flush() {
    await Promise.all(Array.from(this.pendingCheckpoints));
  }
  /**
   * Cleanup resources
   */
  async cleanup() {
    if (this.intervalTimer) {
      clearInterval(this.intervalTimer);
    }
    await this.flush();
  }
};

// src/capabilities/taskAgent/PlanningAgent.ts
var PLANNING_SYSTEM_PROMPT = `You are an AI planning agent. Your job is to analyze goals and break them down into structured, executable task plans.

**Your Role:**
1. Analyze the user's goal and context
2. Break down the goal into logical, atomic tasks
3. Identify dependencies between tasks
4. Define completion criteria for each task (how we know the task is done)
5. Structure tasks for optimal execution (parallel where possible)
6. Use the planning tools to create the plan

**Planning Principles:**
- Each task should have a single, clear responsibility
- Tasks should be atomic (can't be broken down further meaningfully)
- Dependencies should be explicit (use dependsOn)
- Parallel tasks should be marked as such (execution.parallel)
- Task names should be descriptive snake_case (e.g., "fetch_user_data")
- Descriptions should be clear and actionable

**Completion Criteria Guidelines:**
Each task should have clear, natural language completion criteria that describe how to verify the task is complete. These criteria should be:
- Specific and measurable (e.g., "response contains at least 5 items")
- Flexible, not rigid (avoid exact JSON schemas or exact string matches)
- Focused on outcomes, not implementation (e.g., "user data is stored in memory" not "memory_store was called")

Examples of good completion criteria:
- "The response contains weather data for the requested location"
- "At least 3 relevant search results were found"
- "The user's email address has been validated and stored"
- "The file was created with content matching the user's request"

Examples of bad completion criteria (too rigid):
- "Response matches exact JSON format {temp: number, city: string}"
- "Output contains exactly the string 'SUCCESS'"
- "Function returned status code 200"

**Available Planning Tools:**
- create_task: Add a task to the plan with completion criteria
- finalize_plan: Complete the planning phase

Always start by analyzing the goal, then create tasks one by one, building dependencies as you go.`;
var PlanningAgent = class _PlanningAgent {
  agent;
  config;
  currentTasks = [];
  planningComplete = false;
  constructor(config) {
    this.config = config;
    const planningTools = this.createBoundPlanningTools();
    this.agent = Agent.create({
      connector: config.connector,
      model: config.model,
      tools: planningTools,
      instructions: PLANNING_SYSTEM_PROMPT,
      temperature: config.planningTemperature ?? 0.3,
      // Lower temp for more structured output
      maxIterations: config.maxPlanningIterations ?? 20
    });
  }
  /**
   * Create a new PlanningAgent
   */
  static create(config) {
    return new _PlanningAgent(config);
  }
  /**
   * Create planning tools bound to this PlanningAgent instance
   */
  createBoundPlanningTools() {
    return [
      {
        definition: {
          type: "function",
          function: {
            name: "create_task",
            description: "Create a new task in the plan with name, description, completion criteria, and optional dependencies",
            parameters: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  description: 'Task name in snake_case (e.g., "fetch_user_data")'
                },
                description: {
                  type: "string",
                  description: "Clear, actionable description of what this task does"
                },
                completion_criteria: {
                  type: "array",
                  items: { type: "string" },
                  description: 'Array of natural language criteria to verify task completion (e.g., "response contains weather data", "at least 3 results found")'
                },
                depends_on: {
                  type: "array",
                  items: { type: "string" },
                  description: "Array of task names this task depends on (optional)"
                },
                parallel: {
                  type: "boolean",
                  description: "Whether this task can run in parallel with others (default: false)"
                },
                expected_output: {
                  type: "string",
                  description: "Description of expected output (optional)"
                },
                required_memory_keys: {
                  type: "array",
                  items: { type: "string" },
                  description: "Memory keys that must exist after task completion (optional)"
                },
                min_completion_score: {
                  type: "number",
                  description: "Minimum completion score (0-100) to consider task complete (default: 80)"
                }
              },
              required: ["name", "description"]
            }
          }
        },
        execute: async (args) => {
          const name = args.name;
          const description = args.description;
          const completionCriteria = args.completion_criteria;
          const dependsOn = args.depends_on;
          const parallel = args.parallel;
          const expectedOutput = args.expected_output;
          const requiredMemoryKeys = args.required_memory_keys;
          const minCompletionScore = args.min_completion_score;
          let validation;
          if (completionCriteria || requiredMemoryKeys || minCompletionScore) {
            validation = {
              completionCriteria,
              requiredMemoryKeys,
              minCompletionScore: minCompletionScore ?? 80,
              requireUserApproval: "uncertain",
              // Default: ask user in uncertain cases
              mode: "warn"
              // Default: warn but complete
            };
          }
          this.addTask({
            name,
            description,
            dependsOn,
            execution: parallel ? { parallel: true } : void 0,
            expectedOutput,
            validation
          });
          return {
            success: true,
            message: `Task '${name}' created${completionCriteria ? ` with ${completionCriteria.length} completion criteria` : ""}`,
            taskCount: this.currentTasks.length
          };
        },
        idempotency: {
          safe: false
        }
      },
      {
        definition: {
          type: "function",
          function: {
            name: "finalize_plan",
            description: "Mark the planning phase as complete. Call this when all tasks have been created and the plan is ready.",
            parameters: {
              type: "object",
              properties: {}
            }
          }
        },
        execute: async () => {
          this.finalizePlanning();
          return {
            success: true,
            message: "Plan finalized and ready for execution",
            totalTasks: this.currentTasks.length
          };
        },
        idempotency: {
          safe: false
        }
      }
    ];
  }
  /**
   * Generate a plan from a goal
   */
  async generatePlan(input) {
    this.currentTasks = [];
    this.planningComplete = false;
    const prompt = this.buildPlanningPrompt(input);
    const response = await this.agent.run(prompt);
    if (!this.planningComplete && this.currentTasks.length > 0) {
      this.planningComplete = true;
    }
    const plan = createPlan({
      goal: input.goal,
      context: input.context,
      tasks: this.currentTasks,
      allowDynamicTasks: false
      // Plans are static by default
    });
    return {
      plan,
      reasoning: response.output_text || "Plan generated",
      complexity: this.estimateComplexity(this.currentTasks)
    };
  }
  /**
   * Validate and refine an existing plan
   */
  async refinePlan(plan, feedback) {
    this.currentTasks = plan.tasks.map((task) => ({
      name: task.name,
      description: task.description,
      dependsOn: task.dependsOn,
      expectedOutput: task.expectedOutput,
      condition: task.condition,
      execution: task.execution,
      externalDependency: task.externalDependency,
      maxAttempts: task.maxAttempts
    }));
    this.planningComplete = false;
    const prompt = `I have an existing plan that needs refinement based on feedback.

**Current Plan Goal:** ${plan.goal}
**Current Plan Context:** ${plan.context || "None"}

**Current Tasks:**
${this.currentTasks.map((t, i) => `${i + 1}. ${t.name}: ${t.description}${t.dependsOn?.length ? ` (depends on: ${t.dependsOn.join(", ")})` : ""}`).join("\n")}

**Feedback:** ${feedback}

Please refine the plan based on this feedback. You can:
- Add new tasks
- Modify existing task descriptions
- Change dependencies
- Remove unnecessary tasks
- Adjust parallel execution

Use the planning tools to make changes, then finalize when complete.`;
    const response = await this.agent.run(prompt);
    const refinedPlan = createPlan({
      goal: plan.goal,
      context: plan.context,
      tasks: this.currentTasks,
      allowDynamicTasks: false
    });
    return {
      plan: refinedPlan,
      reasoning: response.output_text || "Plan refined",
      complexity: this.estimateComplexity(this.currentTasks)
    };
  }
  /**
   * Build planning prompt from input
   */
  buildPlanningPrompt(input) {
    const parts = [];
    parts.push("Please create an execution plan for the following goal:\n");
    parts.push(`**Goal:** ${input.goal}
`);
    if (input.context) {
      parts.push(`**Context:** ${input.context}
`);
    }
    if (input.constraints && input.constraints.length > 0) {
      parts.push("\n**Constraints:**");
      input.constraints.forEach((c) => parts.push(`- ${c}`));
      parts.push("");
    }
    if (this.config.availableTools && this.config.availableTools.length > 0) {
      parts.push("\n**Available Tools for Execution:**");
      this.config.availableTools.forEach((tool) => {
        parts.push(`- ${tool.definition.function.name}: ${tool.definition.function.description}`);
      });
      parts.push("");
    }
    parts.push("\nAnalyze this goal and create a structured plan with clear tasks and dependencies.");
    parts.push("Use the planning tools to build the plan step by step.");
    return parts.join("\n");
  }
  /**
   * Estimate plan complexity
   */
  estimateComplexity(tasks) {
    const taskCount = tasks.length;
    const hasDependencies = tasks.some((t) => t.dependsOn && t.dependsOn.length > 0);
    const hasConditionals = tasks.some((t) => t.condition);
    const hasExternalDeps = tasks.some((t) => t.externalDependency);
    if (taskCount <= 3 && !hasDependencies && !hasConditionals && !hasExternalDeps) {
      return "low";
    }
    if (taskCount <= 10 && !hasConditionals && !hasExternalDeps) {
      return "medium";
    }
    return "high";
  }
  /**
   * Get current tasks (for tool access)
   */
  getCurrentTasks() {
    return [...this.currentTasks];
  }
  /**
   * Add task (called by planning tools)
   */
  addTask(task) {
    this.currentTasks.push(task);
  }
  /**
   * Update task (called by planning tools)
   */
  updateTask(name, updates) {
    const task = this.currentTasks.find((t) => t.name === name);
    if (task) {
      Object.assign(task, updates);
    }
  }
  /**
   * Remove task (called by planning tools)
   */
  removeTask(name) {
    const index = this.currentTasks.findIndex((t) => t.name === name);
    if (index >= 0) {
      this.currentTasks.splice(index, 1);
    }
  }
  /**
   * Mark planning as complete
   */
  finalizePlanning() {
    this.planningComplete = true;
  }
};
async function generateSimplePlan(goal, context) {
  return createPlan({
    goal,
    context,
    tasks: [
      {
        name: "execute_goal",
        description: `Execute the goal: ${goal}`
      }
    ],
    allowDynamicTasks: true
    // Allow agent to modify plan
  });
}

// src/core/context/types.ts
var DEFAULT_CONTEXT_CONFIG = {
  maxContextTokens: 128e3,
  compactionThreshold: 0.75,
  hardLimit: 0.9,
  responseReserve: 0.15,
  estimator: "approximate",
  autoCompact: true,
  strategy: "proactive",
  strategyOptions: {}
};

// src/infrastructure/context/compactors/TruncateCompactor.ts
var TruncateCompactor = class {
  constructor(estimator) {
    this.estimator = estimator;
  }
  name = "truncate";
  priority = 10;
  canCompact(component) {
    return component.compactable && (component.metadata?.strategy === "truncate" || component.metadata?.truncatable === true);
  }
  async compact(component, targetTokens) {
    if (typeof component.content === "string") {
      return this.truncateString(component, targetTokens);
    }
    if (Array.isArray(component.content)) {
      return this.truncateArray(component, targetTokens);
    }
    return component;
  }
  estimateSavings(component) {
    const current = this.estimator.estimateDataTokens(component.content);
    return Math.floor(current * 0.5);
  }
  truncateString(component, targetTokens) {
    const content = component.content;
    const currentTokens = this.estimator.estimateTokens(content);
    if (currentTokens <= targetTokens) {
      return component;
    }
    const targetChars = targetTokens * 4;
    const truncated = content.substring(0, targetChars) + "\n[truncated...]";
    return {
      ...component,
      content: truncated,
      metadata: {
        ...component.metadata,
        truncated: true,
        originalLength: content.length,
        truncatedLength: truncated.length
      }
    };
  }
  truncateArray(component, targetTokens) {
    const content = component.content;
    let tokens = 0;
    const kept = [];
    for (let i = content.length - 1; i >= 0; i--) {
      const item = content[i];
      const itemTokens = this.estimator.estimateDataTokens(item);
      if (tokens + itemTokens > targetTokens && kept.length > 0) {
        break;
      }
      kept.unshift(item);
      tokens += itemTokens;
    }
    const droppedLength = content.length - kept.length;
    if (droppedLength === 0) {
      return component;
    }
    return {
      ...component,
      content: kept,
      metadata: {
        ...component.metadata,
        truncated: true,
        originalLength: content.length,
        keptLength: kept.length,
        droppedLength
      }
    };
  }
};

// src/infrastructure/context/compactors/SummarizeCompactor.ts
var SUMMARIZATION_PROMPTS = {
  conversation: `Summarize this conversation history, preserving:
- Key decisions made by the user or assistant
- Important facts and data discovered
- User preferences expressed
- Unresolved questions or pending items
- Any errors or issues encountered

Focus on information that would be needed to continue the conversation coherently.
Be concise but preserve critical context.`,
  tool_output: `Summarize these tool outputs, preserving:
- Key results and findings from each tool call
- Important data values (numbers, dates, names, IDs)
- Error messages or warnings
- Status information
- Dependencies or relationships between results

Prioritize factual data over explanatory text.`,
  search_results: `Summarize these search results, preserving:
- Key findings relevant to the task
- Source URLs and their main points (keep URLs intact)
- Factual data (numbers, dates, names, statistics)
- Contradictions or disagreements between sources
- Credibility indicators (official sources, recent dates)

Format as a bulleted list organized by topic or source.`,
  scrape_results: `Summarize this scraped web content, preserving:
- Main topic and key points
- Factual data (numbers, dates, names, prices, specifications)
- Important quotes or statements
- Source attribution (keep the URL)
- Any structured data (tables, lists)

Discard navigation elements, ads, and boilerplate text.`,
  generic: `Summarize this content, preserving:
- Main points and key information
- Important data and facts
- Relationships and dependencies
- Actionable items

Be concise while retaining critical information.`
};
var SummarizeCompactor = class {
  name = "summarize";
  priority = 5;
  // Run before truncate (10)
  config;
  estimator;
  constructor(estimator, config) {
    this.estimator = estimator;
    this.config = {
      textProvider: config.textProvider,
      model: config.model ?? "",
      maxSummaryTokens: config.maxSummaryTokens ?? 500,
      preserveStructure: config.preserveStructure ?? true,
      fallbackToTruncate: config.fallbackToTruncate ?? true,
      temperature: config.temperature ?? 0.3
    };
  }
  /**
   * Check if this compactor can handle the component
   */
  canCompact(component) {
    return component.compactable && component.metadata?.strategy === "summarize";
  }
  /**
   * Compact the component by summarizing its content
   */
  async compact(component, targetTokens) {
    const contentStr = this.stringifyContent(component.content);
    const currentTokens = this.estimator.estimateTokens(contentStr);
    if (currentTokens <= targetTokens) {
      return component;
    }
    const contentType = this.detectContentType(component);
    try {
      const summary = await this.summarize(contentStr, contentType, targetTokens);
      const summaryTokens = this.estimator.estimateTokens(summary);
      if (summaryTokens >= currentTokens * 0.9) {
        if (this.config.fallbackToTruncate) {
          return this.truncateFallback(component, contentStr, targetTokens);
        }
      }
      return {
        ...component,
        content: summary,
        metadata: {
          ...component.metadata,
          summarized: true,
          summarizedFrom: currentTokens,
          summarizedTo: summaryTokens,
          reductionPercent: Math.round(
            (currentTokens - summaryTokens) / currentTokens * 100
          ),
          contentType
        }
      };
    } catch (error) {
      if (this.config.fallbackToTruncate) {
        console.warn(
          `SummarizeCompactor: LLM summarization failed for ${component.name}, falling back to truncation:`,
          error instanceof Error ? error.message : String(error)
        );
        return this.truncateFallback(component, contentStr, targetTokens);
      }
      throw error;
    }
  }
  /**
   * Estimate how many tokens could be saved by summarization
   */
  estimateSavings(component) {
    const current = this.estimator.estimateDataTokens(component.content);
    return Math.floor(current * 0.8);
  }
  /**
   * Perform LLM-based summarization
   */
  async summarize(content, contentType, targetTokens) {
    const systemPrompt = SUMMARIZATION_PROMPTS[contentType];
    const maxSummaryTokens = Math.min(targetTokens, this.config.maxSummaryTokens);
    const structureInstructions = this.config.preserveStructure ? "\n\nPreserve formatting structure (headings, bullet points, numbered lists) where appropriate." : "";
    const prompt = `${systemPrompt}${structureInstructions}

Target summary length: approximately ${maxSummaryTokens} tokens (${maxSummaryTokens * 4} characters).

Content to summarize:
---
${content}
---

Provide the summary:`;
    const response = await this.config.textProvider.generate({
      model: this.config.model || "gpt-4o-mini",
      // Use a fast, cheap model for summarization
      input: prompt,
      temperature: this.config.temperature,
      max_output_tokens: maxSummaryTokens + 100
      // Allow some buffer
    });
    return response.output_text || content;
  }
  /**
   * Fallback to simple truncation when LLM fails
   */
  truncateFallback(component, contentStr, targetTokens) {
    const targetChars = targetTokens * 4;
    const truncated = contentStr.substring(0, targetChars) + "\n\n[... content truncated due to context limits ...]";
    return {
      ...component,
      content: truncated,
      metadata: {
        ...component.metadata,
        truncated: true,
        truncatedFrom: contentStr.length,
        truncatedTo: truncated.length,
        summarizationFailed: true
      }
    };
  }
  /**
   * Detect content type from component metadata or name
   */
  detectContentType(component) {
    if (component.metadata?.contentType) {
      return component.metadata.contentType;
    }
    const name = component.name.toLowerCase();
    if (name.includes("conversation") || name.includes("history") || name.includes("messages")) {
      return "conversation";
    }
    if (name.includes("search")) {
      return "search_results";
    }
    if (name.includes("scrape") || name.includes("fetch")) {
      return "scrape_results";
    }
    if (name.includes("tool") || name.includes("output")) {
      return "tool_output";
    }
    return "generic";
  }
  /**
   * Convert content to string for processing
   */
  stringifyContent(content) {
    if (typeof content === "string") {
      return content;
    }
    if (Array.isArray(content)) {
      return content.map((item) => {
        if (typeof item === "string") return item;
        if (item && typeof item === "object") {
          if ("role" in item && "content" in item) {
            return `[${item.role}]: ${item.content}`;
          }
          if ("tool" in item && "output" in item) {
            return `[${item.tool}]: ${JSON.stringify(item.output)}`;
          }
        }
        return JSON.stringify(item);
      }).join("\n\n");
    }
    return JSON.stringify(content, null, 2);
  }
};

// src/infrastructure/context/compactors/MemoryEvictionCompactor.ts
var MemoryEvictionCompactor = class {
  constructor(estimator) {
    this.estimator = estimator;
  }
  name = "memory-eviction";
  priority = 8;
  canCompact(component) {
    return component.compactable && (component.metadata?.strategy === "evict" || component.name === "memory_index");
  }
  async compact(component, targetTokens) {
    if (component.metadata?.evict && typeof component.metadata.evict === "function") {
      const currentTokens = this.estimator.estimateDataTokens(component.content);
      const tokensToFree = Math.max(0, currentTokens - targetTokens);
      const avgEntrySize = component.metadata.avgEntrySize || 100;
      const entriesToEvict = Math.ceil(tokensToFree / avgEntrySize);
      if (entriesToEvict > 0) {
        await component.metadata.evict(entriesToEvict);
        if (component.metadata.getUpdatedContent && typeof component.metadata.getUpdatedContent === "function") {
          const updatedContent = await component.metadata.getUpdatedContent();
          return {
            ...component,
            content: updatedContent,
            metadata: {
              ...component.metadata,
              evicted: true,
              evictedCount: entriesToEvict
            }
          };
        }
      }
    }
    return component;
  }
  estimateSavings(component) {
    const avgEntrySize = component.metadata?.avgEntrySize || 100;
    return avgEntrySize * 2;
  }
};

// src/infrastructure/context/estimators/ApproximateEstimator.ts
var ApproximateTokenEstimator = class {
  /**
   * Estimate tokens for text with content-type awareness
   *
   * @param text - The text to estimate tokens for
   * @param contentType - Type of content:
   *   - 'code': Code is typically denser (~3 chars/token)
   *   - 'prose': Natural language text (~4 chars/token)
   *   - 'mixed': Mix of code and prose (~3.5 chars/token)
   */
  estimateTokens(text, contentType = "mixed") {
    if (!text || text.length === 0) {
      return 0;
    }
    const charsPerToken = contentType === "code" ? 3 : contentType === "prose" ? 4 : 3.5;
    return Math.ceil(text.length / charsPerToken);
  }
  /**
   * Estimate tokens for structured data (always uses 'mixed' estimation)
   */
  estimateDataTokens(data, contentType = "mixed") {
    if (data === null || data === void 0) {
      return 1;
    }
    try {
      const serialized = JSON.stringify(data);
      return this.estimateTokens(serialized, contentType);
    } catch {
      return 100;
    }
  }
  /**
   * Estimate tokens for an image using tile-based model (matches OpenAI pricing).
   *
   * - detail='low': 85 tokens
   * - detail='high' with known dimensions: 85 + 170 per 512×512 tile
   * - Unknown dimensions: 1000 tokens (conservative default)
   */
  estimateImageTokens(width, height, detail) {
    if (detail === "low") return 85;
    if (width && height) {
      const tiles = Math.ceil(width / 512) * Math.ceil(height / 512);
      return 85 + 170 * tiles;
    }
    return 1e3;
  }
};

// src/infrastructure/context/estimators/index.ts
function createEstimator(name) {
  switch (name) {
    case "approximate":
      return new ApproximateTokenEstimator();
    case "tiktoken":
      throw new Error('Tiktoken estimator not yet implemented. Use "approximate" for now.');
    default:
      throw new Error(`Unknown token estimator: ${name}`);
  }
}

// src/domain/interfaces/IHistoryManager.ts
var DEFAULT_HISTORY_MANAGER_CONFIG = {
  maxMessages: 50,
  maxTokens: 32e3,
  compactionStrategy: "sliding-window",
  preserveRecentCount: 10
};

// src/infrastructure/storage/InMemoryHistoryStorage.ts
var InMemoryHistoryStorage = class {
  messages = [];
  summaries = [];
  async addMessage(message) {
    this.messages.push(message);
  }
  async getMessages() {
    return [...this.messages];
  }
  async getRecentMessages(count) {
    return this.messages.slice(-count);
  }
  async removeMessage(id) {
    const index = this.messages.findIndex((m) => m.id === id);
    if (index >= 0) {
      this.messages.splice(index, 1);
    }
  }
  async removeOlderThan(timestamp) {
    const originalLength = this.messages.length;
    this.messages = this.messages.filter((m) => m.timestamp >= timestamp);
    return originalLength - this.messages.length;
  }
  async clear() {
    this.messages = [];
    this.summaries = [];
  }
  async getCount() {
    return this.messages.length;
  }
  async getState() {
    return {
      version: 1,
      messages: [...this.messages],
      summaries: [...this.summaries]
    };
  }
  async restoreState(state) {
    this.messages = [...state.messages];
    this.summaries = state.summaries ? [...state.summaries] : [];
  }
};
function getDefaultBaseDirectory3() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "agents");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "agents");
}
function sanitizeId(id) {
  return id.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || "default";
}
var FORMAT_VERSION = CONTEXT_SESSION_FORMAT_VERSION;
var FileContextStorage = class {
  agentId;
  sessionsDirectory;
  indexPath;
  prettyPrint;
  index = null;
  constructor(config) {
    this.agentId = config.agentId;
    const sanitizedAgentId = sanitizeId(config.agentId);
    const baseDir = config.baseDirectory ?? getDefaultBaseDirectory3();
    this.prettyPrint = config.prettyPrint ?? true;
    this.sessionsDirectory = path2.join(baseDir, sanitizedAgentId, "sessions");
    this.indexPath = path2.join(this.sessionsDirectory, "_index.json");
  }
  /**
   * Save context state to a session file
   */
  async save(sessionId, state, metadata) {
    await this.ensureDirectory();
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const sanitizedSessionId = sanitizeId(sessionId);
    const filePath = this.getFilePath(sanitizedSessionId);
    let createdAt = now;
    const existing = await this.loadRaw(sanitizedSessionId);
    if (existing) {
      createdAt = existing.createdAt;
    }
    const storedSession = {
      version: FORMAT_VERSION,
      sessionId,
      createdAt,
      lastSavedAt: now,
      state,
      metadata: metadata ?? {}
    };
    const data = this.prettyPrint ? JSON.stringify(storedSession, null, 2) : JSON.stringify(storedSession);
    const tempPath = `${filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, data, "utf-8");
      await fs19.promises.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
    await this.updateIndex(storedSession);
  }
  /**
   * Load context state from a session file
   */
  async load(sessionId) {
    const sanitizedSessionId = sanitizeId(sessionId);
    return this.loadRaw(sanitizedSessionId);
  }
  /**
   * Delete a session
   */
  async delete(sessionId) {
    const sanitizedSessionId = sanitizeId(sessionId);
    const filePath = this.getFilePath(sanitizedSessionId);
    try {
      await fs19.promises.unlink(filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
    await this.removeFromIndex(sessionId);
  }
  /**
   * Check if a session exists
   */
  async exists(sessionId) {
    const sanitizedSessionId = sanitizeId(sessionId);
    const filePath = this.getFilePath(sanitizedSessionId);
    try {
      await fs19.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * List all sessions (summaries only)
   */
  async list(options) {
    const index = await this.loadIndex();
    let entries = [...index.sessions];
    if (options?.tags && options.tags.length > 0) {
      entries = entries.filter((e) => {
        const entryTags = e.metadata.tags ?? [];
        return options.tags.some((t) => entryTags.includes(t));
      });
    }
    if (options?.createdAfter) {
      const after = options.createdAfter.getTime();
      entries = entries.filter((e) => new Date(e.createdAt).getTime() >= after);
    }
    if (options?.createdBefore) {
      const before = options.createdBefore.getTime();
      entries = entries.filter((e) => new Date(e.createdAt).getTime() <= before);
    }
    if (options?.savedAfter) {
      const after = options.savedAfter.getTime();
      entries = entries.filter((e) => new Date(e.lastSavedAt).getTime() >= after);
    }
    if (options?.savedBefore) {
      const before = options.savedBefore.getTime();
      entries = entries.filter((e) => new Date(e.lastSavedAt).getTime() <= before);
    }
    entries.sort(
      (a, b) => new Date(b.lastSavedAt).getTime() - new Date(a.lastSavedAt).getTime()
    );
    if (options?.offset) {
      entries = entries.slice(options.offset);
    }
    if (options?.limit) {
      entries = entries.slice(0, options.limit);
    }
    return entries.map((e) => ({
      sessionId: e.sessionId,
      createdAt: new Date(e.createdAt),
      lastSavedAt: new Date(e.lastSavedAt),
      messageCount: e.messageCount,
      memoryEntryCount: e.memoryEntryCount,
      metadata: e.metadata
    }));
  }
  /**
   * Update session metadata without loading full state
   */
  async updateMetadata(sessionId, metadata) {
    const stored = await this.load(sessionId);
    if (!stored) {
      throw new Error(`Session '${sessionId}' not found`);
    }
    stored.metadata = { ...stored.metadata, ...metadata };
    stored.lastSavedAt = (/* @__PURE__ */ new Date()).toISOString();
    const sanitizedSessionId = sanitizeId(sessionId);
    const filePath = this.getFilePath(sanitizedSessionId);
    const data = this.prettyPrint ? JSON.stringify(stored, null, 2) : JSON.stringify(stored);
    await fs19.promises.writeFile(filePath, data, "utf-8");
    await this.updateIndex(stored);
  }
  /**
   * Get the storage path (for display/debugging)
   * @deprecated Use getLocation() instead
   */
  getPath() {
    return this.sessionsDirectory;
  }
  /**
   * Get a human-readable storage location string (for display/debugging)
   */
  getLocation() {
    return this.sessionsDirectory;
  }
  /**
   * Get the agent ID
   */
  getAgentId() {
    return this.agentId;
  }
  /**
   * Rebuild the index by scanning all session files
   * Useful for recovery or migration
   */
  async rebuildIndex() {
    await this.ensureDirectory();
    const files = await fs19.promises.readdir(this.sessionsDirectory);
    const sessionFiles = files.filter((f) => f.endsWith(".json") && !f.startsWith("_"));
    const entries = [];
    for (const file of sessionFiles) {
      try {
        const filePath = path2.join(this.sessionsDirectory, file);
        const data = await fs19.promises.readFile(filePath, "utf-8");
        const stored = JSON.parse(data);
        entries.push(this.storedToIndexEntry(stored));
      } catch {
      }
    }
    this.index = {
      version: 1,
      agentId: this.agentId,
      sessions: entries,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.saveIndex();
  }
  // ==========================================================================
  // Private Helpers
  // ==========================================================================
  getFilePath(sanitizedSessionId) {
    return path2.join(this.sessionsDirectory, `${sanitizedSessionId}.json`);
  }
  async ensureDirectory() {
    try {
      await fs19.promises.mkdir(this.sessionsDirectory, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
  async loadRaw(sanitizedSessionId) {
    const filePath = this.getFilePath(sanitizedSessionId);
    try {
      const data = await fs19.promises.readFile(filePath, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return null;
      }
      if (error instanceof SyntaxError) {
        console.warn(`Corrupted session file: ${filePath}`);
        return null;
      }
      throw error;
    }
  }
  async loadIndex() {
    if (this.index) {
      return this.index;
    }
    try {
      const data = await fs19.promises.readFile(this.indexPath, "utf-8");
      this.index = JSON.parse(data);
      return this.index;
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        this.index = {
          version: 1,
          agentId: this.agentId,
          sessions: [],
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
        return this.index;
      }
      throw error;
    }
  }
  async saveIndex() {
    if (!this.index) return;
    await this.ensureDirectory();
    this.index.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    const data = this.prettyPrint ? JSON.stringify(this.index, null, 2) : JSON.stringify(this.index);
    await fs19.promises.writeFile(this.indexPath, data, "utf-8");
  }
  async updateIndex(stored) {
    const index = await this.loadIndex();
    const entry = this.storedToIndexEntry(stored);
    const existingIdx = index.sessions.findIndex((e) => e.sessionId === stored.sessionId);
    if (existingIdx >= 0) {
      index.sessions[existingIdx] = entry;
    } else {
      index.sessions.push(entry);
    }
    await this.saveIndex();
  }
  async removeFromIndex(sessionId) {
    const index = await this.loadIndex();
    index.sessions = index.sessions.filter((e) => e.sessionId !== sessionId);
    await this.saveIndex();
  }
  storedToIndexEntry(stored) {
    const workingMemoryState = stored.state.pluginStates?.workingMemory;
    return {
      sessionId: stored.sessionId,
      createdAt: stored.createdAt,
      lastSavedAt: stored.lastSavedAt,
      messageCount: stored.state.conversation?.length ?? 0,
      memoryEntryCount: workingMemoryState?.entries?.length ?? 0,
      metadata: stored.metadata
    };
  }
};
function createFileContextStorage(agentId, options) {
  return new FileContextStorage({ agentId, ...options });
}
function getDefaultBaseDirectory4() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "agents");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "agents");
}
function sanitizeAgentId2(agentId) {
  return agentId.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || "default";
}
var FileAgentDefinitionStorage = class {
  baseDirectory;
  indexPath;
  prettyPrint;
  index = null;
  constructor(config = {}) {
    this.baseDirectory = config.baseDirectory ?? getDefaultBaseDirectory4();
    this.prettyPrint = config.prettyPrint ?? true;
    this.indexPath = path2.join(this.baseDirectory, "_agents_index.json");
  }
  /**
   * Save an agent definition
   */
  async save(definition) {
    const sanitizedId = sanitizeAgentId2(definition.agentId);
    const agentDir = path2.join(this.baseDirectory, sanitizedId);
    const filePath = path2.join(agentDir, "definition.json");
    await this.ensureDirectory(agentDir);
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (!definition.createdAt) {
      const existing = await this.loadRaw(sanitizedId);
      definition.createdAt = existing?.createdAt ?? now;
    }
    definition.updatedAt = now;
    definition.version = AGENT_DEFINITION_FORMAT_VERSION;
    const data = this.prettyPrint ? JSON.stringify(definition, null, 2) : JSON.stringify(definition);
    const tempPath = `${filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, data, "utf-8");
      await fs19.promises.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
    await this.updateIndex(definition);
  }
  /**
   * Load an agent definition
   */
  async load(agentId) {
    const sanitizedId = sanitizeAgentId2(agentId);
    return this.loadRaw(sanitizedId);
  }
  /**
   * Delete an agent definition
   */
  async delete(agentId) {
    const sanitizedId = sanitizeAgentId2(agentId);
    const agentDir = path2.join(this.baseDirectory, sanitizedId);
    const filePath = path2.join(agentDir, "definition.json");
    try {
      await fs19.promises.unlink(filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
    await this.removeFromIndex(agentId);
  }
  /**
   * Check if an agent definition exists
   */
  async exists(agentId) {
    const sanitizedId = sanitizeAgentId2(agentId);
    const filePath = path2.join(this.baseDirectory, sanitizedId, "definition.json");
    try {
      await fs19.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * List all agent definitions
   */
  async list(options) {
    const index = await this.loadIndex();
    let entries = [...index.agents];
    if (options?.agentType) {
      entries = entries.filter((e) => e.agentType === options.agentType);
    }
    if (options?.tags && options.tags.length > 0) {
      entries = entries.filter((e) => {
        const entryTags = e.metadata?.tags ?? [];
        return options.tags.some((t) => entryTags.includes(t));
      });
    }
    entries.sort(
      (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
    if (options?.offset) {
      entries = entries.slice(options.offset);
    }
    if (options?.limit) {
      entries = entries.slice(0, options.limit);
    }
    return entries.map((e) => ({
      agentId: e.agentId,
      name: e.name,
      agentType: e.agentType,
      model: e.model,
      createdAt: new Date(e.createdAt),
      updatedAt: new Date(e.updatedAt),
      metadata: e.metadata
    }));
  }
  /**
   * Update metadata without loading full definition
   */
  async updateMetadata(agentId, metadata) {
    const definition = await this.load(agentId);
    if (!definition) {
      throw new Error(`Agent '${agentId}' not found`);
    }
    definition.metadata = { ...definition.metadata, ...metadata };
    await this.save(definition);
  }
  /**
   * Get storage path
   */
  getPath() {
    return this.baseDirectory;
  }
  /**
   * Rebuild the index by scanning all agent directories
   */
  async rebuildIndex() {
    await this.ensureDirectory(this.baseDirectory);
    const entries = await fs19.promises.readdir(this.baseDirectory, { withFileTypes: true });
    const agentDirs = entries.filter((e) => e.isDirectory() && !e.name.startsWith("_"));
    const indexEntries = [];
    for (const dir of agentDirs) {
      try {
        const filePath = path2.join(this.baseDirectory, dir.name, "definition.json");
        const data = await fs19.promises.readFile(filePath, "utf-8");
        const definition = JSON.parse(data);
        indexEntries.push(this.definitionToIndexEntry(definition));
      } catch {
      }
    }
    this.index = {
      version: 1,
      agents: indexEntries,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.saveIndex();
  }
  // ==========================================================================
  // Private Helpers
  // ==========================================================================
  async ensureDirectory(dir) {
    try {
      await fs19.promises.mkdir(dir, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
  async loadRaw(sanitizedId) {
    const filePath = path2.join(this.baseDirectory, sanitizedId, "definition.json");
    try {
      const data = await fs19.promises.readFile(filePath, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return null;
      }
      if (error instanceof SyntaxError) {
        console.warn(`Corrupted agent definition: ${filePath}`);
        return null;
      }
      throw error;
    }
  }
  async loadIndex() {
    if (this.index) {
      return this.index;
    }
    try {
      const data = await fs19.promises.readFile(this.indexPath, "utf-8");
      this.index = JSON.parse(data);
      return this.index;
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        this.index = {
          version: 1,
          agents: [],
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
        return this.index;
      }
      throw error;
    }
  }
  async saveIndex() {
    if (!this.index) return;
    await this.ensureDirectory(this.baseDirectory);
    this.index.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    const data = this.prettyPrint ? JSON.stringify(this.index, null, 2) : JSON.stringify(this.index);
    await fs19.promises.writeFile(this.indexPath, data, "utf-8");
  }
  async updateIndex(definition) {
    const index = await this.loadIndex();
    const entry = this.definitionToIndexEntry(definition);
    const existingIdx = index.agents.findIndex((e) => e.agentId === definition.agentId);
    if (existingIdx >= 0) {
      index.agents[existingIdx] = entry;
    } else {
      index.agents.push(entry);
    }
    await this.saveIndex();
  }
  async removeFromIndex(agentId) {
    const index = await this.loadIndex();
    index.agents = index.agents.filter((e) => e.agentId !== agentId);
    await this.saveIndex();
  }
  definitionToIndexEntry(definition) {
    return {
      agentId: definition.agentId,
      name: definition.name,
      agentType: definition.agentType,
      model: definition.connector.model,
      createdAt: definition.createdAt,
      updatedAt: definition.updatedAt,
      metadata: definition.metadata
    };
  }
};
function createFileAgentDefinitionStorage(config) {
  return new FileAgentDefinitionStorage(config);
}
var MIME_TYPES2 = {
  png: "image/png",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  webp: "image/webp",
  gif: "image/gif",
  mp4: "video/mp4",
  webm: "video/webm",
  mp3: "audio/mpeg",
  wav: "audio/wav",
  opus: "audio/opus",
  ogg: "audio/ogg",
  aac: "audio/aac",
  flac: "audio/flac",
  pcm: "audio/pcm"
};
var MEDIA_TYPE_PREFIXES = ["image", "video", "audio"];
var FileMediaStorage = class {
  outputDir;
  initialized = false;
  constructor(config) {
    this.outputDir = config?.outputDir ?? path2__namespace.join(os2__namespace.tmpdir(), "oneringai-media");
  }
  async save(data, metadata) {
    const dir = metadata.userId ? path2__namespace.join(this.outputDir, metadata.userId) : this.outputDir;
    await fs18__namespace.mkdir(dir, { recursive: true });
    const filename = metadata.suggestedFilename ?? this.generateFilename(metadata);
    const filePath = path2__namespace.join(dir, filename);
    await fs18__namespace.writeFile(filePath, data);
    const format = metadata.format.toLowerCase();
    const mimeType = MIME_TYPES2[format] ?? "application/octet-stream";
    return {
      location: filePath,
      mimeType,
      size: data.length
    };
  }
  async read(location) {
    try {
      return await fs18__namespace.readFile(location);
    } catch (err) {
      if (err.code === "ENOENT") {
        return null;
      }
      throw err;
    }
  }
  async delete(location) {
    try {
      await fs18__namespace.unlink(location);
    } catch (err) {
      if (err.code === "ENOENT") {
        return;
      }
      throw err;
    }
  }
  async exists(location) {
    try {
      await fs18__namespace.access(location);
      return true;
    } catch {
      return false;
    }
  }
  async list(options) {
    await this.ensureDir();
    let entries = [];
    const files = await fs18__namespace.readdir(this.outputDir);
    for (const file of files) {
      const filePath = path2__namespace.join(this.outputDir, file);
      try {
        const stat6 = await fs18__namespace.stat(filePath);
        if (!stat6.isFile()) continue;
        const ext = path2__namespace.extname(file).slice(1).toLowerCase();
        const mimeType = MIME_TYPES2[ext] ?? "application/octet-stream";
        let type;
        for (const prefix of MEDIA_TYPE_PREFIXES) {
          if (file.startsWith(`${prefix}_`)) {
            type = prefix;
            break;
          }
        }
        entries.push({
          location: filePath,
          mimeType,
          size: stat6.size,
          type,
          createdAt: stat6.birthtime
        });
      } catch {
      }
    }
    if (options?.type) {
      entries = entries.filter((e) => e.type === options.type);
    }
    entries.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    const offset = options?.offset ?? 0;
    const limit = options?.limit ?? entries.length;
    return entries.slice(offset, offset + limit);
  }
  getPath() {
    return this.outputDir;
  }
  generateFilename(metadata) {
    const timestamp = Date.now();
    const random2 = crypto2__namespace.randomBytes(4).toString("hex");
    const indexSuffix = metadata.index != null ? `_${metadata.index}` : "";
    return `${metadata.type}_${timestamp}_${random2}${indexSuffix}.${metadata.format}`;
  }
  async ensureDir() {
    if (!this.initialized) {
      await fs18__namespace.mkdir(this.outputDir, { recursive: true });
      this.initialized = true;
    }
  }
};
function createFileMediaStorage(config) {
  return new FileMediaStorage(config);
}
function getDefaultBaseDirectory5() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "users");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "users");
}
var DEFAULT_USER_ID2 = "default";
function sanitizeUserId2(userId) {
  if (!userId) {
    return DEFAULT_USER_ID2;
  }
  return userId.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || DEFAULT_USER_ID2;
}
function sanitizeName(name) {
  return name.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || "default";
}
var FileCustomToolStorage = class {
  baseDirectory;
  prettyPrint;
  constructor(config = {}) {
    this.baseDirectory = config.baseDirectory ?? getDefaultBaseDirectory5();
    this.prettyPrint = config.prettyPrint ?? true;
  }
  /**
   * Get the directory path for a specific user's custom tools
   */
  getUserDirectory(userId) {
    const sanitizedId = sanitizeUserId2(userId);
    return path2.join(this.baseDirectory, sanitizedId, "custom-tools");
  }
  /**
   * Get the index file path for a specific user
   */
  getUserIndexPath(userId) {
    return path2.join(this.getUserDirectory(userId), "_index.json");
  }
  /**
   * Get the tool file path for a specific user
   */
  getToolPath(userId, sanitizedName) {
    return path2.join(this.getUserDirectory(userId), `${sanitizedName}.json`);
  }
  /**
   * Save a custom tool definition
   */
  async save(userId, definition) {
    const directory = this.getUserDirectory(userId);
    const sanitized = sanitizeName(definition.name);
    const filePath = this.getToolPath(userId, sanitized);
    await this.ensureDirectory(directory);
    const data = this.prettyPrint ? JSON.stringify(definition, null, 2) : JSON.stringify(definition);
    const tempPath = `${filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, data, "utf-8");
      await fs19.promises.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
    await this.updateIndex(userId, definition);
  }
  /**
   * Load a custom tool definition by name
   */
  async load(userId, name) {
    const sanitized = sanitizeName(name);
    const filePath = this.getToolPath(userId, sanitized);
    try {
      const data = await fs19.promises.readFile(filePath, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return null;
      }
      if (error instanceof SyntaxError) {
        return null;
      }
      throw error;
    }
  }
  /**
   * Delete a custom tool definition
   */
  async delete(userId, name) {
    const sanitized = sanitizeName(name);
    const filePath = this.getToolPath(userId, sanitized);
    try {
      await fs19.promises.unlink(filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
    await this.removeFromIndex(userId, name);
  }
  /**
   * Check if a custom tool exists
   */
  async exists(userId, name) {
    const sanitized = sanitizeName(name);
    const filePath = this.getToolPath(userId, sanitized);
    try {
      await fs19.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * List custom tools (summaries only)
   */
  async list(userId, options) {
    const index = await this.loadIndex(userId);
    let entries = [...index.tools];
    if (options?.tags && options.tags.length > 0) {
      entries = entries.filter((e) => {
        const entryTags = e.tags ?? [];
        return options.tags.some((t) => entryTags.includes(t));
      });
    }
    if (options?.category) {
      entries = entries.filter((e) => e.category === options.category);
    }
    if (options?.search) {
      const searchLower = options.search.toLowerCase();
      entries = entries.filter(
        (e) => e.name.toLowerCase().includes(searchLower) || e.description.toLowerCase().includes(searchLower)
      );
    }
    entries.sort(
      (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
    if (options?.offset) {
      entries = entries.slice(options.offset);
    }
    if (options?.limit) {
      entries = entries.slice(0, options.limit);
    }
    return entries.map((e) => ({
      name: e.name,
      displayName: e.displayName,
      description: e.description,
      createdAt: e.createdAt,
      updatedAt: e.updatedAt,
      metadata: {
        tags: e.tags,
        category: e.category
      }
    }));
  }
  /**
   * Update metadata without loading full definition
   */
  async updateMetadata(userId, name, metadata) {
    const definition = await this.load(userId, name);
    if (!definition) {
      throw new Error(`Custom tool '${name}' not found`);
    }
    definition.metadata = { ...definition.metadata, ...metadata };
    definition.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    await this.save(userId, definition);
  }
  /**
   * Get storage path for a specific user
   */
  getPath(userId) {
    return this.getUserDirectory(userId);
  }
  // ==========================================================================
  // Private Helpers
  // ==========================================================================
  async ensureDirectory(dir) {
    try {
      await fs19.promises.mkdir(dir, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
  async loadIndex(userId) {
    const indexPath = this.getUserIndexPath(userId);
    try {
      const data = await fs19.promises.readFile(indexPath, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return {
          version: 1,
          tools: [],
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      throw error;
    }
  }
  async saveIndex(userId, index) {
    const directory = this.getUserDirectory(userId);
    const indexPath = this.getUserIndexPath(userId);
    await this.ensureDirectory(directory);
    index.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    const data = this.prettyPrint ? JSON.stringify(index, null, 2) : JSON.stringify(index);
    await fs19.promises.writeFile(indexPath, data, "utf-8");
  }
  async updateIndex(userId, definition) {
    const index = await this.loadIndex(userId);
    const entry = this.definitionToIndexEntry(definition);
    const existingIdx = index.tools.findIndex((e) => e.name === definition.name);
    if (existingIdx >= 0) {
      index.tools[existingIdx] = entry;
    } else {
      index.tools.push(entry);
    }
    await this.saveIndex(userId, index);
  }
  async removeFromIndex(userId, name) {
    const index = await this.loadIndex(userId);
    index.tools = index.tools.filter((e) => e.name !== name);
    await this.saveIndex(userId, index);
  }
  definitionToIndexEntry(definition) {
    return {
      name: definition.name,
      displayName: definition.displayName,
      description: definition.description,
      createdAt: definition.createdAt,
      updatedAt: definition.updatedAt,
      tags: definition.metadata?.tags,
      category: definition.metadata?.category
    };
  }
};
function createFileCustomToolStorage(config) {
  return new FileCustomToolStorage(config);
}
var STORAGE_VERSION = 1;
var DEFAULT_USER_ID3 = "default";
function getDefaultBaseDirectory6() {
  const platform2 = process.platform;
  if (platform2 === "win32") {
    const appData = process.env.APPDATA || process.env.LOCALAPPDATA;
    if (appData) {
      return path2.join(appData, "oneringai", "users");
    }
  }
  return path2.join(os2.homedir(), ".oneringai", "users");
}
function sanitizeUserId3(userId) {
  if (!userId) {
    return DEFAULT_USER_ID3;
  }
  return userId.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || DEFAULT_USER_ID3;
}
function sanitizeId2(id) {
  return id.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").toLowerCase() || "default";
}
var FileRoutineDefinitionStorage = class {
  baseDirectory;
  prettyPrint;
  constructor(config = {}) {
    this.baseDirectory = config.baseDirectory ?? getDefaultBaseDirectory6();
    this.prettyPrint = config.prettyPrint ?? true;
  }
  getUserDirectory(userId) {
    const sanitizedId = sanitizeUserId3(userId);
    return path2.join(this.baseDirectory, sanitizedId, "routines");
  }
  getIndexPath(userId) {
    return path2.join(this.getUserDirectory(userId), "_index.json");
  }
  getRoutinePath(userId, sanitizedId) {
    return path2.join(this.getUserDirectory(userId), `${sanitizedId}.json`);
  }
  async save(userId, definition) {
    const directory = this.getUserDirectory(userId);
    const sanitized = sanitizeId2(definition.id);
    const filePath = this.getRoutinePath(userId, sanitized);
    await this.ensureDirectory(directory);
    const stored = { version: STORAGE_VERSION, definition };
    const data = this.prettyPrint ? JSON.stringify(stored, null, 2) : JSON.stringify(stored);
    const tempPath = `${filePath}.tmp`;
    try {
      await fs19.promises.writeFile(tempPath, data, "utf-8");
      await fs19.promises.rename(tempPath, filePath);
    } catch (error) {
      try {
        await fs19.promises.unlink(tempPath);
      } catch {
      }
      throw error;
    }
    await this.updateIndex(userId, definition);
  }
  async load(userId, id) {
    const sanitized = sanitizeId2(id);
    const filePath = this.getRoutinePath(userId, sanitized);
    try {
      const data = await fs19.promises.readFile(filePath, "utf-8");
      const stored = JSON.parse(data);
      return stored.definition;
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return null;
      }
      if (error instanceof SyntaxError) {
        return null;
      }
      throw error;
    }
  }
  async delete(userId, id) {
    const sanitized = sanitizeId2(id);
    const filePath = this.getRoutinePath(userId, sanitized);
    try {
      await fs19.promises.unlink(filePath);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "ENOENT") {
        throw error;
      }
    }
    await this.removeFromIndex(userId, id);
  }
  async exists(userId, id) {
    const sanitized = sanitizeId2(id);
    const filePath = this.getRoutinePath(userId, sanitized);
    try {
      await fs19.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  async list(userId, options) {
    const index = await this.loadIndex(userId);
    let entries = [...index.routines];
    if (options?.tags && options.tags.length > 0) {
      entries = entries.filter((e) => {
        const entryTags = e.tags ?? [];
        return options.tags.some((t) => entryTags.includes(t));
      });
    }
    if (options?.search) {
      const searchLower = options.search.toLowerCase();
      entries = entries.filter(
        (e) => e.name.toLowerCase().includes(searchLower) || e.description.toLowerCase().includes(searchLower)
      );
    }
    entries.sort(
      (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
    if (options?.offset) {
      entries = entries.slice(options.offset);
    }
    if (options?.limit) {
      entries = entries.slice(0, options.limit);
    }
    const results = [];
    for (const entry of entries) {
      const def = await this.load(userId, entry.id);
      if (def) {
        results.push(def);
      }
    }
    return results;
  }
  getPath(userId) {
    return this.getUserDirectory(userId);
  }
  // ==========================================================================
  // Private Helpers
  // ==========================================================================
  async ensureDirectory(dir) {
    try {
      await fs19.promises.mkdir(dir, { recursive: true });
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code !== "EEXIST") {
        throw error;
      }
    }
  }
  async loadIndex(userId) {
    const indexPath = this.getIndexPath(userId);
    try {
      const data = await fs19.promises.readFile(indexPath, "utf-8");
      return JSON.parse(data);
    } catch (error) {
      if (error instanceof Error && "code" in error && error.code === "ENOENT") {
        return await this.rebuildIndex(userId);
      }
      throw error;
    }
  }
  async saveIndex(userId, index) {
    const directory = this.getUserDirectory(userId);
    const indexPath = this.getIndexPath(userId);
    await this.ensureDirectory(directory);
    index.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    const data = this.prettyPrint ? JSON.stringify(index, null, 2) : JSON.stringify(index);
    await fs19.promises.writeFile(indexPath, data, "utf-8");
  }
  async updateIndex(userId, definition) {
    const index = await this.loadIndex(userId);
    const entry = this.definitionToIndexEntry(definition);
    const existingIdx = index.routines.findIndex((e) => e.id === definition.id);
    if (existingIdx >= 0) {
      index.routines[existingIdx] = entry;
    } else {
      index.routines.push(entry);
    }
    await this.saveIndex(userId, index);
  }
  async removeFromIndex(userId, id) {
    const index = await this.loadIndex(userId);
    index.routines = index.routines.filter((e) => e.id !== id);
    await this.saveIndex(userId, index);
  }
  definitionToIndexEntry(definition) {
    return {
      id: definition.id,
      name: definition.name,
      description: definition.description,
      tags: definition.tags,
      author: definition.author,
      updatedAt: definition.updatedAt
    };
  }
  /**
   * Rebuild index by scanning directory for .json files (excluding _index.json).
   * Returns empty index if directory doesn't exist.
   */
  async rebuildIndex(userId) {
    const directory = this.getUserDirectory(userId);
    const index = {
      version: 1,
      routines: [],
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    };
    let files;
    try {
      files = await fs19.promises.readdir(directory);
    } catch {
      return index;
    }
    for (const file of files) {
      if (!file.endsWith(".json") || file === "_index.json") continue;
      try {
        const data = await fs19.promises.readFile(path2.join(directory, file), "utf-8");
        const stored = JSON.parse(data);
        if (stored.definition) {
          index.routines.push(this.definitionToIndexEntry(stored.definition));
        }
      } catch {
      }
    }
    if (index.routines.length > 0) {
      await this.saveIndex(userId, index);
    }
    return index;
  }
};
function createFileRoutineDefinitionStorage(config) {
  return new FileRoutineDefinitionStorage(config);
}

// src/domain/entities/CustomToolDefinition.ts
var CUSTOM_TOOL_DEFINITION_VERSION = 1;

// src/capabilities/agents/StreamHelpers.ts
var StreamHelpers = class {
  /**
   * Collect complete response from stream
   * Accumulates all events and reconstructs final LLMResponse
   */
  static async collectResponse(stream) {
    let state = null;
    for await (const event of stream) {
      if (!state && event.type === "response.created" /* RESPONSE_CREATED */) {
        state = new StreamState(event.response_id, event.model, event.created_at);
      }
      if (!state) continue;
      this.updateStateFromEvent(state, event);
    }
    if (!state) {
      throw new Error("No stream events received");
    }
    return this.reconstructLLMResponse(state);
  }
  /**
   * Get only text deltas from stream (for simple text streaming)
   * Filters out all other event types
   */
  static async *textOnly(stream) {
    for await (const event of stream) {
      if (isOutputTextDelta(event)) {
        yield event.delta;
      }
    }
  }
  /**
   * Filter stream events by type
   */
  static async *filterByType(stream, eventType) {
    for await (const event of stream) {
      if (event.type === eventType) {
        yield event;
      }
    }
  }
  /**
   * Accumulate text from stream into a single string
   */
  static async accumulateText(stream) {
    const chunks = [];
    for await (const event of stream) {
      if (isOutputTextDelta(event)) {
        chunks.push(event.delta);
      }
    }
    return chunks.join("");
  }
  /**
   * Buffer stream events into batches
   */
  static async *bufferEvents(stream, batchSize) {
    let buffer = [];
    for await (const event of stream) {
      buffer.push(event);
      if (buffer.length >= batchSize) {
        yield buffer;
        buffer = [];
      }
    }
    if (buffer.length > 0) {
      yield buffer;
    }
  }
  /**
   * Tap into stream without consuming it
   * Useful for logging or side effects
   */
  static async *tap(stream, callback) {
    for await (const event of stream) {
      await callback(event);
      yield event;
    }
  }
  /**
   * Take first N events from stream
   */
  static async *take(stream, count) {
    let taken = 0;
    for await (const event of stream) {
      if (taken >= count) break;
      yield event;
      taken++;
    }
  }
  /**
   * Skip first N events from stream
   */
  static async *skip(stream, count) {
    let skipped = 0;
    for await (const event of stream) {
      if (skipped < count) {
        skipped++;
        continue;
      }
      yield event;
    }
  }
  /**
   * Update StreamState from event
   * @private
   */
  static updateStateFromEvent(state, event) {
    switch (event.type) {
      case "response.output_text.delta" /* OUTPUT_TEXT_DELTA */:
        state.accumulateTextDelta(event.item_id, event.delta);
        break;
      case "response.tool_call.start" /* TOOL_CALL_START */:
        state.startToolCall(event.tool_call_id, event.tool_name);
        break;
      case "response.tool_call_arguments.delta" /* TOOL_CALL_ARGUMENTS_DELTA */:
        state.accumulateToolArguments(event.tool_call_id, event.delta);
        break;
      case "response.tool_call_arguments.done" /* TOOL_CALL_ARGUMENTS_DONE */:
        state.completeToolCall(event.tool_call_id);
        break;
      case "response.tool_execution.done" /* TOOL_EXECUTION_DONE */:
        state.setToolResult(event.tool_call_id, event.result);
        break;
      case "response.iteration.complete" /* ITERATION_COMPLETE */:
        state.incrementIteration();
        break;
      case "response.complete" /* RESPONSE_COMPLETE */:
        if (process.env.DEBUG_STREAMING) {
          console.error("[DEBUG] RESPONSE_COMPLETE event:", event.usage);
        }
        state.updateUsage(event.usage);
        state.markComplete(event.status);
        break;
    }
  }
  /**
   * Reconstruct LLMResponse from StreamState
   * @private
   */
  static reconstructLLMResponse(state) {
    const output = [];
    if (state.hasText()) {
      const textContent = state.getAllText();
      if (textContent) {
        output.push({
          type: "message",
          role: "assistant" /* ASSISTANT */,
          content: [
            {
              type: "output_text" /* OUTPUT_TEXT */,
              text: textContent
            }
          ]
        });
      }
    }
    const toolCalls = state.getCompletedToolCalls();
    if (toolCalls.length > 0) {
      const toolUseContent = toolCalls.map((tc) => ({
        type: "tool_use" /* TOOL_USE */,
        id: tc.id,
        name: tc.function.name,
        arguments: tc.function.arguments
      }));
      const firstOutput = output[0];
      if (firstOutput && firstOutput.type === "message") {
        firstOutput.content.push(...toolUseContent);
      } else {
        output.push({
          type: "message",
          role: "assistant" /* ASSISTANT */,
          content: toolUseContent
        });
      }
    }
    const outputText = this.extractOutputText(output);
    return {
      id: state.responseId,
      object: "response",
      created_at: state.createdAt,
      status: state.status,
      model: state.model,
      output,
      output_text: outputText,
      usage: state.usage
    };
  }
  /**
   * Extract text from output items
   * @private
   */
  static extractOutputText(output) {
    const texts = [];
    for (const item of output) {
      if (item.type === "message") {
        for (const content of item.content) {
          if (content.type === "output_text" /* OUTPUT_TEXT */) {
            texts.push(content.text);
          }
        }
      }
    }
    return texts.join(" ").trim();
  }
};

// src/infrastructure/providers/base/ProviderErrorMapper.ts
var ProviderErrorMapper = class {
  /**
   * Map any provider error to our standard error types
   */
  static mapError(error, context) {
    const { providerName, maxContextTokens, model } = context;
    const effectiveMaxTokens = model ? resolveMaxContextTokens(model, maxContextTokens ?? 128e3) : maxContextTokens ?? 128e3;
    if (error instanceof AIError) {
      return error;
    }
    const status = error.status || error.statusCode || error.code;
    const message = error.message || String(error);
    const messageLower = message.toLowerCase();
    if (status === 401 || status === 403 || messageLower.includes("api key") || messageLower.includes("api_key") || messageLower.includes("authentication") || messageLower.includes("unauthorized") || messageLower.includes("invalid key") || messageLower.includes("permission denied")) {
      return new ProviderAuthError(providerName, message);
    }
    if (status === 429 || messageLower.includes("rate limit") || messageLower.includes("rate_limit") || messageLower.includes("too many requests") || messageLower.includes("resource exhausted") || messageLower.includes("quota exceeded")) {
      const retryAfter = this.extractRetryAfter(error);
      return new ProviderRateLimitError(providerName, retryAfter);
    }
    if (status === 413 || error.code === "context_length_exceeded" || messageLower.includes("context length") || messageLower.includes("context_length") || messageLower.includes("token limit") || messageLower.includes("too long") || messageLower.includes("maximum context") || messageLower.includes("max_tokens") || messageLower.includes("prompt is too long")) {
      return new ProviderContextLengthError(providerName, effectiveMaxTokens);
    }
    return new ProviderError(providerName, message, status, error);
  }
  /**
   * Extract retry-after value from error headers or body
   */
  static extractRetryAfter(error) {
    const retryAfterHeader = error.headers?.["retry-after"] || error.headers?.["Retry-After"] || error.headers?.get?.("retry-after");
    if (retryAfterHeader) {
      const seconds = parseInt(retryAfterHeader, 10);
      if (!isNaN(seconds)) {
        return seconds * 1e3;
      }
    }
    if (error.retryAfter) {
      return typeof error.retryAfter === "number" ? error.retryAfter : parseInt(error.retryAfter, 10) * 1e3;
    }
    if (error.errorDetails) {
      for (const detail of error.errorDetails) {
        if (detail.retryDelay) {
          const match = detail.retryDelay.match(/(\d+)s/);
          if (match) {
            return parseInt(match[1], 10) * 1e3;
          }
        }
      }
    }
    return void 0;
  }
};

// src/domain/entities/Services.ts
var SERVICE_DEFINITIONS = [
  // ============ Major Vendors ============
  {
    id: "microsoft",
    name: "Microsoft",
    category: "major-vendors",
    urlPattern: /graph\.microsoft\.com|login\.microsoftonline\.com/i,
    baseURL: "https://graph.microsoft.com/v1.0",
    docsURL: "https://learn.microsoft.com/en-us/graph/",
    commonScopes: ["User.Read", "Files.ReadWrite", "Mail.Read", "Calendars.ReadWrite"]
  },
  {
    id: "google",
    name: "Google",
    category: "major-vendors",
    urlPattern: /googleapis\.com|accounts\.google\.com/i,
    baseURL: "https://www.googleapis.com",
    docsURL: "https://developers.google.com/",
    commonScopes: [
      "https://www.googleapis.com/auth/drive",
      "https://www.googleapis.com/auth/calendar",
      "https://www.googleapis.com/auth/gmail.readonly"
    ]
  },
  // ============ Communication ============
  {
    id: "slack",
    name: "Slack",
    category: "communication",
    urlPattern: /slack\.com/i,
    baseURL: "https://slack.com/api",
    docsURL: "https://api.slack.com/methods",
    commonScopes: ["chat:write", "channels:read", "users:read"]
  },
  {
    id: "discord",
    name: "Discord",
    category: "communication",
    urlPattern: /discord\.com|discordapp\.com/i,
    baseURL: "https://discord.com/api/v10",
    docsURL: "https://discord.com/developers/docs",
    commonScopes: ["bot", "messages.read"]
  },
  {
    id: "telegram",
    name: "Telegram",
    category: "communication",
    urlPattern: /api\.telegram\.org/i,
    baseURL: "https://api.telegram.org",
    docsURL: "https://core.telegram.org/bots/api"
  },
  // ============ Development & Project Management ============
  {
    id: "github",
    name: "GitHub",
    category: "development",
    urlPattern: /api\.github\.com/i,
    baseURL: "https://api.github.com",
    docsURL: "https://docs.github.com/en/rest",
    commonScopes: ["repo", "read:user", "read:org"]
  },
  {
    id: "gitlab",
    name: "GitLab",
    category: "development",
    urlPattern: /gitlab\.com|gitlab\./i,
    baseURL: "https://gitlab.com/api/v4",
    docsURL: "https://docs.gitlab.com/ee/api/",
    commonScopes: ["api", "read_user", "read_repository"]
  },
  {
    id: "bitbucket",
    name: "Bitbucket",
    category: "development",
    urlPattern: /api\.bitbucket\.org|bitbucket\.org/i,
    baseURL: "https://api.bitbucket.org/2.0",
    docsURL: "https://developer.atlassian.com/cloud/bitbucket/rest/",
    commonScopes: ["repository", "pullrequest"]
  },
  {
    id: "jira",
    name: "Jira",
    category: "development",
    urlPattern: /atlassian\.net.*jira|jira\./i,
    baseURL: "https://your-domain.atlassian.net/rest/api/3",
    docsURL: "https://developer.atlassian.com/cloud/jira/platform/rest/v3/",
    commonScopes: ["read:jira-work", "write:jira-work"]
  },
  {
    id: "linear",
    name: "Linear",
    category: "development",
    urlPattern: /api\.linear\.app/i,
    baseURL: "https://api.linear.app/graphql",
    docsURL: "https://developers.linear.app/docs",
    commonScopes: ["read", "write"]
  },
  {
    id: "asana",
    name: "Asana",
    category: "development",
    urlPattern: /api\.asana\.com/i,
    baseURL: "https://app.asana.com/api/1.0",
    docsURL: "https://developers.asana.com/docs"
  },
  {
    id: "trello",
    name: "Trello",
    category: "development",
    urlPattern: /api\.trello\.com/i,
    baseURL: "https://api.trello.com/1",
    docsURL: "https://developer.atlassian.com/cloud/trello/rest/",
    commonScopes: ["read", "write"]
  },
  // ============ Productivity & Collaboration ============
  {
    id: "notion",
    name: "Notion",
    category: "productivity",
    urlPattern: /api\.notion\.com/i,
    baseURL: "https://api.notion.com/v1",
    docsURL: "https://developers.notion.com/reference"
  },
  {
    id: "airtable",
    name: "Airtable",
    category: "productivity",
    urlPattern: /api\.airtable\.com/i,
    baseURL: "https://api.airtable.com/v0",
    docsURL: "https://airtable.com/developers/web/api",
    commonScopes: ["data.records:read", "data.records:write"]
  },
  {
    id: "confluence",
    name: "Confluence",
    category: "productivity",
    urlPattern: /atlassian\.net.*wiki|confluence\./i,
    baseURL: "https://your-domain.atlassian.net/wiki/rest/api",
    docsURL: "https://developer.atlassian.com/cloud/confluence/rest/",
    commonScopes: ["read:confluence-content.all", "write:confluence-content"]
  },
  // ============ CRM & Sales ============
  {
    id: "salesforce",
    name: "Salesforce",
    category: "crm",
    urlPattern: /salesforce\.com|force\.com/i,
    baseURL: "https://your-instance.salesforce.com/services/data/v58.0",
    docsURL: "https://developer.salesforce.com/docs/apis",
    commonScopes: ["api", "refresh_token"]
  },
  {
    id: "hubspot",
    name: "HubSpot",
    category: "crm",
    urlPattern: /api\.hubapi\.com|api\.hubspot\.com/i,
    baseURL: "https://api.hubapi.com",
    docsURL: "https://developers.hubspot.com/docs/api",
    commonScopes: ["crm.objects.contacts.read", "crm.objects.contacts.write"]
  },
  {
    id: "pipedrive",
    name: "Pipedrive",
    category: "crm",
    urlPattern: /api\.pipedrive\.com/i,
    baseURL: "https://api.pipedrive.com/v1",
    docsURL: "https://developers.pipedrive.com/docs/api/v1"
  },
  // ============ Payments & Finance ============
  {
    id: "stripe",
    name: "Stripe",
    category: "payments",
    urlPattern: /api\.stripe\.com/i,
    baseURL: "https://api.stripe.com/v1",
    docsURL: "https://stripe.com/docs/api"
  },
  {
    id: "paypal",
    name: "PayPal",
    category: "payments",
    urlPattern: /api\.paypal\.com|api-m\.paypal\.com/i,
    baseURL: "https://api-m.paypal.com/v2",
    docsURL: "https://developer.paypal.com/docs/api/"
  },
  {
    id: "quickbooks",
    name: "QuickBooks",
    category: "payments",
    urlPattern: /quickbooks\.api\.intuit\.com|intuit\.com.*quickbooks/i,
    baseURL: "https://quickbooks.api.intuit.com/v3",
    docsURL: "https://developer.intuit.com/app/developer/qbo/docs/api/accounting/all-entities/account",
    commonScopes: ["com.intuit.quickbooks.accounting"]
  },
  {
    id: "ramp",
    name: "Ramp",
    category: "payments",
    urlPattern: /api\.ramp\.com/i,
    baseURL: "https://api.ramp.com/developer/v1",
    docsURL: "https://docs.ramp.com/reference"
  },
  // ============ Cloud Providers ============
  {
    id: "aws",
    name: "Amazon Web Services",
    category: "cloud",
    urlPattern: /amazonaws\.com/i,
    baseURL: "https://aws.amazon.com",
    docsURL: "https://docs.aws.amazon.com/"
  },
  // ============ Storage ============
  {
    id: "dropbox",
    name: "Dropbox",
    category: "storage",
    urlPattern: /api\.dropboxapi\.com|dropbox\.com/i,
    baseURL: "https://api.dropboxapi.com/2",
    docsURL: "https://www.dropbox.com/developers/documentation",
    commonScopes: ["files.content.read", "files.content.write"]
  },
  {
    id: "box",
    name: "Box",
    category: "storage",
    urlPattern: /api\.box\.com/i,
    baseURL: "https://api.box.com/2.0",
    docsURL: "https://developer.box.com/reference/"
  },
  // ============ Email ============
  {
    id: "sendgrid",
    name: "SendGrid",
    category: "email",
    urlPattern: /api\.sendgrid\.com/i,
    baseURL: "https://api.sendgrid.com/v3",
    docsURL: "https://docs.sendgrid.com/api-reference"
  },
  {
    id: "mailchimp",
    name: "Mailchimp",
    category: "email",
    urlPattern: /api\.mailchimp\.com|mandrillapp\.com/i,
    baseURL: "https://server.api.mailchimp.com/3.0",
    docsURL: "https://mailchimp.com/developer/marketing/api/"
  },
  {
    id: "postmark",
    name: "Postmark",
    category: "email",
    urlPattern: /api\.postmarkapp\.com/i,
    baseURL: "https://api.postmarkapp.com",
    docsURL: "https://postmarkapp.com/developer"
  },
  // ============ Monitoring & Observability ============
  {
    id: "datadog",
    name: "Datadog",
    category: "monitoring",
    urlPattern: /api\.datadoghq\.com/i,
    baseURL: "https://api.datadoghq.com/api/v2",
    docsURL: "https://docs.datadoghq.com/api/"
  },
  {
    id: "pagerduty",
    name: "PagerDuty",
    category: "monitoring",
    urlPattern: /api\.pagerduty\.com/i,
    baseURL: "https://api.pagerduty.com",
    docsURL: "https://developer.pagerduty.com/api-reference/"
  },
  {
    id: "sentry",
    name: "Sentry",
    category: "monitoring",
    urlPattern: /sentry\.io/i,
    baseURL: "https://sentry.io/api/0",
    docsURL: "https://docs.sentry.io/api/"
  },
  // ============ Search ============
  {
    id: "serper",
    name: "Serper",
    category: "search",
    urlPattern: /serper\.dev/i,
    baseURL: "https://google.serper.dev",
    docsURL: "https://serper.dev/docs"
  },
  {
    id: "brave-search",
    name: "Brave Search",
    category: "search",
    urlPattern: /api\.search\.brave\.com/i,
    baseURL: "https://api.search.brave.com/res/v1",
    docsURL: "https://brave.com/search/api/"
  },
  {
    id: "tavily",
    name: "Tavily",
    category: "search",
    urlPattern: /api\.tavily\.com/i,
    baseURL: "https://api.tavily.com",
    docsURL: "https://tavily.com/docs"
  },
  {
    id: "rapidapi-search",
    name: "RapidAPI Search",
    category: "search",
    urlPattern: /real-time-web-search\.p\.rapidapi\.com/i,
    baseURL: "https://real-time-web-search.p.rapidapi.com",
    docsURL: "https://rapidapi.com/letscrape-6bRBa3QguO5/api/real-time-web-search"
  },
  // ============ Scraping ============
  {
    id: "zenrows",
    name: "ZenRows",
    category: "scrape",
    urlPattern: /api\.zenrows\.com/i,
    baseURL: "https://api.zenrows.com/v1",
    docsURL: "https://docs.zenrows.com/universal-scraper-api/api-reference"
  },
  // ============ Other ============
  {
    id: "twilio",
    name: "Twilio",
    category: "other",
    urlPattern: /api\.twilio\.com/i,
    baseURL: "https://api.twilio.com/2010-04-01",
    docsURL: "https://www.twilio.com/docs/usage/api"
  },
  {
    id: "zendesk",
    name: "Zendesk",
    category: "other",
    urlPattern: /zendesk\.com/i,
    baseURL: "https://your-subdomain.zendesk.com/api/v2",
    docsURL: "https://developer.zendesk.com/api-reference/",
    commonScopes: ["read", "write"]
  },
  {
    id: "intercom",
    name: "Intercom",
    category: "other",
    urlPattern: /api\.intercom\.io/i,
    baseURL: "https://api.intercom.io",
    docsURL: "https://developers.intercom.com/docs/"
  },
  {
    id: "shopify",
    name: "Shopify",
    category: "other",
    urlPattern: /shopify\.com.*admin/i,
    baseURL: "https://your-store.myshopify.com/admin/api/2024-01",
    docsURL: "https://shopify.dev/docs/api",
    commonScopes: ["read_products", "write_products", "read_orders"]
  }
];
var Services = Object.fromEntries(
  SERVICE_DEFINITIONS.map((def) => [
    // Convert kebab-case to PascalCase for object key
    def.id.split("-").map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(""),
    def.id
  ])
);
var SERVICE_URL_PATTERNS = SERVICE_DEFINITIONS.map((def) => ({
  service: def.id,
  pattern: def.urlPattern
}));
var SERVICE_INFO = Object.fromEntries(
  SERVICE_DEFINITIONS.map((def) => [
    def.id,
    {
      id: def.id,
      name: def.name,
      category: def.category,
      baseURL: def.baseURL,
      docsURL: def.docsURL,
      commonScopes: def.commonScopes
    }
  ])
);
var compiledPatterns = null;
function getCompiledPatterns() {
  if (!compiledPatterns) {
    compiledPatterns = SERVICE_DEFINITIONS.map((def) => ({
      service: def.id,
      pattern: def.urlPattern
    }));
  }
  return compiledPatterns;
}
function detectServiceFromURL(url2) {
  const patterns = getCompiledPatterns();
  for (const { service, pattern } of patterns) {
    if (pattern.test(url2)) {
      return service;
    }
  }
  return void 0;
}
function getServiceInfo(serviceType) {
  return SERVICE_INFO[serviceType];
}
function getServiceDefinition(serviceType) {
  return SERVICE_DEFINITIONS.find((def) => def.id === serviceType);
}
function getServicesByCategory(category) {
  return SERVICE_DEFINITIONS.filter((def) => def.category === category);
}
function getAllServiceIds() {
  return SERVICE_DEFINITIONS.map((def) => def.id);
}
function isKnownService(serviceId) {
  return SERVICE_DEFINITIONS.some((def) => def.id === serviceId);
}

// src/index.ts
init_Connector();

// src/tools/connector/ConnectorTools.ts
init_Connector();
init_Logger();
var PROTECTED_HEADERS = ["authorization", "x-api-key", "api-key", "bearer"];
function safeStringify2(obj) {
  const seen = /* @__PURE__ */ new WeakSet();
  return JSON.stringify(obj, (_key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);
    }
    return value;
  });
}
function filterProtectedHeaders(headers) {
  if (!headers) return {};
  const filtered = {};
  for (const [key, value] of Object.entries(headers)) {
    if (!PROTECTED_HEADERS.includes(key.toLowerCase())) {
      filtered[key] = value;
    }
  }
  return filtered;
}
function normalizeBody(body) {
  if (typeof body === "string") {
    try {
      return JSON.parse(body);
    } catch {
      return body;
    }
  }
  return body;
}
function detectAPIError(data) {
  if (!data || typeof data !== "object") return null;
  const obj = data;
  if (obj.ok === false && typeof obj.error === "string") {
    return obj.error;
  }
  if (obj.success === false) {
    if (typeof obj.error === "string") return obj.error;
    if (typeof obj.message === "string") return obj.message;
  }
  if (obj.error && typeof obj.error === "object") {
    const err = obj.error;
    if (typeof err.message === "string") return err.message;
  }
  return null;
}
var ConnectorTools = class {
  /** Registry of service-specific tool factories */
  static factories = /* @__PURE__ */ new Map();
  /** Cache for detected service types (connector name -> service type) */
  static serviceTypeCache = /* @__PURE__ */ new Map();
  /** Cache for generated tools (cacheKey -> tools) */
  static toolCache = /* @__PURE__ */ new Map();
  /** Maximum cache size to prevent memory issues */
  static MAX_CACHE_SIZE = 100;
  /**
   * Clear all caches (useful for testing or when connectors change)
   */
  static clearCache() {
    this.serviceTypeCache.clear();
    this.toolCache.clear();
  }
  /**
   * Invalidate cache for a specific connector
   */
  static invalidateCache(connectorName) {
    this.serviceTypeCache.delete(connectorName);
    for (const key of this.toolCache.keys()) {
      if (key.startsWith(`${connectorName}:`)) {
        this.toolCache.delete(key);
      }
    }
  }
  /**
   * Register a tool factory for a service type
   *
   * @param serviceType - Service identifier (e.g., 'slack', 'github')
   * @param factory - Function that creates tools from a Connector
   *
   * @example
   * ```typescript
   * ConnectorTools.registerService('slack', (connector) => [
   *   createSlackSendMessageTool(connector),
   *   createSlackListChannelsTool(connector),
   * ]);
   * ```
   */
  static registerService(serviceType, factory) {
    this.factories.set(serviceType, factory);
    exports.logger.debug(`[ConnectorTools.registerService] Registered factory for: ${serviceType} (total factories: ${this.factories.size})`);
  }
  /**
   * Unregister a service tool factory
   */
  static unregisterService(serviceType) {
    return this.factories.delete(serviceType);
  }
  /**
   * Get ALL tools for a connector (generic API + service-specific)
   * This is the main entry point
   *
   * @param connectorOrName - Connector instance or name
   * @param userId - Optional user ID for multi-user OAuth
   * @returns Array of tools
   *
   * @example
   * ```typescript
   * const tools = ConnectorTools.for('slack');
   * // Returns: [slack_api, slack_send_message, slack_list_channels, ...]
   * ```
   */
  static for(connectorOrName, userId, options) {
    const connector = this.resolveConnector(connectorOrName, options?.registry);
    const tools = [];
    if (connector.baseURL) {
      tools.push(this.createGenericAPITool(connector, { userId }));
    }
    const serviceType = this.detectService(connector);
    if (serviceType && this.factories.has(serviceType)) {
      const factory = this.factories.get(serviceType);
      const serviceTools = factory(connector, userId);
      for (const tool of serviceTools) {
        tool.definition.function.name = `${sanitizeToolName(connector.name)}_${tool.definition.function.name}`;
      }
      tools.push(...serviceTools);
    }
    return tools;
  }
  /**
   * Get just the generic API tool for a connector
   *
   * @param connectorOrName - Connector instance or name
   * @param options - Optional configuration
   * @returns Generic API tool
   *
   * @example
   * ```typescript
   * const apiTool = ConnectorTools.genericAPI('github');
   * ```
   */
  static genericAPI(connectorOrName, options) {
    const connector = this.resolveConnector(connectorOrName);
    return this.createGenericAPITool(connector, options);
  }
  /**
   * Get only service-specific tools (no generic API tool)
   *
   * @param connectorOrName - Connector instance or name
   * @param userId - Optional user ID for multi-user OAuth
   * @returns Service-specific tools only
   */
  static serviceTools(connectorOrName, userId) {
    const connector = this.resolveConnector(connectorOrName);
    const serviceType = this.detectService(connector);
    if (!serviceType || !this.factories.has(serviceType)) {
      return [];
    }
    return this.factories.get(serviceType)(connector, userId);
  }
  /**
   * Discover tools for ALL registered connectors with external services
   * Skips AI provider connectors (those with vendor but no serviceType)
   *
   * @param userId - Optional user ID for multi-user OAuth
   * @returns Map of connector name to tools
   *
   * @example
   * ```typescript
   * const allTools = ConnectorTools.discoverAll();
   * for (const [name, tools] of allTools) {
   *   agent.tools.registerMany(tools, { namespace: name });
   * }
   * ```
   */
  static discoverAll(userId, options) {
    const result = /* @__PURE__ */ new Map();
    const allConnectors = options?.registry ? options.registry.listAll() : exports.Connector.listAll();
    const factoryKeys = Array.from(this.factories.keys());
    exports.logger.debug(`[ConnectorTools.discoverAll] ${allConnectors.length} connectors in library, ${factoryKeys.length} factories registered: [${factoryKeys.join(", ")}]`);
    for (const connector of allConnectors) {
      const hasServiceType = !!connector.config.serviceType;
      const isExternalAPI = connector.baseURL && !connector.vendor;
      const hasVendorFactory = !!connector.vendor && this.factories.has(connector.vendor);
      exports.logger.debug(`[ConnectorTools.discoverAll] connector=${connector.name}: vendor=${connector.vendor}, serviceType=${connector.config.serviceType}, baseURL=${connector.baseURL ? "yes" : "no"} \u2192 hasServiceType=${hasServiceType}, isExternalAPI=${isExternalAPI}, hasVendorFactory=${hasVendorFactory}`);
      if (hasServiceType || isExternalAPI || hasVendorFactory) {
        try {
          const tools = this.for(connector, userId);
          exports.logger.debug(`[ConnectorTools.discoverAll]   \u2192 ${tools.length} tools: [${tools.map((t) => t.definition.function.name).join(", ")}]`);
          if (tools.length > 0) {
            result.set(connector.name, tools);
          }
        } catch (err) {
          exports.logger.error(`[ConnectorTools.discoverAll]   \u2192 ERROR generating tools for ${connector.name}: ${err instanceof Error ? err.message : String(err)}`);
        }
      }
    }
    exports.logger.debug(`[ConnectorTools.discoverAll] Result: ${result.size} connectors with tools`);
    return result;
  }
  /**
   * Find a connector by service type
   * Returns the first connector matching the service type
   *
   * @param serviceType - Service identifier
   * @returns Connector or undefined
   */
  static findConnector(serviceType, options) {
    const connectors = options?.registry ? options.registry.listAll() : exports.Connector.listAll();
    return connectors.find((c) => this.detectService(c) === serviceType);
  }
  /**
   * Find all connectors for a service type
   * Useful when you have multiple connectors for the same service
   *
   * @param serviceType - Service identifier
   * @returns Array of matching connectors
   */
  static findConnectors(serviceType, options) {
    const connectors = options?.registry ? options.registry.listAll() : exports.Connector.listAll();
    return connectors.filter((c) => this.detectService(c) === serviceType);
  }
  /**
   * List services that have registered tool factories
   */
  static listSupportedServices() {
    return Array.from(this.factories.keys());
  }
  /**
   * Check if a service has dedicated tool factory
   */
  static hasServiceTools(serviceType) {
    return this.factories.has(serviceType);
  }
  /**
   * Detect the service type for a connector
   * Uses explicit serviceType if set, otherwise infers from baseURL
   * Results are cached for performance
   */
  static detectService(connector) {
    const cacheKey = connector.name;
    if (this.serviceTypeCache.has(cacheKey)) {
      return this.serviceTypeCache.get(cacheKey);
    }
    let result;
    if (connector.config.serviceType) {
      result = connector.config.serviceType;
    } else if (connector.baseURL) {
      result = detectServiceFromURL(connector.baseURL);
    }
    if (!result && connector.vendor) {
      result = connector.vendor;
    }
    this.maintainCacheSize(this.serviceTypeCache);
    this.serviceTypeCache.set(cacheKey, result);
    return result;
  }
  /**
   * Maintain cache size to prevent memory leaks
   */
  static maintainCacheSize(cache) {
    if (cache.size >= this.MAX_CACHE_SIZE) {
      const toRemove = Math.ceil(this.MAX_CACHE_SIZE * 0.1);
      const keys = Array.from(cache.keys()).slice(0, toRemove);
      for (const key of keys) {
        cache.delete(key);
      }
    }
  }
  // ============ Private Methods ============
  static resolveConnector(connectorOrName, registry) {
    if (typeof connectorOrName === "string") {
      return registry ? registry.get(connectorOrName) : exports.Connector.get(connectorOrName);
    }
    return connectorOrName;
  }
  static createGenericAPITool(connector, options) {
    const toolName = options?.toolName ?? `${sanitizeToolName(connector.name)}_api`;
    const userId = options?.userId;
    const description = options?.description ?? `Make an authenticated API call to ${connector.displayName}.` + (connector.baseURL ? ` Base URL: ${connector.baseURL}.` : " Provide full URL in endpoint.") + ' IMPORTANT: For POST/PUT/PATCH requests, pass data in the "body" parameter as a JSON object, NOT as query string parameters in the endpoint URL. The body is sent as application/json.';
    return {
      definition: {
        type: "function",
        function: {
          name: toolName,
          description,
          parameters: {
            type: "object",
            properties: {
              method: {
                type: "string",
                enum: ["GET", "POST", "PUT", "DELETE", "PATCH"],
                description: "HTTP method"
              },
              endpoint: {
                type: "string",
                description: 'API endpoint path (relative to base URL) or full URL. Do NOT put request data as query parameters here for POST/PUT/PATCH \u2014 use the "body" parameter instead.'
              },
              body: {
                type: "object",
                description: 'JSON request body for POST/PUT/PATCH requests. MUST be a JSON object (NOT a string). Example: {"channel": "C123", "text": "hello"}. Do NOT stringify this \u2014 pass it as a raw JSON object. Do NOT use query string parameters for POST data.'
              },
              queryParams: {
                type: "object",
                description: 'URL query parameters (for filtering/pagination on GET requests). Do NOT use for POST/PUT/PATCH data \u2014 use "body" instead.'
              },
              headers: {
                type: "object",
                description: "Additional request headers"
              }
            },
            required: ["method", "endpoint"]
          }
        }
      },
      execute: async (args, context) => {
        const effectiveUserId = context?.userId ?? userId;
        let url2 = args.endpoint;
        if (args.queryParams && Object.keys(args.queryParams).length > 0) {
          const params = new URLSearchParams();
          for (const [key, value] of Object.entries(args.queryParams)) {
            params.append(key, String(value));
          }
          url2 += (url2.includes("?") ? "&" : "?") + params.toString();
        }
        const safeHeaders = filterProtectedHeaders(args.headers);
        let bodyStr;
        if (args.body) {
          try {
            const normalized = normalizeBody(args.body);
            bodyStr = safeStringify2(normalized);
          } catch (e) {
            return {
              success: false,
              error: `Failed to serialize request body: ${e instanceof Error ? e.message : String(e)}`
            };
          }
        }
        try {
          const response = await connector.fetch(
            url2,
            {
              method: args.method,
              headers: {
                "Content-Type": "application/json",
                ...safeHeaders
              },
              body: bodyStr
            },
            effectiveUserId
          );
          const text = await response.text();
          let data;
          try {
            data = JSON.parse(text);
          } catch {
            data = text;
          }
          const apiError = detectAPIError(data);
          return {
            success: response.ok && !apiError,
            status: response.status,
            data: response.ok && !apiError ? data : void 0,
            error: apiError ? apiError : response.ok ? void 0 : typeof data === "string" ? data : safeStringify2(data)
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
          };
        }
      },
      describeCall: (args) => {
        const bodyInfo = args.body ? ` body=${JSON.stringify(args.body).slice(0, 100)}` : "";
        return `${args.method} ${args.endpoint}${bodyInfo}`;
      },
      permission: options?.permission ?? {
        scope: "session",
        riskLevel: "medium",
        approvalMessage: `This will make an API call to ${connector.displayName}`
      }
    };
  }
};

// src/connectors/oauth/index.ts
init_OAuthManager();

// src/connectors/index.ts
init_MemoryStorage();

// src/connectors/oauth/infrastructure/storage/FileStorage.ts
init_encryption();
var FileStorage = class {
  directory;
  encryptionKey;
  constructor(config) {
    if (!config.encryptionKey) {
      throw new Error(
        "FileStorage requires an encryption key. Set OAUTH_ENCRYPTION_KEY in environment or provide config.encryptionKey"
      );
    }
    this.directory = config.directory;
    this.encryptionKey = config.encryptionKey;
    this.ensureDirectory().catch((error) => {
      console.error("Failed to create token directory:", error);
    });
  }
  async ensureDirectory() {
    try {
      await fs18__namespace.mkdir(this.directory, { recursive: true });
      await fs18__namespace.chmod(this.directory, 448);
    } catch (error) {
    }
  }
  /**
   * Get file path for a token key (hashed for security)
   */
  getFilePath(key) {
    const hash = crypto2__namespace.createHash("sha256").update(key).digest("hex");
    return path2__namespace.join(this.directory, `${hash}.token`);
  }
  async storeToken(key, token) {
    await this.ensureDirectory();
    const filePath = this.getFilePath(key);
    const plaintext = JSON.stringify(token);
    const encrypted = encrypt(plaintext, this.encryptionKey);
    await fs18__namespace.writeFile(filePath, encrypted, "utf8");
    await fs18__namespace.chmod(filePath, 384);
  }
  async getToken(key) {
    const filePath = this.getFilePath(key);
    try {
      const encrypted = await fs18__namespace.readFile(filePath, "utf8");
      const decrypted = decrypt(encrypted, this.encryptionKey);
      return JSON.parse(decrypted);
    } catch (error) {
      if (error.code === "ENOENT") {
        return null;
      }
      console.error("Failed to read/decrypt token file:", error);
      try {
        await fs18__namespace.unlink(filePath);
      } catch {
      }
      return null;
    }
  }
  async deleteToken(key) {
    const filePath = this.getFilePath(key);
    try {
      await fs18__namespace.unlink(filePath);
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
  }
  async hasToken(key) {
    const filePath = this.getFilePath(key);
    try {
      await fs18__namespace.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * List all token keys (for debugging)
   */
  async listTokens() {
    try {
      const files = await fs18__namespace.readdir(this.directory);
      return files.filter((f) => f.endsWith(".token")).map((f) => f.replace(".token", ""));
    } catch {
      return [];
    }
  }
  /**
   * Clear all tokens
   */
  async clearAll() {
    try {
      const files = await fs18__namespace.readdir(this.directory);
      const tokenFiles = files.filter((f) => f.endsWith(".token"));
      await Promise.all(
        tokenFiles.map((f) => fs18__namespace.unlink(path2__namespace.join(this.directory, f)).catch(() => {
        }))
      );
    } catch {
    }
  }
};

// src/connectors/authenticatedFetch.ts
init_Connector();
async function authenticatedFetch(url2, options, authProvider, userId) {
  const connector = exports.Connector.get(authProvider);
  return connector.fetch(url2.toString(), options, userId);
}
function createAuthenticatedFetch(authProvider, userId) {
  const connector = exports.Connector.get(authProvider);
  return async (url2, options) => {
    return connector.fetch(url2.toString(), options, userId);
  };
}

// src/connectors/toolGenerator.ts
init_Connector();
function generateWebAPITool() {
  return {
    definition: {
      type: "function",
      function: {
        name: "api_request",
        description: `Make authenticated HTTP request to any registered OAuth API.

This tool automatically handles OAuth authentication for registered providers.

REGISTERED PROVIDERS:
${exports.Connector.getDescriptionsForTools()}

HOW TO USE:
1. Choose the appropriate authProvider based on which API you need to access
2. Provide the URL (full URL or path relative to provider's baseURL)
3. Specify the HTTP method (GET, POST, etc.)
4. For POST/PUT/PATCH, include the request body

EXAMPLES:
Read Microsoft emails:
{
  authProvider: "microsoft",
  url: "/v1.0/me/messages",
  method: "GET"
}

List GitHub repositories:
{
  authProvider: "github",
  url: "/user/repos",
  method: "GET"
}

Create Salesforce account:
{
  authProvider: "salesforce",
  url: "/services/data/v57.0/sobjects/Account",
  method: "POST",
  body: { Name: "Acme Corp", Industry: "Technology" }
}`,
        parameters: {
          type: "object",
          properties: {
            authProvider: {
              type: "string",
              enum: exports.Connector.list(),
              description: "Which connector to use for authentication. Choose based on the API you need to access."
            },
            url: {
              type: "string",
              description: 'URL to request. Can be full URL (https://...) or path relative to provider baseURL (e.g., "/v1.0/me")'
            },
            method: {
              type: "string",
              enum: ["GET", "POST", "PUT", "DELETE", "PATCH"],
              description: "HTTP method (default: GET)"
            },
            body: {
              description: "Request body for POST/PUT/PATCH requests. Will be JSON-stringified automatically."
            },
            headers: {
              type: "object",
              description: "Additional headers to include. Authorization header is added automatically."
            }
          },
          required: ["authProvider", "url"]
        }
      },
      blocking: true,
      timeout: 3e4
    },
    execute: async (args) => {
      try {
        const connector = exports.Connector.get(args.authProvider);
        const fullUrl = args.url.startsWith("http") ? args.url : `${connector.baseURL}${args.url}`;
        const requestOptions = {
          method: args.method || "GET",
          headers: {
            "Content-Type": "application/json",
            ...args.headers
          }
        };
        if (args.body && (args.method === "POST" || args.method === "PUT" || args.method === "PATCH")) {
          requestOptions.body = JSON.stringify(args.body);
        }
        const response = await authenticatedFetch(fullUrl, requestOptions, args.authProvider);
        const contentType = response.headers.get("content-type") || "";
        let data;
        if (contentType.includes("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        return {
          success: response.ok,
          status: response.status,
          statusText: response.statusText,
          data
        };
      } catch (error) {
        return {
          success: false,
          status: 0,
          statusText: "Error",
          data: null,
          error: error.message
        };
      }
    }
  };
}

// src/connectors/index.ts
init_pkce();
init_encryption();

// src/domain/interfaces/IConnectorConfigStorage.ts
var CONNECTOR_CONFIG_VERSION = 1;

// src/connectors/storage/ConnectorConfigStore.ts
init_encryption();
init_StorageRegistry();
var ENCRYPTED_PREFIX = "$ENC$:";
var ConnectorConfigStore = class _ConnectorConfigStore {
  constructor(storage, encryptionKey) {
    this.storage = storage;
    this.encryptionKey = encryptionKey;
    if (!encryptionKey || encryptionKey.length < 16) {
      throw new Error(
        "ConnectorConfigStore requires an encryption key of at least 16 characters"
      );
    }
  }
  /**
   * Factory that resolves storage from StorageRegistry when no explicit storage is provided.
   *
   * @param encryptionKey - Encryption key for secrets (required, min 16 chars)
   * @param storage - Optional explicit storage backend (overrides registry)
   * @returns ConnectorConfigStore instance
   * @throws Error if no storage available (neither explicit nor in registry)
   */
  static create(encryptionKey, storage) {
    if (storage) {
      return new _ConnectorConfigStore(storage, encryptionKey);
    }
    const registryStorage = exports.StorageRegistry.get("connectorConfig");
    if (!registryStorage) {
      throw new Error(
        "No storage provided and no connectorConfig configured in StorageRegistry. Pass storage explicitly or call StorageRegistry.set('connectorConfig', storage) first."
      );
    }
    return new _ConnectorConfigStore(registryStorage, encryptionKey);
  }
  /**
   * Save a connector configuration (secrets are encrypted automatically)
   *
   * @param name - Unique identifier for this connector
   * @param config - The connector configuration
   */
  async save(name, config) {
    if (!name || name.trim().length === 0) {
      throw new Error("Connector name is required");
    }
    const existing = await this.storage.get(name);
    const now = Date.now();
    const encryptedConfig = this.encryptSecrets(config);
    const stored = {
      config: { ...encryptedConfig, name },
      createdAt: existing?.createdAt ?? now,
      updatedAt: now,
      version: CONNECTOR_CONFIG_VERSION
    };
    await this.storage.save(name, stored);
  }
  /**
   * Retrieve a connector configuration (secrets are decrypted automatically)
   *
   * @param name - Unique identifier for the connector
   * @returns The decrypted config or null if not found
   */
  async get(name) {
    const stored = await this.storage.get(name);
    if (!stored) {
      return null;
    }
    return this.decryptSecrets(stored.config);
  }
  /**
   * Delete a connector configuration
   *
   * @param name - Unique identifier for the connector
   * @returns True if deleted, false if not found
   */
  async delete(name) {
    return this.storage.delete(name);
  }
  /**
   * Check if a connector configuration exists
   *
   * @param name - Unique identifier for the connector
   * @returns True if exists
   */
  async has(name) {
    return this.storage.has(name);
  }
  /**
   * List all connector names
   *
   * @returns Array of connector names
   */
  async list() {
    return this.storage.list();
  }
  /**
   * Get all connector configurations (secrets are decrypted automatically)
   *
   * @returns Array of decrypted configs
   */
  async listAll() {
    const stored = await this.storage.listAll();
    return stored.map((s) => this.decryptSecrets(s.config));
  }
  /**
   * Get stored metadata for a connector
   *
   * @param name - Unique identifier for the connector
   * @returns Metadata (createdAt, updatedAt, version) or null
   */
  async getMetadata(name) {
    const stored = await this.storage.get(name);
    if (!stored) {
      return null;
    }
    return {
      createdAt: stored.createdAt,
      updatedAt: stored.updatedAt,
      version: stored.version
    };
  }
  // ============ Encryption Helpers ============
  /**
   * Encrypt sensitive fields in a ConnectorConfig
   * Fields encrypted: apiKey, clientSecret, privateKey
   */
  encryptSecrets(config) {
    const result = { ...config };
    if (result.auth) {
      result.auth = this.encryptAuthSecrets(result.auth);
    }
    return result;
  }
  /**
   * Decrypt sensitive fields in a ConnectorConfig
   */
  decryptSecrets(config) {
    const result = { ...config };
    if (result.auth) {
      result.auth = this.decryptAuthSecrets(result.auth);
    }
    return result;
  }
  /**
   * Encrypt secrets in ConnectorAuth based on auth type
   */
  encryptAuthSecrets(auth2) {
    const encryptedExtra = this.encryptExtra(auth2.extra);
    switch (auth2.type) {
      case "api_key":
        return {
          ...auth2,
          apiKey: this.encryptValue(auth2.apiKey),
          ...encryptedExtra ? { extra: encryptedExtra } : {}
        };
      case "oauth":
        return {
          ...auth2,
          clientSecret: auth2.clientSecret ? this.encryptValue(auth2.clientSecret) : void 0,
          privateKey: auth2.privateKey ? this.encryptValue(auth2.privateKey) : void 0,
          ...encryptedExtra ? { extra: encryptedExtra } : {}
        };
      case "jwt":
        return {
          ...auth2,
          privateKey: this.encryptValue(auth2.privateKey),
          ...encryptedExtra ? { extra: encryptedExtra } : {}
        };
      default:
        return auth2;
    }
  }
  /**
   * Decrypt secrets in ConnectorAuth based on auth type
   */
  decryptAuthSecrets(auth2) {
    const decryptedExtra = this.decryptExtra(auth2.extra);
    switch (auth2.type) {
      case "api_key":
        return {
          ...auth2,
          apiKey: this.decryptValue(auth2.apiKey),
          ...decryptedExtra ? { extra: decryptedExtra } : {}
        };
      case "oauth":
        return {
          ...auth2,
          clientSecret: auth2.clientSecret ? this.decryptValue(auth2.clientSecret) : void 0,
          privateKey: auth2.privateKey ? this.decryptValue(auth2.privateKey) : void 0,
          ...decryptedExtra ? { extra: decryptedExtra } : {}
        };
      case "jwt":
        return {
          ...auth2,
          privateKey: this.decryptValue(auth2.privateKey),
          ...decryptedExtra ? { extra: decryptedExtra } : {}
        };
      default:
        return auth2;
    }
  }
  /**
   * Encrypt all values in an extra Record (vendor-specific credentials)
   */
  encryptExtra(extra) {
    if (!extra || Object.keys(extra).length === 0) return void 0;
    const result = {};
    for (const [key, value] of Object.entries(extra)) {
      result[key] = this.encryptValue(value);
    }
    return result;
  }
  /**
   * Decrypt all values in an extra Record (vendor-specific credentials)
   */
  decryptExtra(extra) {
    if (!extra || Object.keys(extra).length === 0) return void 0;
    const result = {};
    for (const [key, value] of Object.entries(extra)) {
      result[key] = this.decryptValue(value);
    }
    return result;
  }
  /**
   * Encrypt a single value if not already encrypted
   */
  encryptValue(value) {
    if (this.isEncrypted(value)) {
      return value;
    }
    const encrypted = encrypt(value, this.encryptionKey);
    return `${ENCRYPTED_PREFIX}${encrypted}`;
  }
  /**
   * Decrypt a single value if encrypted
   */
  decryptValue(value) {
    if (!this.isEncrypted(value)) {
      return value;
    }
    const encryptedData = value.slice(ENCRYPTED_PREFIX.length);
    return decrypt(encryptedData, this.encryptionKey);
  }
  /**
   * Check if a value is encrypted (has the $ENC$: prefix)
   */
  isEncrypted(value) {
    return value.startsWith(ENCRYPTED_PREFIX);
  }
};

// src/connectors/storage/MemoryConnectorStorage.ts
var MemoryConnectorStorage = class {
  configs = /* @__PURE__ */ new Map();
  async save(name, stored) {
    this.configs.set(name, JSON.parse(JSON.stringify(stored)));
  }
  async get(name) {
    const stored = this.configs.get(name);
    if (!stored) {
      return null;
    }
    return JSON.parse(JSON.stringify(stored));
  }
  async delete(name) {
    return this.configs.delete(name);
  }
  async has(name) {
    return this.configs.has(name);
  }
  async list() {
    return Array.from(this.configs.keys());
  }
  async listAll() {
    return Array.from(this.configs.values()).map(
      (stored) => JSON.parse(JSON.stringify(stored))
    );
  }
  /**
   * Clear all stored configs (useful for testing)
   */
  clear() {
    this.configs.clear();
  }
  /**
   * Get the number of stored configs
   */
  size() {
    return this.configs.size;
  }
};
var FileConnectorStorage = class {
  directory;
  indexPath;
  initialized = false;
  constructor(config) {
    if (!config.directory) {
      throw new Error("FileConnectorStorage requires a directory path");
    }
    this.directory = config.directory;
    this.indexPath = path2__namespace.join(this.directory, "_index.json");
  }
  async save(name, stored) {
    await this.ensureDirectory();
    const filePath = this.getFilePath(name);
    const json = JSON.stringify(stored, null, 2);
    await fs18__namespace.writeFile(filePath, json, "utf8");
    await fs18__namespace.chmod(filePath, 384);
    await this.updateIndex(name, "add");
  }
  async get(name) {
    const filePath = this.getFilePath(name);
    try {
      const json = await fs18__namespace.readFile(filePath, "utf8");
      return JSON.parse(json);
    } catch (error) {
      const err = error;
      if (err.code === "ENOENT") {
        return null;
      }
      throw error;
    }
  }
  async delete(name) {
    const filePath = this.getFilePath(name);
    try {
      await fs18__namespace.unlink(filePath);
      await this.updateIndex(name, "remove");
      return true;
    } catch (error) {
      const err = error;
      if (err.code === "ENOENT") {
        return false;
      }
      throw error;
    }
  }
  async has(name) {
    const filePath = this.getFilePath(name);
    try {
      await fs18__namespace.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  async list() {
    const index = await this.loadIndex();
    return Object.values(index.connectors);
  }
  async listAll() {
    const names = await this.list();
    const results = [];
    for (const name of names) {
      const stored = await this.get(name);
      if (stored) {
        results.push(stored);
      }
    }
    return results;
  }
  /**
   * Clear all stored configs (useful for testing)
   */
  async clear() {
    try {
      const files = await fs18__namespace.readdir(this.directory);
      const connectorFiles = files.filter(
        (f) => f.endsWith(".connector.json") || f === "_index.json"
      );
      await Promise.all(
        connectorFiles.map(
          (f) => fs18__namespace.unlink(path2__namespace.join(this.directory, f)).catch(() => {
          })
        )
      );
    } catch {
    }
  }
  // ============ Private Helpers ============
  /**
   * Get file path for a connector (hashed for security)
   */
  getFilePath(name) {
    const hash = this.hashName(name);
    return path2__namespace.join(this.directory, `${hash}.connector.json`);
  }
  /**
   * Hash connector name to prevent enumeration
   */
  hashName(name) {
    return crypto2__namespace.createHash("sha256").update(name).digest("hex").slice(0, 16);
  }
  /**
   * Ensure storage directory exists with proper permissions
   */
  async ensureDirectory() {
    if (this.initialized) return;
    try {
      await fs18__namespace.mkdir(this.directory, { recursive: true });
      await fs18__namespace.chmod(this.directory, 448);
      this.initialized = true;
    } catch {
      this.initialized = true;
    }
  }
  /**
   * Load the index file
   */
  async loadIndex() {
    try {
      const json = await fs18__namespace.readFile(this.indexPath, "utf8");
      return JSON.parse(json);
    } catch {
      return { connectors: {} };
    }
  }
  /**
   * Update the index file
   */
  async updateIndex(name, action) {
    const index = await this.loadIndex();
    const hash = this.hashName(name);
    if (action === "add") {
      index.connectors[hash] = name;
    } else {
      delete index.connectors[hash];
    }
    const json = JSON.stringify(index, null, 2);
    await fs18__namespace.writeFile(this.indexPath, json, "utf8");
    await fs18__namespace.chmod(this.indexPath, 384);
  }
};

// src/connectors/vendors/helpers.ts
init_Connector();
var vendorRegistry = null;
function initVendorRegistry(templates) {
  vendorRegistry = new Map(templates.map((t) => [t.id, t]));
}
function getVendorTemplate(vendorId) {
  if (!vendorRegistry) {
    throw new Error(
      "Vendor registry not initialized. Make sure to import from @everworker/oneringai which auto-registers templates."
    );
  }
  return vendorRegistry.get(vendorId);
}
function getAllVendorTemplates() {
  if (!vendorRegistry) {
    throw new Error(
      "Vendor registry not initialized. Make sure to import from @everworker/oneringai which auto-registers templates."
    );
  }
  return Array.from(vendorRegistry.values());
}
function getVendorAuthTemplate(vendorId, authId) {
  const template = getVendorTemplate(vendorId);
  if (!template) return void 0;
  return template.authTemplates.find((a) => a.id === authId);
}
function listVendorIds() {
  if (!vendorRegistry) {
    throw new Error(
      "Vendor registry not initialized. Make sure to import from @everworker/oneringai which auto-registers templates."
    );
  }
  return Array.from(vendorRegistry.keys());
}
function buildAuthConfig(authTemplate, credentials) {
  const defaults = authTemplate.defaults;
  if (authTemplate.type === "api_key") {
    if (!credentials.apiKey) {
      throw new Error("API key is required for api_key auth");
    }
    const standardApiKeyFields = /* @__PURE__ */ new Set(["apiKey", "headerName", "headerPrefix"]);
    const extra = {};
    for (const field of authTemplate.optionalFields ?? []) {
      if (!standardApiKeyFields.has(field) && credentials[field]) {
        extra[field] = credentials[field];
      }
    }
    return {
      type: "api_key",
      apiKey: credentials.apiKey,
      headerName: defaults.headerName ?? "Authorization",
      headerPrefix: defaults.headerPrefix ?? "Bearer",
      ...Object.keys(extra).length > 0 ? { extra } : {}
    };
  }
  if (!authTemplate.flow) {
    throw new Error(`OAuth flow not specified in auth template: ${authTemplate.id}`);
  }
  const oauthDefaults = defaults;
  const oauthConfig = {
    type: "oauth",
    flow: authTemplate.flow,
    clientId: credentials.clientId ?? "",
    clientSecret: credentials.clientSecret,
    tokenUrl: oauthDefaults.tokenUrl ?? "",
    authorizationUrl: oauthDefaults.authorizationUrl,
    redirectUri: credentials.redirectUri,
    scope: credentials.scope ?? authTemplate.scopes?.join(" "),
    usePKCE: oauthDefaults.usePKCE,
    privateKey: credentials.privateKey,
    privateKeyPath: credentials.privateKeyPath,
    audience: credentials.audience ?? oauthDefaults.audience,
    subject: credentials.subject ?? oauthDefaults.subject
  };
  if (oauthConfig.tokenUrl && credentials.tenantId) {
    oauthConfig.tokenUrl = oauthConfig.tokenUrl.replace("{tenantId}", credentials.tenantId);
  }
  if (oauthConfig.authorizationUrl && credentials.tenantId) {
    oauthConfig.authorizationUrl = oauthConfig.authorizationUrl.replace(
      "{tenantId}",
      credentials.tenantId
    );
  }
  if (oauthConfig.tokenUrl && credentials.installationId) {
    oauthConfig.tokenUrl = oauthConfig.tokenUrl.replace(
      "{installationId}",
      credentials.installationId
    );
  }
  const configAsUnknown = oauthConfig;
  Object.keys(configAsUnknown).forEach((key) => {
    if (configAsUnknown[key] === void 0) {
      delete configAsUnknown[key];
    }
  });
  return oauthConfig;
}
function validateCredentials(authTemplate, credentials) {
  const missing = [];
  for (const field of authTemplate.requiredFields) {
    if (!credentials[field]) {
      missing.push(field);
    }
  }
  if (missing.length > 0) {
    throw new Error(
      `Missing required credentials for ${authTemplate.name}: ${missing.join(", ")}`
    );
  }
}
function createConnectorFromTemplate(name, vendorId, authTemplateId, credentials, options) {
  const template = getVendorTemplate(vendorId);
  if (!template) {
    const available = listVendorIds().slice(0, 10).join(", ");
    throw new Error(
      `Unknown vendor: ${vendorId}. Available vendors include: ${available}...`
    );
  }
  const authTemplate = template.authTemplates.find((a) => a.id === authTemplateId);
  if (!authTemplate) {
    const available = template.authTemplates.map((a) => a.id).join(", ");
    throw new Error(
      `Unknown auth method '${authTemplateId}' for vendor '${vendorId}'. Available: ${available}`
    );
  }
  validateCredentials(authTemplate, credentials);
  const auth2 = buildAuthConfig(authTemplate, credentials);
  const config = {
    name,
    serviceType: template.serviceType,
    baseURL: options?.baseURL ?? template.baseURL,
    auth: auth2,
    displayName: options?.displayName ?? `${template.name} (${authTemplate.name})`,
    description: options?.description ?? `${template.name} API connector using ${authTemplate.name}`,
    documentation: template.docsURL
  };
  if (options?.timeout !== void 0) {
    config.timeout = options.timeout;
  }
  if (options?.logging) {
    config.logging = { enabled: true };
  }
  return exports.Connector.create(config);
}
function getConnectorTools(connectorName) {
  return ConnectorTools.for(connectorName);
}
function getVendorInfo(vendorId) {
  const template = getVendorTemplate(vendorId);
  if (!template) return void 0;
  return {
    id: template.id,
    name: template.name,
    category: template.category,
    docsURL: template.docsURL,
    credentialsSetupURL: template.credentialsSetupURL,
    authMethods: template.authTemplates.map((a) => ({
      id: a.id,
      name: a.name,
      type: a.type,
      description: a.description,
      requiredFields: a.requiredFields,
      scopes: a.scopes,
      scopeDescriptions: a.scopeDescriptions
    }))
  };
}
function listVendors() {
  return getAllVendorTemplates().map((t) => ({
    id: t.id,
    name: t.name,
    category: t.category,
    docsURL: t.docsURL,
    credentialsSetupURL: t.credentialsSetupURL,
    authMethods: t.authTemplates.map((a) => ({
      id: a.id,
      name: a.name,
      type: a.type,
      description: a.description,
      requiredFields: a.requiredFields,
      scopes: a.scopes,
      scopeDescriptions: a.scopeDescriptions
    }))
  }));
}
function listVendorsByCategory(category) {
  return listVendors().filter((v) => v.category === category);
}
function listVendorsByAuthType(authType) {
  return listVendors().filter(
    (v) => v.authMethods.some((a) => a.type === authType)
  );
}
function getCredentialsSetupURL(vendorId) {
  const template = getVendorTemplate(vendorId);
  return template?.credentialsSetupURL;
}
function getDocsURL(vendorId) {
  const template = getVendorTemplate(vendorId);
  return template?.docsURL;
}

// src/connectors/vendors/templates/microsoft.ts
var microsoftTemplate = {
  id: "microsoft",
  name: "Microsoft",
  serviceType: "microsoft",
  baseURL: "https://graph.microsoft.com/v1.0",
  docsURL: "https://learn.microsoft.com/en-us/graph/",
  credentialsSetupURL: "https://portal.azure.com/#view/Microsoft_AAD_RegisteredApps/ApplicationsListBlade",
  category: "major-vendors",
  notes: "Unified access to Microsoft 365, Teams, OneDrive, Outlook, Calendar via Microsoft Graph API",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (Delegated Permissions)",
      type: "oauth",
      flow: "authorization_code",
      description: "User signs in with Microsoft account. Best for accessing user data (mail, calendar, files)",
      requiredFields: ["clientId", "clientSecret", "redirectUri", "tenantId"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/authorize",
        tokenUrl: "https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token"
      },
      scopes: [
        "User.Read",
        "Mail.Read",
        "Mail.ReadWrite",
        "Mail.Send",
        "Calendars.ReadWrite",
        "Contacts.Read",
        "Contacts.ReadWrite",
        "Files.ReadWrite",
        "Sites.Read.All",
        "Sites.ReadWrite.All",
        "Notes.Read",
        "Notes.ReadWrite",
        "Tasks.ReadWrite",
        "ChannelMessage.Send",
        "Team.ReadBasic.All",
        "Chat.ReadWrite",
        "People.Read",
        "Presence.Read",
        "Directory.Read.All",
        "BookingsAppointment.ReadWrite.All",
        "offline_access"
      ],
      scopeDescriptions: {
        "User.Read": "Read your profile",
        "Mail.Read": "Read your email",
        "Mail.ReadWrite": "Read and write your email",
        "Mail.Send": "Send email on your behalf",
        "Calendars.ReadWrite": "Read and write your calendar",
        "Contacts.Read": "Read your contacts",
        "Contacts.ReadWrite": "Read and write your contacts",
        "Files.ReadWrite": "Read and write your files (OneDrive)",
        "Sites.Read.All": "Read SharePoint sites",
        "Sites.ReadWrite.All": "Read and write SharePoint sites",
        "Notes.Read": "Read your OneNote notebooks",
        "Notes.ReadWrite": "Read and write your OneNote notebooks",
        "Tasks.ReadWrite": "Read and write your tasks (To Do / Planner)",
        "ChannelMessage.Send": "Send messages in Teams channels",
        "Team.ReadBasic.All": "Read Teams basic info",
        "Chat.ReadWrite": "Read and write Teams chats",
        "People.Read": "Read your relevant people list",
        "Presence.Read": "Read user presence information",
        "Directory.Read.All": "Read directory data (Azure AD)",
        "BookingsAppointment.ReadWrite.All": "Manage Bookings appointments",
        "offline_access": "Maintain access (refresh token)"
      }
    },
    {
      id: "client-credentials",
      name: "App-Only (Client Credentials)",
      type: "oauth",
      flow: "client_credentials",
      description: "App authenticates as itself - requires admin consent. Best for automation and background tasks",
      requiredFields: ["clientId", "clientSecret", "tenantId"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "client_credentials",
        tokenUrl: "https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token"
      },
      scopes: ["https://graph.microsoft.com/.default"],
      scopeDescriptions: {
        "https://graph.microsoft.com/.default": "All permissions granted to the app registration"
      }
    }
  ]
};

// src/connectors/vendors/templates/google.ts
var googleTemplate = {
  id: "google",
  name: "Google",
  serviceType: "google",
  baseURL: "https://www.googleapis.com",
  docsURL: "https://developers.google.com/",
  credentialsSetupURL: "https://console.cloud.google.com/apis/credentials",
  category: "major-vendors",
  notes: "Unified access to Google Workspace (Drive, Docs, Sheets, Calendar), Gmail, and Cloud APIs",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (User Consent)",
      type: "oauth",
      flow: "authorization_code",
      description: "User logs in with Google account. Best for accessing user data (Drive, Gmail, Calendar)",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://accounts.google.com/o/oauth2/v2/auth",
        tokenUrl: "https://oauth2.googleapis.com/token"
      },
      scopes: [
        "https://www.googleapis.com/auth/drive",
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/gmail.readonly",
        "https://www.googleapis.com/auth/gmail.send",
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/documents",
        "https://www.googleapis.com/auth/contacts.readonly",
        "https://www.googleapis.com/auth/tasks",
        "https://www.googleapis.com/auth/admin.directory.user.readonly"
      ],
      scopeDescriptions: {
        "https://www.googleapis.com/auth/drive": "Read and write Google Drive files",
        "https://www.googleapis.com/auth/calendar": "Read and write Google Calendar",
        "https://www.googleapis.com/auth/gmail.readonly": "Read Gmail messages",
        "https://www.googleapis.com/auth/gmail.send": "Send Gmail messages",
        "https://www.googleapis.com/auth/spreadsheets": "Read and write Google Sheets",
        "https://www.googleapis.com/auth/documents": "Read and write Google Docs",
        "https://www.googleapis.com/auth/contacts.readonly": "Read Google Contacts",
        "https://www.googleapis.com/auth/tasks": "Read and write Google Tasks",
        "https://www.googleapis.com/auth/admin.directory.user.readonly": "Read user directory (Admin)"
      }
    },
    {
      id: "service-account",
      name: "Service Account (JWT Bearer)",
      type: "oauth",
      flow: "jwt_bearer",
      description: "Server-to-server auth without user. Download JSON key from GCP Console. Can impersonate users with domain-wide delegation",
      requiredFields: ["clientId", "privateKey"],
      optionalFields: ["scope", "subject"],
      defaults: {
        type: "oauth",
        flow: "jwt_bearer",
        tokenUrl: "https://oauth2.googleapis.com/token",
        audience: "https://oauth2.googleapis.com/token"
      },
      scopes: [
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/drive"
      ],
      scopeDescriptions: {
        "https://www.googleapis.com/auth/cloud-platform": "Full access to Google Cloud Platform",
        "https://www.googleapis.com/auth/drive": "Read and write Google Drive files"
      }
    }
  ]
};

// src/connectors/vendors/templates/slack.ts
var slackTemplate = {
  id: "slack",
  name: "Slack",
  serviceType: "slack",
  baseURL: "https://slack.com/api",
  docsURL: "https://api.slack.com/methods",
  credentialsSetupURL: "https://api.slack.com/apps",
  category: "communication",
  authTemplates: [
    {
      id: "bot-token",
      name: "Bot Token",
      type: "api_key",
      description: "Internal workspace bot - get from OAuth & Permissions page of your Slack app. For Socket Mode bots, also provide appToken and signingSecret in extra fields.",
      requiredFields: ["apiKey"],
      optionalFields: ["appToken", "signingSecret"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Token)",
      type: "oauth",
      flow: "authorization_code",
      description: "Distributed app - users authorize via Slack OAuth",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope", "userScope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://slack.com/oauth/v2/authorize",
        tokenUrl: "https://slack.com/api/oauth.v2.access"
      },
      scopes: ["chat:write", "channels:read", "users:read", "im:write", "groups:read", "files:read", "files:write", "reactions:read", "reactions:write", "team:read"],
      scopeDescriptions: {
        "chat:write": "Send messages as the app",
        "channels:read": "View basic channel info",
        "users:read": "View people in the workspace",
        "im:write": "Send direct messages",
        "groups:read": "View basic private channel info",
        "files:read": "View files shared in channels",
        "files:write": "Upload and manage files",
        "reactions:read": "View emoji reactions",
        "reactions:write": "Add and remove emoji reactions",
        "team:read": "View workspace info"
      }
    }
  ]
};

// src/connectors/vendors/templates/discord.ts
var discordTemplate = {
  id: "discord",
  name: "Discord",
  serviceType: "discord",
  baseURL: "https://discord.com/api/v10",
  docsURL: "https://discord.com/developers/docs",
  credentialsSetupURL: "https://discord.com/developers/applications",
  category: "communication",
  authTemplates: [
    {
      id: "bot-token",
      name: "Bot Token",
      type: "api_key",
      description: "Bot token for Discord bots - get from Bot section of your application",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bot"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Token)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth2 for user authorization - users grant permissions to your app",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://discord.com/api/oauth2/authorize",
        tokenUrl: "https://discord.com/api/oauth2/token"
      },
      scopes: ["identify", "email", "guilds", "guilds.members.read", "messages.read", "bot", "connections"],
      scopeDescriptions: {
        "identify": "Access your username and avatar",
        "email": "Access your email address",
        "guilds": "View your server list",
        "guilds.members.read": "Read server member info",
        "messages.read": "Read messages in accessible channels",
        "bot": "Add a bot to your servers",
        "connections": "View your connected accounts"
      }
    }
  ]
};

// src/connectors/vendors/templates/telegram.ts
var telegramTemplate = {
  id: "telegram",
  name: "Telegram",
  serviceType: "telegram",
  baseURL: "https://api.telegram.org",
  docsURL: "https://core.telegram.org/bots/api",
  credentialsSetupURL: "https://t.me/BotFather",
  category: "communication",
  notes: "Telegram Bot API requires token to be part of URL path: /bot<token>/method",
  authTemplates: [
    {
      id: "bot-token",
      name: "Bot Token",
      type: "api_key",
      description: "Bot token from @BotFather - used in URL path, not header",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: ""
      }
    }
  ]
};

// src/connectors/vendors/templates/github.ts
var githubTemplate = {
  id: "github",
  name: "GitHub",
  serviceType: "github",
  baseURL: "https://api.github.com",
  docsURL: "https://docs.github.com/en/rest",
  credentialsSetupURL: "https://github.com/settings/developers",
  category: "development",
  authTemplates: [
    {
      id: "pat",
      name: "Personal Access Token",
      type: "api_key",
      description: "Simple token for personal use, scripts, or single-user apps. Create at Settings > Developer settings > Personal access tokens",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth App (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "User logs in via GitHub and grants permissions to your app",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://github.com/login/oauth/authorize",
        tokenUrl: "https://github.com/login/oauth/access_token"
      },
      scopes: ["repo", "read:user", "user:email", "read:org", "workflow", "gist", "notifications", "delete_repo", "admin:org"],
      scopeDescriptions: {
        "repo": "Full control of private repositories",
        "read:user": "Read user profile data",
        "user:email": "Access user email addresses",
        "read:org": "Read org and team membership",
        "workflow": "Update GitHub Actions workflows",
        "gist": "Create and manage gists",
        "notifications": "Access notifications",
        "delete_repo": "Delete repositories",
        "admin:org": "Full control of orgs and teams"
      }
    },
    {
      id: "github-app",
      name: "GitHub App (Installation Token)",
      type: "oauth",
      flow: "jwt_bearer",
      description: "App authenticates as itself for org-wide automation. Requires App ID, private key, and installation ID",
      requiredFields: ["appId", "privateKey", "installationId"],
      defaults: {
        type: "oauth",
        flow: "jwt_bearer",
        tokenUrl: "https://api.github.com/app/installations/{installationId}/access_tokens"
      }
    }
  ]
};

// src/connectors/vendors/templates/gitlab.ts
var gitlabTemplate = {
  id: "gitlab",
  name: "GitLab",
  serviceType: "gitlab",
  baseURL: "https://gitlab.com/api/v4",
  docsURL: "https://docs.gitlab.com/ee/api/",
  credentialsSetupURL: "https://gitlab.com/-/profile/personal_access_tokens",
  category: "development",
  notes: "For self-hosted GitLab, replace baseURL with your instance URL",
  authTemplates: [
    {
      id: "pat",
      name: "Personal Access Token",
      type: "api_key",
      description: "Personal access token for API access. Create at User Settings > Access Tokens",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "PRIVATE-TOKEN",
        headerPrefix: ""
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth2 application for user authorization",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://gitlab.com/oauth/authorize",
        tokenUrl: "https://gitlab.com/oauth/token"
      },
      scopes: ["api", "read_user", "read_repository", "write_repository"],
      scopeDescriptions: {
        "api": "Full API access",
        "read_user": "Read user profile",
        "read_repository": "Read repository contents",
        "write_repository": "Write to repositories"
      }
    }
  ]
};

// src/connectors/vendors/templates/atlassian.ts
var jiraTemplate = {
  id: "jira",
  name: "Jira",
  serviceType: "jira",
  baseURL: "https://your-domain.atlassian.net/rest/api/3",
  docsURL: "https://developer.atlassian.com/cloud/jira/platform/rest/v3/",
  credentialsSetupURL: "https://id.atlassian.com/manage-profile/security/api-tokens",
  category: "development",
  notes: 'Replace "your-domain" in baseURL with your Atlassian domain',
  authTemplates: [
    {
      id: "api-token",
      name: "API Token",
      type: "api_key",
      description: "API token with email for Basic Auth. Create at Atlassian Account > Security > API tokens",
      requiredFields: ["apiKey", "username"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    },
    {
      id: "oauth-3lo",
      name: "OAuth 2.0 (3LO)",
      type: "oauth",
      flow: "authorization_code",
      description: "Three-legged OAuth for user authorization. Create app at developer.atlassian.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://auth.atlassian.com/authorize",
        tokenUrl: "https://auth.atlassian.com/oauth/token"
      },
      scopes: ["read:jira-work", "write:jira-work", "read:jira-user", "manage:jira-project", "manage:jira-configuration"],
      scopeDescriptions: {
        "read:jira-work": "Read issues, projects, boards",
        "write:jira-work": "Create and update issues",
        "read:jira-user": "Read user information",
        "manage:jira-project": "Manage projects and components",
        "manage:jira-configuration": "Manage Jira settings"
      }
    }
  ]
};
var confluenceTemplate = {
  id: "confluence",
  name: "Confluence",
  serviceType: "confluence",
  baseURL: "https://your-domain.atlassian.net/wiki/rest/api",
  docsURL: "https://developer.atlassian.com/cloud/confluence/rest/",
  credentialsSetupURL: "https://id.atlassian.com/manage-profile/security/api-tokens",
  category: "productivity",
  notes: 'Replace "your-domain" in baseURL with your Atlassian domain',
  authTemplates: [
    {
      id: "api-token",
      name: "API Token",
      type: "api_key",
      description: "API token with email for Basic Auth. Create at Atlassian Account > Security > API tokens",
      requiredFields: ["apiKey", "username"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    },
    {
      id: "oauth-3lo",
      name: "OAuth 2.0 (3LO)",
      type: "oauth",
      flow: "authorization_code",
      description: "Three-legged OAuth for user authorization",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://auth.atlassian.com/authorize",
        tokenUrl: "https://auth.atlassian.com/oauth/token"
      },
      scopes: ["read:confluence-content.all", "write:confluence-content", "read:confluence-space.summary", "write:confluence-space", "read:confluence-user"],
      scopeDescriptions: {
        "read:confluence-content.all": "Read all pages and blog posts",
        "write:confluence-content": "Create and update pages",
        "read:confluence-space.summary": "Read space summaries",
        "write:confluence-space": "Create and manage spaces",
        "read:confluence-user": "Read user information"
      }
    }
  ]
};
var bitbucketTemplate = {
  id: "bitbucket",
  name: "Bitbucket",
  serviceType: "bitbucket",
  baseURL: "https://api.bitbucket.org/2.0",
  docsURL: "https://developer.atlassian.com/cloud/bitbucket/rest/",
  credentialsSetupURL: "https://bitbucket.org/account/settings/app-passwords/",
  category: "development",
  authTemplates: [
    {
      id: "app-password",
      name: "App Password",
      type: "api_key",
      description: "App password with username for Basic Auth. Create at Personal Settings > App passwords",
      requiredFields: ["apiKey", "username"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth Consumer",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth consumer for user authorization. Create at Workspace Settings > OAuth consumers",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://bitbucket.org/site/oauth2/authorize",
        tokenUrl: "https://bitbucket.org/site/oauth2/access_token"
      },
      scopes: ["repository", "repository:write", "pullrequest", "pullrequest:write", "account", "pipeline", "wiki"],
      scopeDescriptions: {
        "repository": "Read repositories",
        "repository:write": "Write to repositories",
        "pullrequest": "Read pull requests",
        "pullrequest:write": "Create and update pull requests",
        "account": "Read account information",
        "pipeline": "Access Pipelines (CI/CD)",
        "wiki": "Access repository wiki"
      }
    }
  ]
};
var trelloTemplate = {
  id: "trello",
  name: "Trello",
  serviceType: "trello",
  baseURL: "https://api.trello.com/1",
  docsURL: "https://developer.atlassian.com/cloud/trello/rest/",
  credentialsSetupURL: "https://trello.com/power-ups/admin",
  category: "development",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key + Token",
      type: "api_key",
      description: "API key and token pair. Get key at trello.com/app-key, generate token from there",
      requiredFields: ["apiKey"],
      optionalFields: ["applicationKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: 'OAuth oauth_consumer_key="{apiKey}", oauth_token='
      }
    },
    {
      id: "oauth-user",
      name: "OAuth 1.0a",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth 1.0a for user authorization (legacy)",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://trello.com/1/authorize",
        tokenUrl: "https://trello.com/1/OAuthGetAccessToken"
      },
      scopes: ["read", "write", "account"],
      scopeDescriptions: {
        "read": "Read boards, lists, and cards",
        "write": "Create and update boards, lists, and cards",
        "account": "Read member information"
      }
    }
  ]
};

// src/connectors/vendors/templates/linear.ts
var linearTemplate = {
  id: "linear",
  name: "Linear",
  serviceType: "linear",
  baseURL: "https://api.linear.app/graphql",
  docsURL: "https://developers.linear.app/docs",
  credentialsSetupURL: "https://linear.app/settings/api",
  category: "development",
  notes: "Linear uses GraphQL API. All requests go to the /graphql endpoint",
  authTemplates: [
    {
      id: "api-key",
      name: "Personal API Key",
      type: "api_key",
      description: "Personal API key for full access. Create at Settings > API",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: ""
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth application for user authorization. Create at Settings > API > OAuth applications",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://linear.app/oauth/authorize",
        tokenUrl: "https://api.linear.app/oauth/token"
      },
      scopes: ["read", "write", "issues:create", "comments:create"]
    }
  ]
};

// src/connectors/vendors/templates/asana.ts
var asanaTemplate = {
  id: "asana",
  name: "Asana",
  serviceType: "asana",
  baseURL: "https://app.asana.com/api/1.0",
  docsURL: "https://developers.asana.com/docs",
  credentialsSetupURL: "https://app.asana.com/0/developer-console",
  category: "development",
  authTemplates: [
    {
      id: "pat",
      name: "Personal Access Token",
      type: "api_key",
      description: "Personal access token for API access. Create at My Profile Settings > Apps > Developer Apps",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth application for user authorization. Create at developer console",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://app.asana.com/-/oauth_authorize",
        tokenUrl: "https://app.asana.com/-/oauth_token"
      },
      scopes: ["default"]
    }
  ]
};

// src/connectors/vendors/templates/notion.ts
var notionTemplate = {
  id: "notion",
  name: "Notion",
  serviceType: "notion",
  baseURL: "https://api.notion.com/v1",
  docsURL: "https://developers.notion.com/reference",
  credentialsSetupURL: "https://www.notion.so/my-integrations",
  category: "productivity",
  authTemplates: [
    {
      id: "internal-token",
      name: "Internal Integration Token",
      type: "api_key",
      description: "Internal integration token for workspace access. Create at notion.so/my-integrations",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "Public Integration (OAuth)",
      type: "oauth",
      flow: "authorization_code",
      description: "Public integration for multi-workspace access",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://api.notion.com/v1/oauth/authorize",
        tokenUrl: "https://api.notion.com/v1/oauth/token"
      }
    }
  ]
};

// src/connectors/vendors/templates/airtable.ts
var airtableTemplate = {
  id: "airtable",
  name: "Airtable",
  serviceType: "airtable",
  baseURL: "https://api.airtable.com/v0",
  docsURL: "https://airtable.com/developers/web/api",
  credentialsSetupURL: "https://airtable.com/create/tokens",
  category: "productivity",
  authTemplates: [
    {
      id: "pat",
      name: "Personal Access Token",
      type: "api_key",
      description: "Personal access token with scoped permissions. Create at airtable.com/create/tokens",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth integration for multi-user access. Register at airtable.com/create/oauth",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://airtable.com/oauth2/v1/authorize",
        tokenUrl: "https://airtable.com/oauth2/v1/token",
        usePKCE: true
      },
      scopes: ["data.records:read", "data.records:write", "schema.bases:read"]
    }
  ]
};

// src/connectors/vendors/templates/salesforce.ts
var salesforceTemplate = {
  id: "salesforce",
  name: "Salesforce",
  serviceType: "salesforce",
  baseURL: "https://login.salesforce.com/services/data/v59.0",
  docsURL: "https://developer.salesforce.com/docs/apis",
  credentialsSetupURL: "https://login.salesforce.com/lightning/setup/ConnectedApplication/home",
  category: "crm",
  notes: "After OAuth, baseURL changes to instance URL (e.g., yourinstance.salesforce.com)",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "User logs in via Salesforce. Create Connected App in Setup",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://login.salesforce.com/services/oauth2/authorize",
        tokenUrl: "https://login.salesforce.com/services/oauth2/token"
      },
      scopes: ["api", "refresh_token", "offline_access", "chatter_api", "wave_api", "full"],
      scopeDescriptions: {
        "api": "Access and manage your data",
        "refresh_token": "Maintain access with refresh tokens",
        "offline_access": "Access data while you are offline",
        "chatter_api": "Access Chatter feeds and posts",
        "wave_api": "Access Analytics (Wave) API",
        "full": "Full access to all data"
      }
    },
    {
      id: "jwt-bearer",
      name: "JWT Bearer (Server-to-Server)",
      type: "oauth",
      flow: "jwt_bearer",
      description: "Automated server integration - requires certificate setup in Connected App",
      requiredFields: ["clientId", "privateKey", "username"],
      defaults: {
        type: "oauth",
        flow: "jwt_bearer",
        tokenUrl: "https://login.salesforce.com/services/oauth2/token",
        audience: "https://login.salesforce.com"
      }
    }
  ]
};

// src/connectors/vendors/templates/hubspot.ts
var hubspotTemplate = {
  id: "hubspot",
  name: "HubSpot",
  serviceType: "hubspot",
  baseURL: "https://api.hubapi.com",
  docsURL: "https://developers.hubspot.com/docs/api",
  credentialsSetupURL: "https://developers.hubspot.com/get-started",
  category: "crm",
  authTemplates: [
    {
      id: "api-key",
      name: "Private App Token",
      type: "api_key",
      description: "Private app access token. Create at Settings > Integrations > Private Apps",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "Public app OAuth for multi-portal access. Create app at developers.hubspot.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://app.hubspot.com/oauth/authorize",
        tokenUrl: "https://api.hubapi.com/oauth/v1/token"
      },
      scopes: [
        "crm.objects.contacts.read",
        "crm.objects.contacts.write",
        "crm.objects.companies.read",
        "crm.objects.companies.write",
        "crm.objects.deals.read",
        "crm.objects.deals.write",
        "tickets",
        "e-commerce"
      ],
      scopeDescriptions: {
        "crm.objects.contacts.read": "Read contacts",
        "crm.objects.contacts.write": "Create and update contacts",
        "crm.objects.companies.read": "Read companies",
        "crm.objects.companies.write": "Create and update companies",
        "crm.objects.deals.read": "Read deals",
        "crm.objects.deals.write": "Create and update deals",
        "tickets": "Read and write support tickets",
        "e-commerce": "Access e-commerce data (products, line items)"
      }
    }
  ]
};

// src/connectors/vendors/templates/pipedrive.ts
var pipedriveTemplate = {
  id: "pipedrive",
  name: "Pipedrive",
  serviceType: "pipedrive",
  baseURL: "https://api.pipedrive.com/v1",
  docsURL: "https://developers.pipedrive.com/docs/api/v1",
  credentialsSetupURL: "https://app.pipedrive.com/settings/api",
  category: "crm",
  authTemplates: [
    {
      id: "api-token",
      name: "API Token",
      type: "api_key",
      description: "Personal API token. Find at Settings > Personal preferences > API",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (App Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth app for marketplace distribution. Create at developers.pipedrive.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://oauth.pipedrive.com/oauth/authorize",
        tokenUrl: "https://oauth.pipedrive.com/oauth/token"
      }
    }
  ]
};

// src/connectors/vendors/templates/stripe.ts
var stripeTemplate = {
  id: "stripe",
  name: "Stripe",
  serviceType: "stripe",
  baseURL: "https://api.stripe.com/v1",
  docsURL: "https://stripe.com/docs/api",
  credentialsSetupURL: "https://dashboard.stripe.com/apikeys",
  category: "payments",
  authTemplates: [
    {
      id: "api-key",
      name: "Secret API Key",
      type: "api_key",
      description: "Secret API key for server-side requests. Get from Dashboard > Developers > API keys",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-connect",
      name: "OAuth (Stripe Connect)",
      type: "oauth",
      flow: "authorization_code",
      description: "Stripe Connect for marketplace platforms. Requires Connect setup in dashboard",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://connect.stripe.com/oauth/authorize",
        tokenUrl: "https://connect.stripe.com/oauth/token"
      },
      scopes: ["read_write"]
    }
  ]
};

// src/connectors/vendors/templates/paypal.ts
var paypalTemplate = {
  id: "paypal",
  name: "PayPal",
  serviceType: "paypal",
  baseURL: "https://api-m.paypal.com/v2",
  docsURL: "https://developer.paypal.com/docs/api/",
  credentialsSetupURL: "https://developer.paypal.com/dashboard/applications",
  category: "payments",
  notes: "Use sandbox URL (api-m.sandbox.paypal.com) for testing",
  authTemplates: [
    {
      id: "oauth-client-credentials",
      name: "OAuth (Client Credentials)",
      type: "oauth",
      flow: "client_credentials",
      description: "App-level authentication. Create REST API app at developer.paypal.com",
      requiredFields: ["clientId", "clientSecret"],
      defaults: {
        type: "oauth",
        flow: "client_credentials",
        tokenUrl: "https://api-m.paypal.com/v1/oauth2/token"
      }
    }
  ]
};

// src/connectors/vendors/templates/quickbooks.ts
var quickbooksTemplate = {
  id: "quickbooks",
  name: "QuickBooks",
  serviceType: "quickbooks",
  baseURL: "https://quickbooks.api.intuit.com/v3",
  docsURL: "https://developer.intuit.com/app/developer/qbo/docs/api/accounting/all-entities/account",
  credentialsSetupURL: "https://developer.intuit.com/app/developer/dashboard",
  category: "payments",
  notes: "Use sandbox URL (sandbox-quickbooks.api.intuit.com) for testing. Requires company/realm ID in API paths.",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "Standard OAuth 2.0 flow for accessing QuickBooks on behalf of a user. Create an app at developer.intuit.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://appcenter.intuit.com/connect/oauth2",
        tokenUrl: "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
      },
      scopes: ["com.intuit.quickbooks.accounting", "com.intuit.quickbooks.payment"]
    }
  ]
};

// src/connectors/vendors/templates/ramp.ts
var rampTemplate = {
  id: "ramp",
  name: "Ramp",
  serviceType: "ramp",
  baseURL: "https://api.ramp.com/developer/v1",
  docsURL: "https://docs.ramp.com",
  credentialsSetupURL: "https://app.ramp.com/settings/developer",
  category: "payments",
  authTemplates: [
    {
      id: "oauth-client-credentials",
      name: "OAuth (Client Credentials)",
      type: "oauth",
      flow: "client_credentials",
      description: "App-level authentication using client credentials. Create an API application in Ramp developer settings",
      requiredFields: ["clientId", "clientSecret"],
      defaults: {
        type: "oauth",
        flow: "client_credentials",
        tokenUrl: "https://api.ramp.com/developer/v1/token"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth 2.0 authorization code flow for accessing Ramp on behalf of a user",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://app.ramp.com/v1/authorize",
        tokenUrl: "https://api.ramp.com/developer/v1/token"
      },
      scopes: [
        "transactions:read",
        "users:read",
        "users:write",
        "cards:read",
        "cards:write",
        "departments:read",
        "reimbursements:read"
      ]
    }
  ]
};

// src/connectors/vendors/templates/aws.ts
var awsTemplate = {
  id: "aws",
  name: "Amazon Web Services",
  serviceType: "aws",
  baseURL: "https://aws.amazon.com",
  docsURL: "https://docs.aws.amazon.com/",
  credentialsSetupURL: "https://console.aws.amazon.com/iam/home#/security_credentials",
  category: "cloud",
  notes: "AWS uses signature-based auth. baseURL varies by service (e.g., s3.amazonaws.com)",
  authTemplates: [
    {
      id: "access-key",
      name: "Access Key",
      type: "api_key",
      description: "IAM access key pair. Create at IAM > Users > Security credentials or root Security credentials",
      requiredFields: ["accessKeyId", "secretAccessKey"],
      optionalFields: ["region"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "AWS4-HMAC-SHA256"
      }
    }
  ]
};

// src/connectors/vendors/templates/dropbox.ts
var dropboxTemplate = {
  id: "dropbox",
  name: "Dropbox",
  serviceType: "dropbox",
  baseURL: "https://api.dropboxapi.com/2",
  docsURL: "https://www.dropbox.com/developers/documentation",
  credentialsSetupURL: "https://www.dropbox.com/developers/apps",
  category: "storage",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth app for user authorization. Create app at dropbox.com/developers/apps",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://www.dropbox.com/oauth2/authorize",
        tokenUrl: "https://api.dropboxapi.com/oauth2/token",
        usePKCE: true
      },
      scopes: ["files.content.read", "files.content.write", "files.metadata.read", "files.metadata.write", "sharing.read", "sharing.write", "account_info.read"],
      scopeDescriptions: {
        "files.content.read": "Read file contents",
        "files.content.write": "Upload and modify files",
        "files.metadata.read": "Read file and folder metadata",
        "files.metadata.write": "Modify file and folder metadata",
        "sharing.read": "View sharing settings",
        "sharing.write": "Manage sharing settings",
        "account_info.read": "Read account information"
      }
    }
  ]
};

// src/connectors/vendors/templates/box.ts
var boxTemplate = {
  id: "box",
  name: "Box",
  serviceType: "box",
  baseURL: "https://api.box.com/2.0",
  docsURL: "https://developer.box.com/reference/",
  credentialsSetupURL: "https://developer.box.com/console",
  category: "storage",
  authTemplates: [
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth 2.0 for user authorization. Create app at developer.box.com/console",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://account.box.com/api/oauth2/authorize",
        tokenUrl: "https://api.box.com/oauth2/token"
      },
      scopes: ["root_readwrite", "manage_users", "manage_groups", "manage_enterprise"],
      scopeDescriptions: {
        "root_readwrite": "Read and write all files and folders",
        "manage_users": "Manage enterprise users",
        "manage_groups": "Manage enterprise groups",
        "manage_enterprise": "Manage enterprise settings"
      }
    },
    {
      id: "client-credentials",
      name: "Client Credentials (Server Auth)",
      type: "oauth",
      flow: "client_credentials",
      description: "Server-to-server auth with Client Credentials Grant. Enable in app settings",
      requiredFields: ["clientId", "clientSecret"],
      optionalFields: ["subject"],
      defaults: {
        type: "oauth",
        flow: "client_credentials",
        tokenUrl: "https://api.box.com/oauth2/token"
      }
    }
  ]
};

// src/connectors/vendors/templates/email.ts
var sendgridTemplate = {
  id: "sendgrid",
  name: "SendGrid",
  serviceType: "sendgrid",
  baseURL: "https://api.sendgrid.com/v3",
  docsURL: "https://docs.sendgrid.com/api-reference",
  credentialsSetupURL: "https://app.sendgrid.com/settings/api_keys",
  category: "email",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "API key for SendGrid access. Create at Settings > API Keys",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    }
  ]
};
var mailchimpTemplate = {
  id: "mailchimp",
  name: "Mailchimp",
  serviceType: "mailchimp",
  baseURL: "https://server.api.mailchimp.com/3.0",
  docsURL: "https://mailchimp.com/developer/marketing/api/",
  credentialsSetupURL: "https://admin.mailchimp.com/account/api/",
  category: "email",
  notes: 'Replace "server" in baseURL with your datacenter (e.g., us1, us2)',
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "API key for Mailchimp access. Create at Account > Extras > API keys",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth for multi-account access. Register app at mailchimp.com/developer",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://login.mailchimp.com/oauth2/authorize",
        tokenUrl: "https://login.mailchimp.com/oauth2/token"
      }
    }
  ]
};
var postmarkTemplate = {
  id: "postmark",
  name: "Postmark",
  serviceType: "postmark",
  baseURL: "https://api.postmarkapp.com",
  docsURL: "https://postmarkapp.com/developer",
  credentialsSetupURL: "https://account.postmarkapp.com/api_tokens",
  category: "email",
  authTemplates: [
    {
      id: "server-token",
      name: "Server API Token",
      type: "api_key",
      description: "Server API token for sending emails. Find in server settings",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "X-Postmark-Server-Token",
        headerPrefix: ""
      }
    },
    {
      id: "account-token",
      name: "Account API Token",
      type: "api_key",
      description: "Account API token for account management. Find in account settings",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "X-Postmark-Account-Token",
        headerPrefix: ""
      }
    }
  ]
};

// src/connectors/vendors/templates/monitoring.ts
var datadogTemplate = {
  id: "datadog",
  name: "Datadog",
  serviceType: "datadog",
  baseURL: "https://api.datadoghq.com/api/v2",
  docsURL: "https://docs.datadoghq.com/api/",
  credentialsSetupURL: "https://app.datadoghq.com/organization-settings/api-keys",
  category: "monitoring",
  notes: "Use region-specific URL (e.g., api.datadoghq.eu for EU)",
  authTemplates: [
    {
      id: "api-key",
      name: "API & Application Keys",
      type: "api_key",
      description: "API key + Application key for full access. Get from Organization Settings",
      requiredFields: ["apiKey", "applicationKey"],
      defaults: {
        type: "api_key",
        headerName: "DD-API-KEY",
        headerPrefix: ""
      }
    }
  ]
};
var pagerdutyTemplate = {
  id: "pagerduty",
  name: "PagerDuty",
  serviceType: "pagerduty",
  baseURL: "https://api.pagerduty.com",
  docsURL: "https://developer.pagerduty.com/api-reference/",
  credentialsSetupURL: "https://support.pagerduty.com/main/docs/api-access-keys",
  category: "monitoring",
  authTemplates: [
    {
      id: "api-key",
      name: "API Token",
      type: "api_key",
      description: "REST API token. Create at User Settings > Create API Key or via Admin",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Token token="
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (App Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth app for multi-account access. Register at developer.pagerduty.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://app.pagerduty.com/oauth/authorize",
        tokenUrl: "https://app.pagerduty.com/oauth/token"
      },
      scopes: ["read", "write"],
      scopeDescriptions: {
        "read": "Read incidents, services, and schedules",
        "write": "Create and update incidents and services"
      }
    }
  ]
};
var sentryTemplate = {
  id: "sentry",
  name: "Sentry",
  serviceType: "sentry",
  baseURL: "https://sentry.io/api/0",
  docsURL: "https://docs.sentry.io/api/",
  credentialsSetupURL: "https://sentry.io/settings/account/api/auth-tokens/",
  category: "monitoring",
  authTemplates: [
    {
      id: "auth-token",
      name: "Auth Token",
      type: "api_key",
      description: "Authentication token. Create at User Settings > Auth Tokens",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (Integration)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth integration. Create at Organization Settings > Integrations",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://sentry.io/oauth/authorize/",
        tokenUrl: "https://sentry.io/oauth/token/"
      },
      scopes: ["project:read", "project:write", "event:read", "org:read", "member:read"],
      scopeDescriptions: {
        "project:read": "Read project settings",
        "project:write": "Manage project settings",
        "event:read": "Read error events and issues",
        "org:read": "Read organization info",
        "member:read": "Read org member info"
      }
    }
  ]
};

// src/connectors/vendors/templates/search.ts
var serperTemplate = {
  id: "serper",
  name: "Serper",
  serviceType: "serper",
  baseURL: "https://google.serper.dev",
  docsURL: "https://serper.dev/docs",
  credentialsSetupURL: "https://serper.dev/api-key",
  category: "search",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "Serper API key for Google search. Get at serper.dev dashboard",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "X-API-KEY",
        headerPrefix: ""
      }
    }
  ]
};
var braveSearchTemplate = {
  id: "brave-search",
  name: "Brave Search",
  serviceType: "brave-search",
  baseURL: "https://api.search.brave.com/res/v1",
  docsURL: "https://brave.com/search/api/",
  credentialsSetupURL: "https://brave.com/search/api/",
  category: "search",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "Brave Search API key. Sign up at brave.com/search/api",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "X-Subscription-Token",
        headerPrefix: ""
      }
    }
  ]
};
var tavilyTemplate = {
  id: "tavily",
  name: "Tavily",
  serviceType: "tavily",
  baseURL: "https://api.tavily.com",
  docsURL: "https://tavily.com/docs",
  credentialsSetupURL: "https://tavily.com/#api",
  category: "search",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "Tavily API key for AI-optimized search. Get at tavily.com",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    }
  ]
};
var rapidapiSearchTemplate = {
  id: "rapidapi-search",
  name: "RapidAPI Web Search",
  serviceType: "rapidapi-search",
  baseURL: "https://real-time-web-search.p.rapidapi.com",
  docsURL: "https://rapidapi.com/letscrape-6bRBa3QguO5/api/real-time-web-search",
  credentialsSetupURL: "https://rapidapi.com/developer/dashboard",
  category: "search",
  authTemplates: [
    {
      id: "api-key",
      name: "RapidAPI Key",
      type: "api_key",
      description: "RapidAPI key for web search. Subscribe at rapidapi.com",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "X-RapidAPI-Key",
        headerPrefix: ""
      }
    }
  ]
};

// src/connectors/vendors/templates/scrape.ts
var zenrowsTemplate = {
  id: "zenrows",
  name: "ZenRows",
  serviceType: "zenrows",
  baseURL: "https://api.zenrows.com/v1",
  docsURL: "https://docs.zenrows.com/universal-scraper-api/api-reference",
  credentialsSetupURL: "https://www.zenrows.com/register",
  category: "scrape",
  authTemplates: [
    {
      id: "api-key",
      name: "API Key",
      type: "api_key",
      description: "ZenRows API key for web scraping. Get at zenrows.com dashboard",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    }
  ]
};

// src/connectors/vendors/templates/other.ts
var twilioTemplate = {
  id: "twilio",
  name: "Twilio",
  serviceType: "twilio",
  baseURL: "https://api.twilio.com/2010-04-01",
  docsURL: "https://www.twilio.com/docs/usage/api",
  credentialsSetupURL: "https://console.twilio.com/us1/account/keys-credentials/api-keys",
  category: "other",
  authTemplates: [
    {
      id: "api-key",
      name: "Account SID + Auth Token",
      type: "api_key",
      description: "Account credentials for Basic Auth. Find at console.twilio.com",
      requiredFields: ["apiKey", "accountId"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    },
    {
      id: "api-key-sid",
      name: "API Key + Secret",
      type: "api_key",
      description: "API key credentials (recommended). Create at Console > API Keys",
      requiredFields: ["apiKey", "applicationKey", "accountId"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    }
  ]
};
var zendeskTemplate = {
  id: "zendesk",
  name: "Zendesk",
  serviceType: "zendesk",
  baseURL: "https://your-subdomain.zendesk.com/api/v2",
  docsURL: "https://developer.zendesk.com/api-reference/",
  credentialsSetupURL: "https://support.zendesk.com/hc/en-us/articles/4408889192858",
  category: "other",
  notes: 'Replace "your-subdomain" in baseURL with your Zendesk subdomain',
  authTemplates: [
    {
      id: "api-token",
      name: "API Token",
      type: "api_key",
      description: "API token with email/token for Basic Auth. Create at Admin > Channels > API",
      requiredFields: ["apiKey", "username"],
      optionalFields: ["subdomain"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Basic"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (User Authorization)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth client for user authorization. Create at Admin > Channels > API > OAuth Clients",
      requiredFields: ["clientId", "clientSecret", "redirectUri", "subdomain"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://{subdomain}.zendesk.com/oauth/authorizations/new",
        tokenUrl: "https://{subdomain}.zendesk.com/oauth/tokens"
      },
      scopes: ["read", "write", "tickets:read", "tickets:write"],
      scopeDescriptions: {
        "read": "Read all resources",
        "write": "Create and update resources",
        "tickets:read": "Read support tickets",
        "tickets:write": "Create and update tickets"
      }
    }
  ]
};
var intercomTemplate = {
  id: "intercom",
  name: "Intercom",
  serviceType: "intercom",
  baseURL: "https://api.intercom.io",
  docsURL: "https://developers.intercom.com/docs/",
  credentialsSetupURL: "https://developers.intercom.com/docs/build-an-integration",
  category: "other",
  authTemplates: [
    {
      id: "access-token",
      name: "Access Token",
      type: "api_key",
      description: "Access token for API access. Create app at app.intercom.com/developers",
      requiredFields: ["apiKey"],
      defaults: {
        type: "api_key",
        headerName: "Authorization",
        headerPrefix: "Bearer"
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (App Installation)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth for Intercom app marketplace distribution",
      requiredFields: ["clientId", "clientSecret", "redirectUri"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://app.intercom.com/oauth",
        tokenUrl: "https://api.intercom.io/auth/eagle/token"
      }
    }
  ]
};
var shopifyTemplate = {
  id: "shopify",
  name: "Shopify",
  serviceType: "shopify",
  baseURL: "https://your-store.myshopify.com/admin/api/2024-01",
  docsURL: "https://shopify.dev/docs/api",
  credentialsSetupURL: "https://partners.shopify.com/",
  category: "other",
  notes: 'Replace "your-store" in baseURL with your store name',
  authTemplates: [
    {
      id: "access-token",
      name: "Admin API Access Token",
      type: "api_key",
      description: "Private app access token. Create custom app at your-store.myshopify.com/admin/apps",
      requiredFields: ["apiKey"],
      optionalFields: ["subdomain"],
      defaults: {
        type: "api_key",
        headerName: "X-Shopify-Access-Token",
        headerPrefix: ""
      }
    },
    {
      id: "oauth-user",
      name: "OAuth (Public/Custom App)",
      type: "oauth",
      flow: "authorization_code",
      description: "OAuth for public apps or per-store custom apps. Create at partners.shopify.com",
      requiredFields: ["clientId", "clientSecret", "redirectUri", "subdomain"],
      optionalFields: ["scope"],
      defaults: {
        type: "oauth",
        flow: "authorization_code",
        authorizationUrl: "https://{subdomain}.myshopify.com/admin/oauth/authorize",
        tokenUrl: "https://{subdomain}.myshopify.com/admin/oauth/access_token"
      },
      scopes: ["read_products", "write_products", "read_orders", "write_orders", "read_customers", "write_customers", "read_inventory", "write_inventory", "read_fulfillments", "write_fulfillments"],
      scopeDescriptions: {
        "read_products": "Read products and collections",
        "write_products": "Create and update products",
        "read_orders": "Read orders and transactions",
        "write_orders": "Create and update orders",
        "read_customers": "Read customer information",
        "write_customers": "Create and update customers",
        "read_inventory": "Read inventory levels",
        "write_inventory": "Update inventory levels",
        "read_fulfillments": "Read fulfillment data",
        "write_fulfillments": "Create and update fulfillments"
      }
    }
  ]
};

// src/connectors/vendors/templates/index.ts
var allVendorTemplates = [
  // Major Vendors (first for visibility)
  microsoftTemplate,
  googleTemplate,
  // Communication
  slackTemplate,
  discordTemplate,
  telegramTemplate,
  // Development
  githubTemplate,
  gitlabTemplate,
  bitbucketTemplate,
  jiraTemplate,
  linearTemplate,
  asanaTemplate,
  trelloTemplate,
  // Productivity
  notionTemplate,
  airtableTemplate,
  confluenceTemplate,
  // CRM
  salesforceTemplate,
  hubspotTemplate,
  pipedriveTemplate,
  // Payments
  stripeTemplate,
  paypalTemplate,
  quickbooksTemplate,
  rampTemplate,
  // Cloud
  awsTemplate,
  // Storage
  dropboxTemplate,
  boxTemplate,
  // Email
  sendgridTemplate,
  mailchimpTemplate,
  postmarkTemplate,
  // Monitoring
  datadogTemplate,
  pagerdutyTemplate,
  sentryTemplate,
  // Search
  serperTemplate,
  braveSearchTemplate,
  tavilyTemplate,
  rapidapiSearchTemplate,
  // Scrape
  zenrowsTemplate,
  // Other
  twilioTemplate,
  zendeskTemplate,
  intercomTemplate,
  shopifyTemplate
];
var VENDOR_ICON_MAP = {
  // Major Vendors (unified)
  microsoft: "microsoft",
  google: "google",
  // Cloud
  aws: "amazonwebservices",
  azure: "microsoftazure",
  gcp: "googlecloud",
  // Communication
  discord: "discord",
  slack: "slack",
  telegram: "telegram",
  "microsoft-teams": "microsoftteams",
  // CRM
  salesforce: "salesforce",
  hubspot: "hubspot",
  pipedrive: "pipedrive",
  // Development
  github: "github",
  gitlab: "gitlab",
  bitbucket: "bitbucket",
  jira: "jira",
  confluence: "confluence",
  trello: "trello",
  linear: "linear",
  asana: "asana",
  // Productivity
  notion: "notion",
  airtable: "airtable",
  "google-workspace": "google",
  "google-drive": "googledrive",
  "microsoft-365": "microsoft365",
  onedrive: "onedrive",
  // Payments
  stripe: "stripe",
  paypal: "paypal",
  quickbooks: "quickbooks",
  ramp: null,
  // No Simple Icon available
  // Email
  sendgrid: "sendgrid",
  mailchimp: "mailchimp",
  postmark: "postmark",
  // Storage
  dropbox: "dropbox",
  box: "box",
  // Monitoring
  datadog: "datadog",
  pagerduty: "pagerduty",
  sentry: "sentry",
  // Search
  serper: null,
  // No Simple Icon available
  "brave-search": "brave",
  tavily: null,
  // No Simple Icon available
  rapidapi: "rapidapi",
  // Scrape
  zenrows: null,
  // No Simple Icon available
  // Other
  twilio: "twilio",
  zendesk: "zendesk",
  intercom: "intercom",
  shopify: "shopify"
};
var FALLBACK_PLACEHOLDERS = {
  // Major Vendors (fallbacks in case Simple Icons doesn't work)
  microsoft: { color: "#00A4EF", letter: "M" },
  google: { color: "#4285F4", letter: "G" },
  // Cloud (trademark removed from Simple Icons)
  aws: { color: "#FF9900", letter: "A" },
  azure: { color: "#0078D4", letter: "A" },
  // Communication (trademark removed)
  slack: { color: "#4A154B", letter: "S" },
  "microsoft-teams": { color: "#6264A7", letter: "T" },
  // CRM (trademark removed)
  salesforce: { color: "#00A1E0", letter: "S" },
  pipedrive: { color: "#1A1F26", letter: "P" },
  // Productivity (trademark removed)
  "microsoft-365": { color: "#D83B01", letter: "M" },
  onedrive: { color: "#0078D4", letter: "O" },
  // Email (trademark removed)
  sendgrid: { color: "#1A82E2", letter: "S" },
  postmark: { color: "#FFDE00", letter: "P" },
  // Payments (no Simple Icon available)
  ramp: { color: "#F2C94C", letter: "R" },
  // Search (no Simple Icon available)
  serper: { color: "#4A90A4", letter: "S" },
  tavily: { color: "#7C3AED", letter: "T" },
  rapidapi: { color: "#0055DA", letter: "R" },
  // Scrape (no Simple Icon available)
  zenrows: { color: "#00D4AA", letter: "Z" },
  // Other (trademark removed)
  twilio: { color: "#F22F46", letter: "T" }
};
function slugToKey(slug) {
  return `si${slug.charAt(0).toUpperCase()}${slug.slice(1)}`;
}
function getSimpleIcon(slug) {
  const key = slugToKey(slug);
  return simpleIcons__namespace[key];
}
function generatePlaceholderSvg(letter, color) {
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect width="24" height="24" rx="4" fill="${color}"/><text x="12" y="17" font-family="system-ui, sans-serif" font-size="14" font-weight="600" fill="white" text-anchor="middle">${letter}</text></svg>`;
}
function hasVendorLogo(vendorId) {
  const slug = VENDOR_ICON_MAP[vendorId];
  if (slug === void 0) {
    return false;
  }
  if (slug !== null && getSimpleIcon(slug)) {
    return true;
  }
  return vendorId in FALLBACK_PLACEHOLDERS;
}
function getVendorLogo(vendorId) {
  const slug = VENDOR_ICON_MAP[vendorId];
  if (slug === void 0) {
    return void 0;
  }
  if (slug !== null) {
    const icon = getSimpleIcon(slug);
    if (icon) {
      return {
        vendorId,
        svg: icon.svg,
        hex: icon.hex,
        isPlaceholder: false,
        simpleIconsSlug: slug
      };
    }
  }
  const fallback = FALLBACK_PLACEHOLDERS[vendorId];
  if (fallback) {
    return {
      vendorId,
      svg: generatePlaceholderSvg(fallback.letter, fallback.color),
      hex: fallback.color.replace("#", ""),
      isPlaceholder: true
    };
  }
  return void 0;
}
function getVendorLogoSvg(vendorId, color) {
  const logo = getVendorLogo(vendorId);
  if (!logo) return void 0;
  if (color && !logo.isPlaceholder) {
    return logo.svg.replace(/fill="[^"]*"/g, `fill="#${color}"`);
  }
  return logo.svg;
}
function getVendorColor(vendorId) {
  const logo = getVendorLogo(vendorId);
  return logo?.hex;
}
function getAllVendorLogos() {
  const logos = /* @__PURE__ */ new Map();
  for (const vendorId of Object.keys(VENDOR_ICON_MAP)) {
    const logo = getVendorLogo(vendorId);
    if (logo) {
      logos.set(vendorId, logo);
    }
  }
  return logos;
}
function listVendorsWithLogos() {
  return Object.keys(VENDOR_ICON_MAP).filter(hasVendorLogo);
}
var SIMPLE_ICONS_CDN = "https://cdn.simpleicons.org";
function getVendorLogoCdnUrl(vendorId, color) {
  const slug = VENDOR_ICON_MAP[vendorId];
  if (!slug) return void 0;
  if (color) {
    return `${SIMPLE_ICONS_CDN}/${slug}/${color}`;
  }
  return `${SIMPLE_ICONS_CDN}/${slug}`;
}

// src/connectors/vendors/index.ts
initVendorRegistry(allVendorTemplates);

// src/infrastructure/resilience/index.ts
init_CircuitBreaker();
init_CircuitBreaker();
init_BackoffStrategy();
init_BackoffStrategy();

// src/infrastructure/resilience/RateLimiter.ts
var RateLimitError = class _RateLimitError extends AIError {
  constructor(retryAfterMs, message) {
    super(message ?? `Rate limited. Retry after ${retryAfterMs}ms`, "RATE_LIMIT_ERROR", 429);
    this.retryAfterMs = retryAfterMs;
    this.name = "RateLimitError";
    Object.setPrototypeOf(this, _RateLimitError.prototype);
  }
};
var DEFAULT_RATE_LIMITER_CONFIG = {
  maxRequests: 60,
  windowMs: 6e4,
  onLimit: "wait",
  maxWaitMs: 6e4
};
var TokenBucketRateLimiter = class {
  tokens;
  lastRefill;
  config;
  waitQueue = [];
  // Metrics
  totalRequests = 0;
  throttledRequests = 0;
  totalWaitMs = 0;
  constructor(config = {}) {
    this.config = {
      maxRequests: config.maxRequests ?? DEFAULT_RATE_LIMITER_CONFIG.maxRequests,
      windowMs: config.windowMs ?? DEFAULT_RATE_LIMITER_CONFIG.windowMs,
      onLimit: config.onLimit ?? DEFAULT_RATE_LIMITER_CONFIG.onLimit,
      maxWaitMs: config.maxWaitMs ?? DEFAULT_RATE_LIMITER_CONFIG.maxWaitMs
    };
    this.tokens = this.config.maxRequests;
    this.lastRefill = Date.now();
  }
  /**
   * Acquire a token (request permission to make an LLM call)
   * @returns Promise that resolves when token is acquired
   * @throws RateLimitError if onLimit='throw' and no tokens available
   */
  async acquire() {
    this.totalRequests++;
    this.refill();
    if (this.tokens > 0) {
      this.tokens--;
      return;
    }
    this.throttledRequests++;
    const waitTime = this.getWaitTime();
    if (this.config.onLimit === "throw") {
      throw new RateLimitError(waitTime);
    }
    if (waitTime > this.config.maxWaitMs) {
      throw new RateLimitError(
        waitTime,
        `Wait time ${waitTime}ms exceeds max ${this.config.maxWaitMs}ms`
      );
    }
    const startWait = Date.now();
    await this.waitForToken(waitTime);
    this.totalWaitMs += Date.now() - startWait;
  }
  /**
   * Try to acquire without waiting
   * @returns true if acquired, false if rate limited
   */
  tryAcquire() {
    this.totalRequests++;
    this.refill();
    if (this.tokens > 0) {
      this.tokens--;
      return true;
    }
    this.throttledRequests++;
    return false;
  }
  /**
   * Get current available tokens
   */
  getAvailableTokens() {
    this.refill();
    return this.tokens;
  }
  /**
   * Get time until next token is available
   */
  getWaitTime() {
    this.refill();
    if (this.tokens > 0) return 0;
    const elapsed = Date.now() - this.lastRefill;
    return Math.max(0, this.config.windowMs - elapsed);
  }
  /**
   * Get rate limiter metrics
   */
  getMetrics() {
    return {
      totalRequests: this.totalRequests,
      throttledRequests: this.throttledRequests,
      totalWaitMs: this.totalWaitMs,
      avgWaitMs: this.throttledRequests > 0 ? this.totalWaitMs / this.throttledRequests : 0
    };
  }
  /**
   * Reset the rate limiter state
   */
  reset() {
    this.tokens = this.config.maxRequests;
    this.lastRefill = Date.now();
    for (const waiter of this.waitQueue) {
      if (waiter.timeout) {
        clearTimeout(waiter.timeout);
      }
    }
    this.waitQueue = [];
  }
  /**
   * Reset metrics
   */
  resetMetrics() {
    this.totalRequests = 0;
    this.throttledRequests = 0;
    this.totalWaitMs = 0;
  }
  /**
   * Get the current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Refill tokens if window has expired
   */
  refill() {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    if (elapsed >= this.config.windowMs) {
      this.tokens = this.config.maxRequests;
      this.lastRefill = now;
      this.processWaitQueue();
    }
  }
  /**
   * Wait for a token to become available
   */
  async waitForToken(waitTime) {
    return new Promise((resolve4, reject) => {
      const timeout = setTimeout(() => {
        const index = this.waitQueue.findIndex((w) => w.timeout === timeout);
        if (index !== -1) {
          this.waitQueue.splice(index, 1);
        }
        this.refill();
        if (this.tokens > 0) {
          this.tokens--;
          resolve4();
        } else {
          reject(new RateLimitError(this.getWaitTime(), "Token still unavailable after wait"));
        }
      }, waitTime);
      this.waitQueue.push({ resolve: resolve4, reject, timeout });
    });
  }
  /**
   * Process waiting requests when tokens become available
   */
  processWaitQueue() {
    while (this.waitQueue.length > 0 && this.tokens > 0) {
      const waiter = this.waitQueue.shift();
      if (waiter) {
        if (waiter.timeout) {
          clearTimeout(waiter.timeout);
        }
        this.tokens--;
        waiter.resolve();
      }
    }
  }
};

// src/infrastructure/observability/index.ts
init_Logger();
init_Metrics();

// src/utils/messageBuilder.ts
var MessageBuilder = class {
  messages = [];
  /**
   * Add a user text message
   */
  addUserMessage(text) {
    this.messages.push({
      type: "message",
      role: "user" /* USER */,
      content: [
        {
          type: "input_text" /* INPUT_TEXT */,
          text
        }
      ]
    });
    return this;
  }
  /**
   * Add a user message with text and images
   */
  addUserMessageWithImages(text, imageUrls) {
    const content = [
      {
        type: "input_text" /* INPUT_TEXT */,
        text
      }
    ];
    for (const url2 of imageUrls) {
      content.push({
        type: "input_image_url" /* INPUT_IMAGE_URL */,
        image_url: {
          url: url2,
          detail: "auto"
          // Can be 'auto', 'low', or 'high'
        }
      });
    }
    this.messages.push({
      type: "message",
      role: "user" /* USER */,
      content
    });
    return this;
  }
  /**
   * Add an assistant message (for conversation history)
   */
  addAssistantMessage(text) {
    this.messages.push({
      type: "message",
      role: "assistant" /* ASSISTANT */,
      content: [
        {
          type: "output_text" /* OUTPUT_TEXT */,
          text,
          annotations: []
        }
      ]
    });
    return this;
  }
  /**
   * Add a system/developer message
   */
  addDeveloperMessage(text) {
    this.messages.push({
      type: "message",
      role: "developer" /* DEVELOPER */,
      content: [
        {
          type: "input_text" /* INPUT_TEXT */,
          text
        }
      ]
    });
    return this;
  }
  /**
   * Build and return the messages array
   */
  build() {
    return this.messages;
  }
  /**
   * Clear all messages
   */
  clear() {
    this.messages = [];
    return this;
  }
  /**
   * Get the current message count
   */
  count() {
    return this.messages.length;
  }
};
function createTextMessage(text, role = "user" /* USER */) {
  return {
    type: "message",
    role,
    content: [
      {
        type: "input_text" /* INPUT_TEXT */,
        text
      }
    ]
  };
}
function createMessageWithImages(text, imageUrls, role = "user" /* USER */) {
  const content = [
    {
      type: "input_text" /* INPUT_TEXT */,
      text
    }
  ];
  for (const url2 of imageUrls) {
    content.push({
      type: "input_image_url" /* INPUT_IMAGE_URL */,
      image_url: {
        url: url2,
        detail: "auto"
      }
    });
  }
  return {
    type: "message",
    role,
    content
  };
}
var execAsync = util.promisify(child_process.exec);
function cleanupTempFile(filePath) {
  try {
    if (fs19__namespace.existsSync(filePath)) {
      fs19__namespace.unlinkSync(filePath);
    }
  } catch {
  }
}
async function readClipboardImage() {
  const platform2 = os2__namespace.platform();
  try {
    switch (platform2) {
      case "darwin":
        return await readClipboardImageMac();
      case "linux":
        return await readClipboardImageLinux();
      case "win32":
        return await readClipboardImageWindows();
      default:
        return {
          success: false,
          error: `Unsupported platform: ${platform2}`
        };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
async function readClipboardImageMac() {
  const tempFile = path2__namespace.join(os2__namespace.tmpdir(), `clipboard-${Date.now()}.png`);
  try {
    try {
      await execAsync(`pngpaste "${tempFile}"`);
      return await convertFileToDataUri(tempFile);
    } catch (pngpasteError) {
      const script = `
        set theFile to (POSIX file "${tempFile}")
        try
          set theImage to the clipboard as \xABclass PNGf\xBB
          set fileRef to open for access theFile with write permission
          write theImage to fileRef
          close access fileRef
          return "success"
        on error errMsg
          try
            close access theFile
          end try
          error errMsg
        end try
      `;
      const { stdout } = await execAsync(`osascript -e '${script}'`);
      if (stdout.includes("success") || fs19__namespace.existsSync(tempFile)) {
        return await convertFileToDataUri(tempFile);
      }
      return {
        success: false,
        error: "No image found in clipboard. Try copying an image first (Cmd+C or screenshot with Cmd+Ctrl+Shift+4)"
      };
    }
  } finally {
    cleanupTempFile(tempFile);
  }
}
async function readClipboardImageLinux() {
  const tempFile = path2__namespace.join(os2__namespace.tmpdir(), `clipboard-${Date.now()}.png`);
  try {
    try {
      await execAsync(`xclip -selection clipboard -t image/png -o > "${tempFile}"`);
      if (fs19__namespace.existsSync(tempFile) && fs19__namespace.statSync(tempFile).size > 0) {
        return await convertFileToDataUri(tempFile);
      }
    } catch {
    }
    try {
      await execAsync(`wl-paste -t image/png > "${tempFile}"`);
      if (fs19__namespace.existsSync(tempFile) && fs19__namespace.statSync(tempFile).size > 0) {
        return await convertFileToDataUri(tempFile);
      }
    } catch {
    }
    return {
      success: false,
      error: "No image in clipboard. Install xclip (X11) or wl-clipboard (Wayland)"
    };
  } finally {
    cleanupTempFile(tempFile);
  }
}
async function readClipboardImageWindows() {
  const tempFile = path2__namespace.join(os2__namespace.tmpdir(), `clipboard-${Date.now()}.png`);
  try {
    const psScript = `
      Add-Type -AssemblyName System.Windows.Forms;
      $clip = [System.Windows.Forms.Clipboard]::GetImage();
      if ($clip -ne $null) {
        $clip.Save('${tempFile.replace(/\\/g, "\\\\")}', [System.Drawing.Imaging.ImageFormat]::Png);
        Write-Output 'success';
      } else {
        Write-Error 'No image in clipboard';
      }
    `;
    await execAsync(`powershell -Command "${psScript}"`);
    if (fs19__namespace.existsSync(tempFile) && fs19__namespace.statSync(tempFile).size > 0) {
      return await convertFileToDataUri(tempFile);
    }
    return {
      success: false,
      error: "No image found in clipboard"
    };
  } finally {
    cleanupTempFile(tempFile);
  }
}
async function convertFileToDataUri(filePath) {
  try {
    const imageBuffer = fs19__namespace.readFileSync(filePath);
    const base64Image = imageBuffer.toString("base64");
    const magic = imageBuffer.slice(0, 4).toString("hex");
    let mimeType = "image/png";
    if (magic.startsWith("89504e47")) {
      mimeType = "image/png";
    } else if (magic.startsWith("ffd8ff")) {
      mimeType = "image/jpeg";
    } else if (magic.startsWith("47494638")) {
      mimeType = "image/gif";
    } else if (magic.startsWith("52494646")) {
      mimeType = "image/webp";
    }
    const dataUri = `data:${mimeType};base64,${base64Image}`;
    return {
      success: true,
      dataUri,
      format: mimeType
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
async function hasClipboardImage() {
  const platform2 = os2__namespace.platform();
  try {
    switch (platform2) {
      case "darwin":
        const { stdout } = await execAsync('osascript -e "clipboard info"');
        return stdout.includes("\xABclass PNGf\xBB") || stdout.includes("public.png");
      case "linux":
        try {
          await execAsync("xclip -selection clipboard -t TARGETS -o | grep -q image");
          return true;
        } catch {
          return false;
        }
      case "win32":
        const psCheck = `
          Add-Type -AssemblyName System.Windows.Forms;
          if ([System.Windows.Forms.Clipboard]::GetImage() -ne $null) {
            Write-Output 'true'
          } else {
            Write-Output 'false'
          }
        `;
        const { stdout: result } = await execAsync(`powershell -Command "${psCheck}"`);
        return result.trim() === "true";
      default:
        return false;
    }
  } catch {
    return false;
  }
}

// src/tools/index.ts
var tools_exports = {};
__export(tools_exports, {
  ConnectorTools: () => ConnectorTools,
  DEFAULT_DESKTOP_CONFIG: () => DEFAULT_DESKTOP_CONFIG,
  DEFAULT_FILESYSTEM_CONFIG: () => DEFAULT_FILESYSTEM_CONFIG,
  DEFAULT_SHELL_CONFIG: () => DEFAULT_SHELL_CONFIG,
  DESKTOP_TOOL_NAMES: () => DESKTOP_TOOL_NAMES,
  DocumentReader: () => DocumentReader,
  FileMediaOutputHandler: () => FileMediaStorage,
  FormatDetector: () => FormatDetector,
  NutTreeDriver: () => NutTreeDriver,
  ToolRegistry: () => ToolRegistry,
  applyHumanDelay: () => applyHumanDelay,
  bash: () => bash,
  createBashTool: () => createBashTool,
  createCreatePRTool: () => createCreatePRTool,
  createCustomToolDelete: () => createCustomToolDelete,
  createCustomToolDraft: () => createCustomToolDraft,
  createCustomToolList: () => createCustomToolList,
  createCustomToolLoad: () => createCustomToolLoad,
  createCustomToolMetaTools: () => createCustomToolMetaTools,
  createCustomToolSave: () => createCustomToolSave,
  createCustomToolTest: () => createCustomToolTest,
  createDesktopGetCursorTool: () => createDesktopGetCursorTool,
  createDesktopGetScreenSizeTool: () => createDesktopGetScreenSizeTool,
  createDesktopKeyboardKeyTool: () => createDesktopKeyboardKeyTool,
  createDesktopKeyboardTypeTool: () => createDesktopKeyboardTypeTool,
  createDesktopMouseClickTool: () => createDesktopMouseClickTool,
  createDesktopMouseDragTool: () => createDesktopMouseDragTool,
  createDesktopMouseMoveTool: () => createDesktopMouseMoveTool,
  createDesktopMouseScrollTool: () => createDesktopMouseScrollTool,
  createDesktopScreenshotTool: () => createDesktopScreenshotTool,
  createDesktopWindowFocusTool: () => createDesktopWindowFocusTool,
  createDesktopWindowListTool: () => createDesktopWindowListTool,
  createDraftEmailTool: () => createDraftEmailTool,
  createEditFileTool: () => createEditFileTool,
  createEditMeetingTool: () => createEditMeetingTool,
  createExecuteJavaScriptTool: () => createExecuteJavaScriptTool,
  createFindMeetingSlotsTool: () => createFindMeetingSlotsTool,
  createGetMeetingTranscriptTool: () => createGetMeetingTranscriptTool,
  createGetPRTool: () => createGetPRTool,
  createGitHubReadFileTool: () => createGitHubReadFileTool,
  createGlobTool: () => createGlobTool,
  createGrepTool: () => createGrepTool,
  createImageGenerationTool: () => createImageGenerationTool,
  createListDirectoryTool: () => createListDirectoryTool,
  createMeetingTool: () => createMeetingTool,
  createPRCommentsTool: () => createPRCommentsTool,
  createPRFilesTool: () => createPRFilesTool,
  createReadFileTool: () => createReadFileTool,
  createSearchCodeTool: () => createSearchCodeTool,
  createSearchFilesTool: () => createSearchFilesTool,
  createSendEmailTool: () => createSendEmailTool,
  createSpeechToTextTool: () => createSpeechToTextTool,
  createTextToSpeechTool: () => createTextToSpeechTool,
  createVideoTools: () => createVideoTools,
  createWebScrapeTool: () => createWebScrapeTool,
  createWebSearchTool: () => createWebSearchTool,
  createWriteFileTool: () => createWriteFileTool,
  customToolDelete: () => customToolDelete,
  customToolDraft: () => customToolDraft,
  customToolList: () => customToolList,
  customToolLoad: () => customToolLoad,
  customToolSave: () => customToolSave,
  customToolTest: () => customToolTest,
  desktopGetCursor: () => desktopGetCursor,
  desktopGetScreenSize: () => desktopGetScreenSize,
  desktopKeyboardKey: () => desktopKeyboardKey,
  desktopKeyboardType: () => desktopKeyboardType,
  desktopMouseClick: () => desktopMouseClick,
  desktopMouseDrag: () => desktopMouseDrag,
  desktopMouseMove: () => desktopMouseMove,
  desktopMouseScroll: () => desktopMouseScroll,
  desktopScreenshot: () => desktopScreenshot,
  desktopTools: () => desktopTools,
  desktopWindowFocus: () => desktopWindowFocus,
  desktopWindowList: () => desktopWindowList,
  developerTools: () => developerTools,
  editFile: () => editFile,
  executeInVM: () => executeInVM,
  executeJavaScript: () => executeJavaScript,
  expandTilde: () => expandTilde,
  formatAttendees: () => formatAttendees,
  formatRecipients: () => formatRecipients,
  getAllBuiltInTools: () => getAllBuiltInTools,
  getBackgroundOutput: () => getBackgroundOutput,
  getDesktopDriver: () => getDesktopDriver,
  getMediaOutputHandler: () => getMediaOutputHandler,
  getMediaStorage: () => getMediaStorage,
  getToolByName: () => getToolByName,
  getToolCategories: () => getToolCategories,
  getToolRegistry: () => getToolRegistry,
  getToolsByCategory: () => getToolsByCategory,
  getToolsRequiringConnector: () => getToolsRequiringConnector,
  getUserPathPrefix: () => getUserPathPrefix,
  glob: () => glob,
  grep: () => grep,
  hydrateCustomTool: () => hydrateCustomTool,
  isBlockedCommand: () => isBlockedCommand,
  isExcludedExtension: () => isExcludedExtension,
  isTeamsMeetingUrl: () => isTeamsMeetingUrl,
  jsonManipulator: () => jsonManipulator,
  killBackgroundProcess: () => killBackgroundProcess,
  listDirectory: () => listDirectory,
  mergeTextPieces: () => mergeTextPieces,
  microsoftFetch: () => microsoftFetch,
  normalizeEmails: () => normalizeEmails,
  parseKeyCombo: () => parseKeyCombo,
  parseRepository: () => parseRepository,
  readFile: () => readFile5,
  resetDefaultDriver: () => resetDefaultDriver,
  resolveMeetingId: () => resolveMeetingId,
  resolveRepository: () => resolveRepository,
  setMediaOutputHandler: () => setMediaOutputHandler,
  setMediaStorage: () => setMediaStorage,
  toolRegistry: () => toolRegistry,
  validatePath: () => validatePath,
  webFetch: () => webFetch,
  writeFile: () => writeFile5
});
var DEFAULT_FILESYSTEM_CONFIG = {
  workingDirectory: process.cwd(),
  allowedDirectories: [],
  blockedDirectories: ["node_modules", ".git", ".svn", ".hg", "__pycache__", ".cache"],
  maxFileSize: 10 * 1024 * 1024,
  // 10MB
  maxResults: 1e3,
  followSymlinks: false,
  excludeExtensions: [
    ".exe",
    ".dll",
    ".so",
    ".dylib",
    ".bin",
    ".obj",
    ".o",
    ".a",
    ".zip",
    ".tar",
    ".gz",
    ".bz2",
    ".7z",
    ".rar",
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".bmp",
    ".ico",
    ".svg",
    ".webp",
    ".mp3",
    ".mp4",
    ".wav",
    ".avi",
    ".mov",
    ".mkv",
    // Note: .pdf, .docx, .xlsx, .pptx are NOT excluded — DocumentReader handles them
    ".doc",
    ".xls",
    ".ppt",
    // Legacy Office formats not yet supported
    ".woff",
    ".woff2",
    ".ttf",
    ".eot",
    ".otf"
  ]
};
function toForwardSlash(p) {
  return path2.sep === "\\" ? p.replace(/\\/g, "/") : p;
}
function validatePath(inputPath, config = {}) {
  const workingDir = config.workingDirectory || process.cwd();
  const allowedDirs = config.allowedDirectories || [];
  const blockedDirs = config.blockedDirectories || DEFAULT_FILESYSTEM_CONFIG.blockedDirectories;
  let expandedPath = inputPath;
  if (inputPath.startsWith("~/")) {
    expandedPath = path2.resolve(os2.homedir(), inputPath.slice(2));
  } else if (inputPath === "~") {
    expandedPath = os2.homedir();
  }
  let resolvedPath;
  if (path2.isAbsolute(expandedPath)) {
    resolvedPath = path2.normalize(expandedPath);
  } else {
    resolvedPath = path2.resolve(workingDir, expandedPath);
  }
  const normalizedResolved = toForwardSlash(resolvedPath);
  const pathSegments = normalizedResolved.split("/").filter(Boolean);
  for (const blocked of blockedDirs) {
    if (!blocked.includes("/")) {
      if (pathSegments.includes(blocked)) {
        return {
          valid: false,
          resolvedPath,
          error: `Path is in blocked directory: ${blocked}`
        };
      }
    } else {
      const blockedPath = toForwardSlash(path2.isAbsolute(blocked) ? blocked : path2.resolve(workingDir, blocked));
      if (normalizedResolved.startsWith(blockedPath + "/") || normalizedResolved === blockedPath) {
        return {
          valid: false,
          resolvedPath,
          error: `Path is in blocked directory: ${blocked}`
        };
      }
    }
  }
  if (allowedDirs.length > 0) {
    let isAllowed = false;
    for (const allowed of allowedDirs) {
      const allowedPath = toForwardSlash(path2.isAbsolute(allowed) ? allowed : path2.resolve(workingDir, allowed));
      if (normalizedResolved.startsWith(allowedPath + "/") || normalizedResolved === allowedPath) {
        isAllowed = true;
        break;
      }
    }
    if (!isAllowed) {
      return {
        valid: false,
        resolvedPath,
        error: `Path is outside allowed directories`
      };
    }
  }
  return { valid: true, resolvedPath };
}
function expandTilde(inputPath) {
  if (inputPath.startsWith("~/")) {
    return path2.resolve(os2.homedir(), inputPath.slice(2));
  } else if (inputPath === "~") {
    return os2.homedir();
  }
  return inputPath;
}
function isExcludedExtension(filePath, excludeExtensions = DEFAULT_FILESYSTEM_CONFIG.excludeExtensions) {
  const ext = filePath.toLowerCase().substring(filePath.lastIndexOf("."));
  return excludeExtensions.includes(ext);
}
function createReadFileTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "read_file",
        description: `Read content from a file on the local filesystem. Supports text files AND binary document formats \u2014 PDF, DOCX, PPTX, XLSX, ODS, ODT, ODP, and images (PNG, JPG, GIF, WEBP) are automatically converted to markdown text.

USAGE:
- The file_path parameter must be an absolute path, not a relative path
- By default, reads up to 2000 lines starting from the beginning of the file
- You can optionally specify a line offset and limit (especially handy for long files)
- Any lines longer than 2000 characters will be truncated
- Results are returned with line numbers starting at 1

DOCUMENT SUPPORT:
- PDF files: extracted as markdown text with per-page sections
- Word documents (.docx): converted to markdown preserving headings, lists, tables
- PowerPoint (.pptx): extracted slide-by-slide as markdown
- Excel (.xlsx) / CSV / ODS: tables converted to markdown tables
- OpenDocument (.odt, .odp, .ods): converted like their MS Office equivalents
- Images (.png, .jpg, .gif, .webp): described as image metadata
- Binary documents are auto-detected by extension \u2014 just pass the file path

WHEN TO USE:
- To read source code files before making edits
- To understand file contents and structure
- To read configuration files
- To examine log files or data files
- To read PDF, Word, Excel, PowerPoint, or other document files as text

IMPORTANT:
- Always read a file before attempting to edit it
- Use offset/limit for very large files to read in chunks
- The tool will return an error if the file doesn't exist
- offset/limit are ignored for binary document formats (full document is always returned)

EXAMPLES:
- Read entire file: { "file_path": "/path/to/file.ts" }
- Read lines 100-200: { "file_path": "/path/to/file.ts", "offset": 100, "limit": 100 }
- Read a PDF: { "file_path": "/path/to/report.pdf" }
- Read an Excel file: { "file_path": "/path/to/data.xlsx" }
- Read a Word doc: { "file_path": "/path/to/document.docx" }`,
        parameters: {
          type: "object",
          properties: {
            file_path: {
              type: "string",
              description: "The absolute path to the file to read"
            },
            offset: {
              type: "number",
              description: "Line number to start reading from (1-indexed). Only provide if the file is too large to read at once."
            },
            limit: {
              type: "number",
              description: "Number of lines to read. Only provide if the file is too large to read at once."
            }
          },
          required: ["file_path"]
        }
      }
    },
    describeCall: (args) => {
      if (args.offset && args.limit) {
        return `${args.file_path} [lines ${args.offset}-${args.offset + args.limit}]`;
      }
      return args.file_path;
    },
    execute: async (args) => {
      const { file_path, offset = 1, limit = 2e3 } = args;
      const validation = validatePath(file_path, mergedConfig);
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error,
          path: file_path
        };
      }
      const resolvedPath = validation.resolvedPath;
      if (!fs19.existsSync(resolvedPath)) {
        return {
          success: false,
          error: `File not found: ${file_path}`,
          path: file_path
        };
      }
      try {
        const stats = await fs18.stat(resolvedPath);
        if (!stats.isFile()) {
          return {
            success: false,
            error: `Path is not a file: ${file_path}. Use list_directory to explore directories.`,
            path: file_path
          };
        }
        if (stats.size > mergedConfig.maxFileSize) {
          return {
            success: false,
            error: `File is too large (${(stats.size / 1024 / 1024).toFixed(2)}MB). Maximum size is ${(mergedConfig.maxFileSize / 1024 / 1024).toFixed(2)}MB. Use offset and limit to read in chunks.`,
            path: file_path,
            size: stats.size
          };
        }
        const ext = path2.extname(resolvedPath).toLowerCase();
        if (FormatDetector.isBinaryDocumentFormat(ext)) {
          try {
            const reader = DocumentReader.create(mergedConfig.documentReaderConfig);
            const result2 = await reader.read(
              { type: "file", path: resolvedPath },
              {
                extractImages: false,
                ...mergedConfig.documentReaderConfig?.defaults
              }
            );
            if (result2.success) {
              const content2 = mergeTextPieces(result2.pieces);
              return {
                success: true,
                content: content2,
                lines: content2.split("\n").length,
                truncated: false,
                encoding: "document",
                size: stats.size,
                path: file_path
              };
            }
          } catch {
          }
        }
        const content = await fs18.readFile(resolvedPath, "utf-8");
        const allLines = content.split("\n");
        const totalLines = allLines.length;
        const startIndex = Math.max(0, offset - 1);
        const endIndex = Math.min(totalLines, startIndex + limit);
        const selectedLines = allLines.slice(startIndex, endIndex);
        const lineNumberWidth = String(endIndex).length;
        const formattedLines = selectedLines.map((line, i) => {
          const lineNum = startIndex + i + 1;
          const paddedNum = String(lineNum).padStart(lineNumberWidth, " ");
          const truncatedLine = line.length > 2e3 ? line.substring(0, 2e3) + "..." : line;
          return `${paddedNum}	${truncatedLine}`;
        });
        const truncated = endIndex < totalLines;
        const result = formattedLines.join("\n");
        return {
          success: true,
          content: result,
          lines: totalLines,
          truncated,
          encoding: "utf-8",
          size: stats.size,
          path: file_path
        };
      } catch (error) {
        if (error instanceof Error && error.message.includes("encoding")) {
          return {
            success: false,
            error: `File appears to be binary or uses an unsupported encoding: ${file_path}`,
            path: file_path
          };
        }
        return {
          success: false,
          error: `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
          path: file_path
        };
      }
    }
  };
}
var readFile5 = createReadFileTool();
function createWriteFileTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "write_file",
        description: `Write content to a file on the local filesystem.

USAGE:
- This tool will overwrite the existing file if there is one at the provided path
- If the file exists, you MUST use the read_file tool first to read its contents before writing
- The file_path must be an absolute path, not a relative path
- Parent directories will be created automatically if they don't exist

WHEN TO USE:
- To create new files
- To completely replace file contents (after reading the original)
- When the edit_file tool cannot handle the changes needed

IMPORTANT:
- ALWAYS prefer editing existing files over creating new ones
- NEVER proactively create documentation files (*.md) or README files unless explicitly requested
- If modifying an existing file, use edit_file instead for surgical changes
- This tool will FAIL if you try to write to an existing file without reading it first

EXAMPLES:
- Create new file: { "file_path": "/path/to/new-file.ts", "content": "export const x = 1;" }
- Rewrite file: { "file_path": "/path/to/existing.ts", "content": "// new content..." }`,
        parameters: {
          type: "object",
          properties: {
            file_path: {
              type: "string",
              description: "The absolute path to the file to write (must be absolute, not relative)"
            },
            content: {
              type: "string",
              description: "The content to write to the file"
            }
          },
          required: ["file_path", "content"]
        }
      }
    },
    describeCall: (args) => {
      const size = args.content?.length || 0;
      if (size > 1e3) {
        return `${args.file_path} (${Math.round(size / 1024)}KB)`;
      }
      return args.file_path;
    },
    execute: async (args) => {
      const { file_path, content } = args;
      const validation = validatePath(file_path, mergedConfig);
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error,
          path: file_path
        };
      }
      const resolvedPath = validation.resolvedPath;
      const fileExists = fs19.existsSync(resolvedPath);
      try {
        const parentDir = path2.dirname(resolvedPath);
        if (!fs19.existsSync(parentDir)) {
          await fs18.mkdir(parentDir, { recursive: true });
        }
        await fs18.writeFile(resolvedPath, content, "utf-8");
        return {
          success: true,
          path: file_path,
          bytesWritten: Buffer.byteLength(content, "utf-8"),
          created: !fileExists
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to write file: ${error instanceof Error ? error.message : String(error)}`,
          path: file_path
        };
      }
    }
  };
}
var writeFile5 = createWriteFileTool();
function createEditFileTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "edit_file",
        description: `Perform exact string replacements in files.

USAGE:
- You MUST use read_file at least once before editing any file
- The old_string must match EXACTLY what's in the file, including all whitespace and indentation
- When editing text from read_file output, preserve the exact indentation as it appears AFTER the line number prefix
- The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content
- NEVER include any part of the line number prefix in old_string or new_string

IMPORTANT RULES:
- ALWAYS prefer editing existing files over writing new ones
- The edit will FAIL if old_string is not found in the file
- The edit will FAIL if old_string appears more than once (unless replace_all is true)
- Use replace_all: true when you want to rename variables, update imports, etc.
- old_string and new_string must be different

MATCHING TIPS:
- Include enough surrounding context to make old_string unique
- Copy the exact whitespace from the file (spaces vs tabs matter!)
- For indented code, include the full indentation in old_string

EXAMPLES:
- Simple edit:
  { "file_path": "/path/to/file.ts", "old_string": "const x = 1;", "new_string": "const x = 2;" }

- Edit with context for uniqueness:
  { "file_path": "/path/to/file.ts",
    "old_string": "function foo() {\\n  return 1;\\n}",
    "new_string": "function foo() {\\n  return 2;\\n}" }

- Replace all occurrences:
  { "file_path": "/path/to/file.ts", "old_string": "oldName", "new_string": "newName", "replace_all": true }`,
        parameters: {
          type: "object",
          properties: {
            file_path: {
              type: "string",
              description: "The absolute path to the file to modify"
            },
            old_string: {
              type: "string",
              description: "The exact text to find and replace"
            },
            new_string: {
              type: "string",
              description: "The text to replace it with (must be different from old_string)"
            },
            replace_all: {
              type: "boolean",
              description: "Replace all occurrences instead of requiring uniqueness (default: false)"
            }
          },
          required: ["file_path", "old_string", "new_string"]
        }
      }
    },
    describeCall: (args) => {
      const mode = args.replace_all ? " (replace all)" : "";
      return `${args.file_path}${mode}`;
    },
    execute: async (args) => {
      const { file_path, old_string, new_string, replace_all = false } = args;
      if (old_string === new_string) {
        return {
          success: false,
          error: "old_string and new_string must be different",
          path: file_path
        };
      }
      const validation = validatePath(file_path, mergedConfig);
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error,
          path: file_path
        };
      }
      const resolvedPath = validation.resolvedPath;
      if (!fs19.existsSync(resolvedPath)) {
        return {
          success: false,
          error: `File not found: ${file_path}`,
          path: file_path
        };
      }
      try {
        const content = await fs18.readFile(resolvedPath, "utf-8");
        let occurrences = 0;
        let searchIndex = 0;
        while (true) {
          const foundIndex = content.indexOf(old_string, searchIndex);
          if (foundIndex === -1) break;
          occurrences++;
          searchIndex = foundIndex + 1;
        }
        if (occurrences === 0) {
          const trimmedOld = old_string.trim();
          const hasTrimmedMatch = content.includes(trimmedOld);
          let errorMsg = `old_string not found in file. `;
          if (hasTrimmedMatch && trimmedOld !== old_string) {
            errorMsg += `A similar string was found but with different whitespace. Check your indentation matches exactly.`;
          } else {
            errorMsg += `Make sure you're copying the exact text from the file, including all whitespace.`;
          }
          return {
            success: false,
            error: errorMsg,
            path: file_path,
            replacements: 0
          };
        }
        if (occurrences > 1 && !replace_all) {
          return {
            success: false,
            error: `old_string appears ${occurrences} times in the file. Either provide more context to make it unique, or set replace_all: true to replace all occurrences.`,
            path: file_path,
            replacements: 0
          };
        }
        let newContent;
        if (replace_all) {
          newContent = content.split(old_string).join(new_string);
        } else {
          newContent = content.replace(old_string, new_string);
        }
        await fs18.writeFile(resolvedPath, newContent, "utf-8");
        const diffPreview = generateDiffPreview(old_string, new_string);
        return {
          success: true,
          path: file_path,
          replacements: replace_all ? occurrences : 1,
          diff: diffPreview
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to edit file: ${error instanceof Error ? error.message : String(error)}`,
          path: file_path
        };
      }
    }
  };
}
function generateDiffPreview(oldStr, newStr) {
  const oldLines = oldStr.split("\n");
  const newLines = newStr.split("\n");
  const diff = [];
  const maxLines = Math.max(oldLines.length, newLines.length);
  const previewLines = Math.min(maxLines, 5);
  diff.push("--- old");
  for (let i = 0; i < Math.min(oldLines.length, previewLines); i++) {
    diff.push(`- ${oldLines[i]}`);
  }
  if (oldLines.length > previewLines) {
    diff.push(`  ... (${oldLines.length - previewLines} more lines)`);
  }
  diff.push("+++ new");
  for (let i = 0; i < Math.min(newLines.length, previewLines); i++) {
    diff.push(`+ ${newLines[i]}`);
  }
  if (newLines.length > previewLines) {
    diff.push(`  ... (${newLines.length - previewLines} more lines)`);
  }
  return diff.join("\n");
}
var editFile = createEditFileTool();
function matchGlobPattern(pattern, filePath) {
  let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*\*/g, "{{GLOBSTAR}}").replace(/\*/g, "[^/]*").replace(/\?/g, ".").replace(/\{\{GLOBSTAR\}\}/g, ".*");
  regexPattern = "^" + regexPattern + "$";
  try {
    const regex = new RegExp(regexPattern);
    return regex.test(filePath);
  } catch {
    return false;
  }
}
async function findFiles(dir, pattern, baseDir, config, results = [], depth = 0) {
  if (depth > 50 || results.length >= config.maxResults) {
    return results;
  }
  try {
    const entries = await fs18.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (results.length >= config.maxResults) break;
      const fullPath = path2.join(dir, entry.name);
      const relativePath = toForwardSlash(path2.relative(baseDir, fullPath));
      if (entry.isDirectory()) {
        const isBlocked = config.blockedDirectories.some(
          (blocked) => entry.name === blocked || relativePath.includes(`/${blocked}/`) || relativePath.startsWith(`${blocked}/`)
        );
        if (isBlocked) continue;
        await findFiles(fullPath, pattern, baseDir, config, results, depth + 1);
      } else if (entry.isFile()) {
        if (matchGlobPattern(pattern, relativePath)) {
          try {
            const stats = await fs18.stat(fullPath);
            results.push({
              path: relativePath,
              mtime: stats.mtimeMs
            });
          } catch {
          }
        }
      }
    }
  } catch {
  }
  return results;
}
function createGlobTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "glob",
        description: `Fast file pattern matching tool that finds files by name patterns.

USAGE:
- Supports glob patterns like "**/*.js", "src/**/*.ts", "*.{ts,tsx}"
- Returns matching file paths sorted by modification time (newest first)
- Use this tool when you need to find files by name patterns

PATTERN SYNTAX:
- * matches any characters except /
- ** matches any characters including /
- ? matches a single character
- {a,b} matches either a or b

EXAMPLES:
- Find all TypeScript files: { "pattern": "**/*.ts" }
- Find files in src folder: { "pattern": "src/**/*.{ts,tsx}" }
- Find test files: { "pattern": "**/*.test.ts" }
- Find specific file type in path: { "pattern": "src/components/**/*.tsx", "path": "/project" }

WHEN TO USE:
- To find files by extension or name pattern
- To explore project structure
- To find related files (tests, types, etc.)
- Before using grep when you know the file pattern`,
        parameters: {
          type: "object",
          properties: {
            pattern: {
              type: "string",
              description: 'The glob pattern to match files against (e.g., "**/*.ts", "src/**/*.tsx")'
            },
            path: {
              type: "string",
              description: "The directory to search in. If not specified, uses the current working directory. IMPORTANT: Omit this field to use the default directory."
            }
          },
          required: ["pattern"]
        }
      }
    },
    describeCall: (args) => {
      if (args.path) {
        return `${args.pattern} in ${args.path}`;
      }
      return args.pattern;
    },
    execute: async (args) => {
      const { pattern, path: path6 } = args;
      const searchDir = path6 || mergedConfig.workingDirectory;
      const validation = validatePath(searchDir, {
        ...mergedConfig,
        blockedDirectories: []
        // Allow searching from any valid directory
      });
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error
        };
      }
      const resolvedDir = validation.resolvedPath;
      if (!fs19.existsSync(resolvedDir)) {
        return {
          success: false,
          error: `Directory not found: ${searchDir}`
        };
      }
      try {
        const results = await findFiles(resolvedDir, pattern, resolvedDir, mergedConfig);
        results.sort((a, b) => b.mtime - a.mtime);
        const truncated = results.length >= mergedConfig.maxResults;
        return {
          success: true,
          files: results.map((r) => r.path),
          count: results.length,
          truncated
        };
      } catch (error) {
        return {
          success: false,
          error: `Glob search failed: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}
var glob = createGlobTool();
var FILE_TYPE_MAP = {
  ts: [".ts", ".tsx"],
  js: [".js", ".jsx", ".mjs", ".cjs"],
  py: [".py", ".pyi"],
  java: [".java"],
  go: [".go"],
  rust: [".rs"],
  c: [".c", ".h"],
  cpp: [".cpp", ".hpp", ".cc", ".hh", ".cxx", ".hxx"],
  cs: [".cs"],
  rb: [".rb"],
  php: [".php"],
  swift: [".swift"],
  kotlin: [".kt", ".kts"],
  scala: [".scala"],
  html: [".html", ".htm"],
  css: [".css", ".scss", ".sass", ".less"],
  json: [".json"],
  yaml: [".yaml", ".yml"],
  xml: [".xml"],
  md: [".md", ".markdown"],
  sql: [".sql"],
  sh: [".sh", ".bash", ".zsh"]
};
async function findFilesToSearch(dir, baseDir, config, globPattern, fileType, files = [], depth = 0) {
  if (depth > 50 || files.length >= config.maxResults * 10) {
    return files;
  }
  try {
    const entries = await fs18.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      if (entry.isDirectory()) {
        const isBlocked = config.blockedDirectories.some(
          (blocked) => entry.name === blocked
        );
        if (isBlocked) continue;
        await findFilesToSearch(fullPath, baseDir, config, globPattern, fileType, files, depth + 1);
      } else if (entry.isFile()) {
        if (isExcludedExtension(entry.name, config.excludeExtensions)) continue;
        if (fileType) {
          const extensions = FILE_TYPE_MAP[fileType.toLowerCase()];
          if (extensions) {
            const ext = path2.extname(entry.name).toLowerCase();
            if (!extensions.includes(ext)) continue;
          }
        }
        if (globPattern) {
          const pattern = globPattern.replace(/\./g, "\\.").replace(/\*/g, ".*").replace(/\{([^}]+)\}/g, (_, p) => `(${p.split(",").join("|")})`);
          const regex = new RegExp(pattern + "$");
          if (!regex.test(entry.name)) continue;
        }
        files.push(fullPath);
      }
    }
  } catch {
  }
  return files;
}
async function searchFile(filePath, regex, contextBefore, contextAfter) {
  const matches = [];
  try {
    const content = await fs18.readFile(filePath, "utf-8");
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i] ?? "";
      regex.lastIndex = 0;
      if (regex.test(line)) {
        const match = {
          file: filePath,
          line: i + 1,
          content: line.length > 500 ? line.substring(0, 500) + "..." : line
        };
        if (contextBefore > 0 || contextAfter > 0) {
          match.context = {
            before: lines.slice(Math.max(0, i - contextBefore), i).map((l) => l.length > 200 ? l.substring(0, 200) + "..." : l),
            after: lines.slice(i + 1, Math.min(lines.length, i + 1 + contextAfter)).map((l) => l.length > 200 ? l.substring(0, 200) + "..." : l)
          };
        }
        matches.push(match);
      }
    }
  } catch {
  }
  return matches;
}
function createGrepTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "grep",
        description: `A powerful search tool for finding content within files.

USAGE:
- Search for patterns using full regex syntax (e.g., "log.*Error", "function\\s+\\w+")
- Filter files with glob parameter (e.g., "*.js", "**/*.tsx") or type parameter (e.g., "js", "py")
- Output modes: "content" shows matching lines, "files_with_matches" shows only file paths, "count" shows match counts

PATTERN SYNTAX:
- Uses JavaScript regex syntax (not grep)
- Literal braces need escaping (use \\{ and \\} to find { and })
- Common patterns:
  - "TODO" - literal text
  - "function\\s+\\w+" - function declarations
  - "import.*from" - import statements
  - "\\bclass\\b" - word boundary matching

OUTPUT MODES:
- "content" - Shows matching lines with line numbers (default)
- "files_with_matches" - Shows only file paths that contain matches
- "count" - Shows match counts per file

EXAMPLES:
- Find TODO comments: { "pattern": "TODO|FIXME", "type": "ts" }
- Find function calls: { "pattern": "fetchUser\\(", "glob": "*.ts" }
- Find imports: { "pattern": "import.*react", "case_insensitive": true }
- List files with errors: { "pattern": "error", "output_mode": "files_with_matches" }
- Count matches: { "pattern": "console\\.log", "output_mode": "count" }

WHEN TO USE:
- To find where something is defined or used
- To search for patterns across multiple files
- To find all occurrences of a term
- Before making bulk changes`,
        parameters: {
          type: "object",
          properties: {
            pattern: {
              type: "string",
              description: "The regex pattern to search for in file contents"
            },
            path: {
              type: "string",
              description: "File or directory to search in. Defaults to current working directory."
            },
            glob: {
              type: "string",
              description: 'Glob pattern to filter files (e.g., "*.js", "*.{ts,tsx}")'
            },
            type: {
              type: "string",
              description: 'File type to search (e.g., "ts", "js", "py", "java", "go"). More efficient than glob.'
            },
            output_mode: {
              type: "string",
              enum: ["content", "files_with_matches", "count"],
              description: 'Output mode: "content" shows lines, "files_with_matches" shows paths, "count" shows counts. Default: "files_with_matches"'
            },
            case_insensitive: {
              type: "boolean",
              description: "Case insensitive search (default: false)"
            },
            context_before: {
              type: "number",
              description: 'Number of lines to show before each match (requires output_mode: "content")'
            },
            context_after: {
              type: "number",
              description: 'Number of lines to show after each match (requires output_mode: "content")'
            },
            limit: {
              type: "number",
              description: "Limit output to first N results. Default: unlimited."
            }
          },
          required: ["pattern"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [`"${args.pattern}"`];
      if (args.glob) parts.push(`in ${args.glob}`);
      else if (args.type) parts.push(`in *.${args.type}`);
      if (args.path) parts.push(`(${args.path})`);
      return parts.join(" ");
    },
    execute: async (args) => {
      const {
        pattern,
        path: path6,
        glob: globPattern,
        type: fileType,
        output_mode = "files_with_matches",
        case_insensitive = false,
        context_before = 0,
        context_after = 0,
        limit
      } = args;
      const searchPath = path6 || mergedConfig.workingDirectory;
      const validation = validatePath(searchPath, {
        ...mergedConfig,
        blockedDirectories: []
        // Allow grep from any valid directory
      });
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error
        };
      }
      const resolvedPath = validation.resolvedPath;
      if (!fs19.existsSync(resolvedPath)) {
        return {
          success: false,
          error: `Path not found: ${searchPath}`
        };
      }
      let regex;
      try {
        regex = new RegExp(pattern, case_insensitive ? "gi" : "g");
      } catch (error) {
        return {
          success: false,
          error: `Invalid regex pattern: ${error instanceof Error ? error.message : String(error)}`
        };
      }
      try {
        const stats = await fs18.stat(resolvedPath);
        let filesToSearch;
        if (stats.isFile()) {
          filesToSearch = [resolvedPath];
        } else {
          filesToSearch = await findFilesToSearch(
            resolvedPath,
            resolvedPath,
            mergedConfig,
            globPattern,
            fileType
          );
        }
        const allMatches = [];
        const fileMatchCounts = /* @__PURE__ */ new Map();
        let filesMatched = 0;
        for (const file of filesToSearch) {
          if (limit && allMatches.length >= limit) break;
          const matches = await searchFile(
            file,
            regex,
            output_mode === "content" ? context_before : 0,
            output_mode === "content" ? context_after : 0
          );
          if (matches.length > 0) {
            filesMatched++;
            const relativePath = toForwardSlash(path2.relative(resolvedPath, file)) || file;
            for (const match of matches) {
              match.file = relativePath;
            }
            fileMatchCounts.set(relativePath, matches.length);
            if (output_mode === "content") {
              const remaining = limit ? limit - allMatches.length : Infinity;
              allMatches.push(...matches.slice(0, remaining));
            } else {
              const firstMatch = matches[0];
              if (firstMatch) {
                allMatches.push(firstMatch);
              }
            }
          }
        }
        let resultMatches;
        switch (output_mode) {
          case "files_with_matches":
            const uniqueFiles = new Set(allMatches.map((m) => m.file));
            resultMatches = Array.from(uniqueFiles).map((file) => ({
              file,
              line: 0,
              content: ""
            }));
            break;
          case "count":
            resultMatches = Array.from(fileMatchCounts.entries()).map(([file, count]) => ({
              file,
              line: count,
              content: `${count} matches`
            }));
            break;
          case "content":
          default:
            resultMatches = allMatches;
        }
        const totalMatches = Array.from(fileMatchCounts.values()).reduce((a, b) => a + b, 0);
        const truncated = limit ? allMatches.length >= limit : totalMatches >= mergedConfig.maxResults;
        return {
          success: true,
          matches: resultMatches,
          filesSearched: filesToSearch.length,
          filesMatched,
          totalMatches,
          truncated
        };
      } catch (error) {
        return {
          success: false,
          error: `Grep search failed: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}
var grep = createGrepTool();
async function listDir(dir, baseDir, config, recursive, filter, maxDepth = 3, currentDepth = 0, entries = []) {
  if (currentDepth > maxDepth || entries.length >= config.maxResults) {
    return entries;
  }
  try {
    const dirEntries = await fs18.readdir(dir, { withFileTypes: true });
    for (const entry of dirEntries) {
      if (entries.length >= config.maxResults) break;
      const fullPath = path2.join(dir, entry.name);
      const relativePath = toForwardSlash(path2.relative(baseDir, fullPath));
      if (entry.isDirectory() && config.blockedDirectories.includes(entry.name)) {
        continue;
      }
      const isFile = entry.isFile();
      const isDir = entry.isDirectory();
      if (filter === "files" && !isFile) {
        if (isDir && recursive) {
          await listDir(fullPath, baseDir, config, recursive, filter, maxDepth, currentDepth + 1, entries);
        }
        continue;
      }
      if (filter === "directories" && !isDir) continue;
      try {
        const stats = await fs18.stat(fullPath);
        const dirEntry = {
          name: entry.name,
          path: relativePath,
          type: isFile ? "file" : "directory"
        };
        if (isFile) {
          dirEntry.size = stats.size;
        }
        dirEntry.modified = stats.mtime.toISOString();
        entries.push(dirEntry);
        if (isDir && recursive) {
          await listDir(fullPath, baseDir, config, recursive, filter, maxDepth, currentDepth + 1, entries);
        }
      } catch {
      }
    }
  } catch {
  }
  return entries;
}
function createListDirectoryTool(config = {}) {
  const mergedConfig = { ...DEFAULT_FILESYSTEM_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "list_directory",
        description: `List the contents of a directory on the local filesystem.

USAGE:
- Shows files and directories in the specified path
- Includes file sizes and modification times
- Can list recursively with depth limit
- Can filter to show only files or only directories

WHEN TO USE:
- To explore a project's structure
- To see what files exist in a directory
- To find files before using read_file or edit_file
- As an alternative to glob when you want to see directory structure

EXAMPLES:
- List current directory: { "path": "." }
- List specific directory: { "path": "/path/to/project/src" }
- List recursively: { "path": ".", "recursive": true, "max_depth": 2 }
- List only files: { "path": ".", "filter": "files" }
- List only directories: { "path": ".", "filter": "directories" }`,
        parameters: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "Path to the directory to list"
            },
            recursive: {
              type: "boolean",
              description: "Whether to list recursively (default: false)"
            },
            filter: {
              type: "string",
              enum: ["files", "directories"],
              description: "Filter to show only files or only directories"
            },
            max_depth: {
              type: "number",
              description: "Maximum depth for recursive listing (default: 3)"
            }
          },
          required: ["path"]
        }
      }
    },
    describeCall: (args) => {
      const flags = [];
      if (args.recursive) flags.push("recursive");
      if (args.filter) flags.push(args.filter);
      if (flags.length > 0) {
        return `${args.path} (${flags.join(", ")})`;
      }
      return args.path;
    },
    execute: async (args) => {
      const { path: path6, recursive = false, filter, max_depth = 3 } = args;
      const validation = validatePath(path6, {
        ...mergedConfig,
        blockedDirectories: []
        // Allow listing any valid directory
      });
      if (!validation.valid) {
        return {
          success: false,
          error: validation.error
        };
      }
      const resolvedPath = validation.resolvedPath;
      if (!fs19.existsSync(resolvedPath)) {
        return {
          success: false,
          error: `Directory not found: ${path6}`
        };
      }
      try {
        const stats = await fs18.stat(resolvedPath);
        if (!stats.isDirectory()) {
          return {
            success: false,
            error: `Path is not a directory: ${path6}. Use read_file to read file contents.`
          };
        }
        const entries = await listDir(
          resolvedPath,
          resolvedPath,
          mergedConfig,
          recursive,
          filter,
          max_depth
        );
        entries.sort((a, b) => {
          if (a.type !== b.type) {
            return a.type === "directory" ? -1 : 1;
          }
          return a.name.localeCompare(b.name);
        });
        const truncated = entries.length >= mergedConfig.maxResults;
        return {
          success: true,
          entries,
          count: entries.length,
          truncated
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to list directory: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}
var listDirectory = createListDirectoryTool();

// src/tools/shell/types.ts
var DEFAULT_SHELL_CONFIG = {
  workingDirectory: process.cwd(),
  defaultTimeout: 12e4,
  // 2 minutes
  maxTimeout: 6e5,
  // 10 minutes
  shell: process.platform === "win32" ? "cmd.exe" : "/bin/bash",
  env: {},
  blockedCommands: [
    "rm -rf /",
    "rm -rf /*",
    "rm -rf ~",
    "rm -rf ~/*",
    "mkfs",
    "dd if=/dev/zero",
    ":(){:|:&};:"
    // Fork bomb
  ],
  blockedPatterns: [
    /rm\s+(-rf?|--recursive)\s+\/(?!\S)/i,
    // rm -rf / variations
    />\s*\/dev\/sd[a-z]/i,
    // Writing to disk devices
    /mkfs/i,
    /dd\s+.*of=\/dev\//i
    // dd to devices
  ],
  maxOutputSize: 1e5,
  allowBackground: true
};
function isBlockedCommand(command, config = {}) {
  const blockedCommands = config.blockedCommands || DEFAULT_SHELL_CONFIG.blockedCommands;
  const blockedPatterns = config.blockedPatterns || DEFAULT_SHELL_CONFIG.blockedPatterns;
  for (const blocked of blockedCommands) {
    if (command.includes(blocked)) {
      return { blocked: true, reason: `Command contains blocked sequence: "${blocked}"` };
    }
  }
  for (const pattern of blockedPatterns) {
    if (pattern.test(command)) {
      return { blocked: true, reason: `Command matches blocked pattern` };
    }
  }
  return { blocked: false };
}
var backgroundProcesses = /* @__PURE__ */ new Map();
function generateBackgroundId() {
  return `bg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function createBashTool(config = {}) {
  const mergedConfig = { ...DEFAULT_SHELL_CONFIG, ...config };
  return {
    definition: {
      type: "function",
      function: {
        name: "bash",
        description: `Execute shell commands with optional timeout.

SHELL: This tool uses ${mergedConfig.shell}${process.platform === "win32" ? " (Windows). Use Windows command syntax (dir, type, del, etc.), NOT Unix commands (ls, cat, rm, etc.). Use \\ as path separator or quote paths with forward slashes." : " (Unix). Use standard Unix command syntax."}

USAGE:
- Execute any shell command
- Working directory persists between commands
- Commands timeout after 2 minutes by default (configurable up to 10 minutes)
- Large outputs (>100KB) will be truncated

IMPORTANT: This tool is for terminal operations like git, npm, docker, etc.
For file operations, prefer dedicated tools:
- Use read_file instead of cat/head/tail
- Use edit_file instead of sed/awk
- Use write_file instead of echo with redirection
- Use glob instead of find
- Use grep tool instead of grep command

BEST PRACTICES:
- Always quote file paths with spaces: cd "/path with spaces"
- Use absolute paths when possible${process.platform === "win32" ? `
- Chain dependent commands with &&: git add . && git commit -m "msg"
- Use PowerShell syntax if cmd.exe is insufficient` : `
- Chain dependent commands with &&: git add . && git commit -m "msg"
- Use ; only when you don't care if earlier commands fail`}
- Avoid interactive commands (no -i flags)

GIT SAFETY:
- NEVER run destructive commands (push --force, reset --hard, clean -f) without explicit permission
- NEVER update git config
- NEVER skip hooks (--no-verify) without permission
- Always create NEW commits rather than amending
- Stage specific files rather than using "git add -A"

EXAMPLES:
- Run npm install: { "command": "npm install", "description": "Install dependencies" }
- Check git status: { "command": "git status", "description": "Show working tree status" }
- Run tests: { "command": "npm test", "timeout": 300000, "description": "Run test suite" }
- Build project: { "command": "npm run build", "description": "Build the project" }`,
        parameters: {
          type: "object",
          properties: {
            command: {
              type: "string",
              description: "The shell command to execute"
            },
            timeout: {
              type: "number",
              description: "Optional timeout in milliseconds (max 600000ms / 10 minutes)"
            },
            description: {
              type: "string",
              description: "Clear, concise description of what this command does"
            },
            run_in_background: {
              type: "boolean",
              description: "Run the command in the background. Returns immediately with a background ID."
            }
          },
          required: ["command"]
        }
      }
    },
    describeCall: (args) => {
      const cmd = args.command;
      const maxLen = 60;
      const prefix = args.run_in_background ? "[bg] " : "";
      if (cmd.length > maxLen - prefix.length) {
        return prefix + cmd.slice(0, maxLen - prefix.length - 3) + "...";
      }
      return prefix + cmd;
    },
    execute: async (args) => {
      const {
        command,
        timeout = mergedConfig.defaultTimeout,
        run_in_background = false
      } = args;
      const blockCheck = isBlockedCommand(command, mergedConfig);
      if (blockCheck.blocked) {
        return {
          success: false,
          error: `Command blocked for safety: ${blockCheck.reason}`
        };
      }
      const effectiveTimeout = Math.min(timeout, mergedConfig.maxTimeout);
      const env = {
        ...process.env,
        ...mergedConfig.env
      };
      return new Promise((resolve4) => {
        const startTime = Date.now();
        const childProcess = child_process.spawn(command, [], {
          shell: mergedConfig.shell,
          cwd: mergedConfig.workingDirectory,
          env,
          stdio: ["pipe", "pipe", "pipe"],
          detached: true
        });
        if (run_in_background && mergedConfig.allowBackground) {
          const bgId = generateBackgroundId();
          const output = [];
          backgroundProcesses.set(bgId, { process: childProcess, output });
          childProcess.stdout.on("data", (data) => {
            output.push(data.toString());
          });
          childProcess.stderr.on("data", (data) => {
            output.push(data.toString());
          });
          childProcess.on("close", () => {
            setTimeout(() => {
              backgroundProcesses.delete(bgId);
            }, 3e5);
          });
          resolve4({
            success: true,
            backgroundId: bgId,
            stdout: `Command started in background with ID: ${bgId}`
          });
          return;
        }
        let stdout = "";
        let stderr = "";
        let killed = false;
        const killProcessGroup = (signal) => {
          try {
            if (childProcess.pid) {
              process.kill(-childProcess.pid, signal);
            }
          } catch {
            try {
              childProcess.kill(signal);
            } catch {
            }
          }
        };
        const GRACEFUL_KILL_WAIT_MS = 3e3;
        const timeoutId = setTimeout(() => {
          killed = true;
          killProcessGroup("SIGTERM");
          setTimeout(() => {
            if (!childProcess.killed) {
              killProcessGroup("SIGKILL");
            }
          }, GRACEFUL_KILL_WAIT_MS);
        }, effectiveTimeout);
        childProcess.stdout.on("data", (data) => {
          stdout += data.toString();
          if (stdout.length > mergedConfig.maxOutputSize * 2) {
            stdout = stdout.slice(-mergedConfig.maxOutputSize);
          }
        });
        childProcess.stderr.on("data", (data) => {
          stderr += data.toString();
          if (stderr.length > mergedConfig.maxOutputSize * 2) {
            stderr = stderr.slice(-mergedConfig.maxOutputSize);
          }
        });
        let resolved = false;
        const safeResolve = (result) => {
          if (resolved) return;
          resolved = true;
          clearTimeout(timeoutId);
          clearTimeout(hardTimeoutId);
          resolve4(result);
        };
        const HARD_TIMEOUT_GRACE_MS = 5e3;
        const hardTimeoutId = setTimeout(() => {
          if (!resolved) {
            killProcessGroup("SIGKILL");
            safeResolve({
              success: false,
              stdout,
              stderr,
              duration: Date.now() - startTime,
              error: `Command timed out after ${effectiveTimeout}ms (hard timeout: process group did not exit)`
            });
          }
        }, effectiveTimeout + GRACEFUL_KILL_WAIT_MS + HARD_TIMEOUT_GRACE_MS);
        childProcess.on("close", (code, signal) => {
          const duration = Date.now() - startTime;
          let truncated = false;
          if (stdout.length > mergedConfig.maxOutputSize) {
            stdout = stdout.slice(0, mergedConfig.maxOutputSize) + "\n... (output truncated)";
            truncated = true;
          }
          if (stderr.length > mergedConfig.maxOutputSize) {
            stderr = stderr.slice(0, mergedConfig.maxOutputSize) + "\n... (output truncated)";
            truncated = true;
          }
          if (killed) {
            safeResolve({
              success: false,
              stdout,
              stderr,
              exitCode: code ?? void 0,
              signal: signal ?? void 0,
              duration,
              truncated,
              error: `Command timed out after ${effectiveTimeout}ms`
            });
          } else {
            safeResolve({
              success: code === 0,
              stdout,
              stderr,
              exitCode: code ?? void 0,
              signal: signal ?? void 0,
              duration,
              truncated,
              error: code !== 0 ? `Command exited with code ${code}` : void 0
            });
          }
        });
        childProcess.on("error", (error) => {
          safeResolve({
            success: false,
            error: `Failed to execute command: ${error.message}`,
            duration: Date.now() - startTime
          });
        });
      });
    }
  };
}
function getBackgroundOutput(bgId) {
  const bg = backgroundProcesses.get(bgId);
  if (!bg) {
    return { found: false };
  }
  return {
    found: true,
    output: bg.output.join(""),
    running: !bg.process.killed && bg.process.exitCode === null
  };
}
function killBackgroundProcess(bgId) {
  const bg = backgroundProcesses.get(bgId);
  if (!bg) {
    return false;
  }
  bg.process.kill("SIGTERM");
  return true;
}
var bash = createBashTool();

// src/tools/json/pathUtils.ts
function parsePath(path6) {
  if (path6 === "" || path6 === "$") {
    return [];
  }
  const keys = path6.split(".");
  const filtered = keys.filter((p) => p.length > 0);
  if (filtered.length !== keys.length) {
    throw new Error(`Invalid path format: ${path6} (consecutive dots not allowed)`);
  }
  return filtered;
}
function getValueAtPath(obj, path6) {
  const keys = parsePath(path6);
  let current = obj;
  for (const key of keys) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[key];
  }
  return current;
}
function setValueAtPath(obj, path6, value) {
  const keys = parsePath(path6);
  if (keys.length === 0) {
    throw new Error("Cannot set root object - path must not be empty");
  }
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current) || current[key] === null || current[key] === void 0) {
      const nextKey = keys[i + 1];
      const isArrayIndex = nextKey !== void 0 && /^\d+$/.test(nextKey);
      current[key] = isArrayIndex ? [] : {};
    }
    current = current[key];
    if (current === null || current === void 0) {
      throw new Error(`Cannot navigate through null/undefined at path: ${keys.slice(0, i + 1).join(".")}`);
    }
  }
  const lastKey = keys[keys.length - 1];
  if (Array.isArray(current)) {
    const index = parseInt(lastKey);
    if (isNaN(index)) {
      throw new Error(`Array index must be numeric, got: ${lastKey}`);
    }
    current[index] = value;
  } else {
    current[lastKey] = value;
  }
  return true;
}
function deleteAtPath(obj, path6) {
  const keys = parsePath(path6);
  if (keys.length === 0) {
    throw new Error("Cannot delete root object - path must not be empty");
  }
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current)) {
      return false;
    }
    current = current[key];
    if (current === null || current === void 0) {
      return false;
    }
  }
  const lastKey = keys[keys.length - 1];
  if (!(lastKey in current)) {
    return false;
  }
  if (Array.isArray(current)) {
    const index = parseInt(lastKey);
    if (isNaN(index) || index < 0 || index >= current.length) {
      return false;
    }
    current.splice(index, 1);
  } else {
    delete current[lastKey];
  }
  return true;
}
function pathExists(obj, path6) {
  try {
    const value = getValueAtPath(obj, path6);
    return value !== void 0;
  } catch {
    return false;
  }
}

// src/tools/json/jsonManipulator.ts
var jsonManipulator = {
  definition: {
    type: "function",
    function: {
      name: "json_manipulate",
      description: `Manipulate JSON objects by deleting, adding, or replacing fields at any depth.

IMPORTANT - PATH FORMAT (DOT NOTATION):
Use dots to separate nested field names. Examples:
\u2022 Top-level field: "name"
\u2022 Nested field: "user.email"
\u2022 Array element: "users.0.name" (where 0 is the array index)
\u2022 Deep nesting: "settings.theme.colors.primary"
\u2022 For root operations: use empty string ""

OPERATIONS:

1. DELETE - Remove a field from the object
   \u2022 Removes the specified field and its value
   \u2022 Returns error if path doesn't exist
   \u2022 Example: operation="delete", path="user.address.city"
   \u2022 Result: The city field is removed from user.address

2. ADD - Add a new field to the object
   \u2022 Creates intermediate objects/arrays if they don't exist
   \u2022 If field already exists, it will be overwritten
   \u2022 Example: operation="add", path="user.phone", value="+1234567890"
   \u2022 Result: Creates user.phone field with the phone number

3. REPLACE - Replace the value of an EXISTING field
   \u2022 Only works if the field already exists (use ADD for new fields)
   \u2022 Returns error if path doesn't exist
   \u2022 Example: operation="replace", path="user.name", value="Jane Doe"
   \u2022 Result: Changes the existing user.name value

ARRAY OPERATIONS:
\u2022 Access array elements by index: "users.0.name" (first user's name)
\u2022 Add to array: "users.2" appends if index >= array length
\u2022 Delete from array: "users.1" removes element and shifts remaining items

COMPLETE EXAMPLES:

Example 1 - Delete a field:
  Input: { operation: "delete", path: "user.email", object: {user: {name: "John", email: "j@ex.com"}} }
  Output: {user: {name: "John"}}

Example 2 - Add nested field (auto-creates intermediate objects):
  Input: { operation: "add", path: "user.address.city", value: "Paris", object: {user: {name: "John"}} }
  Output: {user: {name: "John", address: {city: "Paris"}}}

Example 3 - Replace value:
  Input: { operation: "replace", path: "settings.theme", value: "dark", object: {settings: {theme: "light"}} }
  Output: {settings: {theme: "dark"}}

Example 4 - Array manipulation:
  Input: { operation: "replace", path: "users.0.active", value: false, object: {users: [{name: "Bob", active: true}]} }
  Output: {users: [{name: "Bob", active: false}]}

The tool returns a result object with:
\u2022 success: boolean (true if operation succeeded)
\u2022 result: the modified JSON object (or null if failed)
\u2022 message: success message (if succeeded)
\u2022 error: error description (if failed)`,
      parameters: {
        type: "object",
        properties: {
          operation: {
            type: "string",
            enum: ["delete", "add", "replace"],
            description: 'The operation to perform. "delete" removes a field, "add" creates a new field (or overwrites existing), "replace" changes an existing field value.'
          },
          path: {
            type: "string",
            description: 'Dot notation path to the field. Examples: "name", "user.email", "users.0.name", "settings.theme.colors.primary". Use empty string "" only for root-level operations.'
          },
          value: {
            description: "The value to add or replace. Can be any JSON-compatible type: string, number, boolean, object, array, or null. Required for add/replace operations, ignored for delete."
          },
          object: {
            type: "object",
            description: "The JSON object to manipulate. The original object is not modified; a new modified copy is returned in the result."
          }
        },
        required: ["operation", "path", "object"]
      }
    },
    blocking: true,
    // Always wait for result
    timeout: 1e4
    // 10 seconds should be plenty for JSON operations
  },
  execute: async (args) => {
    try {
      if (!["delete", "add", "replace"].includes(args.operation)) {
        return {
          success: false,
          result: null,
          error: `Invalid operation: "${args.operation}". Must be "delete", "add", or "replace".`
        };
      }
      if (!args.object || typeof args.object !== "object") {
        return {
          success: false,
          result: null,
          error: "Invalid object: must provide a valid JSON object"
        };
      }
      let clonedObject;
      try {
        clonedObject = JSON.parse(JSON.stringify(args.object));
      } catch (error) {
        return {
          success: false,
          result: null,
          error: `Cannot clone object: ${error.message}. Object may contain circular references or non-JSON values.`
        };
      }
      switch (args.operation) {
        case "delete": {
          try {
            const deleted = deleteAtPath(clonedObject, args.path);
            if (!deleted) {
              return {
                success: false,
                result: null,
                error: `Path not found: "${args.path}". The field does not exist in the object.`
              };
            }
            return {
              success: true,
              result: clonedObject,
              message: `Successfully deleted field at path: "${args.path}"`
            };
          } catch (error) {
            return {
              success: false,
              result: null,
              error: `Delete operation failed: ${error.message}`
            };
          }
        }
        case "add": {
          if (args.value === void 0) {
            return {
              success: false,
              result: null,
              error: 'Add operation requires a "value" parameter'
            };
          }
          try {
            setValueAtPath(clonedObject, args.path, args.value);
            return {
              success: true,
              result: clonedObject,
              message: `Successfully added field at path: "${args.path}"`
            };
          } catch (error) {
            return {
              success: false,
              result: null,
              error: `Add operation failed: ${error.message}`
            };
          }
        }
        case "replace": {
          if (args.value === void 0) {
            return {
              success: false,
              result: null,
              error: 'Replace operation requires a "value" parameter'
            };
          }
          if (!pathExists(clonedObject, args.path)) {
            return {
              success: false,
              result: null,
              error: `Path not found: "${args.path}". Use "add" operation to create new fields.`
            };
          }
          try {
            setValueAtPath(clonedObject, args.path, args.value);
            return {
              success: true,
              result: clonedObject,
              message: `Successfully replaced value at path: "${args.path}"`
            };
          } catch (error) {
            return {
              success: false,
              result: null,
              error: `Replace operation failed: ${error.message}`
            };
          }
        }
        default:
          return {
            success: false,
            result: null,
            error: `Unknown operation: ${args.operation}`
          };
      }
    } catch (error) {
      return {
        success: false,
        result: null,
        error: `Unexpected error manipulating JSON: ${error.message}`
      };
    }
  }
};

// src/tools/web/createWebSearchTool.ts
init_Logger();
var searchLogger = exports.logger.child({ component: "webSearch" });
function createWebSearchTool(connector) {
  return {
    definition: {
      type: "function",
      function: {
        name: "web_search",
        description: `Search the web and get relevant results with snippets.

RETURNS:
An array of search results, each containing:
- title: Page title
- url: Direct URL to the page
- snippet: Short description/excerpt from the page
- position: Search ranking position (1, 2, 3...)

USE CASES:
- Find current information on any topic
- Research multiple sources
- Discover relevant websites
- Find URLs to fetch with web_fetch tool

WORKFLOW PATTERN:
1. Use web_search to find relevant URLs
2. Use web_fetch to get full content from top results
3. Process and summarize the information

EXAMPLE:
{
  "query": "latest AI developments 2026",
  "numResults": 5
}`,
        parameters: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "The search query string. Be specific for better results."
            },
            numResults: {
              type: "number",
              description: "Number of results to return (default: 10, max: 100)."
            },
            country: {
              type: "string",
              description: 'Country/region code for localized results (e.g., "us", "gb", "de")'
            },
            language: {
              type: "string",
              description: 'Language code for results (e.g., "en", "fr", "de")'
            }
          },
          required: ["query"]
        }
      },
      blocking: true,
      timeout: 15e3
    },
    execute: async (args) => {
      const numResults = args.numResults || 10;
      searchLogger.debug({ connectorName: connector.name }, "Executing search with connector");
      try {
        const searchProvider = SearchProvider.create({ connector: connector.name });
        const response = await searchProvider.search(args.query, {
          numResults,
          country: args.country,
          language: args.language
        });
        if (response.success) {
          searchLogger.debug({
            provider: response.provider,
            count: response.count
          }, "Search completed successfully");
        } else {
          searchLogger.warn({
            provider: response.provider,
            error: response.error
          }, "Search failed");
        }
        return {
          success: response.success,
          query: response.query,
          provider: response.provider,
          results: response.results,
          count: response.count,
          error: response.error
        };
      } catch (error) {
        searchLogger.error({ error: error.message, connectorName: connector.name }, "Search threw exception");
        return {
          success: false,
          query: args.query,
          provider: connector.name,
          results: [],
          count: 0,
          error: error.message || "Unknown error"
        };
      }
    },
    describeCall: (args) => `"${args.query}"${args.numResults ? ` (${args.numResults} results)` : ""}`
  };
}

// src/tools/web/contentDetector.ts
function detectContentQuality(html, text, $) {
  const issues = [];
  let score = 100;
  let requiresJS = false;
  if (text.length < 100) {
    issues.push("Very little text content extracted");
    score -= 40;
    requiresJS = true;
  }
  const errorPatterns = [
    { pattern: /access denied/i, penalty: 50 },
    { pattern: /403 forbidden/i, penalty: 50 },
    { pattern: /404 not found/i, penalty: 50 },
    { pattern: /page not found/i, penalty: 40 },
    { pattern: /cloudflare/i, penalty: 30 },
    { pattern: /please enable javascript/i, penalty: 40 },
    { pattern: /requires javascript/i, penalty: 40 },
    { pattern: /robot|bot detection/i, penalty: 30 }
  ];
  for (const { pattern, penalty } of errorPatterns) {
    if (pattern.test(html) || pattern.test(text)) {
      issues.push(`Error pattern detected: ${pattern.source}`);
      score -= penalty;
    }
  }
  const scriptCount = $("script").length;
  const textLength = text.length;
  if (scriptCount > 10 && textLength < 500) {
    issues.push("Page is mostly JavaScript code (code dump)");
    score -= 40;
    requiresJS = true;
  }
  const scriptLength = $("script").text().length;
  if (scriptLength > textLength * 2 && textLength < 1e3) {
    issues.push("High JavaScript-to-content ratio");
    score -= 20;
    requiresJS = true;
  }
  const jsFrameworks = [
    { pattern: /\breact\b/i, name: "React" },
    { pattern: /\bvue\b/i, name: "Vue" },
    { pattern: /\bangular\b/i, name: "Angular" },
    { pattern: /__NEXT_DATA__/i, name: "Next.js" },
    { pattern: /\bwebpack\b/i, name: "Webpack" },
    { pattern: /_app-.*\.js/i, name: "SPA" }
  ];
  for (const framework of jsFrameworks) {
    if (framework.pattern.test(html)) {
      issues.push(`${framework.name} framework detected`);
      requiresJS = true;
    }
  }
  const bodyText = $("body").text().trim();
  const divCount = $("div").length;
  if (bodyText.length < 100 && divCount > 5) {
    issues.push("Empty body with many divs (likely Single Page App)");
    score -= 30;
    requiresJS = true;
  }
  const noscript = $("noscript").text();
  if (noscript.length > 50) {
    issues.push("Noscript tag present (site requires JavaScript)");
    requiresJS = true;
  }
  const paragraphCount = $("p").length;
  const headingCount = $("h1, h2, h3, h4, h5, h6").length;
  if (paragraphCount < 3 && headingCount < 2 && textLength < 500) {
    issues.push("Very few content elements (likely needs JavaScript)");
    score -= 20;
    requiresJS = true;
  }
  let suggestion;
  if (requiresJS && score < 50) {
    suggestion = "Content quality is low. This appears to be a JavaScript-rendered site. Use a scraping service connector for better results.";
  } else if (score < 30) {
    suggestion = "Content extraction failed or page has errors. Check the URL and try again.";
  }
  return {
    score: Math.max(0, Math.min(100, score)),
    requiresJS,
    suggestion,
    issues
  };
}

// src/tools/web/webFetch.ts
init_htmlToMarkdown();
var webFetch = {
  definition: {
    type: "function",
    function: {
      name: "web_fetch",
      description: `Fetch and extract content from a URL \u2014 works with web pages AND document files (PDF, DOCX, XLSX, PPTX, etc.). Document URLs are automatically detected and converted to markdown text.

WEB PAGES:
This tool performs HTTP fetch and HTML parsing. It works well for:
- Static websites (blogs, documentation, articles)
- Server-rendered HTML pages
- Content that doesn't require JavaScript

DOCUMENT URLs:
When the URL points to a document file (detected via Content-Type header or URL extension), the document is automatically downloaded and converted to markdown:
- PDF files: extracted as markdown with per-page sections
- Word (.docx), PowerPoint (.pptx): converted to structured markdown
- Excel (.xlsx), CSV, ODS: tables converted to markdown tables
- OpenDocument formats (.odt, .odp, .ods): converted like MS Office equivalents
- Returns contentType: "document" and includes documentMetadata in the result

LIMITATIONS:
- Cannot execute JavaScript
- May fail on React/Vue/Angular sites (will return low quality score)
- May get blocked by bot protection
- Cannot handle dynamic content loading

QUALITY DETECTION:
The tool analyzes the fetched content and returns a quality score (0-100):
- 80-100: Excellent quality, content extracted successfully
- 50-79: Moderate quality, some content extracted
- 0-49: Low quality, likely needs JavaScript or has errors

If the quality score is low or requiresJS is true, consider using a scraping service connector for better results.

RETURNS:
{
  success: boolean,
  url: string,
  title: string,
  content: string,          // Clean markdown (converted from HTML or document)
  contentType: string,      // 'html' | 'json' | 'text' | 'document' | 'error'
  qualityScore: number,     // 0-100 (quality of extraction)
  requiresJS: boolean,      // True if site likely needs JavaScript
  suggestedAction: string,  // Suggestion if quality is low
  issues: string[],         // List of detected issues
  excerpt: string,          // Short summary excerpt (if extracted)
  byline: string,           // Author info (if extracted)
  wasTruncated: boolean,    // True if content was truncated
  documentMetadata: object, // Document metadata (format, pages, etc.) \u2014 only for document URLs
  error: string             // Error message if failed
}

EXAMPLES:
Fetch a blog post:
{
  url: "https://example.com/blog/article"
}

Fetch a PDF document:
{
  url: "https://example.com/reports/q4-2025.pdf"
}

Fetch an Excel spreadsheet:
{
  url: "https://example.com/data/metrics.xlsx"
}`,
      parameters: {
        type: "object",
        properties: {
          url: {
            type: "string",
            description: "The URL to fetch. Must start with http:// or https://"
          },
          userAgent: {
            type: "string",
            description: "Optional custom user agent string. Default is a generic bot user agent."
          },
          timeout: {
            type: "number",
            description: "Timeout in milliseconds (default: 10000)"
          }
        },
        required: ["url"]
      }
    },
    blocking: true,
    timeout: 15e3
  },
  execute: async (args) => {
    try {
      try {
        new URL(args.url);
      } catch {
        return {
          success: false,
          url: args.url,
          title: "",
          content: "",
          contentType: "error",
          qualityScore: 0,
          requiresJS: false,
          error: "Invalid URL format"
        };
      }
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), args.timeout || 1e4);
      const response = await fetch(args.url, {
        headers: {
          "User-Agent": args.userAgent || "Mozilla/5.0 (compatible; OneRingAI/1.0; +https://github.com/oneringai/agents)",
          Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          "Accept-Language": "en-US,en;q=0.9"
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        return {
          success: false,
          url: args.url,
          title: "",
          content: "",
          contentType: "error",
          qualityScore: 0,
          requiresJS: false,
          error: `HTTP ${response.status}: ${response.statusText}`
        };
      }
      const contentType = response.headers.get("content-type") || "";
      const urlExt = (() => {
        try {
          const pathname = new URL(args.url).pathname;
          const ext = pathname.split(".").pop()?.toLowerCase();
          return ext ? `.${ext}` : "";
        } catch {
          return "";
        }
      })();
      if (FormatDetector.isDocumentMimeType(contentType) || FormatDetector.isBinaryDocumentFormat(urlExt)) {
        try {
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          const disposition = response.headers.get("content-disposition");
          let filename = "document";
          if (disposition) {
            const match = disposition.match(/filename[^;=\n]*=(['"]?)([^'"\n;]*)\1/);
            if (match?.[2]) filename = match[2];
          } else {
            try {
              const basename = new URL(args.url).pathname.split("/").pop();
              if (basename && basename.includes(".")) filename = basename;
            } catch {
            }
          }
          const reader = DocumentReader.create();
          const result = await reader.read(
            { type: "buffer", buffer, filename },
            { extractImages: false }
          );
          if (result.success) {
            return {
              success: true,
              url: args.url,
              title: `Document: ${filename}`,
              content: mergeTextPieces(result.pieces),
              contentType: "document",
              qualityScore: 100,
              requiresJS: false,
              documentMetadata: result.metadata
            };
          }
        } catch {
        }
      }
      if (contentType.includes("application/json")) {
        const json = await response.json();
        return {
          success: true,
          url: args.url,
          title: "JSON Response",
          content: JSON.stringify(json, null, 2),
          contentType: "json",
          qualityScore: 100,
          requiresJS: false
        };
      }
      if (contentType.includes("text/plain")) {
        const text = await response.text();
        return {
          success: true,
          url: args.url,
          title: "Text Response",
          content: text,
          contentType: "text",
          qualityScore: 100,
          requiresJS: false
        };
      }
      const html = await response.text();
      const $ = cheerio.load(html);
      const mdResult = await htmlToMarkdown(html, args.url);
      const title = mdResult.title || $("title").text() || $("h1").first().text() || "Untitled";
      const quality = detectContentQuality(html, mdResult.markdown, $);
      return {
        success: true,
        url: args.url,
        title,
        content: mdResult.markdown,
        contentType: "html",
        qualityScore: quality.score,
        requiresJS: quality.requiresJS,
        suggestedAction: quality.suggestion,
        issues: quality.issues,
        excerpt: mdResult.excerpt,
        byline: mdResult.byline,
        wasReadabilityUsed: mdResult.wasReadabilityUsed,
        wasTruncated: mdResult.wasTruncated
      };
    } catch (error) {
      if (error.name === "AbortError") {
        return {
          success: false,
          url: args.url,
          title: "",
          content: "",
          contentType: "error",
          qualityScore: 0,
          requiresJS: false,
          error: `Request timeout after ${args.timeout || 1e4}ms`
        };
      }
      return {
        success: false,
        url: args.url,
        title: "",
        content: "",
        contentType: "error",
        qualityScore: 0,
        requiresJS: false,
        error: error.message
      };
    }
  }
};

// src/tools/web/createWebScrapeTool.ts
init_Logger();
var scrapeLogger = exports.logger.child({ component: "webScrape" });
var DEFAULT_MIN_QUALITY = 50;
function stripBase64DataUris(content) {
  if (!content) return content;
  let cleaned = content.replace(/!\[[^\]]*\]\(data:[^)]+\)/g, "[image removed]");
  cleaned = cleaned.replace(/url\(['"]?data:[^)]+['"]?\)/gi, "url([data-uri-removed])");
  cleaned = cleaned.replace(/data:(?:image|font|application)\/[^;]+;base64,[A-Za-z0-9+/=]{100,}/g, "[base64-data-removed]");
  return cleaned;
}
function createWebScrapeTool(connector) {
  async function tryNative(args, startTime, attemptedMethods) {
    attemptedMethods.push("native");
    scrapeLogger.debug({ url: args.url }, "Trying native fetch");
    try {
      const result = await webFetch.execute({
        url: args.url,
        timeout: args.timeout || 1e4
      });
      const cleanContent = stripBase64DataUris(result.content);
      return {
        success: result.success,
        url: args.url,
        finalUrl: args.url,
        method: "native",
        title: result.title,
        content: cleanContent,
        qualityScore: result.qualityScore,
        durationMs: Date.now() - startTime,
        attemptedMethods,
        error: result.error
      };
    } catch (error) {
      return {
        success: false,
        url: args.url,
        method: "native",
        title: "",
        content: "",
        durationMs: Date.now() - startTime,
        attemptedMethods,
        error: error.message
      };
    }
  }
  async function tryAPI(args, startTime, attemptedMethods) {
    attemptedMethods.push(`api:${connector.name}`);
    scrapeLogger.debug({ url: args.url, connectorName: connector.name }, "Trying external API");
    try {
      const provider = ScrapeProvider.create({ connector: connector.name });
      const options = {
        timeout: args.timeout,
        waitForSelector: args.waitForSelector,
        includeHtml: args.includeHtml,
        includeMarkdown: args.includeMarkdown,
        includeLinks: args.includeLinks
      };
      const result = await provider.scrape(args.url, options);
      const rawContent = result.result?.content || "";
      const rawMarkdown = result.result?.markdown;
      const cleanContent = stripBase64DataUris(rawContent);
      const cleanMarkdown = rawMarkdown ? stripBase64DataUris(rawMarkdown) : void 0;
      const isDuplicate = !!cleanMarkdown && cleanContent === cleanMarkdown;
      return {
        success: result.success,
        url: args.url,
        finalUrl: result.finalUrl,
        method: result.provider,
        title: result.result?.title || "",
        content: cleanContent,
        html: result.result?.html,
        markdown: isDuplicate ? void 0 : cleanMarkdown,
        metadata: result.result?.metadata,
        links: result.result?.links,
        qualityScore: result.success ? 90 : 0,
        durationMs: Date.now() - startTime,
        attemptedMethods,
        error: result.error
      };
    } catch (error) {
      return {
        success: false,
        url: args.url,
        method: "api",
        title: "",
        content: "",
        durationMs: Date.now() - startTime,
        attemptedMethods,
        error: error.message
      };
    }
  }
  return {
    definition: {
      type: "function",
      function: {
        name: "web_scrape",
        description: `Scrape any URL with automatic fallback - guaranteed to work on most sites.

Automatically tries multiple methods in sequence:
1. Native fetch - Fast (~1s), works for blogs/docs/articles
2. External API - Handles bot protection, CAPTCHAs, SPAs (if configured)

RETURNS:
{
  success: boolean,
  url: string,
  finalUrl: string,        // After redirects
  method: string,          // 'native', 'js', or provider name
  title: string,
  content: string,         // Clean text
  html: string,            // If requested
  markdown: string,        // If requested
  metadata: {...},         // Title, description, author, etc.
  links: [{url, text}],    // If requested
  qualityScore: number,    // 0-100
  durationMs: number,
  attemptedMethods: []     // Methods tried
}

EXAMPLES:
Basic:
{ "url": "https://example.com/article" }

With options:
{
  "url": "https://example.com",
  "includeMarkdown": true,
  "includeLinks": true
}

For JS-heavy sites:
{
  "url": "https://spa-app.com",
  "waitForSelector": ".main-content"
}`,
        parameters: {
          type: "object",
          properties: {
            url: {
              type: "string",
              description: "URL to scrape. Must start with http:// or https://"
            },
            timeout: {
              type: "number",
              description: "Timeout in milliseconds (default: 30000)"
            },
            includeHtml: {
              type: "boolean",
              description: "Include raw HTML in response (default: false)"
            },
            includeMarkdown: {
              type: "boolean",
              description: "Include markdown conversion (default: false)"
            },
            includeLinks: {
              type: "boolean",
              description: "Extract and include links (default: false)"
            },
            waitForSelector: {
              type: "string",
              description: "CSS selector to wait for before scraping (for JS-heavy sites)"
            }
          },
          required: ["url"]
        }
      },
      blocking: true,
      timeout: 6e4
    },
    execute: async (args) => {
      const startTime = Date.now();
      const attemptedMethods = [];
      try {
        new URL(args.url);
      } catch {
        return {
          success: false,
          url: args.url,
          method: "none",
          title: "",
          content: "",
          durationMs: Date.now() - startTime,
          attemptedMethods: [],
          error: "Invalid URL format"
        };
      }
      const native = await tryNative(args, startTime, attemptedMethods);
      if (native.success && (native.qualityScore ?? 0) >= DEFAULT_MIN_QUALITY) {
        return native;
      }
      const api = await tryAPI(args, startTime, attemptedMethods);
      if (api.success) return api;
      if (native.success) return native;
      const errors = [];
      if (native.error) errors.push(`native: ${native.error}`);
      if (api.error) errors.push(`api(${connector.name}): ${api.error}`);
      const detail = errors.length > 0 ? errors.join(" | ") : "Unknown failure";
      return {
        success: false,
        url: args.url,
        method: "none",
        title: "",
        content: "",
        durationMs: Date.now() - startTime,
        attemptedMethods,
        error: `All scraping methods failed. ${detail}`
      };
    },
    describeCall: (args) => args.url
  };
}

// src/tools/web/register.ts
var SEARCH_SERVICE_TYPES = ["serper", "brave-search", "tavily", "rapidapi-search"];
var SCRAPE_SERVICE_TYPES = ["zenrows", "jina-reader", "firecrawl", "scrapingbee"];
function registerWebTools() {
  for (const st of SEARCH_SERVICE_TYPES) {
    ConnectorTools.registerService(st, (connector) => [
      createWebSearchTool(connector)
    ]);
  }
  for (const st of SCRAPE_SERVICE_TYPES) {
    ConnectorTools.registerService(st, (connector) => [
      createWebScrapeTool(connector)
    ]);
  }
}

// src/tools/web/index.ts
registerWebTools();

// src/tools/code/executeJavaScript.ts
init_Connector();
var DEFAULT_TIMEOUT = 1e4;
var DEFAULT_MAX_TIMEOUT = 3e4;
function formatConnectorEntry(c) {
  const parts = [];
  const serviceOrVendor = c.serviceType ?? c.vendor ?? void 0;
  if (serviceOrVendor) parts.push(`Service: ${serviceOrVendor}`);
  if (c.config.description) parts.push(c.config.description);
  if (c.baseURL) parts.push(`URL: ${c.baseURL}`);
  const details = parts.map((p) => `     ${p}`).join("\n");
  return `   \u2022 "${c.name}" (${c.displayName})
${details}`;
}
function generateDescription(context, maxTimeout) {
  const registry = context?.connectorRegistry ?? exports.Connector.asRegistry();
  const connectors = registry.listAll();
  const connectorList = connectors.length > 0 ? connectors.map(formatConnectorEntry).join("\n\n") : "   No connectors registered.";
  const timeoutSec = Math.round(maxTimeout / 1e3);
  return `Execute JavaScript code in a secure sandbox with authenticated API access to external services.

Use this tool when you need to:
- Call external APIs (GitHub, Slack, Stripe, etc.) using registered connectors
- Process, transform, or compute data that requires programmatic logic
- Chain multiple API calls or perform complex data manipulation
- Do anything that plain text generation cannot accomplish

SANDBOX API:

1. authenticatedFetch(url, options, connectorName)
   Makes authenticated HTTP requests using the connector's credentials.
   The current user's identity (userId) is automatically included \u2014 no need to pass it.
   Auth headers are added automatically \u2014 DO NOT set Authorization header manually.

   Parameters:
     \u2022 url: Full URL or path relative to the connector's base URL
       - Full: "https://api.github.com/user/repos"
       - Relative: "/user/repos" (resolved against connector's base URL)
     \u2022 options: Standard fetch options { method, headers, body }
       - For POST/PUT: set body to JSON.stringify(data) and headers to { 'Content-Type': 'application/json' }
     \u2022 connectorName: Name of a registered connector (see list below)

   Returns: Promise<Response>
     \u2022 response.ok \u2014 true if status 200-299
     \u2022 response.status \u2014 HTTP status code
     \u2022 await response.json() \u2014 parse JSON body
     \u2022 await response.text() \u2014 get text body

2. fetch(url, options) \u2014 Standard fetch without authentication

3. connectors.list() \u2014 Array of available connector names
4. connectors.get(name) \u2014 Connector info: { displayName, description, baseURL, serviceType }

VARIABLES:
   \u2022 input \u2014 data passed via the "input" parameter (default: {})
   \u2022 output \u2014 SET THIS to return your result to the caller

GLOBALS: console.log/error/warn, JSON, Math, Date, Buffer, Promise, Array, Object, String, Number, Boolean, setTimeout, setInterval, URL, URLSearchParams, RegExp, Map, Set, Error, TextEncoder, TextDecoder

REGISTERED CONNECTORS:
${connectorList}

EXAMPLES:

// GET request
const resp = await authenticatedFetch('/user/repos', { method: 'GET' }, 'github');
const repos = await resp.json();
output = repos.map(r => r.full_name);

// POST request with JSON body
const resp = await authenticatedFetch('/chat.postMessage', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ channel: '#general', text: 'Hello!' })
}, 'slack');
output = await resp.json();

// Data processing (no API needed)
const items = input.data;
output = items.filter(i => i.score > 0.8).sort((a, b) => b.score - a.score);

LIMITS: ${timeoutSec}s max timeout, no file system access, no require/import.`;
}
function createExecuteJavaScriptTool(options) {
  const maxTimeout = options?.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
  const defaultTimeout = options?.defaultTimeout ?? DEFAULT_TIMEOUT;
  return {
    definition: {
      type: "function",
      function: {
        name: "execute_javascript",
        // Static fallback description (used if descriptionFactory is not supported)
        description: "Execute JavaScript code in a secure sandbox with authenticated API access via connectors.",
        parameters: {
          type: "object",
          properties: {
            code: {
              type: "string",
              description: 'JavaScript code to execute. Set the "output" variable with your result. Code is auto-wrapped in async IIFE \u2014 you can use await directly. For explicit async control, wrap in (async () => { ... })().'
            },
            input: {
              description: 'Optional data available as the "input" variable in your code. Can be any JSON value.'
            },
            timeout: {
              type: "number",
              description: `Execution timeout in milliseconds. Default: ${defaultTimeout}ms, max: ${maxTimeout}ms. Increase for slow API calls or multiple sequential requests.`
            }
          },
          required: ["code"]
        }
      },
      blocking: true,
      timeout: maxTimeout + 5e3
      // Tool-level timeout slightly above max code timeout
    },
    // Dynamic description — regenerated each time tool definitions are sent to LLM.
    // Receives ToolContext so connector list is scoped to current userId.
    descriptionFactory: (context) => generateDescription(context, maxTimeout),
    execute: async (args, context) => {
      const logs = [];
      const startTime = Date.now();
      try {
        const timeout = Math.min(Math.max(args.timeout || defaultTimeout, 0), maxTimeout);
        const registry = context?.connectorRegistry ?? exports.Connector.asRegistry();
        const result = await executeInVM(
          args.code,
          args.input,
          timeout,
          logs,
          context?.userId,
          registry
        );
        return {
          success: true,
          result,
          logs,
          executionTime: Date.now() - startTime
        };
      } catch (error) {
        return {
          success: false,
          result: null,
          logs,
          error: error.message,
          executionTime: Date.now() - startTime
        };
      }
    }
  };
}
var executeJavaScript = createExecuteJavaScriptTool();
async function executeInVM(code, input, timeout, logs, userId, registry) {
  const sandbox = {
    // Input/output
    input: input ?? {},
    output: null,
    // Console (captured) — stringify objects for readable logs
    console: {
      log: (...args) => logs.push(args.map((a) => typeof a === "object" ? JSON.stringify(a) : String(a)).join(" ")),
      error: (...args) => logs.push("ERROR: " + args.map((a) => typeof a === "object" ? JSON.stringify(a) : String(a)).join(" ")),
      warn: (...args) => logs.push("WARN: " + args.map((a) => typeof a === "object" ? JSON.stringify(a) : String(a)).join(" "))
    },
    // Authenticated fetch — userId auto-injected from ToolContext.
    // Only connectors visible in the scoped registry are accessible.
    authenticatedFetch: (url2, options, connectorName) => {
      registry.get(connectorName);
      return authenticatedFetch(url2, options, connectorName, userId);
    },
    // Standard fetch (no auth)
    fetch: globalThis.fetch,
    // Connector info (userId-scoped)
    connectors: {
      list: () => registry.list(),
      get: (name) => {
        try {
          const connector = registry.get(name);
          return {
            displayName: connector.displayName,
            description: connector.config.description || "",
            baseURL: connector.baseURL,
            serviceType: connector.serviceType
          };
        } catch {
          return null;
        }
      }
    },
    // Standard globals
    Buffer,
    JSON,
    Math,
    Date,
    setTimeout,
    setInterval,
    clearTimeout,
    clearInterval,
    Promise,
    // Built-in types
    Array,
    Object,
    String,
    Number,
    Boolean,
    RegExp,
    Map,
    Set,
    Error,
    URL,
    URLSearchParams,
    TextEncoder,
    TextDecoder
  };
  const vmContext = vm__namespace.createContext(sandbox);
  const wrappedCode = code.trim().startsWith("(async") ? code : `
    (async () => {
      ${code}
      return output;
    })()
  `;
  const script = new vm__namespace.Script(wrappedCode);
  const resultPromise = script.runInContext(vmContext, {
    timeout,
    displayErrors: true
  });
  const result = await resultPromise;
  return result !== void 0 ? result : sandbox.output;
}

// src/tools/multimedia/config.ts
init_StorageRegistry();
function getMediaStorage() {
  return exports.StorageRegistry.resolve("media", () => new FileMediaStorage());
}
function setMediaStorage(storage) {
  exports.StorageRegistry.set("media", storage);
}
var getMediaOutputHandler = getMediaStorage;
var setMediaOutputHandler = setMediaStorage;

// src/tools/multimedia/imageGeneration.ts
function createImageGenerationTool(connector, storage, userId) {
  const vendor = connector.vendor;
  const handler = storage ?? getMediaStorage();
  const vendorModels = vendor ? getImageModelsByVendor(vendor) : [];
  const modelNames = vendorModels.map((m) => m.name);
  const properties = {
    prompt: {
      type: "string",
      description: "Text description of the image to generate"
    }
  };
  if (modelNames.length > 0) {
    const descriptions = vendorModels.map((m) => `${m.name}: ${m.description || m.displayName}`).join("; ");
    properties.model = {
      type: "string",
      enum: modelNames,
      description: `Image model to use. Options: ${descriptions}`
    };
  }
  const hasSizes = vendorModels.some((m) => m.capabilities.sizes.length > 1);
  if (hasSizes) {
    const allSizes = [...new Set(vendorModels.flatMap((m) => m.capabilities.sizes))];
    properties.size = {
      type: "string",
      enum: allSizes,
      description: "Image dimensions"
    };
  }
  const hasAspectRatios = vendorModels.some((m) => m.capabilities.aspectRatios?.length);
  if (hasAspectRatios) {
    const allRatios = [...new Set(vendorModels.flatMap((m) => m.capabilities.aspectRatios ?? []))];
    properties.aspectRatio = {
      type: "string",
      enum: allRatios,
      description: "Image aspect ratio"
    };
  }
  const hasQuality = vendorModels.some((m) => m.capabilities.features.qualityControl);
  if (hasQuality) {
    properties.quality = {
      type: "string",
      enum: ["standard", "hd"],
      description: "Image quality level"
    };
  }
  const hasStyle = vendorModels.some((m) => m.capabilities.features.styleControl);
  if (hasStyle) {
    properties.style = {
      type: "string",
      enum: ["vivid", "natural"],
      description: "Image style (vivid for hyper-real, natural for less hyper-real)"
    };
  }
  const maxN = Math.max(...vendorModels.map((m) => m.capabilities.maxImagesPerRequest));
  if (maxN > 1) {
    properties.n = {
      type: "number",
      description: `Number of images to generate (1-${maxN})`,
      minimum: 1,
      maximum: maxN
    };
  }
  return {
    definition: {
      type: "function",
      function: {
        name: "generate_image",
        description: `Generate images from text prompts using ${connector.displayName}`,
        parameters: {
          type: "object",
          properties,
          required: ["prompt"]
        }
      }
    },
    execute: async (args, context) => {
      try {
        const effectiveUserId = userId ?? context?.userId;
        const imageGen = ImageGeneration.create({ connector });
        const response = await imageGen.generate({
          prompt: args.prompt,
          model: args.model,
          size: args.size,
          quality: args.quality,
          style: args.style,
          n: args.n,
          response_format: "b64_json"
        });
        const images = [];
        for (let i = 0; i < response.data.length; i++) {
          const item = response.data[i];
          let buffer;
          if (item.b64_json) {
            buffer = Buffer.from(item.b64_json, "base64");
          } else if (item.url) {
            const resp = await fetch(item.url);
            buffer = Buffer.from(await resp.arrayBuffer());
          } else {
            continue;
          }
          const modelName = args.model || modelNames[0] || "unknown";
          const modelInfo = IMAGE_MODEL_REGISTRY[modelName];
          const format = modelInfo?.capabilities.outputFormats[0] === "url" ? "png" : modelInfo?.capabilities.outputFormats[0] || "png";
          const result = await handler.save(buffer, {
            type: "image",
            format,
            model: modelName,
            vendor: vendor || "unknown",
            index: response.data.length > 1 ? i : void 0,
            userId: effectiveUserId
          });
          images.push({
            location: result.location,
            mimeType: result.mimeType,
            revisedPrompt: item.revised_prompt
          });
        }
        return { success: true, images };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    },
    describeCall: (args) => args.prompt.length > 50 ? args.prompt.slice(0, 47) + "..." : args.prompt,
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Generate image(s) using ${connector.displayName}`
    }
  };
}

// src/tools/multimedia/videoGeneration.ts
var videoGenInstances = /* @__PURE__ */ new Map();
function createVideoTools(connector, storage, userId) {
  const vendor = connector.vendor;
  const handler = storage ?? getMediaStorage();
  const vendorModels = vendor ? getVideoModelsByVendor(vendor) : [];
  const modelNames = vendorModels.map((m) => m.name);
  const generateProperties = {
    prompt: {
      type: "string",
      description: "Text description of the video to generate"
    }
  };
  if (modelNames.length > 0) {
    const descriptions = vendorModels.map((m) => `${m.name}: ${m.displayName}`).join("; ");
    generateProperties.model = {
      type: "string",
      enum: modelNames,
      description: `Video model to use. Options: ${descriptions}`
    };
  }
  const allDurations = [...new Set(vendorModels.flatMap((m) => m.capabilities.durations))].sort(
    (a, b) => a - b
  );
  if (allDurations.length > 0) {
    generateProperties.duration = {
      type: "number",
      description: `Video duration in seconds. Supported: ${allDurations.join(", ")}`
    };
  }
  const allResolutions = [...new Set(vendorModels.flatMap((m) => m.capabilities.resolutions))];
  if (allResolutions.length > 0) {
    generateProperties.resolution = {
      type: "string",
      enum: allResolutions,
      description: "Video resolution"
    };
  }
  const allAspectRatios = [
    ...new Set(vendorModels.flatMap((m) => m.capabilities.aspectRatios ?? []))
  ];
  if (allAspectRatios.length > 0) {
    generateProperties.aspectRatio = {
      type: "string",
      enum: allAspectRatios,
      description: "Video aspect ratio"
    };
  }
  const hasSeed = vendorModels.some((m) => m.capabilities.features.seed);
  if (hasSeed) {
    generateProperties.seed = {
      type: "number",
      description: "Random seed for reproducible generation"
    };
  }
  const generateTool = {
    definition: {
      type: "function",
      function: {
        name: "generate_video",
        description: `Start video generation from a text prompt using ${connector.displayName}. Returns a jobId to check status with video_status.`,
        parameters: {
          type: "object",
          properties: generateProperties,
          required: ["prompt"]
        }
      }
    },
    execute: async (args, _context) => {
      try {
        const videoGen = VideoGeneration.create({ connector });
        const response = await videoGen.generate({
          prompt: args.prompt,
          model: args.model,
          duration: args.duration,
          resolution: args.resolution,
          aspectRatio: args.aspectRatio,
          seed: args.seed
        });
        videoGenInstances.set(response.jobId, videoGen);
        return {
          success: true,
          jobId: response.jobId,
          status: response.status
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    },
    describeCall: (args) => args.prompt.length > 50 ? args.prompt.slice(0, 47) + "..." : args.prompt,
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Generate video using ${connector.displayName}`
    }
  };
  const statusTool = {
    definition: {
      type: "function",
      function: {
        name: "video_status",
        description: "Check the status of a video generation job. If completed, downloads and saves the video.",
        parameters: {
          type: "object",
          properties: {
            jobId: {
              type: "string",
              description: "The job ID returned by generate_video"
            }
          },
          required: ["jobId"]
        }
      }
    },
    execute: async (args, context) => {
      try {
        const effectiveUserId = userId ?? context?.userId;
        let videoGen = videoGenInstances.get(args.jobId);
        if (!videoGen) {
          videoGen = VideoGeneration.create({ connector });
        }
        const status = await videoGen.getStatus(args.jobId);
        if (status.status === "completed") {
          let buffer;
          if (status.video?.b64_json) {
            buffer = Buffer.from(status.video.b64_json, "base64");
          } else if (status.video?.url) {
            const resp = await fetch(status.video.url);
            buffer = Buffer.from(await resp.arrayBuffer());
          } else if (videoGen.download) {
            try {
              buffer = await videoGen.download(args.jobId);
            } catch {
            }
          }
          if (buffer) {
            const format = status.video?.format || "mp4";
            const modelName = modelNames[0] || "unknown";
            const result = await handler.save(buffer, {
              type: "video",
              format,
              model: modelName,
              vendor: vendor || "unknown",
              userId: effectiveUserId
            });
            videoGenInstances.delete(args.jobId);
            return {
              success: true,
              status: "completed",
              location: result.location,
              mimeType: result.mimeType
            };
          }
          videoGenInstances.delete(args.jobId);
          return {
            success: true,
            status: "completed",
            location: status.video?.url
          };
        }
        if (status.status === "failed") {
          videoGenInstances.delete(args.jobId);
          return {
            success: false,
            status: "failed",
            error: status.error || "Video generation failed"
          };
        }
        return {
          success: true,
          status: status.status,
          progress: status.progress
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    },
    describeCall: (args) => `job ${args.jobId}`,
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: "Check video generation status"
    }
  };
  return [generateTool, statusTool];
}

// src/tools/multimedia/textToSpeech.ts
function createTextToSpeechTool(connector, storage, userId) {
  const vendor = connector.vendor;
  const handler = storage ?? getMediaStorage();
  const vendorModels = vendor ? getTTSModelsByVendor(vendor) : [];
  const modelNames = vendorModels.map((m) => m.name);
  const properties = {
    text: {
      type: "string",
      description: "Text to convert to speech"
    }
  };
  if (modelNames.length > 0) {
    const descriptions = vendorModels.map((m) => `${m.name}: ${m.description || m.displayName}`).join("; ");
    properties.model = {
      type: "string",
      enum: modelNames,
      description: `TTS model to use. Options: ${descriptions}`
    };
  }
  const allVoices = [
    ...new Map(
      vendorModels.flatMap((m) => m.capabilities.voices).map((v) => [v.id, v])
    ).values()
  ];
  if (allVoices.length > 0) {
    const voiceDescriptions = allVoices.slice(0, 10).map((v) => `${v.id}${v.name !== v.id ? ` (${v.name})` : ""}`).join(", ");
    properties.voice = {
      type: "string",
      enum: allVoices.map((v) => v.id),
      description: `Voice to use. Options include: ${voiceDescriptions}${allVoices.length > 10 ? `, and ${allVoices.length - 10} more` : ""}`
    };
  }
  const allFormats = [...new Set(vendorModels.flatMap((m) => [...m.capabilities.formats]))];
  if (allFormats.length > 0) {
    properties.format = {
      type: "string",
      enum: allFormats,
      description: `Output audio format: ${allFormats.join(", ")}`
    };
  }
  const hasSpeed = vendorModels.some((m) => m.capabilities.speed.supported);
  if (hasSpeed) {
    const speedModel = vendorModels.find((m) => m.capabilities.speed.supported);
    properties.speed = {
      type: "number",
      description: `Speech speed (${speedModel?.capabilities.speed.min ?? 0.25} to ${speedModel?.capabilities.speed.max ?? 4})`,
      minimum: speedModel?.capabilities.speed.min ?? 0.25,
      maximum: speedModel?.capabilities.speed.max ?? 4
    };
  }
  return {
    definition: {
      type: "function",
      function: {
        name: "text_to_speech",
        description: `Convert text to speech audio using ${connector.displayName}`,
        parameters: {
          type: "object",
          properties,
          required: ["text"]
        }
      }
    },
    execute: async (args, context) => {
      try {
        const effectiveUserId = userId ?? context?.userId;
        const tts = TextToSpeech.create({
          connector,
          model: args.model,
          voice: args.voice,
          format: args.format,
          speed: args.speed
        });
        const response = await tts.synthesize(args.text);
        const format = response.format || args.format || "mp3";
        const result = await handler.save(response.audio, {
          type: "audio",
          format,
          model: args.model || modelNames[0] || "unknown",
          vendor: vendor || "unknown",
          userId: effectiveUserId
        });
        return {
          success: true,
          location: result.location,
          format,
          mimeType: result.mimeType
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    },
    describeCall: (args) => args.text.length > 50 ? args.text.slice(0, 47) + "..." : args.text,
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Convert text to speech using ${connector.displayName}`
    }
  };
}

// src/tools/multimedia/speechToText.ts
function createSpeechToTextTool(connector, storage) {
  const vendor = connector.vendor;
  const handler = storage ?? getMediaStorage();
  const vendorModels = vendor ? getSTTModelsByVendor(vendor) : [];
  const modelNames = vendorModels.map((m) => m.name);
  const properties = {
    audioSource: {
      type: "string",
      description: "Path or location of the audio file to transcribe (file path, storage location, etc.)"
    }
  };
  if (modelNames.length > 0) {
    const descriptions = vendorModels.map((m) => `${m.name}: ${m.description || m.displayName}`).join("; ");
    properties.model = {
      type: "string",
      enum: modelNames,
      description: `STT model to use. Options: ${descriptions}`
    };
  }
  properties.language = {
    type: "string",
    description: 'Language code (ISO-639-1, e.g., "en", "es", "fr"). Optional for auto-detection.'
  };
  properties.prompt = {
    type: "string",
    description: "Optional context hint to guide transcription (e.g., domain-specific terms)"
  };
  return {
    definition: {
      type: "function",
      function: {
        name: "speech_to_text",
        description: `Transcribe audio to text using ${connector.displayName}`,
        parameters: {
          type: "object",
          properties,
          required: ["audioSource"]
        }
      }
    },
    execute: async (args, _context) => {
      try {
        const audioBuffer = await handler.read(args.audioSource);
        if (!audioBuffer) {
          return {
            success: false,
            error: `Audio not found at: ${args.audioSource}`
          };
        }
        const stt = SpeechToText.create({
          connector,
          model: args.model,
          language: args.language
        });
        const response = await stt.transcribe(audioBuffer, {
          prompt: args.prompt
        });
        return {
          success: true,
          text: response.text,
          language: response.language,
          durationSeconds: response.durationSeconds
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    },
    describeCall: (args) => args.audioSource,
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Transcribe audio using ${connector.displayName}`
    }
  };
}

// src/tools/multimedia/register.ts
var VENDOR_CAPABILITIES = {
  [Vendor.OpenAI]: ["image", "video", "tts", "stt"],
  [Vendor.Google]: ["image", "video", "tts"],
  [Vendor.Grok]: ["image", "video"]
};
function registerMultimediaTools(storage) {
  for (const [vendor, capabilities] of Object.entries(VENDOR_CAPABILITIES)) {
    ConnectorTools.registerService(vendor, (connector, userId) => {
      const handler = getMediaStorage();
      const tools = [];
      if (capabilities.includes("image")) {
        tools.push(createImageGenerationTool(connector, handler, userId));
      }
      if (capabilities.includes("video")) {
        tools.push(...createVideoTools(connector, handler, userId));
      }
      if (capabilities.includes("tts")) {
        tools.push(createTextToSpeechTool(connector, handler, userId));
      }
      if (capabilities.includes("stt")) {
        tools.push(createSpeechToTextTool(connector, handler));
      }
      return tools;
    });
  }
}

// src/tools/multimedia/index.ts
registerMultimediaTools();

// src/tools/github/types.ts
function parseRepository(input) {
  if (!input || input.trim().length === 0) {
    throw new Error("Repository cannot be empty");
  }
  const trimmed = input.trim();
  try {
    const url2 = new URL(trimmed);
    if (url2.hostname === "github.com" || url2.hostname === "www.github.com") {
      const segments = url2.pathname.split("/").filter(Boolean);
      if (segments.length >= 2) {
        return { owner: segments[0], repo: segments[1].replace(/\.git$/, "") };
      }
    }
  } catch {
  }
  const parts = trimmed.split("/");
  if (parts.length === 2 && parts[0].length > 0 && parts[1].length > 0) {
    return { owner: parts[0], repo: parts[1] };
  }
  throw new Error(
    `Invalid repository format: "${input}". Expected "owner/repo" or "https://github.com/owner/repo"`
  );
}
function resolveRepository(repository, connector) {
  const repoStr = repository ?? connector.getOptions().defaultRepository;
  if (!repoStr) {
    return {
      success: false,
      error: 'No repository specified. Provide a "repository" parameter (e.g., "owner/repo") or configure defaultRepository on the connector.'
    };
  }
  try {
    return { success: true, repo: parseRepository(repoStr) };
  } catch (err) {
    return { success: false, error: err instanceof Error ? err.message : String(err) };
  }
}
var GitHubAPIError = class extends Error {
  constructor(status, statusText, body) {
    const msg = typeof body === "object" && body !== null && "message" in body ? body.message : statusText;
    super(`GitHub API error ${status}: ${msg}`);
    this.status = status;
    this.statusText = statusText;
    this.body = body;
    this.name = "GitHubAPIError";
  }
};
async function githubFetch(connector, endpoint, options) {
  let url2 = endpoint;
  if (options?.queryParams && Object.keys(options.queryParams).length > 0) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.queryParams)) {
      params.append(key, String(value));
    }
    url2 += (url2.includes("?") ? "&" : "?") + params.toString();
  }
  const headers = {
    "Accept": options?.accept ?? "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28"
  };
  if (options?.body) {
    headers["Content-Type"] = "application/json";
  }
  const response = await connector.fetch(
    url2,
    {
      method: options?.method ?? "GET",
      headers,
      body: options?.body ? JSON.stringify(options.body) : void 0
    },
    options?.userId
  );
  const text = await response.text();
  let data;
  try {
    data = JSON.parse(text);
  } catch {
    data = text;
  }
  if (!response.ok) {
    throw new GitHubAPIError(response.status, response.statusText, data);
  }
  return data;
}

// src/tools/github/searchFiles.ts
function matchGlobPattern2(pattern, filePath) {
  let regexPattern = pattern.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*\*/g, "{{GLOBSTAR}}").replace(/\*/g, "[^/]*").replace(/\?/g, ".").replace(/\{\{GLOBSTAR\}\}/g, ".*");
  regexPattern = "^" + regexPattern + "$";
  try {
    const regex = new RegExp(regexPattern);
    return regex.test(filePath);
  } catch {
    return false;
  }
}
function createSearchFilesTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "search_files",
        description: `Search for files by name/path pattern in a GitHub repository.

USAGE:
- Supports glob patterns like "**/*.ts", "src/**/*.tsx"
- Returns matching file paths sorted alphabetically
- Uses the repository's file tree for fast matching

PATTERN SYNTAX:
- * matches any characters except /
- ** matches any characters including /
- ? matches a single character

EXAMPLES:
- Find all TypeScript files: { "pattern": "**/*.ts" }
- Find files in src: { "pattern": "src/**/*.{ts,tsx}" }
- Find package.json: { "pattern": "**/package.json" }
- Search specific branch: { "pattern": "**/*.ts", "ref": "develop" }`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            pattern: {
              type: "string",
              description: 'Glob pattern to match files (e.g., "**/*.ts", "src/**/*.tsx")'
            },
            ref: {
              type: "string",
              description: "Branch, tag, or commit SHA. Defaults to the repository's default branch."
            }
          },
          required: ["pattern"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [args.pattern];
      if (args.repository) parts.push(`in ${args.repository}`);
      if (args.ref) parts.push(`@${args.ref}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Search files in a GitHub repository via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        let ref = args.ref;
        if (!ref) {
          const repoInfo = await githubFetch(
            connector,
            `/repos/${owner}/${repo}`,
            { userId: effectiveUserId }
          );
          ref = repoInfo.default_branch;
        }
        const tree = await githubFetch(
          connector,
          `/repos/${owner}/${repo}/git/trees/${ref}?recursive=1`,
          { userId: effectiveUserId }
        );
        const matching = tree.tree.filter(
          (entry) => entry.type === "blob" && matchGlobPattern2(args.pattern, entry.path)
        ).map((entry) => ({
          path: entry.path,
          size: entry.size ?? 0,
          type: entry.type
        })).sort((a, b) => a.path.localeCompare(b.path));
        return {
          success: true,
          files: matching,
          count: matching.length,
          truncated: tree.truncated
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to search files: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/searchCode.ts
function createSearchCodeTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "search_code",
        description: `Search for code content across a GitHub repository.

USAGE:
- Search by keyword, function name, class name, or any text
- Filter by language, path, or file extension
- Returns matching files with text fragments showing context

RATE LIMITS:
- GitHub's code search API is limited to 30 requests per minute
- Results may be incomplete for very large repositories

EXAMPLES:
- Find function: { "query": "function handleAuth", "language": "typescript" }
- Find imports: { "query": "import React", "extension": "tsx" }
- Search in path: { "query": "TODO", "path": "src/utils" }
- Limit results: { "query": "console.log", "limit": 10 }`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            query: {
              type: "string",
              description: "Search query \u2014 keyword, function name, or any text to find in code"
            },
            language: {
              type: "string",
              description: 'Filter by programming language (e.g., "typescript", "python", "go")'
            },
            path: {
              type: "string",
              description: 'Filter by file path prefix (e.g., "src/", "lib/utils")'
            },
            extension: {
              type: "string",
              description: 'Filter by file extension without dot (e.g., "ts", "py", "go")'
            },
            limit: {
              type: "number",
              description: "Maximum number of results (default: 30, max: 100)"
            }
          },
          required: ["query"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [`"${args.query}"`];
      if (args.language) parts.push(`lang:${args.language}`);
      if (args.repository) parts.push(`in ${args.repository}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Search code in a GitHub repository via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        const qualifiers = [`repo:${owner}/${repo}`];
        if (args.language) qualifiers.push(`language:${args.language}`);
        if (args.path) qualifiers.push(`path:${args.path}`);
        if (args.extension) qualifiers.push(`extension:${args.extension}`);
        const q = `${args.query} ${qualifiers.join(" ")}`;
        const perPage = Math.min(args.limit ?? 30, 100);
        const result = await githubFetch(
          connector,
          `/search/code`,
          {
            userId: effectiveUserId,
            // Request text-match fragments
            accept: "application/vnd.github.text-match+json",
            queryParams: { q, per_page: perPage }
          }
        );
        const matches = result.items.map((item) => ({
          file: item.path,
          fragment: item.text_matches?.[0]?.fragment
        }));
        return {
          success: true,
          matches,
          count: result.total_count,
          truncated: result.incomplete_results || result.total_count > perPage
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to search code: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/readFile.ts
function createGitHubReadFileTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "read_file",
        description: `Read file content from a GitHub repository.

USAGE:
- Reads a file and returns content with line numbers
- Supports line range selection with offset/limit for large files
- By default reads up to 2000 lines from the beginning

EXAMPLES:
- Read entire file: { "path": "src/index.ts" }
- Read specific branch: { "path": "README.md", "ref": "develop" }
- Read lines 100-200: { "path": "src/app.ts", "offset": 100, "limit": 100 }
- Specific repo: { "repository": "owner/repo", "path": "package.json" }

NOTE: Files larger than 1MB are fetched via the Git Blob API. Very large files (>5MB) may be truncated.`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            path: {
              type: "string",
              description: 'File path within the repository (e.g., "src/index.ts")'
            },
            ref: {
              type: "string",
              description: "Branch, tag, or commit SHA. Defaults to the repository's default branch."
            },
            offset: {
              type: "number",
              description: "Line number to start reading from (1-indexed). Only provide if the file is too large."
            },
            limit: {
              type: "number",
              description: "Number of lines to read (default: 2000). Only provide if the file is too large."
            }
          },
          required: ["path"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [args.path];
      if (args.repository) parts.push(`in ${args.repository}`);
      if (args.ref) parts.push(`@${args.ref}`);
      if (args.offset && args.limit) parts.push(`[lines ${args.offset}-${args.offset + args.limit}]`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Read a file from a GitHub repository via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        let fileContent;
        let fileSha;
        let fileSize;
        const refParam = args.ref ? `?ref=${encodeURIComponent(args.ref)}` : "";
        const contentResp = await githubFetch(
          connector,
          `/repos/${owner}/${repo}/contents/${args.path}${refParam}`,
          { userId: effectiveUserId }
        );
        if (contentResp.type !== "file") {
          return {
            success: false,
            error: `Path is not a file: ${args.path} (type: ${contentResp.type}). Use search_files to explore the repository.`,
            path: args.path
          };
        }
        fileSha = contentResp.sha;
        fileSize = contentResp.size;
        if (contentResp.content && contentResp.encoding === "base64") {
          fileContent = Buffer.from(contentResp.content, "base64").toString("utf-8");
        } else if (contentResp.git_url) {
          const blob = await githubFetch(
            connector,
            contentResp.git_url,
            { userId: effectiveUserId }
          );
          fileContent = Buffer.from(blob.content, "base64").toString("utf-8");
          fileSize = blob.size;
        } else {
          return {
            success: false,
            error: `Cannot read file content: ${args.path} (no content or git_url in response)`,
            path: args.path
          };
        }
        const offset = args.offset ?? 1;
        const limit = args.limit ?? 2e3;
        const allLines = fileContent.split("\n");
        const totalLines = allLines.length;
        const startIndex = Math.max(0, offset - 1);
        const endIndex = Math.min(totalLines, startIndex + limit);
        const selectedLines = allLines.slice(startIndex, endIndex);
        const lineNumberWidth = String(endIndex).length;
        const formattedLines = selectedLines.map((line, i) => {
          const lineNum = startIndex + i + 1;
          const paddedNum = String(lineNum).padStart(lineNumberWidth, " ");
          const truncatedLine = line.length > 2e3 ? line.substring(0, 2e3) + "..." : line;
          return `${paddedNum}	${truncatedLine}`;
        });
        const truncated = endIndex < totalLines;
        const result = formattedLines.join("\n");
        return {
          success: true,
          content: result,
          path: args.path,
          size: fileSize,
          lines: totalLines,
          truncated,
          sha: fileSha
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
          path: args.path
        };
      }
    }
  };
}

// src/tools/github/getPR.ts
function createGetPRTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "get_pr",
        description: `Get full details of a pull request from a GitHub repository.

Returns: title, description, state, author, labels, reviewers, merge status, branches, file stats, and more.

EXAMPLES:
- Get PR: { "pull_number": 123 }
- Specific repo: { "repository": "owner/repo", "pull_number": 456 }`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            pull_number: {
              type: "number",
              description: "Pull request number"
            }
          },
          required: ["pull_number"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [`#${args.pull_number}`];
      if (args.repository) parts.push(`in ${args.repository}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Get pull request details from GitHub via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        const pr = await githubFetch(
          connector,
          `/repos/${owner}/${repo}/pulls/${args.pull_number}`,
          { userId: effectiveUserId }
        );
        return {
          success: true,
          data: {
            number: pr.number,
            title: pr.title,
            body: pr.body,
            state: pr.state,
            draft: pr.draft,
            author: pr.user.login,
            labels: pr.labels.map((l) => l.name),
            reviewers: pr.requested_reviewers.map((r) => r.login),
            mergeable: pr.mergeable,
            head: pr.head.ref,
            base: pr.base.ref,
            url: pr.html_url,
            created_at: pr.created_at,
            updated_at: pr.updated_at,
            additions: pr.additions,
            deletions: pr.deletions,
            changed_files: pr.changed_files
          }
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to get PR: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/prFiles.ts
function createPRFilesTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "pr_files",
        description: `Get the files changed in a pull request with diffs.

Returns: filename, status (added/modified/removed/renamed), additions, deletions, and patch (diff) content for each file.

EXAMPLES:
- Get files: { "pull_number": 123 }
- Specific repo: { "repository": "owner/repo", "pull_number": 456 }

NOTE: Very large diffs may be truncated by GitHub. Patch content may be absent for binary files.`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            pull_number: {
              type: "number",
              description: "Pull request number"
            }
          },
          required: ["pull_number"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [`files for #${args.pull_number}`];
      if (args.repository) parts.push(`in ${args.repository}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Get PR changed files from GitHub via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        const files = await githubFetch(
          connector,
          `/repos/${owner}/${repo}/pulls/${args.pull_number}/files`,
          {
            userId: effectiveUserId,
            queryParams: { per_page: 100 }
          }
        );
        return {
          success: true,
          files: files.map((f) => ({
            filename: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.changes,
            patch: f.patch
          })),
          count: files.length
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to get PR files: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/prComments.ts
function createPRCommentsTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "pr_comments",
        description: `Get all comments and reviews on a pull request.

Returns a unified list of:
- **review_comment**: Line-level comments on specific code (includes file path and line number)
- **review**: Full reviews (approve/request changes/comment)
- **comment**: General comments on the PR (issue-level)

All entries are sorted by creation date (oldest first).

EXAMPLES:
- Get comments: { "pull_number": 123 }
- Specific repo: { "repository": "owner/repo", "pull_number": 456 }`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            pull_number: {
              type: "number",
              description: "Pull request number"
            }
          },
          required: ["pull_number"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [`comments for #${args.pull_number}`];
      if (args.repository) parts.push(`in ${args.repository}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Get PR comments and reviews from GitHub via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        const basePath = `/repos/${owner}/${repo}`;
        const queryOpts = { userId: effectiveUserId, queryParams: { per_page: 100 } };
        const [reviewComments, reviews, issueComments] = await Promise.all([
          githubFetch(
            connector,
            `${basePath}/pulls/${args.pull_number}/comments`,
            queryOpts
          ),
          githubFetch(
            connector,
            `${basePath}/pulls/${args.pull_number}/reviews`,
            queryOpts
          ),
          githubFetch(
            connector,
            `${basePath}/issues/${args.pull_number}/comments`,
            queryOpts
          )
        ]);
        const allComments = [];
        for (const rc of reviewComments) {
          allComments.push({
            id: rc.id,
            type: "review_comment",
            author: rc.user.login,
            body: rc.body,
            created_at: rc.created_at,
            path: rc.path,
            line: rc.line ?? rc.original_line ?? void 0
          });
        }
        for (const r of reviews) {
          if (!r.body && r.state === "APPROVED") continue;
          allComments.push({
            id: r.id,
            type: "review",
            author: r.user.login,
            body: r.body || `[${r.state}]`,
            created_at: r.submitted_at,
            state: r.state
          });
        }
        for (const ic of issueComments) {
          allComments.push({
            id: ic.id,
            type: "comment",
            author: ic.user.login,
            body: ic.body,
            created_at: ic.created_at
          });
        }
        allComments.sort(
          (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
        );
        return {
          success: true,
          comments: allComments,
          count: allComments.length
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to get PR comments: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/createPR.ts
function createCreatePRTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "create_pr",
        description: `Create a pull request on a GitHub repository.

USAGE:
- Specify source branch (head) and target branch (base)
- Optionally create as draft

EXAMPLES:
- Create PR: { "title": "Add feature", "head": "feature-branch", "base": "main" }
- Draft PR: { "title": "WIP: Refactor", "head": "refactor", "base": "develop", "draft": true }
- With body: { "title": "Fix bug #42", "body": "Fixes the login issue\\n\\n## Changes\\n- Fixed auth flow", "head": "fix/42", "base": "main" }`,
        parameters: {
          type: "object",
          properties: {
            repository: {
              type: "string",
              description: 'Repository in "owner/repo" format or full GitHub URL. Optional if connector has a default repository.'
            },
            title: {
              type: "string",
              description: "Pull request title"
            },
            body: {
              type: "string",
              description: "Pull request description/body (Markdown supported)"
            },
            head: {
              type: "string",
              description: "Source branch name (the branch with your changes)"
            },
            base: {
              type: "string",
              description: 'Target branch name (the branch you want to merge into, e.g., "main")'
            },
            draft: {
              type: "boolean",
              description: "Create as a draft pull request (default: false)"
            }
          },
          required: ["title", "head", "base"]
        }
      }
    },
    describeCall: (args) => {
      const parts = [args.title];
      if (args.repository) parts.push(`in ${args.repository}`);
      return parts.join(" ");
    },
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Create a pull request on GitHub via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      const resolved = resolveRepository(args.repository, connector);
      if (!resolved.success) {
        return { success: false, error: resolved.error };
      }
      const { owner, repo } = resolved.repo;
      try {
        const pr = await githubFetch(
          connector,
          `/repos/${owner}/${repo}/pulls`,
          {
            method: "POST",
            userId: effectiveUserId,
            body: {
              title: args.title,
              body: args.body,
              head: args.head,
              base: args.base,
              draft: args.draft ?? false
            }
          }
        );
        return {
          success: true,
          data: {
            number: pr.number,
            url: pr.html_url,
            state: pr.state,
            title: pr.title
          }
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to create PR: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/github/register.ts
function registerGitHubTools() {
  ConnectorTools.registerService("github", (connector, userId) => {
    return [
      createSearchFilesTool(connector, userId),
      createSearchCodeTool(connector, userId),
      createGitHubReadFileTool(connector, userId),
      createGetPRTool(connector, userId),
      createPRFilesTool(connector, userId),
      createPRCommentsTool(connector, userId),
      createCreatePRTool(connector, userId)
    ];
  });
}

// src/tools/github/index.ts
registerGitHubTools();

// src/tools/microsoft/types.ts
function getUserPathPrefix(connector, targetUser) {
  const auth2 = connector.config.auth;
  if (auth2.type === "oauth" && auth2.flow === "client_credentials") {
    if (!targetUser) {
      throw new Error(
        'targetUser is required when using client_credentials (application) flow. Provide a user ID or UPN (e.g., "user@domain.com").'
      );
    }
    return `/users/${targetUser}`;
  }
  return "/me";
}
var MicrosoftAPIError = class extends Error {
  constructor(status, statusText, body) {
    const msg = typeof body === "object" && body !== null && "error" in body ? body.error?.message ?? statusText : statusText;
    super(`Microsoft Graph API error ${status}: ${msg}`);
    this.status = status;
    this.statusText = statusText;
    this.body = body;
    this.name = "MicrosoftAPIError";
  }
};
async function microsoftFetch(connector, endpoint, options) {
  let url2 = endpoint;
  if (options?.queryParams && Object.keys(options.queryParams).length > 0) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(options.queryParams)) {
      params.append(key, String(value));
    }
    url2 += (url2.includes("?") ? "&" : "?") + params.toString();
  }
  const headers = {
    "Accept": options?.accept ?? "application/json"
  };
  if (options?.body) {
    headers["Content-Type"] = "application/json";
  }
  const response = await connector.fetch(
    url2,
    {
      method: options?.method ?? "GET",
      headers,
      body: options?.body ? JSON.stringify(options.body) : void 0
    },
    options?.userId
  );
  const text = await response.text();
  if (!response.ok) {
    let data;
    try {
      data = JSON.parse(text);
    } catch {
      data = text;
    }
    throw new MicrosoftAPIError(response.status, response.statusText, data);
  }
  if (!text || text.trim().length === 0) {
    return void 0;
  }
  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
}
function normalizeEmails(input) {
  return input.map((item) => {
    if (typeof item === "string") return item;
    if (typeof item === "object" && item !== null) {
      const obj = item;
      if (obj.emailAddress && typeof obj.emailAddress === "object") {
        const ea = obj.emailAddress;
        if (typeof ea.address === "string") return ea.address;
      }
      if (typeof obj.address === "string") return obj.address;
      if (typeof obj.email === "string") return obj.email;
    }
    return String(item);
  });
}
function formatRecipients(emails) {
  return normalizeEmails(emails).map((address) => ({ emailAddress: { address } }));
}
function formatAttendees(emails) {
  return normalizeEmails(emails).map((address) => ({
    emailAddress: { address },
    type: "required"
  }));
}
function isTeamsMeetingUrl(input) {
  try {
    const url2 = new URL(input.trim());
    return (url2.hostname === "teams.microsoft.com" || url2.hostname === "teams.live.com") && url2.pathname.includes("meetup-join");
  } catch {
    return false;
  }
}
async function resolveMeetingId(connector, input, prefix, effectiveUserId) {
  if (!input || input.trim().length === 0) {
    throw new Error("Meeting ID cannot be empty");
  }
  const trimmed = input.trim();
  if (!isTeamsMeetingUrl(trimmed)) {
    return { meetingId: trimmed };
  }
  const meetings = await microsoftFetch(
    connector,
    `${prefix}/onlineMeetings`,
    {
      userId: effectiveUserId,
      queryParams: { "$filter": `JoinWebUrl eq '${trimmed}'` }
    }
  );
  if (!meetings.value || meetings.value.length === 0) {
    throw new Error(
      `Could not find an online meeting matching the provided Teams URL. Make sure the URL is correct and you have access to this meeting.`
    );
  }
  return {
    meetingId: meetings.value[0].id,
    subject: meetings.value[0].subject
  };
}

// src/tools/microsoft/createDraftEmail.ts
function createDraftEmailTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "create_draft_email",
        description: `Create a draft email or draft reply in the user's Outlook mailbox via Microsoft Graph. The draft is saved but NOT sent \u2014 use send_email to send immediately instead.

PARAMETER FORMATS:
- to/cc: plain string array of email addresses. Example: ["alice@contoso.com", "bob@contoso.com"]. Do NOT use objects.
- subject: plain string. Example: "Project update" or "Re: Project update" for replies.
- body: HTML string. Example: "<p>Hi Alice,</p><p>Here is the update.</p>". Use <p>, <br>, <b>, <ul> tags for formatting.
- replyToMessageId: Graph message ID string (starts with "AAMk..."). Only set when replying to an existing email.

EXAMPLES:
- New draft: { "to": ["alice@contoso.com"], "subject": "Project update", "body": "<p>Hi Alice,</p><p>Here is the update.</p>" }
- Reply draft: { "to": ["alice@contoso.com"], "subject": "Re: Project update", "body": "<p>Thanks!</p>", "replyToMessageId": "AAMkADI1..." }
- With CC: { "to": ["alice@contoso.com"], "subject": "Notes", "body": "<p>See attached.</p>", "cc": ["bob@contoso.com"] }`,
        parameters: {
          type: "object",
          properties: {
            to: {
              type: "array",
              items: { type: "string" },
              description: 'Recipient email addresses as plain strings. Example: ["alice@contoso.com", "bob@contoso.com"]'
            },
            subject: {
              type: "string",
              description: 'Email subject as plain string. Example: "Project update" or "Re: Original subject" for replies.'
            },
            body: {
              type: "string",
              description: 'Email body as an HTML string. Example: "<p>Hello!</p><p>See you tomorrow.</p>"'
            },
            cc: {
              type: "array",
              items: { type: "string" },
              description: 'CC email addresses as plain strings. Example: ["bob@contoso.com"]. Optional.'
            },
            replyToMessageId: {
              type: "string",
              description: 'Graph message ID of the email to reply to. Example: "AAMkADI1M2I3YzgtODg...". When set, creates a threaded reply draft.'
            },
            targetUser: {
              type: "string",
              description: 'User ID or email (UPN) for app-only auth. Example: "alice@contoso.com". Ignored in delegated auth.'
            }
          },
          required: ["to", "subject", "body"]
        }
      }
    },
    describeCall: (args) => {
      const action = args.replyToMessageId ? "Reply draft" : "Draft";
      return `${action} to ${args.to.join(", ")}: ${args.subject}`;
    },
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Create a draft email via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        if (args.replyToMessageId) {
          const replyDraft = await microsoftFetch(
            connector,
            `${prefix}/messages/${args.replyToMessageId}/createReply`,
            { method: "POST", userId: effectiveUserId, body: {} }
          );
          const updated = await microsoftFetch(
            connector,
            `${prefix}/messages/${replyDraft.id}`,
            {
              method: "PATCH",
              userId: effectiveUserId,
              body: {
                subject: args.subject,
                body: { contentType: "HTML", content: args.body },
                toRecipients: formatRecipients(args.to),
                ...args.cc && { ccRecipients: formatRecipients(args.cc) }
              }
            }
          );
          return {
            success: true,
            draftId: updated.id,
            webLink: updated.webLink
          };
        }
        const draft = await microsoftFetch(
          connector,
          `${prefix}/messages`,
          {
            method: "POST",
            userId: effectiveUserId,
            body: {
              isDraft: true,
              subject: args.subject,
              body: { contentType: "HTML", content: args.body },
              toRecipients: formatRecipients(args.to),
              ...args.cc && { ccRecipients: formatRecipients(args.cc) }
            }
          }
        );
        return {
          success: true,
          draftId: draft.id,
          webLink: draft.webLink
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to create draft email: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/sendEmail.ts
function createSendEmailTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "send_email",
        description: `Send an email immediately or reply to an existing message via Microsoft Graph (Outlook). The email is sent right away \u2014 use create_draft_email to save a draft instead.

PARAMETER FORMATS:
- to/cc: plain string array of email addresses. Example: ["alice@contoso.com", "bob@contoso.com"]. Do NOT use objects.
- subject: plain string. Example: "Meeting tomorrow" or "Re: Meeting tomorrow" for replies.
- body: HTML string. Example: "<p>Hi Alice,</p><p>Can we meet at 2pm?</p>". Use <p>, <br>, <b>, <ul> tags.
- replyToMessageId: Graph message ID string (starts with "AAMk..."). Only set when replying to an existing email.

EXAMPLES:
- Send email: { "to": ["alice@contoso.com"], "subject": "Meeting tomorrow", "body": "<p>Can we meet at 2pm?</p>" }
- Reply: { "to": ["alice@contoso.com"], "subject": "Re: Meeting", "body": "<p>Confirmed!</p>", "replyToMessageId": "AAMkADI1..." }
- With CC: { "to": ["alice@contoso.com"], "subject": "Update", "body": "<p>FYI</p>", "cc": ["bob@contoso.com"] }`,
        parameters: {
          type: "object",
          properties: {
            to: {
              type: "array",
              items: { type: "string" },
              description: 'Recipient email addresses as plain strings. Example: ["alice@contoso.com", "bob@contoso.com"]'
            },
            subject: {
              type: "string",
              description: 'Email subject as plain string. Example: "Meeting tomorrow" or "Re: Original subject" for replies.'
            },
            body: {
              type: "string",
              description: 'Email body as an HTML string. Example: "<p>Hi!</p><p>Can we meet at 2pm?</p>"'
            },
            cc: {
              type: "array",
              items: { type: "string" },
              description: 'CC email addresses as plain strings. Example: ["bob@contoso.com"]. Optional.'
            },
            replyToMessageId: {
              type: "string",
              description: 'Graph message ID of the email to reply to. Example: "AAMkADI1M2I3YzgtODg...". When set, sends a threaded reply.'
            },
            targetUser: {
              type: "string",
              description: 'User ID or email (UPN) for app-only auth. Example: "alice@contoso.com". Ignored in delegated auth.'
            }
          },
          required: ["to", "subject", "body"]
        }
      }
    },
    describeCall: (args) => {
      const action = args.replyToMessageId ? "Reply" : "Send";
      return `${action} to ${args.to.join(", ")}: ${args.subject}`;
    },
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Send an email via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        if (args.replyToMessageId) {
          await microsoftFetch(
            connector,
            `${prefix}/messages/${args.replyToMessageId}/reply`,
            {
              method: "POST",
              userId: effectiveUserId,
              body: {
                message: {
                  toRecipients: formatRecipients(args.to),
                  ...args.cc && { ccRecipients: formatRecipients(args.cc) }
                },
                comment: args.body
              }
            }
          );
        } else {
          await microsoftFetch(
            connector,
            `${prefix}/sendMail`,
            {
              method: "POST",
              userId: effectiveUserId,
              body: {
                message: {
                  subject: args.subject,
                  body: { contentType: "HTML", content: args.body },
                  toRecipients: formatRecipients(args.to),
                  ...args.cc && { ccRecipients: formatRecipients(args.cc) }
                },
                saveToSentItems: true
              }
            }
          );
        }
        return { success: true };
      } catch (error) {
        return {
          success: false,
          error: `Failed to send email: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/createMeeting.ts
function createMeetingTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "create_meeting",
        description: `Create a calendar event on the user's Outlook calendar via Microsoft Graph, optionally with a Teams online meeting link.

PARAMETER FORMATS:
- subject: plain string. Example: "Sprint Review"
- startDateTime/endDateTime: ISO 8601 string WITHOUT timezone suffix (timezone is a separate param). Example: "2025-01-15T09:00:00"
- attendees: plain string array of email addresses. Example: ["alice@contoso.com", "bob@contoso.com"]. Do NOT use objects.
- body: HTML string for the invitation body. Example: "<p>Agenda: discuss Q1 goals</p>". Optional.
- timeZone: IANA timezone string. Example: "America/New_York", "Europe/Zurich". Default: "UTC".
- isOnlineMeeting: boolean. Set true to auto-generate a Teams meeting link.
- location: plain string. Example: "Conference Room A". Optional.

EXAMPLES:
- Simple: { "subject": "Standup", "startDateTime": "2025-01-15T09:00:00", "endDateTime": "2025-01-15T09:30:00", "attendees": ["alice@contoso.com"], "timeZone": "America/New_York" }
- Teams: { "subject": "Sprint Review", "startDateTime": "2025-01-15T14:00:00", "endDateTime": "2025-01-15T15:00:00", "attendees": ["alice@contoso.com", "bob@contoso.com"], "isOnlineMeeting": true }`,
        parameters: {
          type: "object",
          properties: {
            subject: {
              type: "string",
              description: 'Meeting title as plain string. Example: "Sprint Review"'
            },
            startDateTime: {
              type: "string",
              description: 'Start date/time as ISO 8601 string without timezone suffix. Example: "2025-01-15T09:00:00"'
            },
            endDateTime: {
              type: "string",
              description: 'End date/time as ISO 8601 string without timezone suffix. Example: "2025-01-15T09:30:00"'
            },
            attendees: {
              type: "array",
              items: { type: "string" },
              description: 'Attendee email addresses as plain strings. Example: ["alice@contoso.com", "bob@contoso.com"]'
            },
            body: {
              type: "string",
              description: 'Meeting description as HTML string. Example: "<p>Agenda: discuss Q1 goals</p>". Optional.'
            },
            isOnlineMeeting: {
              type: "boolean",
              description: "Set to true to generate a Teams online meeting link. Default: false."
            },
            location: {
              type: "string",
              description: 'Physical location as plain string. Example: "Conference Room A". Optional.'
            },
            timeZone: {
              type: "string",
              description: 'IANA timezone string for start/end times. Example: "America/New_York", "Europe/Zurich". Default: "UTC".'
            },
            targetUser: {
              type: "string",
              description: 'User ID or email (UPN) for app-only auth. Example: "alice@contoso.com". Ignored in delegated auth.'
            }
          },
          required: ["subject", "startDateTime", "endDateTime", "attendees"]
        }
      }
    },
    describeCall: (args) => {
      return `Create meeting: ${args.subject} (${args.attendees.length} attendees)`;
    },
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Create a calendar event via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        const tz = args.timeZone ?? "UTC";
        const eventBody = {
          subject: args.subject,
          start: { dateTime: args.startDateTime, timeZone: tz },
          end: { dateTime: args.endDateTime, timeZone: tz },
          attendees: formatAttendees(args.attendees)
        };
        if (args.body) {
          eventBody.body = { contentType: "HTML", content: args.body };
        }
        if (args.isOnlineMeeting) {
          eventBody.isOnlineMeeting = true;
          eventBody.onlineMeetingProvider = "teamsForBusiness";
        }
        if (args.location) {
          eventBody.location = { displayName: args.location };
        }
        const event = await microsoftFetch(
          connector,
          `${prefix}/events`,
          { method: "POST", userId: effectiveUserId, body: eventBody }
        );
        return {
          success: true,
          eventId: event.id,
          webLink: event.webLink,
          onlineMeetingUrl: event.onlineMeeting?.joinUrl
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to create meeting: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/editMeeting.ts
function createEditMeetingTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "edit_meeting",
        description: `Update an existing Outlook calendar event via Microsoft Graph. Only the fields you provide will be changed \u2014 omitted fields keep their current values.

IMPORTANT: The "attendees" field REPLACES the entire attendee list. Include ALL desired attendees (both new and existing), not just the ones you want to add.

PARAMETER FORMATS:
- eventId: Graph event ID string (starts with "AAMk..."). Get this from a previous create_meeting result.
- subject: plain string. Example: "Updated: Sprint Review"
- startDateTime/endDateTime: ISO 8601 string without timezone suffix. Example: "2025-01-15T10:00:00"
- attendees: plain string array of email addresses. Example: ["alice@contoso.com", "charlie@contoso.com"]. Do NOT use objects. REPLACES all attendees.
- body: HTML string. Example: "<p>Updated agenda</p>"
- timeZone: IANA timezone string. Example: "Europe/Zurich". Default: "UTC".
- isOnlineMeeting: boolean. true = add Teams link, false = remove it.
- location: plain string. Example: "Room 201"

EXAMPLES:
- Reschedule: { "eventId": "AAMkADI1...", "startDateTime": "2025-01-15T10:00:00", "endDateTime": "2025-01-15T10:30:00", "timeZone": "America/New_York" }
- Change attendees: { "eventId": "AAMkADI1...", "attendees": ["alice@contoso.com", "charlie@contoso.com"] }
- Add Teams link: { "eventId": "AAMkADI1...", "isOnlineMeeting": true }`,
        parameters: {
          type: "object",
          properties: {
            eventId: {
              type: "string",
              description: 'Calendar event ID string from create_meeting result. Example: "AAMkADI1M2I3YzgtODg..."'
            },
            subject: {
              type: "string",
              description: 'New meeting title as plain string. Example: "Updated: Sprint Review"'
            },
            startDateTime: {
              type: "string",
              description: 'New start date/time as ISO 8601 string without timezone suffix. Example: "2025-01-15T10:00:00"'
            },
            endDateTime: {
              type: "string",
              description: 'New end date/time as ISO 8601 string without timezone suffix. Example: "2025-01-15T10:30:00"'
            },
            attendees: {
              type: "array",
              items: { type: "string" },
              description: 'FULL replacement attendee list as plain email strings. Example: ["alice@contoso.com", "charlie@contoso.com"]. Include ALL attendees.'
            },
            body: {
              type: "string",
              description: 'New meeting description as HTML string. Example: "<p>Updated agenda</p>"'
            },
            isOnlineMeeting: {
              type: "boolean",
              description: "true to add Teams meeting link, false to remove it."
            },
            location: {
              type: "string",
              description: 'New location as plain string. Example: "Conference Room A"'
            },
            timeZone: {
              type: "string",
              description: 'IANA timezone string for start/end times. Example: "Europe/Zurich". Default: "UTC".'
            },
            targetUser: {
              type: "string",
              description: 'User ID or email (UPN) for app-only auth. Example: "alice@contoso.com". Ignored in delegated auth.'
            }
          },
          required: ["eventId"]
        }
      }
    },
    describeCall: (args) => {
      const fields = ["subject", "startDateTime", "endDateTime", "attendees", "body", "location"];
      const changed = fields.filter((f) => args[f] !== void 0);
      return `Edit meeting ${args.eventId.slice(0, 12)}... (${changed.join(", ") || "no changes"})`;
    },
    permission: {
      scope: "session",
      riskLevel: "medium",
      approvalMessage: `Update a calendar event via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        const tz = args.timeZone ?? "UTC";
        const patchBody = {};
        if (args.subject !== void 0) patchBody.subject = args.subject;
        if (args.body !== void 0) patchBody.body = { contentType: "HTML", content: args.body };
        if (args.startDateTime !== void 0) patchBody.start = { dateTime: args.startDateTime, timeZone: tz };
        if (args.endDateTime !== void 0) patchBody.end = { dateTime: args.endDateTime, timeZone: tz };
        if (args.attendees !== void 0) {
          patchBody.attendees = formatAttendees(args.attendees);
        }
        if (args.isOnlineMeeting !== void 0) {
          patchBody.isOnlineMeeting = args.isOnlineMeeting;
          if (args.isOnlineMeeting) {
            patchBody.onlineMeetingProvider = "teamsForBusiness";
          }
        }
        if (args.location !== void 0) {
          patchBody.location = { displayName: args.location };
        }
        const event = await microsoftFetch(
          connector,
          `${prefix}/events/${args.eventId}`,
          { method: "PATCH", userId: effectiveUserId, body: patchBody }
        );
        return {
          success: true,
          eventId: event.id,
          webLink: event.webLink
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to edit meeting: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/getMeetingTranscript.ts
function parseVttToText(vtt) {
  const lines = vtt.split("\n");
  const textLines = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "" || trimmed === "WEBVTT" || trimmed.startsWith("NOTE") || /^\d+$/.test(trimmed) || /^\d{2}:\d{2}/.test(trimmed)) {
      continue;
    }
    textLines.push(trimmed);
  }
  return textLines.join("\n");
}
function createGetMeetingTranscriptTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "get_meeting_transcript",
        description: `Retrieve the transcript from a Teams online meeting via Microsoft Graph. Returns plain text with speaker labels (VTT timestamps are stripped).

NOTE: Requires the OnlineMeetingTranscript.Read.All permission. Transcription must have been enabled during the meeting.

USAGE:
- Provide the Teams online meeting ID (NOT the calendar event ID \u2014 this is different) or a Teams meeting join URL
- The meetingId can be found in the Teams meeting details or extracted from the join URL

EXAMPLES:
- By meeting ID: { "meetingId": "MSo1N2Y5ZGFjYy03MWJmLTQ3NDMtYjQxMy01M2EdFGkdRWHJlQ" }
- By Teams join URL: { "meetingId": "https://teams.microsoft.com/l/meetup-join/19%3ameeting_MjA5YjFi..." }`,
        parameters: {
          type: "object",
          properties: {
            meetingId: {
              type: "string",
              description: 'Teams online meeting ID (e.g. "MSo1N2Y5...") or Teams meeting join URL. This is NOT the calendar event ID.'
            },
            targetUser: {
              type: "string",
              description: "User ID or email (UPN) to act on behalf of. Only needed for app-only (client_credentials) auth. Ignored in delegated auth."
            }
          },
          required: ["meetingId"]
        }
      }
    },
    describeCall: (args) => {
      return `Get transcript for meeting ${args.meetingId.slice(0, 20)}...`;
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Get a meeting transcript via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        const resolved = await resolveMeetingId(connector, args.meetingId, prefix, effectiveUserId);
        const meetingId = resolved.meetingId;
        const transcriptList = await microsoftFetch(
          connector,
          `${prefix}/onlineMeetings/${meetingId}/transcripts`,
          { userId: effectiveUserId }
        );
        if (!transcriptList.value || transcriptList.value.length === 0) {
          return {
            success: false,
            error: "No transcripts found for this meeting. The meeting may not have had transcription enabled."
          };
        }
        const transcriptId = transcriptList.value[0].id;
        const contentUrl = `${prefix}/onlineMeetings/${meetingId}/transcripts/${transcriptId}/content`;
        const response = await connector.fetch(
          contentUrl + "?$format=text/vtt",
          { method: "GET", headers: { "Accept": "text/vtt" } },
          effectiveUserId
        );
        if (!response.ok) {
          const errorText = await response.text();
          return {
            success: false,
            error: `Failed to fetch transcript content: ${response.status} ${errorText}`
          };
        }
        const vttContent = await response.text();
        const transcript = parseVttToText(vttContent);
        return {
          success: true,
          transcript,
          meetingSubject: resolved.subject
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to get meeting transcript: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/findMeetingSlots.ts
function createFindMeetingSlotsTool(connector, userId) {
  return {
    definition: {
      type: "function",
      function: {
        name: "find_meeting_slots",
        description: `Find available meeting time slots when all attendees are free, via Microsoft Graph. Checks each attendee's Outlook calendar and suggests times when everyone is available.

PARAMETER FORMATS:
- attendees: plain string array of email addresses. Example: ["alice@contoso.com", "bob@contoso.com"]. Do NOT use objects \u2014 just plain email strings.
- startDateTime/endDateTime: ISO 8601 string without timezone suffix. Example: "2025-01-15T08:00:00". Can span multiple days.
- duration: number of minutes as integer. Example: 30 or 60.
- timeZone: IANA timezone string. Example: "America/New_York", "Europe/Zurich". Default: "UTC".
- maxResults: integer. Default: 5.

EXAMPLES:
- Find 30min slot: { "attendees": ["alice@contoso.com", "bob@contoso.com"], "startDateTime": "2025-01-15T08:00:00", "endDateTime": "2025-01-15T18:00:00", "duration": 30, "timeZone": "America/New_York" }
- Find 1hr slot across days: { "attendees": ["alice@contoso.com"], "startDateTime": "2025-01-15T08:00:00", "endDateTime": "2025-01-17T18:00:00", "duration": 60, "maxResults": 10 }`,
        parameters: {
          type: "object",
          properties: {
            attendees: {
              type: "array",
              items: { type: "string" },
              description: 'Attendee email addresses as plain strings. Example: ["alice@contoso.com", "bob@contoso.com"]. Do NOT pass objects.'
            },
            startDateTime: {
              type: "string",
              description: 'Search window start as ISO 8601 string without timezone suffix. Example: "2025-01-15T08:00:00"'
            },
            endDateTime: {
              type: "string",
              description: 'Search window end as ISO 8601 string without timezone suffix. Example: "2025-01-15T18:00:00". Can span multiple days.'
            },
            duration: {
              type: "number",
              description: "Meeting duration in minutes as integer. Example: 30 or 60."
            },
            timeZone: {
              type: "string",
              description: 'IANA timezone string for start/end times. Example: "America/New_York", "Europe/Zurich". Default: "UTC".'
            },
            maxResults: {
              type: "number",
              description: "Maximum number of time slot suggestions as integer. Default: 5."
            },
            targetUser: {
              type: "string",
              description: 'User ID or email (UPN) for app-only auth. Example: "alice@contoso.com". Ignored in delegated auth.'
            }
          },
          required: ["attendees", "startDateTime", "endDateTime", "duration"]
        }
      }
    },
    describeCall: (args) => {
      return `Find ${args.duration}min slots for ${args.attendees.length} attendees`;
    },
    permission: {
      scope: "session",
      riskLevel: "low",
      approvalMessage: `Find meeting time slots via ${connector.displayName}`
    },
    execute: async (args, context) => {
      const effectiveUserId = context?.userId ?? userId;
      try {
        const prefix = getUserPathPrefix(connector, args.targetUser);
        const tz = args.timeZone ?? "UTC";
        const result = await microsoftFetch(
          connector,
          `${prefix}/findMeetingTimes`,
          {
            method: "POST",
            userId: effectiveUserId,
            body: {
              attendees: formatAttendees(args.attendees),
              timeConstraint: {
                timeslots: [
                  {
                    start: { dateTime: args.startDateTime, timeZone: tz },
                    end: { dateTime: args.endDateTime, timeZone: tz }
                  }
                ]
              },
              meetingDuration: `PT${args.duration}M`,
              maxCandidates: args.maxResults ?? 5
            }
          }
        );
        const slots = (result.meetingTimeSuggestions ?? []).map((s) => ({
          start: s.meetingTimeSlot.start.dateTime,
          end: s.meetingTimeSlot.end.dateTime,
          confidence: String(s.confidence),
          attendeeAvailability: (s.attendeeAvailability ?? []).map((a) => ({
            attendee: a.attendee.emailAddress.address,
            availability: a.availability
          }))
        }));
        return {
          success: true,
          slots,
          emptySuggestionsReason: result.emptySuggestionsReason
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to find meeting slots: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
  };
}

// src/tools/microsoft/register.ts
function registerMicrosoftTools() {
  ConnectorTools.registerService("microsoft", (connector, userId) => {
    return [
      createDraftEmailTool(connector, userId),
      createSendEmailTool(connector, userId),
      createMeetingTool(connector, userId),
      createEditMeetingTool(connector, userId),
      createGetMeetingTranscriptTool(connector, userId),
      createFindMeetingSlotsTool(connector, userId)
    ];
  });
}

// src/tools/microsoft/index.ts
registerMicrosoftTools();

// src/tools/desktop/types.ts
var DEFAULT_DESKTOP_CONFIG = {
  driver: null,
  // Lazy-initialized
  humanDelay: [50, 150],
  humanizeMovement: false
};
async function applyHumanDelay(config) {
  const [min, max] = config.humanDelay ?? DEFAULT_DESKTOP_CONFIG.humanDelay;
  if (min === 0 && max === 0) return;
  const delay = min + Math.random() * (max - min);
  await new Promise((resolve4) => setTimeout(resolve4, delay));
}
var DESKTOP_TOOL_NAMES = [
  "desktop_screenshot",
  "desktop_mouse_move",
  "desktop_mouse_click",
  "desktop_mouse_drag",
  "desktop_mouse_scroll",
  "desktop_get_cursor",
  "desktop_keyboard_type",
  "desktop_keyboard_key",
  "desktop_get_screen_size",
  "desktop_window_list",
  "desktop_window_focus"
];

// src/tools/desktop/driver/NutTreeDriver.ts
var KEY_MAP = {
  // Modifiers
  ctrl: "LeftControl",
  control: "LeftControl",
  cmd: "LeftCmd",
  command: "LeftCmd",
  meta: "LeftCmd",
  super: "LeftCmd",
  alt: "LeftAlt",
  option: "LeftAlt",
  shift: "LeftShift",
  // Navigation
  enter: "Return",
  return: "Return",
  tab: "Tab",
  escape: "Escape",
  esc: "Escape",
  backspace: "Backspace",
  delete: "Delete",
  space: "Space",
  // Arrow keys
  up: "Up",
  down: "Down",
  left: "Left",
  right: "Right",
  // Function keys
  f1: "F1",
  f2: "F2",
  f3: "F3",
  f4: "F4",
  f5: "F5",
  f6: "F6",
  f7: "F7",
  f8: "F8",
  f9: "F9",
  f10: "F10",
  f11: "F11",
  f12: "F12",
  // Other
  home: "Home",
  end: "End",
  pageup: "PageUp",
  pagedown: "PageDown",
  insert: "Insert",
  printscreen: "Print",
  capslock: "CapsLock",
  numlock: "NumLock",
  scrolllock: "ScrollLock"
};
function parseKeyCombo(keys, KeyEnum) {
  const parts = keys.toLowerCase().split("+").map((k) => k.trim());
  const result = [];
  for (const part of parts) {
    const mapped = KEY_MAP[part];
    if (mapped && KeyEnum[mapped] !== void 0) {
      result.push(KeyEnum[mapped]);
      continue;
    }
    if (part.length === 1) {
      const upper = part.toUpperCase();
      if (KeyEnum[upper] !== void 0) {
        result.push(KeyEnum[upper]);
        continue;
      }
    }
    const pascal = part.charAt(0).toUpperCase() + part.slice(1);
    if (KeyEnum[pascal] !== void 0) {
      result.push(KeyEnum[pascal]);
      continue;
    }
    if (KeyEnum[part] !== void 0) {
      result.push(KeyEnum[part]);
      continue;
    }
    throw new Error(`Unknown key: "${part}". Available modifiers: ctrl, cmd, alt, shift. Common keys: enter, tab, escape, space, up, down, left, right, f1-f12, a-z, 0-9`);
  }
  return result;
}
async function encodeRGBAToPNG(data, width, height) {
  const { PNG } = await import('pngjs');
  const png = new PNG({ width, height });
  const sourceBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data);
  sourceBuffer.copy(png.data, 0, 0, width * height * 4);
  return PNG.sync.write(png);
}
var NutTreeDriver = class {
  _isInitialized = false;
  _scaleFactor = 1;
  // Lazy-loaded nut-tree modules
  _nut = null;
  // Cache of Window objects keyed by windowHandle, populated by getWindowList()
  _windowCache = /* @__PURE__ */ new Map();
  get isInitialized() {
    return this._isInitialized;
  }
  get scaleFactor() {
    return this._scaleFactor;
  }
  async initialize() {
    if (this._isInitialized) return;
    try {
      this._nut = await import('@nut-tree-fork/nut-js');
    } catch {
      throw new Error(
        "@nut-tree-fork/nut-js is not installed. Install it to use desktop automation tools:\n  npm install @nut-tree-fork/nut-js"
      );
    }
    try {
      const { mouse, keyboard } = this._nut;
      if (mouse.config) {
        mouse.config.mouseSpeed = 1e4;
        mouse.config.autoDelayMs = 0;
      }
      if (keyboard.config) {
        keyboard.config.autoDelayMs = 0;
      }
    } catch {
    }
    try {
      const { screen } = this._nut;
      const logicalWidth = await screen.width();
      const screenshotImage = await screen.grab();
      const physicalWidth = screenshotImage.width;
      this._scaleFactor = physicalWidth / logicalWidth;
    } catch (err) {
      if (err.message?.includes("permission") || err.message?.includes("accessibility")) {
        throw new Error(
          "Desktop automation requires accessibility permissions.\nOn macOS: System Settings \u2192 Privacy & Security \u2192 Accessibility \u2192 Enable your terminal app."
        );
      }
      this._scaleFactor = 1;
    }
    this._isInitialized = true;
  }
  assertInitialized() {
    if (!this._isInitialized) {
      throw new Error("NutTreeDriver not initialized. Call initialize() first.");
    }
  }
  /** Convert physical (screenshot) coords to logical (OS) coords */
  toLogical(x, y) {
    return {
      x: Math.round(x / this._scaleFactor),
      y: Math.round(y / this._scaleFactor)
    };
  }
  /** Convert logical (OS) coords to physical (screenshot) coords */
  toPhysical(x, y) {
    return {
      x: Math.round(x * this._scaleFactor),
      y: Math.round(y * this._scaleFactor)
    };
  }
  // ===== Screen =====
  async screenshot(region) {
    this.assertInitialized();
    const { screen } = this._nut;
    let image;
    if (region) {
      const { Region } = this._nut;
      const logTopLeft = this.toLogical(region.x, region.y);
      const logicalWidth = Math.round(region.width / this._scaleFactor);
      const logicalHeight = Math.round(region.height / this._scaleFactor);
      const nutRegion = new Region(logTopLeft.x, logTopLeft.y, logicalWidth, logicalHeight);
      image = await screen.grabRegion(nutRegion);
    } else {
      image = await screen.grab();
    }
    const pngBuffer = await encodeRGBAToPNG(image.data, image.width, image.height);
    const base64 = pngBuffer.toString("base64");
    return {
      base64,
      width: image.width,
      height: image.height
    };
  }
  async getScreenSize() {
    this.assertInitialized();
    const { screen } = this._nut;
    const logicalWidth = await screen.width();
    const logicalHeight = await screen.height();
    return {
      physicalWidth: Math.round(logicalWidth * this._scaleFactor),
      physicalHeight: Math.round(logicalHeight * this._scaleFactor),
      logicalWidth,
      logicalHeight,
      scaleFactor: this._scaleFactor
    };
  }
  // ===== Mouse =====
  async mouseMove(x, y) {
    this.assertInitialized();
    const { mouse, straightTo, Point } = this._nut;
    const logical = this.toLogical(x, y);
    await mouse.move(straightTo(new Point(logical.x, logical.y)));
  }
  async mouseClick(x, y, button, clickCount) {
    this.assertInitialized();
    const { mouse, straightTo, Point, Button } = this._nut;
    const nutButton = button === "right" ? Button.RIGHT : button === "middle" ? Button.MIDDLE : Button.LEFT;
    const logical = this.toLogical(x, y);
    await mouse.move(straightTo(new Point(logical.x, logical.y)));
    for (let i = 0; i < clickCount; i++) {
      await mouse.click(nutButton);
    }
  }
  async mouseDrag(startX, startY, endX, endY, button) {
    this.assertInitialized();
    const { mouse, straightTo, Point, Button } = this._nut;
    const nutButton = button === "right" ? Button.RIGHT : button === "middle" ? Button.MIDDLE : Button.LEFT;
    const logicalStart = this.toLogical(startX, startY);
    const logicalEnd = this.toLogical(endX, endY);
    await mouse.move(straightTo(new Point(logicalStart.x, logicalStart.y)));
    await mouse.pressButton(nutButton);
    await mouse.move(straightTo(new Point(logicalEnd.x, logicalEnd.y)));
    await mouse.releaseButton(nutButton);
  }
  async mouseScroll(deltaX, deltaY, x, y) {
    this.assertInitialized();
    const { mouse, straightTo, Point } = this._nut;
    if (x !== void 0 && y !== void 0) {
      const logical = this.toLogical(x, y);
      await mouse.move(straightTo(new Point(logical.x, logical.y)));
    }
    if (deltaY !== 0) {
      if (deltaY > 0) {
        await mouse.scrollDown(Math.abs(deltaY));
      } else {
        await mouse.scrollUp(Math.abs(deltaY));
      }
    }
    if (deltaX !== 0) {
      if (deltaX > 0) {
        await mouse.scrollRight(Math.abs(deltaX));
      } else {
        await mouse.scrollLeft(Math.abs(deltaX));
      }
    }
  }
  async getCursorPosition() {
    this.assertInitialized();
    const { mouse } = this._nut;
    const pos = await mouse.getPosition();
    return this.toPhysical(pos.x, pos.y);
  }
  // ===== Keyboard =====
  async keyboardType(text, delay) {
    this.assertInitialized();
    const { keyboard } = this._nut;
    const prevDelay = keyboard.config.autoDelayMs;
    if (delay !== void 0) {
      keyboard.config.autoDelayMs = delay;
    }
    try {
      await keyboard.type(text);
    } finally {
      if (delay !== void 0) {
        keyboard.config.autoDelayMs = prevDelay;
      }
    }
  }
  async keyboardKey(keys) {
    this.assertInitialized();
    const { keyboard, Key } = this._nut;
    const parsedKeys = parseKeyCombo(keys, Key);
    if (parsedKeys.length === 1) {
      await keyboard.pressKey(parsedKeys[0]);
      await keyboard.releaseKey(parsedKeys[0]);
    } else {
      for (const key of parsedKeys) {
        await keyboard.pressKey(key);
      }
      for (const key of [...parsedKeys].reverse()) {
        await keyboard.releaseKey(key);
      }
    }
  }
  // ===== Windows =====
  async getWindowList() {
    this.assertInitialized();
    const { getWindows } = this._nut;
    try {
      const windows = await getWindows();
      const result = [];
      this._windowCache.clear();
      for (const win of windows) {
        try {
          const handle = win.windowHandle;
          if (handle === void 0 || handle === null) continue;
          const title = await win.title;
          const region = await win.region;
          this._windowCache.set(handle, win);
          result.push({
            id: handle,
            title: title || "",
            bounds: region ? {
              x: Math.round(region.left * this._scaleFactor),
              y: Math.round(region.top * this._scaleFactor),
              width: Math.round(region.width * this._scaleFactor),
              height: Math.round(region.height * this._scaleFactor)
            } : void 0
          });
        } catch {
        }
      }
      return result;
    } catch {
      return [];
    }
  }
  async focusWindow(windowId) {
    this.assertInitialized();
    let target = this._windowCache.get(windowId);
    if (!target) {
      const { getWindows } = this._nut;
      const windows = await getWindows();
      target = windows.find((w) => w.windowHandle === windowId);
    }
    if (!target) {
      throw new Error(`Window with ID ${windowId} not found. Call desktop_window_list first to get current window IDs.`);
    }
    await target.focus();
  }
};

// src/tools/desktop/getDriver.ts
var defaultDriver = null;
async function getDesktopDriver(config) {
  if (config?.driver) {
    if (!config.driver.isInitialized) {
      await config.driver.initialize();
    }
    return config.driver;
  }
  if (!defaultDriver) {
    defaultDriver = new NutTreeDriver();
  }
  if (!defaultDriver.isInitialized) {
    await defaultDriver.initialize();
  }
  return defaultDriver;
}
function resetDefaultDriver() {
  defaultDriver = null;
}

// src/tools/desktop/screenshot.ts
function createDesktopScreenshotTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_screenshot",
        description: `Take a screenshot of the entire screen or a specific region. Returns the screenshot image for visual analysis. Use this to see what's on screen before performing actions. IMPORTANT: If you capture a region, element positions in the image are relative to the region's top-left corner. To click an element at image position (ix, iy), you must use screen coordinates (ix + region.x, iy + region.y). Prefer full-screen screenshots to avoid coordinate offset errors.`,
        parameters: {
          type: "object",
          properties: {
            region: {
              type: "object",
              description: "Optional region to capture (in physical pixel coordinates). Omit to capture full screen.",
              properties: {
                x: { type: "number", description: "Left edge X coordinate" },
                y: { type: "number", description: "Top edge Y coordinate" },
                width: { type: "number", description: "Width in pixels" },
                height: { type: "number", description: "Height in pixels" }
              },
              required: ["x", "y", "width", "height"]
            }
          },
          required: []
        }
      }
    },
    describeCall: (args) => {
      if (args.region) {
        return `region (${args.region.x},${args.region.y}) ${args.region.width}x${args.region.height}`;
      }
      return "full screen";
    },
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        const screenshot = await driver.screenshot(args.region);
        return {
          success: true,
          width: screenshot.width,
          height: screenshot.height,
          base64: screenshot.base64,
          __images: [{ base64: screenshot.base64, mediaType: "image/png" }],
          // Include region info so the agent can compute screen coordinates:
          // screen_x = image_x + regionOffsetX, screen_y = image_y + regionOffsetY
          ...args.region ? { regionOffsetX: args.region.x, regionOffsetY: args.region.y } : {}
        };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopScreenshot = createDesktopScreenshotTool();

// src/tools/desktop/mouseMove.ts
function createDesktopMouseMoveTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_mouse_move",
        description: `Move the mouse cursor to the specified (x, y) position. Coordinates are in screenshot pixel space (full screen). Returns the actual cursor position after the move for verification.`,
        parameters: {
          type: "object",
          properties: {
            x: { type: "number", description: "X coordinate (in screenshot pixels)" },
            y: { type: "number", description: "Y coordinate (in screenshot pixels)" }
          },
          required: ["x", "y"]
        }
      }
    },
    describeCall: (args) => `(${args.x}, ${args.y})`,
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.mouseMove(args.x, args.y);
        await applyHumanDelay(config ?? {});
        const actual = await driver.getCursorPosition();
        return { success: true, x: actual.x, y: actual.y };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopMouseMove = createDesktopMouseMoveTool();

// src/tools/desktop/mouseClick.ts
function createDesktopMouseClickTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_mouse_click",
        description: `Click the mouse at the specified position or at the current cursor position. Supports left/right/middle button and single/double/triple click.`,
        parameters: {
          type: "object",
          properties: {
            x: { type: "number", description: "X coordinate to click (in screenshot pixels). Omit to click at current position." },
            y: { type: "number", description: "Y coordinate to click (in screenshot pixels). Omit to click at current position." },
            button: {
              type: "string",
              enum: ["left", "right", "middle"],
              description: 'Mouse button to click. Default: "left"'
            },
            clickCount: {
              type: "number",
              description: "Number of clicks (1=single, 2=double, 3=triple). Default: 1"
            }
          },
          required: []
        }
      }
    },
    describeCall: (args) => {
      const pos = args.x !== void 0 ? `(${args.x}, ${args.y})` : "current position";
      const btn = args.button && args.button !== "left" ? ` ${args.button}` : "";
      const count = args.clickCount && args.clickCount > 1 ? ` x${args.clickCount}` : "";
      return `${pos}${btn}${count}`;
    },
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        const button = args.button ?? "left";
        const clickCount = args.clickCount ?? 1;
        if (args.x !== void 0 && args.y !== void 0) {
          await driver.mouseClick(args.x, args.y, button, clickCount);
        } else {
          const pos = await driver.getCursorPosition();
          await driver.mouseClick(pos.x, pos.y, button, clickCount);
        }
        await applyHumanDelay(config ?? {});
        const actual = await driver.getCursorPosition();
        return { success: true, x: actual.x, y: actual.y, button, clickCount };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopMouseClick = createDesktopMouseClickTool();

// src/tools/desktop/mouseDrag.ts
function createDesktopMouseDragTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_mouse_drag",
        description: `Drag the mouse from one position to another. Presses the button at the start position, moves to the end position, then releases.`,
        parameters: {
          type: "object",
          properties: {
            startX: { type: "number", description: "Start X coordinate (in screenshot pixels)" },
            startY: { type: "number", description: "Start Y coordinate (in screenshot pixels)" },
            endX: { type: "number", description: "End X coordinate (in screenshot pixels)" },
            endY: { type: "number", description: "End Y coordinate (in screenshot pixels)" },
            button: {
              type: "string",
              enum: ["left", "right", "middle"],
              description: 'Mouse button to use for dragging. Default: "left"'
            }
          },
          required: ["startX", "startY", "endX", "endY"]
        }
      }
    },
    describeCall: (args) => `(${args.startX},${args.startY}) \u2192 (${args.endX},${args.endY})`,
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.mouseDrag(args.startX, args.startY, args.endX, args.endY, args.button ?? "left");
        await applyHumanDelay(config ?? {});
        return { success: true };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopMouseDrag = createDesktopMouseDragTool();

// src/tools/desktop/mouseScroll.ts
function createDesktopMouseScrollTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_mouse_scroll",
        description: `Scroll the mouse wheel. Positive deltaY scrolls down, negative scrolls up. Positive deltaX scrolls right, negative scrolls left. Optionally specify position to scroll at.`,
        parameters: {
          type: "object",
          properties: {
            deltaX: { type: "number", description: "Horizontal scroll amount. Positive=right, negative=left. Default: 0" },
            deltaY: { type: "number", description: "Vertical scroll amount. Positive=down, negative=up. Default: 0" },
            x: { type: "number", description: "X coordinate to scroll at (in screenshot pixels). Omit to scroll at current position." },
            y: { type: "number", description: "Y coordinate to scroll at (in screenshot pixels). Omit to scroll at current position." }
          },
          required: []
        }
      }
    },
    describeCall: (args) => {
      const parts = [];
      if (args.deltaY) parts.push(args.deltaY > 0 ? `down ${args.deltaY}` : `up ${Math.abs(args.deltaY)}`);
      if (args.deltaX) parts.push(args.deltaX > 0 ? `right ${args.deltaX}` : `left ${Math.abs(args.deltaX)}`);
      if (args.x !== void 0) parts.push(`at (${args.x},${args.y})`);
      return parts.join(", ") || "no-op";
    },
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.mouseScroll(args.deltaX ?? 0, args.deltaY ?? 0, args.x, args.y);
        await applyHumanDelay(config ?? {});
        return { success: true };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopMouseScroll = createDesktopMouseScrollTool();

// src/tools/desktop/getCursor.ts
function createDesktopGetCursorTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_get_cursor",
        description: `Get the current mouse cursor position in screenshot pixel coordinates.`,
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    },
    describeCall: () => "get cursor position",
    execute: async () => {
      try {
        const driver = await getDesktopDriver(config);
        const pos = await driver.getCursorPosition();
        return { success: true, x: pos.x, y: pos.y };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopGetCursor = createDesktopGetCursorTool();

// src/tools/desktop/keyboardType.ts
function createDesktopKeyboardTypeTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_keyboard_type",
        description: `Type text using the keyboard. Each character is typed as a keypress. Use this for entering text into focused input fields.`,
        parameters: {
          type: "object",
          properties: {
            text: { type: "string", description: "The text to type" },
            delay: { type: "number", description: "Delay in ms between each keystroke. Default: uses system default." }
          },
          required: ["text"]
        }
      }
    },
    describeCall: (args) => {
      const preview = args.text.length > 30 ? args.text.slice(0, 27) + "..." : args.text;
      return `"${preview}"`;
    },
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.keyboardType(args.text, args.delay);
        await applyHumanDelay(config ?? {});
        return { success: true };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopKeyboardType = createDesktopKeyboardTypeTool();

// src/tools/desktop/keyboardKey.ts
function createDesktopKeyboardKeyTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_keyboard_key",
        description: `Press a keyboard shortcut or special key. Use "+" to combine keys (e.g., "ctrl+c", "cmd+shift+s", "enter", "tab", "escape"). Modifiers: ctrl, cmd/command, alt/option, shift. Special keys: enter, tab, escape, backspace, delete, space, up, down, left, right, f1-f12, home, end, pageup, pagedown.`,
        parameters: {
          type: "object",
          properties: {
            keys: {
              type: "string",
              description: 'Key combo string (e.g., "ctrl+c", "enter", "cmd+shift+s")'
            }
          },
          required: ["keys"]
        }
      }
    },
    describeCall: (args) => args.keys,
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.keyboardKey(args.keys);
        await applyHumanDelay(config ?? {});
        return { success: true };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopKeyboardKey = createDesktopKeyboardKeyTool();

// src/tools/desktop/getScreenSize.ts
function createDesktopGetScreenSizeTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_get_screen_size",
        description: `Get the screen dimensions. Returns physical pixel size (screenshot space), logical size (OS coordinates), and the scale factor (e.g., 2.0 on Retina displays). All desktop tool coordinates use physical pixel space.`,
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    },
    describeCall: () => "get screen size",
    execute: async () => {
      try {
        const driver = await getDesktopDriver(config);
        const size = await driver.getScreenSize();
        return {
          success: true,
          physicalWidth: size.physicalWidth,
          physicalHeight: size.physicalHeight,
          logicalWidth: size.logicalWidth,
          logicalHeight: size.logicalHeight,
          scaleFactor: size.scaleFactor
        };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopGetScreenSize = createDesktopGetScreenSizeTool();

// src/tools/desktop/windowList.ts
function createDesktopWindowListTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_window_list",
        description: `List all visible windows on the desktop. Returns window IDs, titles, application names, and bounds. Use the window ID with desktop_window_focus to bring a window to the foreground.`,
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    },
    describeCall: () => "list windows",
    execute: async () => {
      try {
        const driver = await getDesktopDriver(config);
        const windows = await driver.getWindowList();
        return { success: true, windows };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopWindowList = createDesktopWindowListTool();

// src/tools/desktop/windowFocus.ts
function createDesktopWindowFocusTool(config) {
  return {
    definition: {
      type: "function",
      function: {
        name: "desktop_window_focus",
        description: `Focus (bring to front) a window by its ID. Use desktop_window_list to get available window IDs.`,
        parameters: {
          type: "object",
          properties: {
            windowId: {
              type: "number",
              description: "The window ID from desktop_window_list"
            }
          },
          required: ["windowId"]
        }
      }
    },
    describeCall: (args) => `window ${args.windowId}`,
    execute: async (args) => {
      try {
        const driver = await getDesktopDriver(config);
        await driver.focusWindow(args.windowId);
        return { success: true };
      } catch (err) {
        return { success: false, error: err.message };
      }
    }
  };
}
var desktopWindowFocus = createDesktopWindowFocusTool();

// src/tools/desktop/index.ts
var desktopTools = [
  desktopScreenshot,
  desktopMouseMove,
  desktopMouseClick,
  desktopMouseDrag,
  desktopMouseScroll,
  desktopGetCursor,
  desktopKeyboardType,
  desktopKeyboardKey,
  desktopGetScreenSize,
  desktopWindowList,
  desktopWindowFocus
];

// src/tools/custom-tools/resolveStorage.ts
init_StorageRegistry();
function buildStorageContext2(toolContext) {
  const global2 = exports.StorageRegistry.getContext();
  if (global2) return global2;
  if (toolContext?.userId) return { userId: toolContext.userId };
  return void 0;
}
function resolveCustomToolStorage(explicit, toolContext) {
  if (explicit) return explicit;
  const factory = exports.StorageRegistry.get("customTools");
  if (factory) {
    return factory(buildStorageContext2(toolContext));
  }
  return new FileCustomToolStorage();
}

// src/tools/custom-tools/customToolDelete.ts
function createCustomToolDelete(storage) {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_delete",
        description: "Delete a custom tool from persistent storage.",
        parameters: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Name of the tool to delete"
            }
          },
          required: ["name"]
        }
      }
    },
    permission: { scope: "session", riskLevel: "medium" },
    execute: async (args, context) => {
      try {
        const userId = context?.userId;
        const s = resolveCustomToolStorage(storage, context);
        const exists = await s.exists(userId, args.name);
        if (!exists) {
          return { success: false, name: args.name, error: `Custom tool '${args.name}' not found` };
        }
        await s.delete(userId, args.name);
        return { success: true, name: args.name };
      } catch (error) {
        return { success: false, name: args.name, error: error.message };
      }
    },
    describeCall: (args) => args.name
  };
}
var customToolDelete = createCustomToolDelete();

// src/tools/custom-tools/sandboxDescription.ts
init_Connector();
function formatConnectorEntry2(c) {
  const parts = [];
  const serviceOrVendor = c.serviceType ?? c.vendor ?? void 0;
  if (serviceOrVendor) parts.push(`Service: ${serviceOrVendor}`);
  if (c.config.description) parts.push(c.config.description);
  if (c.baseURL) parts.push(`URL: ${c.baseURL}`);
  const details = parts.map((p) => `     ${p}`).join("\n");
  return `   \u2022 "${c.name}" (${c.displayName})
${details}`;
}
function buildConnectorList(context) {
  const registry = context?.connectorRegistry ?? exports.Connector.asRegistry();
  const connectors = registry.listAll();
  if (connectors.length === 0) {
    return "   No connectors registered.";
  }
  return connectors.map(formatConnectorEntry2).join("\n\n");
}
var SANDBOX_API_REFERENCE = `SANDBOX API (available inside custom tool code):

1. authenticatedFetch(url, options, connectorName)
   Makes authenticated HTTP requests using the connector's credentials.
   Auth headers are added automatically \u2014 DO NOT set Authorization header manually.

   Parameters:
     \u2022 url: Full URL or path relative to the connector's base URL
       - Full: "https://api.github.com/user/repos"
       - Relative: "/user/repos" (resolved against connector's base URL)
     \u2022 options: Standard fetch options { method, headers, body }
       - For POST/PUT: set body to JSON.stringify(data) and headers to { 'Content-Type': 'application/json' }
     \u2022 connectorName: Name of a registered connector (see REGISTERED CONNECTORS below)

   Returns: Promise<Response>
     \u2022 response.ok \u2014 true if status 200-299
     \u2022 response.status \u2014 HTTP status code
     \u2022 await response.json() \u2014 parse JSON body
     \u2022 await response.text() \u2014 get text body

2. fetch(url, options) \u2014 Standard fetch without authentication

3. connectors.list() \u2014 Array of available connector names
4. connectors.get(name) \u2014 Connector info: { displayName, description, baseURL, serviceType }

VARIABLES:
   \u2022 input \u2014 the tool's input arguments (matches inputSchema)
   \u2022 output \u2014 SET THIS to return the tool's result to the caller

GLOBALS: console.log/error/warn, JSON, Math, Date, Buffer, Promise, Array, Object, String, Number, Boolean, setTimeout, setInterval, URL, URLSearchParams, RegExp, Map, Set, Error, TextEncoder, TextDecoder

LIMITS: No file system access, no require/import. Code runs in async context (await is available).`;
function buildDraftDescription(context) {
  const connectorList = buildConnectorList(context);
  return `Validate a draft custom tool definition. Checks name format, schema structure, and code syntax.

When writing the "code" field, you have access to the full VM sandbox:

${SANDBOX_API_REFERENCE}

REGISTERED CONNECTORS:
${connectorList}

CODE EXAMPLES:

// Simple data processing tool
const items = input.data;
output = items.filter(i => i.score > 0.8).sort((a, b) => b.score - a.score);

// API tool using a connector
const resp = await authenticatedFetch('/user/repos', { method: 'GET' }, 'github');
const repos = await resp.json();
output = repos.map(r => ({ name: r.full_name, stars: r.stargazers_count }));

// Tool that chains multiple API calls
const users = await (await authenticatedFetch('/users', {}, 'my-api')).json();
const enriched = await Promise.all(users.map(async u => {
  const details = await (await authenticatedFetch(\`/users/\${u.id}\`, {}, 'my-api')).json();
  return { ...u, ...details };
}));
output = enriched;`;
}
function buildTestDescription(context) {
  const connectorList = buildConnectorList(context);
  return `Test custom tool code by executing it in the VM sandbox with provided test input. Returns execution result, captured logs, and timing.

The code runs in the same sandbox as execute_javascript:

${SANDBOX_API_REFERENCE}

REGISTERED CONNECTORS:
${connectorList}

The testInput you provide will be available as the \`input\` variable in the code.
Set \`output\` to the value you want returned.`;
}

// src/tools/custom-tools/customToolDraft.ts
var NAME_PATTERN = /^[a-z][a-z0-9_]*$/;
function createCustomToolDraft() {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_draft",
        description: "Validate a draft custom tool definition. Checks name format, schema structure, and code syntax.",
        parameters: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: 'Tool name (lowercase, underscores, must start with letter). Example: "fetch_weather"'
            },
            description: {
              type: "string",
              description: "What the tool does"
            },
            inputSchema: {
              type: "object",
              description: 'JSON Schema for the tool input (must have type: "object")'
            },
            outputSchema: {
              type: "object",
              description: "Optional JSON Schema for the tool output (documentation only)"
            },
            code: {
              type: "string",
              description: "JavaScript code that reads `input` and sets `output`. Runs in the same sandbox as execute_javascript. See tool description for full API reference."
            },
            tags: {
              type: "array",
              description: "Optional tags for categorization",
              items: { type: "string" }
            },
            connectorName: {
              type: "string",
              description: "Optional connector name if the tool requires API access"
            }
          },
          required: ["name", "description", "inputSchema", "code"]
        }
      }
    },
    descriptionFactory: (context) => buildDraftDescription(context),
    permission: { scope: "always", riskLevel: "low" },
    execute: async (args) => {
      const errors = [];
      if (!args.name || typeof args.name !== "string") {
        errors.push("name is required and must be a string");
      } else if (!NAME_PATTERN.test(args.name)) {
        errors.push(
          `name "${args.name}" is invalid. Must match /^[a-z][a-z0-9_]*$/ (lowercase, underscores, start with letter)`
        );
      }
      if (!args.description || typeof args.description !== "string" || args.description.trim().length === 0) {
        errors.push("description is required and must be a non-empty string");
      }
      if (!args.inputSchema || typeof args.inputSchema !== "object") {
        errors.push("inputSchema is required and must be an object");
      } else if (args.inputSchema.type !== "object") {
        errors.push('inputSchema.type must be "object"');
      }
      if (!args.code || typeof args.code !== "string" || args.code.trim().length === 0) {
        errors.push("code is required and must be a non-empty string");
      } else {
        try {
          new Function(args.code);
        } catch (e) {
          errors.push(`code has syntax error: ${e.message}`);
        }
      }
      if (errors.length > 0) {
        return { success: false, errors };
      }
      return {
        success: true,
        validated: {
          name: args.name,
          description: args.description,
          inputSchema: args.inputSchema,
          outputSchema: args.outputSchema,
          code: args.code,
          tags: args.tags,
          connectorName: args.connectorName
        }
      };
    },
    describeCall: (args) => args.name ?? "unknown"
  };
}
var customToolDraft = createCustomToolDraft();

// src/tools/custom-tools/customToolList.ts
function createCustomToolList(storage) {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_list",
        description: "List saved custom tools from persistent storage. Supports filtering by search text, tags, and category.",
        parameters: {
          type: "object",
          properties: {
            search: {
              type: "string",
              description: "Search text (case-insensitive substring match on name + description)"
            },
            tags: {
              type: "array",
              description: "Filter by tags (any match)",
              items: { type: "string" }
            },
            category: {
              type: "string",
              description: "Filter by category"
            },
            limit: {
              type: "number",
              description: "Maximum number of results"
            },
            offset: {
              type: "number",
              description: "Offset for pagination"
            }
          }
        }
      }
    },
    permission: { scope: "always", riskLevel: "low" },
    execute: async (args, context) => {
      const userId = context?.userId;
      const s = resolveCustomToolStorage(storage, context);
      const tools = await s.list(userId, {
        search: args.search,
        tags: args.tags,
        category: args.category,
        limit: args.limit,
        offset: args.offset
      });
      return { tools, total: tools.length };
    },
    describeCall: (args) => args.search ?? "all tools"
  };
}
var customToolList = createCustomToolList();

// src/tools/custom-tools/customToolLoad.ts
function createCustomToolLoad(storage) {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_load",
        description: "Load a full custom tool definition from storage (including code). Use this to inspect, modify, or hydrate a saved tool.",
        parameters: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Name of the tool to load"
            }
          },
          required: ["name"]
        }
      }
    },
    permission: { scope: "always", riskLevel: "low" },
    execute: async (args, context) => {
      const userId = context?.userId;
      const s = resolveCustomToolStorage(storage, context);
      const tool = await s.load(userId, args.name);
      if (!tool) {
        return { success: false, error: `Custom tool '${args.name}' not found` };
      }
      return { success: true, tool };
    },
    describeCall: (args) => args.name
  };
}
var customToolLoad = createCustomToolLoad();

// src/tools/custom-tools/customToolSave.ts
function createCustomToolSave(storage) {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_save",
        description: "Save a custom tool definition to persistent storage. The tool can later be loaded, hydrated, and registered on any agent.",
        parameters: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Tool name (must match /^[a-z][a-z0-9_]*$/)"
            },
            description: {
              type: "string",
              description: "What the tool does"
            },
            displayName: {
              type: "string",
              description: "Optional human-readable display name"
            },
            inputSchema: {
              type: "object",
              description: "JSON Schema for input parameters"
            },
            outputSchema: {
              type: "object",
              description: "Optional JSON Schema for output"
            },
            code: {
              type: "string",
              description: "JavaScript code (same sandbox as execute_javascript)"
            },
            tags: {
              type: "array",
              description: "Tags for categorization",
              items: { type: "string" }
            },
            category: {
              type: "string",
              description: "Category grouping"
            },
            generationPrompt: {
              type: "string",
              description: "The prompt that was used to generate this tool (for reference)"
            },
            connectorNames: {
              type: "array",
              description: "Connector names this tool uses",
              items: { type: "string" }
            }
          },
          required: ["name", "description", "inputSchema", "code"]
        }
      }
    },
    permission: { scope: "session", riskLevel: "medium" },
    execute: async (args, context) => {
      try {
        const userId = context?.userId;
        const s = resolveCustomToolStorage(storage, context);
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const existing = await s.load(userId, args.name);
        const definition = {
          version: CUSTOM_TOOL_DEFINITION_VERSION,
          name: args.name,
          displayName: args.displayName,
          description: args.description,
          inputSchema: args.inputSchema,
          outputSchema: args.outputSchema,
          code: args.code,
          createdAt: existing?.createdAt ?? now,
          updatedAt: now,
          metadata: {
            tags: args.tags,
            category: args.category,
            generationPrompt: args.generationPrompt,
            connectorNames: args.connectorNames,
            requiresConnector: (args.connectorNames?.length ?? 0) > 0
          }
        };
        await s.save(userId, definition);
        return {
          success: true,
          name: args.name,
          storagePath: s.getPath(userId)
        };
      } catch (error) {
        return {
          success: false,
          name: args.name,
          storagePath: resolveCustomToolStorage(storage, context).getPath(context?.userId),
          error: error.message
        };
      }
    },
    describeCall: (args) => args.name
  };
}
var customToolSave = createCustomToolSave();

// src/tools/custom-tools/customToolTest.ts
init_Connector();
var DEFAULT_TEST_TIMEOUT = 1e4;
var MAX_TEST_TIMEOUT = 3e4;
function createCustomToolTest() {
  return {
    definition: {
      type: "function",
      function: {
        name: "custom_tool_test",
        description: "Test custom tool code by executing it in the VM sandbox with provided test input.",
        parameters: {
          type: "object",
          properties: {
            code: {
              type: "string",
              description: "JavaScript code to test. See tool description for full sandbox API reference."
            },
            inputSchema: {
              type: "object",
              description: "The input schema (for documentation, not enforced at test time)"
            },
            testInput: {
              description: "Test input data \u2014 available as `input` in the code"
            },
            connectorName: {
              type: "string",
              description: "Optional connector name for authenticated API access"
            },
            timeout: {
              type: "number",
              description: `Execution timeout in ms. Default: ${DEFAULT_TEST_TIMEOUT}, max: ${MAX_TEST_TIMEOUT}`
            }
          },
          required: ["code", "inputSchema", "testInput"]
        }
      },
      timeout: MAX_TEST_TIMEOUT + 5e3
    },
    descriptionFactory: (context) => buildTestDescription(context),
    permission: { scope: "session", riskLevel: "medium" },
    execute: async (args, context) => {
      const logs = [];
      const startTime = Date.now();
      const timeout = Math.min(Math.max(args.timeout || DEFAULT_TEST_TIMEOUT, 0), MAX_TEST_TIMEOUT);
      try {
        const registry = context?.connectorRegistry ?? exports.Connector.asRegistry();
        const result = await executeInVM(
          args.code,
          args.testInput,
          timeout,
          logs,
          context?.userId,
          registry
        );
        return {
          success: true,
          result,
          logs,
          executionTime: Date.now() - startTime
        };
      } catch (error) {
        return {
          success: false,
          result: null,
          logs,
          error: error.message,
          executionTime: Date.now() - startTime
        };
      }
    },
    describeCall: (args) => `testing code (${args.code.length} chars)`
  };
}
var customToolTest = createCustomToolTest();

// src/tools/registry.generated.ts
var toolRegistry = [
  {
    name: "execute_javascript",
    exportName: "executeJavaScript",
    displayName: "Execute Javascript",
    category: "code",
    description: "Execute JavaScript code in a secure sandbox with authenticated API access via connectors.",
    tool: executeJavaScript,
    safeByDefault: false
  },
  {
    name: "custom_tool_delete",
    exportName: "customToolDelete",
    displayName: "Custom Tool Delete",
    category: "custom-tools",
    description: "Delete a custom tool from persistent storage.",
    tool: customToolDelete,
    safeByDefault: false
  },
  {
    name: "custom_tool_draft",
    exportName: "customToolDraft",
    displayName: "Custom Tool Draft",
    category: "custom-tools",
    description: "Validate a draft custom tool definition. Checks name format, schema structure, and code syntax.",
    tool: customToolDraft,
    safeByDefault: true
  },
  {
    name: "custom_tool_list",
    exportName: "customToolList",
    displayName: "Custom Tool List",
    category: "custom-tools",
    description: "List saved custom tools from persistent storage. Supports filtering by search text, tags, and category.",
    tool: customToolList,
    safeByDefault: true
  },
  {
    name: "custom_tool_load",
    exportName: "customToolLoad",
    displayName: "Custom Tool Load",
    category: "custom-tools",
    description: "Load a full custom tool definition from storage (including code).",
    tool: customToolLoad,
    safeByDefault: true
  },
  {
    name: "custom_tool_save",
    exportName: "customToolSave",
    displayName: "Custom Tool Save",
    category: "custom-tools",
    description: "Save a custom tool definition to persistent storage.",
    tool: customToolSave,
    safeByDefault: false
  },
  {
    name: "custom_tool_test",
    exportName: "customToolTest",
    displayName: "Custom Tool Test",
    category: "custom-tools",
    description: "Test custom tool code by executing it in the VM sandbox with provided test input.",
    tool: customToolTest,
    safeByDefault: false
  },
  {
    name: "desktop_get_cursor",
    exportName: "desktopGetCursor",
    displayName: "Desktop Get Cursor",
    category: "desktop",
    description: "Get the current mouse cursor position in screenshot pixel coordinates.",
    tool: desktopGetCursor,
    safeByDefault: false
  },
  {
    name: "desktop_get_screen_size",
    exportName: "desktopGetScreenSize",
    displayName: "Desktop Get Screen Size",
    category: "desktop",
    description: "Get the screen dimensions. Returns physical pixel size (screenshot space), logical size (OS coordinates), and the scale factor (e.g., 2.0 on Retina displays). All desktop tool coordinates use physical",
    tool: desktopGetScreenSize,
    safeByDefault: false
  },
  {
    name: "desktop_keyboard_key",
    exportName: "desktopKeyboardKey",
    displayName: "Desktop Keyboard Key",
    category: "desktop",
    description: 'Press a keyboard shortcut or special key. Use "+" to combine keys (e.g., "ctrl+c", "cmd+shift+s", "enter", "tab", "escape"). Modifiers: ctrl, cmd/command, alt/option, shift. Special keys: enter, tab, ',
    tool: desktopKeyboardKey,
    safeByDefault: false
  },
  {
    name: "desktop_keyboard_type",
    exportName: "desktopKeyboardType",
    displayName: "Desktop Keyboard Type",
    category: "desktop",
    description: "Type text using the keyboard. Each character is typed as a keypress. Use this for entering text into focused input fields.",
    tool: desktopKeyboardType,
    safeByDefault: false
  },
  {
    name: "desktop_mouse_click",
    exportName: "desktopMouseClick",
    displayName: "Desktop Mouse Click",
    category: "desktop",
    description: "Click the mouse at the specified position or at the current cursor position. Supports left/right/middle button and single/double/triple click.",
    tool: desktopMouseClick,
    safeByDefault: false
  },
  {
    name: "desktop_mouse_drag",
    exportName: "desktopMouseDrag",
    displayName: "Desktop Mouse Drag",
    category: "desktop",
    description: "Drag the mouse from one position to another. Presses the button at the start position, moves to the end position, then releases.",
    tool: desktopMouseDrag,
    safeByDefault: false
  },
  {
    name: "desktop_mouse_move",
    exportName: "desktopMouseMove",
    displayName: "Desktop Mouse Move",
    category: "desktop",
    description: "Move the mouse cursor to the specified (x, y) position. Coordinates are in screenshot pixel space (full screen). Returns the actual cursor position after the move for verification.",
    tool: desktopMouseMove,
    safeByDefault: false
  },
  {
    name: "desktop_mouse_scroll",
    exportName: "desktopMouseScroll",
    displayName: "Desktop Mouse Scroll",
    category: "desktop",
    description: "Scroll the mouse wheel. Positive deltaY scrolls down, negative scrolls up. Positive deltaX scrolls right, negative scrolls left. Optionally specify position to scroll at.",
    tool: desktopMouseScroll,
    safeByDefault: false
  },
  {
    name: "desktop_screenshot",
    exportName: "desktopScreenshot",
    displayName: "Desktop Screenshot",
    category: "desktop",
    description: "Take a screenshot of the entire screen or a specific region. Returns the screenshot image for visual analysis. Use this to see what's on screen before performing actions. IMPORTANT: If you capture a r",
    tool: desktopScreenshot,
    safeByDefault: false
  },
  {
    name: "desktop_window_focus",
    exportName: "desktopWindowFocus",
    displayName: "Desktop Window Focus",
    category: "desktop",
    description: "Focus (bring to front) a window by its ID. Use desktop_window_list to get available window IDs.",
    tool: desktopWindowFocus,
    safeByDefault: false
  },
  {
    name: "desktop_window_list",
    exportName: "desktopWindowList",
    displayName: "Desktop Window List",
    category: "desktop",
    description: "List all visible windows on the desktop. Returns window IDs, titles, application names, and bounds. Use the window ID with desktop_window_focus to bring a window to the foreground.",
    tool: desktopWindowList,
    safeByDefault: false
  },
  {
    name: "edit_file",
    exportName: "editFile",
    displayName: "Edit File",
    category: "filesystem",
    description: "Perform exact string replacements in files.",
    tool: editFile,
    safeByDefault: false
  },
  {
    name: "glob",
    exportName: "glob",
    displayName: "Glob",
    category: "filesystem",
    description: "Fast file pattern matching tool that finds files by name patterns.",
    tool: glob,
    safeByDefault: true
  },
  {
    name: "grep",
    exportName: "grep",
    displayName: "Grep",
    category: "filesystem",
    description: "A powerful search tool for finding content within files.",
    tool: grep,
    safeByDefault: true
  },
  {
    name: "list_directory",
    exportName: "listDirectory",
    displayName: "List Directory",
    category: "filesystem",
    description: "List the contents of a directory on the local filesystem.",
    tool: listDirectory,
    safeByDefault: true
  },
  {
    name: "read_file",
    exportName: "readFile",
    displayName: "Read File",
    category: "filesystem",
    description: "Read content from a file on the local filesystem. Supports text files AND binary document formats \u2014 PDF, DOCX, PPTX, XLSX, ODS, ODT, ODP, and images (PNG, JPG, GIF, WEBP) are automatically converted t",
    tool: readFile5,
    safeByDefault: true
  },
  {
    name: "write_file",
    exportName: "writeFile",
    displayName: "Write File",
    category: "filesystem",
    description: "Write content to a file on the local filesystem.",
    tool: writeFile5,
    safeByDefault: false
  },
  {
    name: "json_manipulate",
    exportName: "jsonManipulator",
    displayName: "Json Manipulate",
    category: "json",
    description: "Manipulate JSON objects by deleting, adding, or replacing fields at any depth.",
    tool: jsonManipulator,
    safeByDefault: true
  },
  {
    name: "bash",
    exportName: "bash",
    displayName: "Bash",
    category: "shell",
    description: "Execute shell commands with optional timeout.",
    tool: bash,
    safeByDefault: false
  },
  {
    name: "web_fetch",
    exportName: "webFetch",
    displayName: "Web Fetch",
    category: "web",
    description: "Fetch and extract content from a URL \u2014 works with web pages AND document files (PDF, DOCX, XLSX, PPTX, etc.). Document URLs are automatically detected and converted to markdown text.",
    tool: webFetch,
    safeByDefault: true
  }
];
function getAllBuiltInTools() {
  return toolRegistry.map((entry) => entry.tool);
}
function getToolRegistry() {
  return [...toolRegistry];
}
function getToolsByCategory(category) {
  return toolRegistry.filter((entry) => entry.category === category);
}
function getToolByName(name) {
  return toolRegistry.find((entry) => entry.name === name);
}
function getToolsRequiringConnector() {
  return toolRegistry.filter((entry) => entry.requiresConnector);
}
function getToolCategories() {
  return [...new Set(toolRegistry.map((entry) => entry.category))];
}

// src/tools/custom-tools/factories.ts
function createCustomToolMetaTools(options) {
  const storage = options?.storage;
  return [
    createCustomToolDraft(),
    createCustomToolTest(),
    createCustomToolSave(storage),
    createCustomToolList(storage),
    createCustomToolLoad(storage),
    createCustomToolDelete(storage)
  ];
}

// src/tools/custom-tools/hydrate.ts
init_Connector();
var DEFAULT_TIMEOUT2 = 1e4;
var MAX_TIMEOUT = 3e4;
function hydrateCustomTool(definition, options) {
  const defaultTimeout = options?.defaultTimeout ?? DEFAULT_TIMEOUT2;
  const maxTimeout = options?.maxTimeout ?? MAX_TIMEOUT;
  return {
    definition: {
      type: "function",
      function: {
        name: definition.name,
        description: definition.description,
        parameters: definition.inputSchema
      },
      timeout: maxTimeout + 5e3
    },
    permission: { scope: "session", riskLevel: "medium" },
    execute: async (args, context) => {
      const logs = [];
      const registry = context?.connectorRegistry ?? exports.Connector.asRegistry();
      const result = await executeInVM(
        definition.code,
        args,
        defaultTimeout,
        logs,
        context?.userId,
        registry
      );
      return result;
    },
    describeCall: (args) => {
      if (!args || typeof args !== "object") return definition.name;
      const firstKey = Object.keys(args)[0];
      if (!firstKey) return definition.name;
      const val = args[firstKey];
      const str = typeof val === "string" ? val : JSON.stringify(val);
      return str.length > 50 ? str.slice(0, 47) + "..." : str;
    }
  };
}

// src/tools/ToolRegistry.ts
init_Connector();
var ToolRegistry = class {
  /**
   * Get built-in tools only (from registry.generated.ts)
   *
   * @returns Array of built-in tool registry entries
   */
  static getBuiltInTools() {
    return [...toolRegistry];
  }
  /**
   * Get tools for a specific connector
   *
   * @param connectorName - Name of the connector to get tools for
   * @returns Array of connector tool entries
   *
   * @example
   * ```typescript
   * const githubTools = ToolRegistry.getConnectorTools('github');
   * ```
   */
  static getConnectorTools(connectorName) {
    try {
      const tools = ConnectorTools.for(connectorName);
      return tools.map((tool) => this.toRegistryEntry(tool, connectorName));
    } catch {
      return [];
    }
  }
  /**
   * Get all connector tools from all registered service connectors
   *
   * This discovers tools from all connectors that have:
   * - Explicit serviceType, OR
   * - baseURL but no vendor (external API, not AI provider)
   *
   * @returns Array of all connector tool entries
   */
  static getAllConnectorTools() {
    const allTools = [];
    const discovered = ConnectorTools.discoverAll();
    for (const [connectorName, tools] of discovered) {
      for (const tool of tools) {
        allTools.push(this.toRegistryEntry(tool, connectorName));
      }
    }
    return allTools;
  }
  /**
   * Get ALL tools (built-in + connector) - main API for UIs
   *
   * This is the primary method for getting a complete list of available tools.
   *
   * @returns Array of all tool registry entries (built-in and connector)
   *
   * @example
   * ```typescript
   * const allTools = ToolRegistry.getAllTools();
   * for (const tool of allTools) {
   *   console.log(`${tool.displayName}: ${tool.description}`);
   * }
   * ```
   */
  static getAllTools() {
    return [...this.getBuiltInTools(), ...this.getAllConnectorTools()];
  }
  /**
   * Get tools filtered by service type
   *
   * @param serviceType - Service type to filter by (e.g., 'github', 'slack')
   * @returns Array of connector tool entries for the service
   */
  static getToolsByService(serviceType) {
    return this.getAllConnectorTools().filter((entry) => entry.serviceType === serviceType);
  }
  /**
   * Get tools filtered by connector name
   *
   * @param connectorName - Connector name to filter by
   * @returns Array of connector tool entries for the connector
   */
  static getToolsByConnector(connectorName) {
    return this.getAllConnectorTools().filter((entry) => entry.connectorName === connectorName);
  }
  /**
   * Check if a tool entry is a connector tool
   *
   * @param entry - Tool registry entry to check
   * @returns True if the entry is a connector tool
   */
  static isConnectorTool(entry) {
    return "connectorName" in entry && typeof entry.connectorName === "string";
  }
  /**
   * Convert a ToolFunction to a ConnectorToolEntry
   */
  static toRegistryEntry(tool, connectorName) {
    let serviceType;
    let displayPrefix;
    try {
      const connector = exports.Connector.get(connectorName);
      serviceType = ConnectorTools.detectService(connector);
      if (connector.vendor) {
        const vendorInfo = getVendorInfo(connector.vendor);
        displayPrefix = vendorInfo?.name || connector.vendor;
      }
    } catch {
    }
    const serviceInfo = serviceType ? getServiceInfo(serviceType) : void 0;
    const displayContext = displayPrefix || serviceInfo?.name;
    const def = tool.definition.function;
    return {
      name: def.name,
      exportName: def.name,
      displayName: this.deriveDisplayName(def.name, displayContext, connectorName),
      category: "connector",
      description: def.description || `API tool for ${connectorName}`,
      tool,
      safeByDefault: false,
      requiresConnector: true,
      connectorServiceTypes: serviceType ? [serviceType] : void 0,
      connectorName,
      serviceType
    };
  }
  /**
   * Derive a human-readable display name from a tool name
   *
   * @param toolName - Full tool name (e.g., "main-openai_generate_image")
   * @param contextName - Vendor or service display name (e.g., "OpenAI")
   * @param connectorName - Connector name used as prefix (e.g., "main-openai")
   */
  static deriveDisplayName(toolName, contextName, connectorName) {
    let baseName = toolName;
    if (connectorName && toolName.startsWith(connectorName + "_")) {
      baseName = toolName.slice(connectorName.length + 1);
    }
    if (baseName === "api") {
      return contextName ? `${contextName} API` : toolName.replace(/_/g, " ");
    }
    const readable = baseName.split("_").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
    return contextName ? `${contextName} ${readable}` : readable;
  }
};

// src/tools/index.ts
var developerTools = [
  readFile5,
  writeFile5,
  editFile,
  glob,
  grep,
  listDirectory,
  bash
];

// src/agents/ProviderConfigAgent.ts
var ProviderConfigAgent = class {
  agent = null;
  conversationHistory = [];
  connectorName;
  /**
   * Create a provider config agent
   * @param connectorName - Name of the connector to use (must be created first with Connector.create())
   */
  constructor(connectorName = "openai") {
    this.connectorName = connectorName;
  }
  /**
   * Start interactive configuration session
   * AI will ask questions and generate the connector config
   *
   * @param initialInput - Optional initial message (e.g., "I want to connect to GitHub")
   * @returns Promise<string | ConnectorConfigResult> - Either next question or final config
   */
  async run(initialInput) {
    this.agent = Agent.create({
      connector: this.connectorName,
      model: this.getDefaultModel(),
      instructions: this.getSystemInstructions(),
      temperature: 0.1,
      // Very low temperature for consistent, focused behavior
      maxIterations: 10
    });
    const builder = new MessageBuilder();
    const startMessage = initialInput || "I want to configure an OAuth provider";
    builder.addUserMessage(startMessage);
    this.conversationHistory.push(...builder.build());
    const response = await this.agent.run(this.conversationHistory);
    this.conversationHistory.push(...response.output.filter(
      (item) => item.type === "message" || item.type === "compaction"
    ));
    const responseText = response.output_text || "";
    if (responseText.includes("===CONFIG_START===")) {
      return this.extractConfig(responseText);
    }
    return responseText;
  }
  /**
   * Continue conversation (for multi-turn interaction)
   *
   * @param userMessage - User's response
   * @returns Promise<string | ConnectorConfigResult> - Either next question or final config
   */
  async continue(userMessage) {
    if (!this.agent) {
      throw new Error("Agent not initialized. Call run() first.");
    }
    const builder = new MessageBuilder();
    builder.addUserMessage(userMessage);
    this.conversationHistory.push(...builder.build());
    const response = await this.agent.run(this.conversationHistory);
    this.conversationHistory.push(...response.output.filter(
      (item) => item.type === "message" || item.type === "compaction"
    ));
    const responseText = response.output_text || "";
    if (responseText.includes("===CONFIG_START===")) {
      return this.extractConfig(responseText);
    }
    return responseText;
  }
  /**
   * Get system instructions for the agent
   */
  getSystemInstructions() {
    return `You are a friendly OAuth Setup Assistant. Your ONLY job is to help users connect their apps to third-party services like Microsoft, Google, GitHub, etc.

YOU MUST NOT answer general questions. ONLY focus on helping set up API connections.

YOUR PROCESS (use NON-TECHNICAL, FRIENDLY language):

1. Ask which system they want to connect to (e.g., Microsoft, Google, GitHub, Salesforce, Slack)

2. Ask about HOW they want to use it (use SIMPLE language):
   - "Will your users log in with their [Provider] accounts?" \u2192 authorization_code
   - "Does your app need to access [Provider] without users logging in?" \u2192 client_credentials
   - "Is this just an API key from [Provider]?" \u2192 static_token

3. Ask BUSINESS questions about what they want to do (then YOU figure out the technical scopes):

   For Microsoft:
   - "Do you need to read user profiles?" \u2192 User.Read
   - "Do you need to read emails?" \u2192 Mail.Read
   - "Do you need to access calendar?" \u2192 Calendars.Read
   - "Do you need to read/write SharePoint files?" \u2192 Sites.Read.All or Sites.ReadWrite.All
   - "Do you need to access Teams?" \u2192 Team.ReadBasic.All
   - Combine multiple scopes if needed

   For Google:
   - "Do you need to read emails?" \u2192 https://www.googleapis.com/auth/gmail.readonly
   - "Do you need to access Google Drive?" \u2192 https://www.googleapis.com/auth/drive
   - "Do you need calendar access?" \u2192 https://www.googleapis.com/auth/calendar

   For GitHub:
   - "Do you need to read user info?" \u2192 user:email
   - "Do you need to access repositories?" \u2192 repo
   - "Do you need to read organization data?" \u2192 read:org

   For Salesforce:
   - "Do you need full access?" \u2192 full
   - "Do you need to access/manage data?" \u2192 api
   - "Do you need refresh tokens?" \u2192 refresh_token offline_access

4. DO NOT ask about redirect URI - it will be configured in code (use "http://localhost:3000/callback" as default)

5. Generate complete JSON configuration

CRITICAL RULES:
- Ask ONE simple question at a time
- Use BUSINESS language, NOT technical OAuth terms
- Ask "What do you want to do?" NOT "What scopes do you need?"
- YOU translate business needs into technical scopes
- Be friendly and conversational
- Provide specific setup URLs (e.g., https://portal.azure.com for Microsoft, https://github.com/settings/developers for GitHub)
- When you have all info, IMMEDIATELY output the config in this EXACT format:

===CONFIG_START===
{
  "name": "github",
  "config": {
    "displayName": "GitHub API",
    "description": "Access GitHub repositories and user data",
    "baseURL": "https://api.github.com",
    "auth": {
      "type": "oauth",
      "flow": "authorization_code",
      "clientId": "ENV:GITHUB_CLIENT_ID",
      "clientSecret": "ENV:GITHUB_CLIENT_SECRET",
      "authorizationUrl": "https://github.com/login/oauth/authorize",
      "tokenUrl": "https://github.com/login/oauth/access_token",
      "redirectUri": "http://localhost:3000/callback",
      "scope": "user:email repo"
    }
  },
  "setupInstructions": "1. Go to https://github.com/settings/developers\\n2. Create New OAuth App\\n3. Set Authorization callback URL\\n4. Copy Client ID and Client Secret",
  "envVariables": ["GITHUB_CLIENT_ID", "GITHUB_CLIENT_SECRET"],
  "setupUrl": "https://github.com/settings/developers"
}
===CONFIG_END===

Use "ENV:VARIABLE_NAME" for values that should come from environment variables.

REMEMBER: Keep it conversational, ask one question at a time, and only output the config when you have all necessary information.`;
  }
  /**
   * Extract configuration from AI response
   */
  extractConfig(responseText) {
    const configMatch = responseText.match(/===CONFIG_START===\s*([\s\S]*?)\s*===CONFIG_END===/);
    if (!configMatch) {
      throw new Error("No configuration found in response. The AI may need more information.");
    }
    try {
      const configJson = configMatch[1].trim();
      const config = JSON.parse(configJson);
      return config;
    } catch (error) {
      throw new Error(`Failed to parse configuration JSON: ${error.message}`);
    }
  }
  /**
   * Get default model
   */
  getDefaultModel() {
    return "gpt-4.1";
  }
  /**
   * Reset conversation
   */
  reset() {
    this.conversationHistory = [];
    this.agent = null;
  }
};

exports.AGENT_DEFINITION_FORMAT_VERSION = AGENT_DEFINITION_FORMAT_VERSION;
exports.AIError = AIError;
exports.APPROVAL_STATE_VERSION = APPROVAL_STATE_VERSION;
exports.Agent = Agent;
exports.AgentContextNextGen = AgentContextNextGen;
exports.ApproximateTokenEstimator = ApproximateTokenEstimator;
exports.BaseMediaProvider = BaseMediaProvider;
exports.BasePluginNextGen = BasePluginNextGen;
exports.BaseProvider = BaseProvider;
exports.BaseTextProvider = BaseTextProvider;
exports.BraveProvider = BraveProvider;
exports.CONNECTOR_CONFIG_VERSION = CONNECTOR_CONFIG_VERSION;
exports.CONTEXT_SESSION_FORMAT_VERSION = CONTEXT_SESSION_FORMAT_VERSION;
exports.CUSTOM_TOOL_DEFINITION_VERSION = CUSTOM_TOOL_DEFINITION_VERSION;
exports.CheckpointManager = CheckpointManager;
exports.ConnectorConfigStore = ConnectorConfigStore;
exports.ConnectorTools = ConnectorTools;
exports.ContentType = ContentType;
exports.ContextOverflowError = ContextOverflowError;
exports.DEFAULT_ALLOWLIST = DEFAULT_ALLOWLIST;
exports.DEFAULT_CHECKPOINT_STRATEGY = DEFAULT_CHECKPOINT_STRATEGY;
exports.DEFAULT_CONFIG = DEFAULT_CONFIG2;
exports.DEFAULT_CONTEXT_CONFIG = DEFAULT_CONTEXT_CONFIG;
exports.DEFAULT_DESKTOP_CONFIG = DEFAULT_DESKTOP_CONFIG;
exports.DEFAULT_FEATURES = DEFAULT_FEATURES;
exports.DEFAULT_FILESYSTEM_CONFIG = DEFAULT_FILESYSTEM_CONFIG;
exports.DEFAULT_HISTORY_MANAGER_CONFIG = DEFAULT_HISTORY_MANAGER_CONFIG;
exports.DEFAULT_MEMORY_CONFIG = DEFAULT_MEMORY_CONFIG;
exports.DEFAULT_PERMISSION_CONFIG = DEFAULT_PERMISSION_CONFIG;
exports.DEFAULT_RATE_LIMITER_CONFIG = DEFAULT_RATE_LIMITER_CONFIG;
exports.DEFAULT_SHELL_CONFIG = DEFAULT_SHELL_CONFIG;
exports.DESKTOP_TOOL_NAMES = DESKTOP_TOOL_NAMES;
exports.DefaultCompactionStrategy = DefaultCompactionStrategy;
exports.DependencyCycleError = DependencyCycleError;
exports.DocumentReader = DocumentReader;
exports.ErrorHandler = ErrorHandler;
exports.ExecutionContext = ExecutionContext;
exports.ExternalDependencyHandler = ExternalDependencyHandler;
exports.FileAgentDefinitionStorage = FileAgentDefinitionStorage;
exports.FileConnectorStorage = FileConnectorStorage;
exports.FileContextStorage = FileContextStorage;
exports.FileCustomToolStorage = FileCustomToolStorage;
exports.FileMediaOutputHandler = FileMediaStorage;
exports.FileMediaStorage = FileMediaStorage;
exports.FilePersistentInstructionsStorage = FilePersistentInstructionsStorage;
exports.FileRoutineDefinitionStorage = FileRoutineDefinitionStorage;
exports.FileStorage = FileStorage;
exports.FileUserInfoStorage = FileUserInfoStorage;
exports.FormatDetector = FormatDetector;
exports.HookManager = HookManager;
exports.IMAGE_MODELS = IMAGE_MODELS;
exports.IMAGE_MODEL_REGISTRY = IMAGE_MODEL_REGISTRY;
exports.ImageGeneration = ImageGeneration;
exports.InContextMemoryPluginNextGen = InContextMemoryPluginNextGen;
exports.InMemoryAgentStateStorage = InMemoryAgentStateStorage;
exports.InMemoryHistoryStorage = InMemoryHistoryStorage;
exports.InMemoryPlanStorage = InMemoryPlanStorage;
exports.InMemoryStorage = InMemoryStorage;
exports.InvalidConfigError = InvalidConfigError;
exports.InvalidToolArgumentsError = InvalidToolArgumentsError;
exports.LLM_MODELS = LLM_MODELS;
exports.LoggingPlugin = LoggingPlugin;
exports.MCPClient = MCPClient;
exports.MCPConnectionError = MCPConnectionError;
exports.MCPError = MCPError;
exports.MCPProtocolError = MCPProtocolError;
exports.MCPRegistry = MCPRegistry;
exports.MCPResourceError = MCPResourceError;
exports.MCPTimeoutError = MCPTimeoutError;
exports.MCPToolError = MCPToolError;
exports.MEMORY_PRIORITY_VALUES = MEMORY_PRIORITY_VALUES;
exports.MODEL_REGISTRY = MODEL_REGISTRY;
exports.MemoryConnectorStorage = MemoryConnectorStorage;
exports.MemoryEvictionCompactor = MemoryEvictionCompactor;
exports.MessageBuilder = MessageBuilder;
exports.MessageRole = MessageRole;
exports.ModelNotSupportedError = ModelNotSupportedError;
exports.NutTreeDriver = NutTreeDriver;
exports.ParallelTasksError = ParallelTasksError;
exports.PersistentInstructionsPluginNextGen = PersistentInstructionsPluginNextGen;
exports.PlanningAgent = PlanningAgent;
exports.ProviderAuthError = ProviderAuthError;
exports.ProviderConfigAgent = ProviderConfigAgent;
exports.ProviderContextLengthError = ProviderContextLengthError;
exports.ProviderError = ProviderError;
exports.ProviderErrorMapper = ProviderErrorMapper;
exports.ProviderNotFoundError = ProviderNotFoundError;
exports.ProviderRateLimitError = ProviderRateLimitError;
exports.RapidAPIProvider = RapidAPIProvider;
exports.RateLimitError = RateLimitError;
exports.SERVICE_DEFINITIONS = SERVICE_DEFINITIONS;
exports.SERVICE_INFO = SERVICE_INFO;
exports.SERVICE_URL_PATTERNS = SERVICE_URL_PATTERNS;
exports.SIMPLE_ICONS_CDN = SIMPLE_ICONS_CDN;
exports.STT_MODELS = STT_MODELS;
exports.STT_MODEL_REGISTRY = STT_MODEL_REGISTRY;
exports.ScrapeProvider = ScrapeProvider;
exports.SearchProvider = SearchProvider;
exports.SerperProvider = SerperProvider;
exports.Services = Services;
exports.SpeechToText = SpeechToText;
exports.StrategyRegistry = StrategyRegistry;
exports.StreamEventType = StreamEventType;
exports.StreamHelpers = StreamHelpers;
exports.StreamState = StreamState;
exports.SummarizeCompactor = SummarizeCompactor;
exports.TERMINAL_TASK_STATUSES = TERMINAL_TASK_STATUSES;
exports.TTS_MODELS = TTS_MODELS;
exports.TTS_MODEL_REGISTRY = TTS_MODEL_REGISTRY;
exports.TaskTimeoutError = TaskTimeoutError;
exports.TaskValidationError = TaskValidationError;
exports.TavilyProvider = TavilyProvider;
exports.TextToSpeech = TextToSpeech;
exports.TokenBucketRateLimiter = TokenBucketRateLimiter;
exports.ToolCallState = ToolCallState;
exports.ToolExecutionError = ToolExecutionError;
exports.ToolExecutionPipeline = ToolExecutionPipeline;
exports.ToolManager = ToolManager;
exports.ToolNotFoundError = ToolNotFoundError;
exports.ToolPermissionManager = ToolPermissionManager;
exports.ToolRegistry = ToolRegistry;
exports.ToolTimeoutError = ToolTimeoutError;
exports.TruncateCompactor = TruncateCompactor;
exports.UserInfoPluginNextGen = UserInfoPluginNextGen;
exports.VENDORS = VENDORS;
exports.VENDOR_ICON_MAP = VENDOR_ICON_MAP;
exports.VIDEO_MODELS = VIDEO_MODELS;
exports.VIDEO_MODEL_REGISTRY = VIDEO_MODEL_REGISTRY;
exports.Vendor = Vendor;
exports.VideoGeneration = VideoGeneration;
exports.WorkingMemory = WorkingMemory;
exports.WorkingMemoryPluginNextGen = WorkingMemoryPluginNextGen;
exports.addJitter = addJitter;
exports.allVendorTemplates = allVendorTemplates;
exports.assertNotDestroyed = assertNotDestroyed;
exports.authenticatedFetch = authenticatedFetch;
exports.backoffSequence = backoffSequence;
exports.backoffWait = backoffWait;
exports.bash = bash;
exports.buildAuthConfig = buildAuthConfig;
exports.buildEndpointWithQuery = buildEndpointWithQuery;
exports.buildQueryString = buildQueryString;
exports.calculateBackoff = calculateBackoff;
exports.calculateCost = calculateCost;
exports.calculateEntrySize = calculateEntrySize;
exports.calculateImageCost = calculateImageCost;
exports.calculateSTTCost = calculateSTTCost;
exports.calculateTTSCost = calculateTTSCost;
exports.calculateVideoCost = calculateVideoCost;
exports.canTaskExecute = canTaskExecute;
exports.createAgentStorage = createAgentStorage;
exports.createAuthenticatedFetch = createAuthenticatedFetch;
exports.createBashTool = createBashTool;
exports.createConnectorFromTemplate = createConnectorFromTemplate;
exports.createCreatePRTool = createCreatePRTool;
exports.createCustomToolDelete = createCustomToolDelete;
exports.createCustomToolDraft = createCustomToolDraft;
exports.createCustomToolList = createCustomToolList;
exports.createCustomToolLoad = createCustomToolLoad;
exports.createCustomToolMetaTools = createCustomToolMetaTools;
exports.createCustomToolSave = createCustomToolSave;
exports.createCustomToolTest = createCustomToolTest;
exports.createDesktopGetCursorTool = createDesktopGetCursorTool;
exports.createDesktopGetScreenSizeTool = createDesktopGetScreenSizeTool;
exports.createDesktopKeyboardKeyTool = createDesktopKeyboardKeyTool;
exports.createDesktopKeyboardTypeTool = createDesktopKeyboardTypeTool;
exports.createDesktopMouseClickTool = createDesktopMouseClickTool;
exports.createDesktopMouseDragTool = createDesktopMouseDragTool;
exports.createDesktopMouseMoveTool = createDesktopMouseMoveTool;
exports.createDesktopMouseScrollTool = createDesktopMouseScrollTool;
exports.createDesktopScreenshotTool = createDesktopScreenshotTool;
exports.createDesktopWindowFocusTool = createDesktopWindowFocusTool;
exports.createDesktopWindowListTool = createDesktopWindowListTool;
exports.createDraftEmailTool = createDraftEmailTool;
exports.createEditFileTool = createEditFileTool;
exports.createEditMeetingTool = createEditMeetingTool;
exports.createEstimator = createEstimator;
exports.createExecuteJavaScriptTool = createExecuteJavaScriptTool;
exports.createFileAgentDefinitionStorage = createFileAgentDefinitionStorage;
exports.createFileContextStorage = createFileContextStorage;
exports.createFileCustomToolStorage = createFileCustomToolStorage;
exports.createFileMediaStorage = createFileMediaStorage;
exports.createFileRoutineDefinitionStorage = createFileRoutineDefinitionStorage;
exports.createFindMeetingSlotsTool = createFindMeetingSlotsTool;
exports.createGetMeetingTranscriptTool = createGetMeetingTranscriptTool;
exports.createGetPRTool = createGetPRTool;
exports.createGitHubReadFileTool = createGitHubReadFileTool;
exports.createGlobTool = createGlobTool;
exports.createGrepTool = createGrepTool;
exports.createImageGenerationTool = createImageGenerationTool;
exports.createImageProvider = createImageProvider;
exports.createListDirectoryTool = createListDirectoryTool;
exports.createMeetingTool = createMeetingTool;
exports.createMessageWithImages = createMessageWithImages;
exports.createMetricsCollector = createMetricsCollector;
exports.createPRCommentsTool = createPRCommentsTool;
exports.createPRFilesTool = createPRFilesTool;
exports.createPlan = createPlan;
exports.createProvider = createProvider;
exports.createReadFileTool = createReadFileTool;
exports.createRoutineDefinition = createRoutineDefinition;
exports.createRoutineExecution = createRoutineExecution;
exports.createSearchCodeTool = createSearchCodeTool;
exports.createSearchFilesTool = createSearchFilesTool;
exports.createSendEmailTool = createSendEmailTool;
exports.createSpeechToTextTool = createSpeechToTextTool;
exports.createTask = createTask;
exports.createTextMessage = createTextMessage;
exports.createTextToSpeechTool = createTextToSpeechTool;
exports.createVideoProvider = createVideoProvider;
exports.createVideoTools = createVideoTools;
exports.createWriteFileTool = createWriteFileTool;
exports.customToolDelete = customToolDelete;
exports.customToolDraft = customToolDraft;
exports.customToolList = customToolList;
exports.customToolLoad = customToolLoad;
exports.customToolSave = customToolSave;
exports.customToolTest = customToolTest;
exports.defaultDescribeCall = defaultDescribeCall;
exports.desktopGetCursor = desktopGetCursor;
exports.desktopGetScreenSize = desktopGetScreenSize;
exports.desktopKeyboardKey = desktopKeyboardKey;
exports.desktopKeyboardType = desktopKeyboardType;
exports.desktopMouseClick = desktopMouseClick;
exports.desktopMouseDrag = desktopMouseDrag;
exports.desktopMouseMove = desktopMouseMove;
exports.desktopMouseScroll = desktopMouseScroll;
exports.desktopScreenshot = desktopScreenshot;
exports.desktopTools = desktopTools;
exports.desktopWindowFocus = desktopWindowFocus;
exports.desktopWindowList = desktopWindowList;
exports.detectDependencyCycle = detectDependencyCycle;
exports.detectServiceFromURL = detectServiceFromURL;
exports.developerTools = developerTools;
exports.documentToContent = documentToContent;
exports.editFile = editFile;
exports.evaluateCondition = evaluateCondition;
exports.executeRoutine = executeRoutine;
exports.extractJSON = extractJSON;
exports.extractJSONField = extractJSONField;
exports.extractNumber = extractNumber;
exports.findConnectorByServiceTypes = findConnectorByServiceTypes;
exports.forPlan = forPlan;
exports.forTasks = forTasks;
exports.formatAttendees = formatAttendees;
exports.formatRecipients = formatRecipients;
exports.generateEncryptionKey = generateEncryptionKey;
exports.generateSimplePlan = generateSimplePlan;
exports.generateWebAPITool = generateWebAPITool;
exports.getActiveImageModels = getActiveImageModels;
exports.getActiveModels = getActiveModels;
exports.getActiveSTTModels = getActiveSTTModels;
exports.getActiveTTSModels = getActiveTTSModels;
exports.getActiveVideoModels = getActiveVideoModels;
exports.getAllBuiltInTools = getAllBuiltInTools;
exports.getAllServiceIds = getAllServiceIds;
exports.getAllVendorLogos = getAllVendorLogos;
exports.getAllVendorTemplates = getAllVendorTemplates;
exports.getBackgroundOutput = getBackgroundOutput;
exports.getConnectorTools = getConnectorTools;
exports.getCredentialsSetupURL = getCredentialsSetupURL;
exports.getDesktopDriver = getDesktopDriver;
exports.getDocsURL = getDocsURL;
exports.getImageModelInfo = getImageModelInfo;
exports.getImageModelsByVendor = getImageModelsByVendor;
exports.getImageModelsWithFeature = getImageModelsWithFeature;
exports.getMediaOutputHandler = getMediaOutputHandler;
exports.getMediaStorage = getMediaStorage;
exports.getModelInfo = getModelInfo;
exports.getModelsByVendor = getModelsByVendor;
exports.getNextExecutableTasks = getNextExecutableTasks;
exports.getRegisteredScrapeProviders = getRegisteredScrapeProviders;
exports.getRoutineProgress = getRoutineProgress;
exports.getSTTModelInfo = getSTTModelInfo;
exports.getSTTModelsByVendor = getSTTModelsByVendor;
exports.getSTTModelsWithFeature = getSTTModelsWithFeature;
exports.getServiceDefinition = getServiceDefinition;
exports.getServiceInfo = getServiceInfo;
exports.getServicesByCategory = getServicesByCategory;
exports.getTTSModelInfo = getTTSModelInfo;
exports.getTTSModelsByVendor = getTTSModelsByVendor;
exports.getTTSModelsWithFeature = getTTSModelsWithFeature;
exports.getTaskDependencies = getTaskDependencies;
exports.getToolByName = getToolByName;
exports.getToolCallDescription = getToolCallDescription;
exports.getToolCategories = getToolCategories;
exports.getToolRegistry = getToolRegistry;
exports.getToolsByCategory = getToolsByCategory;
exports.getToolsRequiringConnector = getToolsRequiringConnector;
exports.getUserPathPrefix = getUserPathPrefix;
exports.getVendorAuthTemplate = getVendorAuthTemplate;
exports.getVendorColor = getVendorColor;
exports.getVendorDefaultBaseURL = getVendorDefaultBaseURL;
exports.getVendorInfo = getVendorInfo;
exports.getVendorLogo = getVendorLogo;
exports.getVendorLogoCdnUrl = getVendorLogoCdnUrl;
exports.getVendorLogoSvg = getVendorLogoSvg;
exports.getVendorTemplate = getVendorTemplate;
exports.getVideoModelInfo = getVideoModelInfo;
exports.getVideoModelsByVendor = getVideoModelsByVendor;
exports.getVideoModelsWithAudio = getVideoModelsWithAudio;
exports.getVideoModelsWithFeature = getVideoModelsWithFeature;
exports.glob = glob;
exports.globalErrorHandler = globalErrorHandler;
exports.grep = grep;
exports.hasClipboardImage = hasClipboardImage;
exports.hasVendorLogo = hasVendorLogo;
exports.hydrateCustomTool = hydrateCustomTool;
exports.isBlockedCommand = isBlockedCommand;
exports.isErrorEvent = isErrorEvent;
exports.isExcludedExtension = isExcludedExtension;
exports.isKnownService = isKnownService;
exports.isOutputTextDelta = isOutputTextDelta;
exports.isResponseComplete = isResponseComplete;
exports.isSimpleScope = isSimpleScope;
exports.isStreamEvent = isStreamEvent;
exports.isTaskAwareScope = isTaskAwareScope;
exports.isTaskBlocked = isTaskBlocked;
exports.isTeamsMeetingUrl = isTeamsMeetingUrl;
exports.isTerminalMemoryStatus = isTerminalMemoryStatus;
exports.isTerminalStatus = isTerminalStatus;
exports.isToolCallArgumentsDelta = isToolCallArgumentsDelta;
exports.isToolCallArgumentsDone = isToolCallArgumentsDone;
exports.isToolCallStart = isToolCallStart;
exports.isVendor = isVendor;
exports.killBackgroundProcess = killBackgroundProcess;
exports.listConnectorsByServiceTypes = listConnectorsByServiceTypes;
exports.listDirectory = listDirectory;
exports.listVendorIds = listVendorIds;
exports.listVendors = listVendors;
exports.listVendorsByAuthType = listVendorsByAuthType;
exports.listVendorsByCategory = listVendorsByCategory;
exports.listVendorsWithLogos = listVendorsWithLogos;
exports.mergeTextPieces = mergeTextPieces;
exports.microsoftFetch = microsoftFetch;
exports.normalizeEmails = normalizeEmails;
exports.parseKeyCombo = parseKeyCombo;
exports.parseRepository = parseRepository;
exports.readClipboardImage = readClipboardImage;
exports.readDocumentAsContent = readDocumentAsContent;
exports.readFile = readFile5;
exports.registerScrapeProvider = registerScrapeProvider;
exports.resetDefaultDriver = resetDefaultDriver;
exports.resolveConnector = resolveConnector;
exports.resolveDependencies = resolveDependencies;
exports.resolveMaxContextTokens = resolveMaxContextTokens;
exports.resolveMeetingId = resolveMeetingId;
exports.resolveModelCapabilities = resolveModelCapabilities;
exports.resolveRepository = resolveRepository;
exports.retryWithBackoff = retryWithBackoff;
exports.sanitizeToolName = sanitizeToolName;
exports.scopeEquals = scopeEquals;
exports.scopeMatches = scopeMatches;
exports.setMediaOutputHandler = setMediaOutputHandler;
exports.setMediaStorage = setMediaStorage;
exports.setMetricsCollector = setMetricsCollector;
exports.simpleTokenEstimator = simpleTokenEstimator;
exports.toConnectorOptions = toConnectorOptions;
exports.toolRegistry = toolRegistry;
exports.tools = tools_exports;
exports.updateTaskStatus = updateTaskStatus;
exports.validatePath = validatePath;
exports.writeFile = writeFile5;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map