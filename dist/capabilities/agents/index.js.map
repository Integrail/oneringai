{"version":3,"sources":["../../../src/domain/errors/AIErrors.ts","../../../src/infrastructure/resilience/CircuitBreaker.ts","../../../src/infrastructure/observability/Logger.ts","../../../src/infrastructure/observability/Metrics.ts","../../../src/capabilities/agents/ToolRegistry.ts","../../../src/capabilities/agents/ExecutionContext.ts","../../../src/capabilities/agents/HookManager.ts","../../../src/domain/entities/StreamEvent.ts","../../../src/domain/entities/StreamState.ts","../../../src/capabilities/agents/AgenticLoop.ts"],"names":["EventEmitter"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Custom error classes for the AI library\n */\n\nexport class AIError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly statusCode?: number,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'AIError';\n    Object.setPrototypeOf(this, AIError.prototype);\n  }\n}\n\nexport class ProviderNotFoundError extends AIError {\n  constructor(providerName: string) {\n    super(\n      `Provider '${providerName}' not found. Did you configure it in OneRingAI constructor?`,\n      'PROVIDER_NOT_FOUND',\n      404\n    );\n    this.name = 'ProviderNotFoundError';\n    Object.setPrototypeOf(this, ProviderNotFoundError.prototype);\n  }\n}\n\nexport class ProviderAuthError extends AIError {\n  constructor(providerName: string, message: string = 'Authentication failed') {\n    super(\n      `${providerName}: ${message}`,\n      'PROVIDER_AUTH_ERROR',\n      401\n    );\n    this.name = 'ProviderAuthError';\n    Object.setPrototypeOf(this, ProviderAuthError.prototype);\n  }\n}\n\nexport class ProviderRateLimitError extends AIError {\n  constructor(\n    providerName: string,\n    public readonly retryAfter?: number\n  ) {\n    super(\n      `${providerName}: Rate limit exceeded${retryAfter ? `. Retry after ${retryAfter}ms` : ''}`,\n      'PROVIDER_RATE_LIMIT',\n      429\n    );\n    this.name = 'ProviderRateLimitError';\n    Object.setPrototypeOf(this, ProviderRateLimitError.prototype);\n  }\n}\n\nexport class ProviderContextLengthError extends AIError {\n  constructor(\n    providerName: string,\n    public readonly maxTokens: number,\n    public readonly requestedTokens?: number\n  ) {\n    super(\n      `${providerName}: Context length exceeded. Max: ${maxTokens}${requestedTokens ? `, Requested: ${requestedTokens}` : ''}`,\n      'PROVIDER_CONTEXT_LENGTH_EXCEEDED',\n      413\n    );\n    this.name = 'ProviderContextLengthError';\n    Object.setPrototypeOf(this, ProviderContextLengthError.prototype);\n  }\n}\n\nexport class ToolExecutionError extends AIError {\n  constructor(\n    toolName: string,\n    message: string,\n    public readonly originalError?: Error\n  ) {\n    super(\n      `Tool '${toolName}' execution failed: ${message}`,\n      'TOOL_EXECUTION_ERROR',\n      500,\n      originalError\n    );\n    this.name = 'ToolExecutionError';\n    Object.setPrototypeOf(this, ToolExecutionError.prototype);\n  }\n}\n\nexport class ToolTimeoutError extends AIError {\n  constructor(\n    toolName: string,\n    public readonly timeoutMs: number\n  ) {\n    super(\n      `Tool '${toolName}' execution timed out after ${timeoutMs}ms`,\n      'TOOL_TIMEOUT',\n      408\n    );\n    this.name = 'ToolTimeoutError';\n    Object.setPrototypeOf(this, ToolTimeoutError.prototype);\n  }\n}\n\nexport class ToolNotFoundError extends AIError {\n  constructor(toolName: string) {\n    super(\n      `Tool '${toolName}' not found. Did you register it with the agent?`,\n      'TOOL_NOT_FOUND',\n      404\n    );\n    this.name = 'ToolNotFoundError';\n    Object.setPrototypeOf(this, ToolNotFoundError.prototype);\n  }\n}\n\nexport class ModelNotSupportedError extends AIError {\n  constructor(providerName: string, model: string, capability: string) {\n    super(\n      `Model '${model}' from ${providerName} does not support ${capability}`,\n      'MODEL_NOT_SUPPORTED',\n      400\n    );\n    this.name = 'ModelNotSupportedError';\n    Object.setPrototypeOf(this, ModelNotSupportedError.prototype);\n  }\n}\n\nexport class InvalidConfigError extends AIError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG', 400);\n    this.name = 'InvalidConfigError';\n    Object.setPrototypeOf(this, InvalidConfigError.prototype);\n  }\n}\n\nexport class InvalidToolArgumentsError extends AIError {\n  constructor(\n    toolName: string,\n    public readonly rawArguments: string,\n    public readonly parseError?: Error\n  ) {\n    super(\n      `Invalid arguments for tool '${toolName}': ${parseError?.message || 'Failed to parse JSON'}`,\n      'INVALID_TOOL_ARGUMENTS',\n      400,\n      parseError\n    );\n    this.name = 'InvalidToolArgumentsError';\n    Object.setPrototypeOf(this, InvalidToolArgumentsError.prototype);\n  }\n}\n\nexport class ProviderError extends AIError {\n  constructor(\n    public readonly providerName: string,\n    message: string,\n    statusCode?: number,\n    originalError?: Error\n  ) {\n    super(\n      `${providerName}: ${message}`,\n      'PROVIDER_ERROR',\n      statusCode,\n      originalError\n    );\n    this.name = 'ProviderError';\n    Object.setPrototypeOf(this, ProviderError.prototype);\n  }\n}\n","/**\n * Generic Circuit Breaker implementation\n *\n * Prevents cascading failures by failing fast when a system is down.\n * Works for any async operation (LLM calls, tool execution, etc.)\n */\n\nimport EventEmitter from 'eventemitter3';\n\n/**\n * Circuit breaker states\n */\nexport type CircuitState = 'closed' | 'open' | 'half-open';\n\n/**\n * Failure record for window tracking\n */\ninterface FailureRecord {\n  timestamp: number;\n  error: string;\n}\n\n/**\n * Circuit breaker configuration\n */\nexport interface CircuitBreakerConfig {\n  /** Number of failures before opening circuit */\n  failureThreshold: number;\n\n  /** Number of successes to close from half-open */\n  successThreshold: number;\n\n  /** Time to wait in open state before trying half-open (ms) */\n  resetTimeoutMs: number;\n\n  /** Time window for counting failures (ms) */\n  windowMs: number;\n\n  /** Classify errors - return true if error should count as failure */\n  isRetryable?: (error: Error) => boolean;\n}\n\n/**\n * Circuit breaker metrics\n */\nexport interface CircuitBreakerMetrics {\n  name: string;\n  state: CircuitState;\n\n  // Counters\n  totalRequests: number;\n  successCount: number;\n  failureCount: number;\n  rejectedCount: number; // Rejected by open circuit\n\n  // Current window\n  recentFailures: number;\n  consecutiveSuccesses: number;\n\n  // Timestamps\n  lastFailureTime?: number;\n  lastSuccessTime?: number;\n  lastStateChange: number;\n  nextRetryTime?: number;\n\n  // Rates\n  failureRate: number;\n  successRate: number;\n}\n\n/**\n * Circuit breaker events\n */\nexport interface CircuitBreakerEvents {\n  opened: { name: string; failureCount: number; lastError: string; nextRetryTime: number };\n  'half-open': { name: string; timestamp: number };\n  closed: { name: string; successCount: number; timestamp: number };\n}\n\n/**\n * Default configuration\n */\nexport const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  resetTimeoutMs: 30000, // 30 seconds\n  windowMs: 60000, // 1 minute\n  isRetryable: () => true, // All errors count by default\n};\n\n/**\n * Circuit breaker error - thrown when circuit is open\n */\nexport class CircuitOpenError extends Error {\n  constructor(\n    public readonly breakerName: string,\n    public readonly nextRetryTime: number,\n    public readonly failureCount: number,\n    public readonly lastError: string\n  ) {\n    const retryInSeconds = Math.ceil((nextRetryTime - Date.now()) / 1000);\n    super(\n      `Circuit breaker '${breakerName}' is OPEN. ` +\n      `Retry in ${retryInSeconds}s. ` +\n      `(${failureCount} recent failures, last: ${lastError})`\n    );\n    this.name = 'CircuitOpenError';\n  }\n}\n\n/**\n * Generic circuit breaker for any async operation\n */\nexport class CircuitBreaker<T = any> extends EventEmitter<CircuitBreakerEvents> {\n  private state: CircuitState = 'closed';\n  private config: CircuitBreakerConfig;\n\n  // Failure tracking\n  private failures: FailureRecord[] = [];\n  private lastError: string = '';\n\n  // Success tracking\n  private consecutiveSuccesses = 0;\n\n  // Timing\n  private openedAt?: number;\n  private lastStateChange: number;\n\n  // Metrics\n  private totalRequests = 0;\n  private successCount = 0;\n  private failureCount = 0;\n  private rejectedCount = 0;\n  private lastFailureTime?: number;\n  private lastSuccessTime?: number;\n\n  constructor(\n    public readonly name: string,\n    config: Partial<CircuitBreakerConfig> = {}\n  ) {\n    super();\n    this.config = { ...DEFAULT_CIRCUIT_BREAKER_CONFIG, ...config };\n    this.lastStateChange = Date.now();\n  }\n\n  /**\n   * Execute function with circuit breaker protection\n   */\n  async execute(fn: () => Promise<T>): Promise<T> {\n    this.totalRequests++;\n\n    // Check circuit state\n    const now = Date.now();\n\n    switch (this.state) {\n      case 'open':\n        // Check if timeout has expired\n        if (this.openedAt && now - this.openedAt >= this.config.resetTimeoutMs) {\n          // Transition to half-open\n          this.transitionTo('half-open');\n        } else {\n          // Still open, reject immediately\n          this.rejectedCount++;\n          const nextRetry = (this.openedAt || now) + this.config.resetTimeoutMs;\n          throw new CircuitOpenError(this.name, nextRetry, this.failures.length, this.lastError);\n        }\n        break;\n\n      case 'half-open':\n        // Allow one request through\n        break;\n\n      case 'closed':\n        // Normal operation\n        break;\n    }\n\n    // Execute the function\n    try {\n      const result = await fn();\n\n      // Success - record it\n      this.recordSuccess();\n\n      return result;\n    } catch (error) {\n      // Failure - record it\n      this.recordFailure(error as Error);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Record successful execution\n   */\n  private recordSuccess(): void {\n    this.successCount++;\n    this.lastSuccessTime = Date.now();\n    this.consecutiveSuccesses++;\n\n    if (this.state === 'half-open') {\n      // Check if enough successes to close\n      if (this.consecutiveSuccesses >= this.config.successThreshold) {\n        this.transitionTo('closed');\n      }\n    } else if (this.state === 'closed') {\n      // Clean up old failures on success\n      this.pruneOldFailures();\n    }\n  }\n\n  /**\n   * Record failed execution\n   */\n  private recordFailure(error: Error): void {\n    // Check if error should count as failure\n    if (this.config.isRetryable && !this.config.isRetryable(error)) {\n      // Non-retryable error, don't count toward circuit breaker\n      return;\n    }\n\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    this.lastError = error.message;\n\n    // Reset consecutive successes\n    this.consecutiveSuccesses = 0;\n\n    // Record failure\n    this.failures.push({\n      timestamp: Date.now(),\n      error: error.message,\n    });\n\n    // Prune old failures outside window\n    this.pruneOldFailures();\n\n    // Check if we should open the circuit\n    if (this.state === 'half-open') {\n      // Failure during half-open  back to open\n      this.transitionTo('open');\n    } else if (this.state === 'closed') {\n      // Check failure threshold\n      if (this.failures.length >= this.config.failureThreshold) {\n        this.transitionTo('open');\n      }\n    }\n  }\n\n  /**\n   * Transition to new state\n   */\n  private transitionTo(newState: CircuitState): void {\n    this.state = newState;\n    this.lastStateChange = Date.now();\n\n    switch (newState) {\n      case 'open':\n        this.openedAt = Date.now();\n        this.emit('opened', {\n          name: this.name,\n          failureCount: this.failures.length,\n          lastError: this.lastError,\n          nextRetryTime: this.openedAt + this.config.resetTimeoutMs,\n        });\n        break;\n\n      case 'half-open':\n        this.emit('half-open', {\n          name: this.name,\n          timestamp: Date.now(),\n        });\n        break;\n\n      case 'closed':\n        // Reset state\n        this.failures = [];\n        this.consecutiveSuccesses = 0;\n        this.openedAt = undefined;\n\n        this.emit('closed', {\n          name: this.name,\n          successCount: this.consecutiveSuccesses,\n          timestamp: Date.now(),\n        });\n        break;\n    }\n  }\n\n  /**\n   * Remove failures outside the time window\n   */\n  private pruneOldFailures(): void {\n    const now = Date.now();\n    const cutoff = now - this.config.windowMs;\n    this.failures = this.failures.filter((f) => f.timestamp > cutoff);\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): CircuitBreakerMetrics {\n    this.pruneOldFailures();\n\n    const total = this.successCount + this.failureCount;\n    const failureRate = total > 0 ? this.failureCount / total : 0;\n    const successRate = total > 0 ? this.successCount / total : 0;\n\n    return {\n      name: this.name,\n      state: this.state,\n      totalRequests: this.totalRequests,\n      successCount: this.successCount,\n      failureCount: this.failureCount,\n      rejectedCount: this.rejectedCount,\n      recentFailures: this.failures.length,\n      consecutiveSuccesses: this.consecutiveSuccesses,\n      lastFailureTime: this.lastFailureTime,\n      lastSuccessTime: this.lastSuccessTime,\n      lastStateChange: this.lastStateChange,\n      nextRetryTime: this.openedAt ? this.openedAt + this.config.resetTimeoutMs : undefined,\n      failureRate,\n      successRate,\n    };\n  }\n\n  /**\n   * Manually reset circuit breaker (force close)\n   */\n  reset(): void {\n    this.transitionTo('closed');\n    this.totalRequests = 0;\n    this.successCount = 0;\n    this.failureCount = 0;\n    this.rejectedCount = 0;\n    this.lastFailureTime = undefined;\n    this.lastSuccessTime = undefined;\n  }\n\n  /**\n   * Check if circuit is allowing requests\n   */\n  isOpen(): boolean {\n    if (this.state === 'open' && this.openedAt) {\n      const now = Date.now();\n      if (now - this.openedAt >= this.config.resetTimeoutMs) {\n        // Should transition to half-open\n        this.transitionTo('half-open');\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): CircuitBreakerConfig {\n    return { ...this.config };\n  }\n}\n","/**\n * Structured logging infrastructure\n *\n * Provides framework-wide structured logging with context propagation.\n * Supports console output (default) with optional file output.\n *\n * Environment variables:\n * - LOG_LEVEL: trace|debug|info|warn|error|silent (default: info)\n * - LOG_FILE: Path to log file (optional, default: console output)\n * - LOG_PRETTY: true|false (default: true in development)\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Log level\n */\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\n/**\n * Log levels as numbers (for comparison)\n */\nconst LOG_LEVEL_VALUES: Record<LogLevel, number> = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  silent: 100,\n};\n\n/**\n * Logger configuration\n */\nexport interface LoggerConfig {\n  /** Log level */\n  level?: LogLevel;\n\n  /** Pretty print for development */\n  pretty?: boolean;\n\n  /** Base context added to all logs */\n  context?: Record<string, any>;\n\n  /** Custom destination (default: console) */\n  destination?: 'console' | 'stdout' | 'stderr';\n\n  /** File path for file logging */\n  filePath?: string;\n}\n\n/**\n * Log entry\n */\nexport interface LogEntry {\n  level: LogLevel;\n  time: number;\n  msg: string;\n  [key: string]: any;\n}\n\n/**\n * Framework logger\n */\nexport class FrameworkLogger {\n  private config: LoggerConfig;\n  private context: Record<string, any>;\n  private levelValue: number;\n  private fileStream?: fs.WriteStream;\n\n  constructor(config: LoggerConfig = {}) {\n    this.config = {\n      level: (config.level || process.env.LOG_LEVEL || 'info') as LogLevel,\n      pretty: config.pretty ?? (process.env.LOG_PRETTY === 'true' || process.env.NODE_ENV === 'development'),\n      destination: config.destination || 'console',\n      context: config.context || {},\n      filePath: config.filePath || process.env.LOG_FILE,\n    };\n\n    this.context = this.config.context || {};\n    this.levelValue = LOG_LEVEL_VALUES[this.config.level || 'info'];\n\n    // Initialize file stream if file path is provided\n    if (this.config.filePath) {\n      this.initFileStream(this.config.filePath);\n    }\n  }\n\n  /**\n   * Initialize file stream for logging\n   */\n  private initFileStream(filePath: string): void {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(filePath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      // Create write stream with append mode\n      this.fileStream = fs.createWriteStream(filePath, {\n        flags: 'a', // append mode\n        encoding: 'utf8',\n      });\n\n      // Handle stream errors\n      this.fileStream.on('error', (err) => {\n        console.error(`[Logger] File stream error: ${err.message}`);\n        this.fileStream = undefined;\n      });\n    } catch (err) {\n      console.error(`[Logger] Failed to initialize log file: ${err instanceof Error ? err.message : err}`);\n    }\n  }\n\n  /**\n   * Create child logger with additional context\n   */\n  child(context: Record<string, any>): FrameworkLogger {\n    return new FrameworkLogger({\n      ...this.config,\n      context: { ...this.context, ...context },\n    });\n  }\n\n  /**\n   * Trace log\n   */\n  trace(obj: Record<string, any> | string, msg?: string): void {\n    this.log('trace', obj, msg);\n  }\n\n  /**\n   * Debug log\n   */\n  debug(obj: Record<string, any> | string, msg?: string): void {\n    this.log('debug', obj, msg);\n  }\n\n  /**\n   * Info log\n   */\n  info(obj: Record<string, any> | string, msg?: string): void {\n    this.log('info', obj, msg);\n  }\n\n  /**\n   * Warn log\n   */\n  warn(obj: Record<string, any> | string, msg?: string): void {\n    this.log('warn', obj, msg);\n  }\n\n  /**\n   * Error log\n   */\n  error(obj: Record<string, any> | string, msg?: string): void {\n    this.log('error', obj, msg);\n  }\n\n  /**\n   * Internal log method\n   */\n  private log(level: LogLevel, obj: Record<string, any> | string, msg?: string): void {\n    // Check if this level should be logged\n    if (LOG_LEVEL_VALUES[level] < this.levelValue) {\n      return;\n    }\n\n    // Parse arguments\n    let data: Record<string, any>;\n    let message: string;\n\n    if (typeof obj === 'string') {\n      message = obj;\n      data = {};\n    } else {\n      message = msg || '';\n      data = obj;\n    }\n\n    // Create log entry\n    const entry: LogEntry = {\n      level,\n      time: Date.now(),\n      ...this.context,\n      ...data,\n      msg: message,\n    };\n\n    // Output\n    this.output(entry);\n  }\n\n  /**\n   * Output log entry\n   */\n  private output(entry: LogEntry): void {\n    if (this.config.pretty) {\n      this.prettyPrint(entry);\n    } else {\n      this.jsonPrint(entry);\n    }\n  }\n\n  /**\n   * Pretty print for development\n   */\n  private prettyPrint(entry: LogEntry): void {\n    const levelColors: Record<LogLevel, string> = {\n      trace: '\\x1b[90m', // Gray\n      debug: '\\x1b[36m', // Cyan\n      info: '\\x1b[32m', // Green\n      warn: '\\x1b[33m', // Yellow\n      error: '\\x1b[31m', // Red\n      silent: '',\n    };\n\n    const reset = '\\x1b[0m';\n    const color = this.fileStream ? '' : levelColors[entry.level] || ''; // No colors in file\n\n    // Format time\n    const time = new Date(entry.time).toISOString().substring(11, 23);\n\n    // Format level\n    const levelStr = entry.level.toUpperCase().padEnd(5);\n\n    // Format context\n    const contextParts: string[] = [];\n    for (const [key, value] of Object.entries(entry)) {\n      if (key !== 'level' && key !== 'time' && key !== 'msg') {\n        contextParts.push(`${key}=${JSON.stringify(value)}`);\n      }\n    }\n    const context = contextParts.length > 0 ? ` ${contextParts.join(' ')}` : '';\n\n    // Output\n    const output = `${color}[${time}] ${levelStr}${reset} ${entry.msg}${context}`;\n\n    // Write to file if available\n    if (this.fileStream) {\n      // Strip ANSI color codes for file output\n      const cleanOutput = output.replace(/\\x1b\\[[0-9;]*m/g, '');\n      this.fileStream.write(cleanOutput + '\\n');\n      return;\n    }\n\n    // Console output\n    switch (entry.level) {\n      case 'error':\n      case 'warn':\n        console.error(output);\n        break;\n      default:\n        console.log(output);\n    }\n  }\n\n  /**\n   * JSON print for production\n   */\n  private jsonPrint(entry: LogEntry): void {\n    const json = JSON.stringify(entry);\n\n    // Write to file if available\n    if (this.fileStream) {\n      this.fileStream.write(json + '\\n');\n      return;\n    }\n\n    // Console output\n    switch (this.config.destination) {\n      case 'stderr':\n        console.error(json);\n        break;\n      default:\n        console.log(json);\n    }\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<LoggerConfig>): void {\n    this.config = { ...this.config, ...config };\n\n    if (config.level) {\n      this.levelValue = LOG_LEVEL_VALUES[config.level];\n    }\n\n    if (config.context) {\n      this.context = { ...this.context, ...config.context };\n    }\n\n    // Reinitialize file stream if file path changed\n    if (config.filePath !== undefined) {\n      this.closeFileStream();\n      if (config.filePath) {\n        this.initFileStream(config.filePath);\n      }\n    }\n  }\n\n  /**\n   * Close file stream\n   */\n  private closeFileStream(): void {\n    if (this.fileStream) {\n      this.fileStream.end();\n      this.fileStream = undefined;\n    }\n  }\n\n  /**\n   * Cleanup resources (call before process exit)\n   */\n  close(): void {\n    this.closeFileStream();\n  }\n\n  /**\n   * Get current log level\n   */\n  getLevel(): LogLevel {\n    return this.config.level || 'info';\n  }\n\n  /**\n   * Check if level is enabled\n   */\n  isLevelEnabled(level: LogLevel): boolean {\n    return LOG_LEVEL_VALUES[level] >= this.levelValue;\n  }\n}\n\n/**\n * Global logger singleton\n */\nexport const logger = new FrameworkLogger({\n  level: (process.env.LOG_LEVEL as LogLevel) || 'info',\n  pretty: process.env.LOG_PRETTY === 'true' || process.env.NODE_ENV === 'development',\n  filePath: process.env.LOG_FILE,\n});\n\n/**\n * Cleanup logger on process exit\n */\nprocess.on('exit', () => {\n  logger.close();\n});\n\nprocess.on('SIGINT', () => {\n  logger.close();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  logger.close();\n  process.exit(0);\n});\n","/**\n * Metrics collection infrastructure\n *\n * Pluggable metrics system with support for various backends.\n */\n\n/**\n * Metric tags\n */\nexport type MetricTags = Record<string, string | number | boolean>;\n\n/**\n * Metrics collector interface\n */\nexport interface MetricsCollector {\n  /**\n   * Increment a counter\n   */\n  increment(metric: string, value?: number, tags?: MetricTags): void;\n\n  /**\n   * Set a gauge value\n   */\n  gauge(metric: string, value: number, tags?: MetricTags): void;\n\n  /**\n   * Record a timing/duration\n   */\n  timing(metric: string, duration: number, tags?: MetricTags): void;\n\n  /**\n   * Record a histogram value\n   */\n  histogram(metric: string, value: number, tags?: MetricTags): void;\n}\n\n/**\n * No-op metrics collector (default - zero overhead)\n */\nexport class NoOpMetrics implements MetricsCollector {\n  increment(): void {}\n  gauge(): void {}\n  timing(): void {}\n  histogram(): void {}\n}\n\n/**\n * Console metrics collector (development/debugging)\n */\nexport class ConsoleMetrics implements MetricsCollector {\n  private prefix: string;\n\n  constructor(prefix: string = 'oneringai') {\n    this.prefix = prefix;\n  }\n\n  increment(metric: string, value: number = 1, tags?: MetricTags): void {\n    this.log('COUNTER', metric, value, tags);\n  }\n\n  gauge(metric: string, value: number, tags?: MetricTags): void {\n    this.log('GAUGE', metric, value, tags);\n  }\n\n  timing(metric: string, duration: number, tags?: MetricTags): void {\n    this.log('TIMING', metric, `${duration}ms`, tags);\n  }\n\n  histogram(metric: string, value: number, tags?: MetricTags): void {\n    this.log('HISTOGRAM', metric, value, tags);\n  }\n\n  private log(type: string, metric: string, value: any, tags?: MetricTags): void {\n    const fullMetric = `${this.prefix}.${metric}`;\n    const tagsStr = tags ? ` ${JSON.stringify(tags)}` : '';\n    console.log(`[METRIC:${type}] ${fullMetric}=${value}${tagsStr}`);\n  }\n}\n\n/**\n * In-memory metrics aggregator (testing/development)\n */\nexport class InMemoryMetrics implements MetricsCollector {\n  private counters = new Map<string, number>();\n  private gauges = new Map<string, number>();\n  private timings = new Map<string, number[]>();\n  private histograms = new Map<string, number[]>();\n\n  increment(metric: string, value: number = 1, tags?: MetricTags): void {\n    const key = this.makeKey(metric, tags);\n    this.counters.set(key, (this.counters.get(key) || 0) + value);\n  }\n\n  gauge(metric: string, value: number, tags?: MetricTags): void {\n    const key = this.makeKey(metric, tags);\n    this.gauges.set(key, value);\n  }\n\n  timing(metric: string, duration: number, tags?: MetricTags): void {\n    const key = this.makeKey(metric, tags);\n    const timings = this.timings.get(key) || [];\n    timings.push(duration);\n    this.timings.set(key, timings);\n  }\n\n  histogram(metric: string, value: number, tags?: MetricTags): void {\n    const key = this.makeKey(metric, tags);\n    const values = this.histograms.get(key) || [];\n    values.push(value);\n    this.histograms.set(key, values);\n  }\n\n  private makeKey(metric: string, tags?: MetricTags): string {\n    if (!tags) return metric;\n    const tagStr = Object.entries(tags)\n      .map(([k, v]) => `${k}:${v}`)\n      .sort()\n      .join(',');\n    return `${metric}{${tagStr}}`;\n  }\n\n  /**\n   * Get all metrics (for testing)\n   */\n  getMetrics(): {\n    counters: Map<string, number>;\n    gauges: Map<string, number>;\n    timings: Map<string, number[]>;\n    histograms: Map<string, number[]>;\n  } {\n    return {\n      counters: new Map(this.counters),\n      gauges: new Map(this.gauges),\n      timings: new Map(this.timings),\n      histograms: new Map(this.histograms),\n    };\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clear(): void {\n    this.counters.clear();\n    this.gauges.clear();\n    this.timings.clear();\n    this.histograms.clear();\n  }\n\n  /**\n   * Get summary statistics for timings\n   */\n  getTimingStats(metric: string, tags?: MetricTags): {\n    count: number;\n    min: number;\n    max: number;\n    mean: number;\n    p50: number;\n    p95: number;\n    p99: number;\n  } | null {\n    const key = this.makeKey(metric, tags);\n    const timings = this.timings.get(key);\n\n    if (!timings || timings.length === 0) {\n      return null;\n    }\n\n    const sorted = [...timings].sort((a, b) => a - b);\n    const count = sorted.length;\n    const sum = sorted.reduce((a, b) => a + b, 0);\n\n    return {\n      count,\n      min: sorted[0] ?? 0,\n      max: sorted[count - 1] ?? 0,\n      mean: sum / count,\n      p50: sorted[Math.floor(count * 0.5)] ?? 0,\n      p95: sorted[Math.floor(count * 0.95)] ?? 0,\n      p99: sorted[Math.floor(count * 0.99)] ?? 0,\n    };\n  }\n}\n\n/**\n * Metrics collector type\n */\nexport type MetricsCollectorType = 'noop' | 'console' | 'inmemory';\n\n/**\n * Create metrics collector from type\n */\nexport function createMetricsCollector(type?: MetricsCollectorType, prefix?: string): MetricsCollector {\n  const collectorType = type || (process.env.METRICS_COLLECTOR as MetricsCollectorType) || 'noop';\n\n  switch (collectorType) {\n    case 'console':\n      return new ConsoleMetrics(prefix);\n    case 'inmemory':\n      return new InMemoryMetrics();\n    default:\n      return new NoOpMetrics();\n  }\n}\n\n/**\n * Global metrics singleton\n */\nexport const metrics: MetricsCollector = createMetricsCollector(\n  undefined,\n  process.env.METRICS_PREFIX || 'oneringai'\n);\n\n/**\n * Update global metrics collector\n */\nexport function setMetricsCollector(collector: MetricsCollector): void {\n  Object.assign(metrics, collector);\n}\n","/**\n * Tool registry - manages tool registration and execution\n */\n\nimport { IToolExecutor } from '../../domain/interfaces/IToolExecutor.js';\nimport { Tool, ToolFunction } from '../../domain/entities/Tool.js';\nimport { ToolNotFoundError, ToolExecutionError } from '../../domain/errors/AIErrors.js';\nimport { CircuitBreaker, CircuitState } from '../../infrastructure/resilience/CircuitBreaker.js';\nimport { logger, FrameworkLogger } from '../../infrastructure/observability/Logger.js';\nimport { metrics } from '../../infrastructure/observability/Metrics.js';\n\nexport class ToolRegistry implements IToolExecutor {\n  private tools: Map<string, ToolFunction> = new Map();\n  private circuitBreakers: Map<string, CircuitBreaker> = new Map();\n  private logger: FrameworkLogger;\n\n  constructor() {\n    this.logger = logger.child({ component: 'ToolRegistry' });\n  }\n\n  /**\n   * Register a new tool\n   */\n  registerTool(tool: ToolFunction): void {\n    this.tools.set(tool.definition.function.name, tool);\n  }\n\n  /**\n   * Unregister a tool\n   */\n  unregisterTool(toolName: string): void {\n    this.tools.delete(toolName);\n  }\n\n  /**\n   * Get or create circuit breaker for a tool\n   */\n  private getCircuitBreaker(toolName: string, tool: ToolFunction): CircuitBreaker {\n    let breaker = this.circuitBreakers.get(toolName);\n\n    if (!breaker) {\n      // Create circuit breaker for this tool\n      const config = (tool as any).circuitBreaker || {\n        failureThreshold: 3,\n        successThreshold: 2,\n        resetTimeoutMs: 60000, // 1 minute\n        windowMs: 300000, // 5 minutes\n      };\n\n      breaker = new CircuitBreaker(`tool:${toolName}`, config);\n\n      // Forward CB events to logger and metrics\n      breaker.on('opened', (data) => {\n        this.logger.warn(data, `Circuit breaker opened for tool: ${toolName}`);\n        metrics.increment('circuit_breaker.opened', 1, {\n          breaker: data.name,\n          tool: toolName,\n        });\n      });\n\n      breaker.on('closed', (data) => {\n        this.logger.info(data, `Circuit breaker closed for tool: ${toolName}`);\n        metrics.increment('circuit_breaker.closed', 1, {\n          breaker: data.name,\n          tool: toolName,\n        });\n      });\n\n      this.circuitBreakers.set(toolName, breaker);\n    }\n\n    return breaker;\n  }\n\n  /**\n   * Execute a tool function\n   */\n  async execute(toolName: string, args: any): Promise<any> {\n    const tool = this.tools.get(toolName);\n    if (!tool) {\n      throw new ToolNotFoundError(toolName);\n    }\n\n    // Get circuit breaker for this tool\n    const breaker = this.getCircuitBreaker(toolName, tool);\n\n    this.logger.debug({ toolName, args }, 'Tool execution started');\n\n    const startTime = Date.now();\n\n    metrics.increment('tool.executed', 1, { tool: toolName });\n\n    try {\n      // Execute with circuit breaker protection\n      const result = await breaker.execute(async () => {\n        return await tool.execute(args);\n      });\n\n      const duration = Date.now() - startTime;\n\n      this.logger.debug({ toolName, duration }, 'Tool execution completed');\n\n      metrics.timing('tool.duration', duration, { tool: toolName });\n      metrics.increment('tool.success', 1, { tool: toolName });\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n\n      this.logger.error({\n        toolName,\n        error: (error as Error).message,\n        duration,\n      }, 'Tool execution failed');\n\n      metrics.increment('tool.failed', 1, {\n        tool: toolName,\n        error: (error as Error).name,\n      });\n\n      throw new ToolExecutionError(\n        toolName,\n        (error as Error).message,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if tool is available\n   */\n  hasToolFunction(toolName: string): boolean {\n    return this.tools.has(toolName);\n  }\n\n  /**\n   * Get tool definition\n   */\n  getToolDefinition(toolName: string): Tool | undefined {\n    const tool = this.tools.get(toolName);\n    return tool?.definition;\n  }\n\n  /**\n   * List all registered tools\n   */\n  listTools(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  /**\n   * Clear all registered tools\n   */\n  clear(): void {\n    this.tools.clear();\n    this.circuitBreakers.clear();\n  }\n\n  /**\n   * Get circuit breaker states for all tools\n   */\n  getCircuitBreakerStates(): Map<string, CircuitState> {\n    const states = new Map<string, CircuitState>();\n    for (const [toolName, breaker] of this.circuitBreakers.entries()) {\n      states.set(toolName, breaker.getState());\n    }\n    return states;\n  }\n\n  /**\n   * Get circuit breaker metrics for a specific tool\n   */\n  getToolCircuitBreakerMetrics(toolName: string) {\n    const breaker = this.circuitBreakers.get(toolName);\n    return breaker?.getMetrics();\n  }\n\n  /**\n   * Manually reset a tool's circuit breaker\n   */\n  resetToolCircuitBreaker(toolName: string): void {\n    const breaker = this.circuitBreakers.get(toolName);\n    if (breaker) {\n      breaker.reset();\n      this.logger.info({ toolName }, 'Tool circuit breaker manually reset');\n    }\n  }\n}\n","/**\n * Execution context - tracks state, metrics, and history for agent execution\n * Includes memory safety (circular buffers) and resource limits\n */\n\nimport { AgentResponse } from '../../domain/entities/Response.js';\nimport { TextGenerateOptions } from '../../domain/interfaces/ITextProvider.js';\nimport { ToolCall, ToolResult, ToolCallState } from '../../domain/entities/Tool.js';\n\nexport type HistoryMode = 'none' | 'summary' | 'full';\n\nexport interface ExecutionContextConfig {\n  maxHistorySize?: number; // Max iterations to store (default: 10)\n  historyMode?: HistoryMode; // What to store (default: 'summary')\n  maxAuditTrailSize?: number; // Max audit entries (default: 1000)\n}\n\nexport interface IterationRecord {\n  iteration: number;\n  request: TextGenerateOptions;\n  response: AgentResponse;\n  toolCalls: ToolCall[];\n  toolResults: ToolResult[];\n  startTime: Date;\n  endTime: Date;\n}\n\nexport interface IterationSummary {\n  iteration: number;\n  tokens: number;\n  toolCount: number;\n  duration: number;\n  timestamp: Date;\n}\n\nexport interface ExecutionMetrics {\n  // Timing\n  totalDuration: number;\n  llmDuration: number;\n  toolDuration: number;\n  hookDuration: number;\n\n  // Counts\n  iterationCount: number;\n  toolCallCount: number;\n  toolSuccessCount: number;\n  toolFailureCount: number;\n  toolTimeoutCount: number;\n\n  // Tokens\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n\n  // Errors\n  errors: Array<{ type: string; message: string; timestamp: Date }>;\n}\n\nexport interface AuditEntry {\n  timestamp: Date;\n  type:\n    | 'hook_executed'\n    | 'tool_modified'\n    | 'tool_skipped'\n    | 'execution_paused'\n    | 'execution_resumed'\n    | 'tool_approved'\n    | 'tool_rejected';\n  hookName?: string;\n  toolName?: string;\n  details: any;\n}\n\nexport class ExecutionContext {\n  // Execution metadata\n  readonly executionId: string;\n  readonly startTime: Date;\n  iteration: number = 0;\n\n  // Tool tracking\n  readonly toolCalls: Map<string, ToolCall> = new Map();\n  readonly toolResults: Map<string, ToolResult> = new Map();\n\n  // Control state\n  paused: boolean = false;\n  pauseReason?: string;\n  cancelled: boolean = false;\n  cancelReason?: string;\n\n  // User data (for hooks to share state)\n  readonly metadata: Map<string, any> = new Map();\n\n  // History storage (memory-safe)\n  private readonly config: ExecutionContextConfig;\n  private readonly iterations: IterationRecord[] = [];\n  private readonly iterationSummaries: IterationSummary[] = [];\n\n  // Metrics\n  readonly metrics: ExecutionMetrics = {\n    totalDuration: 0,\n    llmDuration: 0,\n    toolDuration: 0,\n    hookDuration: 0,\n    iterationCount: 0,\n    toolCallCount: 0,\n    toolSuccessCount: 0,\n    toolFailureCount: 0,\n    toolTimeoutCount: 0,\n    inputTokens: 0,\n    outputTokens: 0,\n    totalTokens: 0,\n    errors: [],\n  };\n\n  // Audit trail\n  private readonly auditTrail: AuditEntry[] = [];\n\n  constructor(\n    executionId: string,\n    config: ExecutionContextConfig = {}\n  ) {\n    this.executionId = executionId;\n    this.startTime = new Date();\n    this.config = {\n      maxHistorySize: config.maxHistorySize || 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: config.maxAuditTrailSize || 1000,\n    };\n  }\n\n  /**\n   * Add iteration to history (memory-safe)\n   */\n  addIteration(record: IterationRecord): void {\n    switch (this.config.historyMode) {\n      case 'none':\n        // Don't store anything\n        break;\n\n      case 'summary':\n        // Store lightweight summary only\n        this.iterationSummaries.push({\n          iteration: record.iteration,\n          tokens: record.response.usage.total_tokens,\n          toolCount: record.toolCalls.length,\n          duration: record.endTime.getTime() - record.startTime.getTime(),\n          timestamp: record.startTime,\n        });\n\n        // Keep circular buffer\n        if (this.iterationSummaries.length > this.config.maxHistorySize!) {\n          this.iterationSummaries.shift();\n        }\n        break;\n\n      case 'full':\n        // Store full iteration data\n        this.iterations.push(record);\n\n        // Keep circular buffer\n        if (this.iterations.length > this.config.maxHistorySize!) {\n          this.iterations.shift();\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get iteration history\n   */\n  getHistory(): IterationRecord[] | IterationSummary[] {\n    return this.config.historyMode === 'full' ? this.iterations : this.iterationSummaries;\n  }\n\n  /**\n   * Add audit entry\n   */\n  audit(type: AuditEntry['type'], details: any, hookName?: string, toolName?: string): void {\n    this.auditTrail.push({\n      timestamp: new Date(),\n      type,\n      hookName,\n      toolName,\n      details,\n    });\n\n    // Keep circular buffer\n    if (this.auditTrail.length > this.config.maxAuditTrailSize!) {\n      this.auditTrail.shift();\n    }\n  }\n\n  /**\n   * Get audit trail\n   */\n  getAuditTrail(): readonly AuditEntry[] {\n    return this.auditTrail;\n  }\n\n  /**\n   * Update metrics\n   */\n  updateMetrics(update: Partial<ExecutionMetrics>): void {\n    Object.assign(this.metrics, update);\n  }\n\n  /**\n   * Add tool call to tracking\n   */\n  addToolCall(toolCall: ToolCall): void {\n    this.toolCalls.set(toolCall.id, toolCall);\n    this.metrics.toolCallCount++;\n  }\n\n  /**\n   * Add tool result to tracking\n   */\n  addToolResult(result: ToolResult): void {\n    this.toolResults.set(result.tool_use_id, result);\n\n    // Update metrics\n    if (result.state === ToolCallState.COMPLETED) {\n      this.metrics.toolSuccessCount++;\n    } else if (result.state === ToolCallState.FAILED) {\n      this.metrics.toolFailureCount++;\n    } else if (result.state === ToolCallState.TIMEOUT) {\n      this.metrics.toolTimeoutCount++;\n    }\n  }\n\n  /**\n   * Check resource limits\n   */\n  checkLimits(limits?: {\n    maxExecutionTime?: number;\n    maxToolCalls?: number;\n    maxContextSize?: number;\n  }): void {\n    if (!limits) return;\n\n    // Check execution time\n    if (limits.maxExecutionTime) {\n      const elapsed = Date.now() - this.startTime.getTime();\n      if (elapsed > limits.maxExecutionTime) {\n        throw new Error(\n          `Execution time limit exceeded: ${elapsed}ms > ${limits.maxExecutionTime}ms`\n        );\n      }\n    }\n\n    // Check tool call count\n    if (limits.maxToolCalls && this.toolCalls.size > limits.maxToolCalls) {\n      throw new Error(\n        `Tool call limit exceeded: ${this.toolCalls.size} > ${limits.maxToolCalls}`\n      );\n    }\n\n    // Check context size\n    if (limits.maxContextSize) {\n      const size = this.estimateSize();\n      if (size > limits.maxContextSize) {\n        throw new Error(\n          `Context size limit exceeded: ${size} bytes > ${limits.maxContextSize} bytes`\n        );\n      }\n    }\n  }\n\n  /**\n   * Estimate memory usage (rough approximation)\n   */\n  private estimateSize(): number {\n    try {\n      const data = {\n        toolCalls: Array.from(this.toolCalls.values()),\n        toolResults: Array.from(this.toolResults.values()),\n        iterations: this.config.historyMode === 'full' ? this.iterations : this.iterationSummaries,\n        auditTrail: this.auditTrail,\n      };\n      return JSON.stringify(data).length;\n    } catch {\n      return 0; // Error estimating, return 0\n    }\n  }\n\n  /**\n   * Cleanup resources and release memory\n   * Clears all internal arrays and maps to allow garbage collection\n   */\n  cleanup(): void {\n    // Store execution summary before clearing\n    const summary = {\n      executionId: this.executionId,\n      totalIterations: this.iteration,\n      totalToolCalls: this.metrics.toolCallCount,\n      totalDuration: Date.now() - this.startTime.getTime(),\n      success: !this.cancelled && this.metrics.errors.length === 0,\n    };\n\n    // Clear all maps\n    this.toolCalls.clear();\n    this.toolResults.clear();\n    this.metadata.clear();\n\n    // Clear all arrays (modify length to allow GC of items)\n    this.iterations.length = 0;\n    this.iterationSummaries.length = 0;\n    this.auditTrail.length = 0;\n    this.metrics.errors.length = 0;\n\n    // Store summary after clearing (for final access if needed)\n    this.metadata.set('execution_summary', summary);\n  }\n\n  /**\n   * Get execution summary\n   */\n  getSummary() {\n    return {\n      executionId: this.executionId,\n      startTime: this.startTime,\n      currentIteration: this.iteration,\n      paused: this.paused,\n      cancelled: this.cancelled,\n      metrics: { ...this.metrics },\n      totalDuration: Date.now() - this.startTime.getTime(),\n    };\n  }\n}\n","/**\n * Hook manager - handles hook registration and execution\n * Includes error isolation, timeouts, and optional parallel execution\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport {\n  Hook,\n  HookConfig,\n  HookName,\n  HookSignatures,\n} from './types/HookTypes.js';\n\nexport class HookManager {\n  private hooks: Map<HookName, Hook<any, any>[]> = new Map();\n  private timeout: number;\n  private parallel: boolean;\n  // Per-hook error tracking: hookKey -> consecutive error count\n  private hookErrorCounts: Map<string, number> = new Map();\n  // Disabled hooks that exceeded error threshold\n  private disabledHooks: Set<string> = new Set();\n  private maxConsecutiveErrors: number = 3;\n  private emitter: EventEmitter;\n\n  constructor(\n    config: HookConfig = {},\n    emitter: EventEmitter,\n    errorHandling?: { maxConsecutiveErrors?: number }\n  ) {\n    this.timeout = config.hookTimeout || 5000; // 5 second default\n    this.parallel = config.parallelHooks || false;\n    this.emitter = emitter;\n    this.maxConsecutiveErrors = errorHandling?.maxConsecutiveErrors || 3;\n\n    // Register hooks from config\n    this.registerFromConfig(config);\n  }\n\n  /**\n   * Register hooks from configuration\n   */\n  private registerFromConfig(config: HookConfig): void {\n    const hookNames: HookName[] = [\n      'before:execution',\n      'after:execution',\n      'before:llm',\n      'after:llm',\n      'before:tool',\n      'after:tool',\n      'approve:tool',\n      'pause:check',\n    ];\n\n    for (const name of hookNames) {\n      const hook = config[name];\n      if (hook) {\n        this.register(name, hook);\n      }\n    }\n  }\n\n  /**\n   * Register a hook\n   */\n  register(name: HookName, hook: Hook<any, any>): void {\n    // Validate hook is a function\n    if (typeof hook !== 'function') {\n      throw new Error(`Hook must be a function, got: ${typeof hook}`);\n    }\n\n    // Get or create hooks array\n    if (!this.hooks.has(name)) {\n      this.hooks.set(name, []);\n    }\n\n    const existing = this.hooks.get(name)!;\n\n    // Limit number of hooks per name\n    if (existing.length >= 10) {\n      throw new Error(`Too many hooks for ${name} (max: 10)`);\n    }\n\n    existing.push(hook);\n  }\n\n  /**\n   * Execute hooks for a given name\n   */\n  async executeHooks<K extends HookName>(\n    name: K,\n    context: HookSignatures[K]['context'],\n    defaultResult: HookSignatures[K]['result']\n  ): Promise<HookSignatures[K]['result']> {\n    const hooks = this.hooks.get(name);\n\n    if (!hooks || hooks.length === 0) {\n      return defaultResult;\n    }\n\n    // Parallel execution (for independent hooks)\n    if (this.parallel && hooks.length > 1) {\n      return this.executeHooksParallel(hooks, context, defaultResult);\n    }\n\n    // Sequential execution (default)\n    return this.executeHooksSequential(hooks, context, defaultResult);\n  }\n\n  /**\n   * Execute hooks sequentially\n   */\n  private async executeHooksSequential<T>(\n    hooks: Hook<any, any>[],\n    context: any,\n    defaultResult: T\n  ): Promise<T> {\n    let result = defaultResult;\n\n    for (let i = 0; i < hooks.length; i++) {\n      const hook = hooks[i]!;\n      const hookKey = this.getHookKey(hook, i);\n      const hookResult = await this.executeHookSafely(hook, context, hookKey);\n\n      // Skip failed hooks\n      if (hookResult === null) {\n        continue;\n      }\n\n      // Merge hook result\n      result = { ...result, ...hookResult };\n\n      // Check for early exit\n      if ((hookResult as any).skip === true) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute hooks in parallel\n   */\n  private async executeHooksParallel<T>(\n    hooks: Hook<any, any>[],\n    context: any,\n    defaultResult: T\n  ): Promise<T> {\n    // Execute all hooks concurrently with unique keys\n    const results = await Promise.all(\n      hooks.map((hook, i) => {\n        const hookKey = this.getHookKey(hook, i);\n        return this.executeHookSafely(hook, context, hookKey);\n      })\n    );\n\n    // Filter out failures and merge results\n    const validResults = results.filter((r) => r !== null);\n\n    return validResults.reduce(\n      (acc, hookResult) => ({ ...acc, ...hookResult }),\n      defaultResult\n    );\n  }\n\n  /**\n   * Generate unique key for a hook\n   */\n  private getHookKey(hook: Hook<any, any>, index: number): string {\n    return `${hook.name || 'anonymous'}_${index}`;\n  }\n\n  /**\n   * Execute single hook with error isolation and timeout (with per-hook error tracking)\n   */\n  private async executeHookSafely<T>(\n    hook: Hook<any, any>,\n    context: any,\n    hookKey?: string\n  ): Promise<T | null> {\n    const key = hookKey || hook.name || 'anonymous';\n\n    // Skip disabled hooks\n    if (this.disabledHooks.has(key)) {\n      return null;\n    }\n\n    const startTime = Date.now();\n\n    try {\n      // Execute with timeout\n      const result = await Promise.race([\n        hook(context),\n        new Promise<never>((_, reject) =>\n          setTimeout(() => reject(new Error('Hook timeout')), this.timeout)\n        ),\n      ]);\n\n      // Reset error counter for this hook on success\n      this.hookErrorCounts.delete(key);\n\n      // Track timing\n      const duration = Date.now() - startTime;\n      if (context.context?.updateMetrics) {\n        context.context.updateMetrics({\n          hookDuration: (context.context.metrics.hookDuration || 0) + duration,\n        });\n      }\n\n      return result as T;\n    } catch (error) {\n      // Increment error counter for this specific hook\n      const errorCount = (this.hookErrorCounts.get(key) || 0) + 1;\n      this.hookErrorCounts.set(key, errorCount);\n\n      // Emit error event\n      this.emitter.emit('hook:error', {\n        executionId: context.executionId,\n        hookName: hook.name || 'anonymous',\n        error: error as Error,\n        consecutiveErrors: errorCount,\n        timestamp: new Date(),\n      });\n\n      // Check consecutive error threshold for this hook\n      if (errorCount >= this.maxConsecutiveErrors) {\n        // Disable this specific hook, not all hooks\n        this.disabledHooks.add(key);\n        console.warn(\n          `Hook \"${key}\" disabled after ${errorCount} consecutive failures. Last error: ${(error as Error).message}`\n        );\n      } else {\n        // Log warning but continue (degraded mode)\n        console.warn(\n          `Hook execution failed (${key}): ${(error as Error).message} (${errorCount}/${this.maxConsecutiveErrors} errors)`\n        );\n      }\n\n      return null; // Hook failed, skip its result\n    }\n  }\n\n  /**\n   * Check if there are any hooks registered\n   */\n  hasHooks(name: HookName): boolean {\n    const hooks = this.hooks.get(name);\n    return !!hooks && hooks.length > 0;\n  }\n\n  /**\n   * Get hook count\n   */\n  getHookCount(name?: HookName): number {\n    if (name) {\n      return this.hooks.get(name)?.length || 0;\n    }\n    // Total across all hooks\n    return Array.from(this.hooks.values()).reduce((sum, arr) => sum + arr.length, 0);\n  }\n\n  /**\n   * Clear all hooks and reset error tracking\n   */\n  clear(): void {\n    this.hooks.clear();\n    this.hookErrorCounts.clear();\n    this.disabledHooks.clear();\n  }\n\n  /**\n   * Re-enable a disabled hook\n   */\n  enableHook(hookKey: string): void {\n    this.disabledHooks.delete(hookKey);\n    this.hookErrorCounts.delete(hookKey);\n  }\n\n  /**\n   * Get list of disabled hooks\n   */\n  getDisabledHooks(): string[] {\n    return Array.from(this.disabledHooks);\n  }\n}\n","/**\n * Streaming event types for real-time LLM responses\n * Based on OpenAI Responses API event format as the internal standard\n */\n\nimport { TokenUsage } from './Response.js';\n\n/**\n * Stream event type enum\n */\nexport enum StreamEventType {\n  RESPONSE_CREATED = 'response.created',\n  RESPONSE_IN_PROGRESS = 'response.in_progress',\n  OUTPUT_TEXT_DELTA = 'response.output_text.delta',\n  OUTPUT_TEXT_DONE = 'response.output_text.done',\n  TOOL_CALL_START = 'response.tool_call.start',\n  TOOL_CALL_ARGUMENTS_DELTA = 'response.tool_call_arguments.delta',\n  TOOL_CALL_ARGUMENTS_DONE = 'response.tool_call_arguments.done',\n  TOOL_EXECUTION_START = 'response.tool_execution.start',\n  TOOL_EXECUTION_DONE = 'response.tool_execution.done',\n  ITERATION_COMPLETE = 'response.iteration.complete',\n  RESPONSE_COMPLETE = 'response.complete',\n  ERROR = 'response.error',\n}\n\n/**\n * Base interface for all stream events\n */\ninterface BaseStreamEvent {\n  type: StreamEventType;\n  response_id: string;\n}\n\n/**\n * Response created - first event in stream\n */\nexport interface ResponseCreatedEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_CREATED;\n  model: string;\n  created_at: number;\n}\n\n/**\n * Response in progress\n */\nexport interface ResponseInProgressEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_IN_PROGRESS;\n}\n\n/**\n * Text delta - incremental text output\n */\nexport interface OutputTextDeltaEvent extends BaseStreamEvent {\n  type: StreamEventType.OUTPUT_TEXT_DELTA;\n  item_id: string;\n  output_index: number;\n  content_index: number;\n  delta: string;\n  sequence_number: number;\n}\n\n/**\n * Text output complete for this item\n */\nexport interface OutputTextDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.OUTPUT_TEXT_DONE;\n  item_id: string;\n  output_index: number;\n  text: string; // Complete accumulated text\n}\n\n/**\n * Tool call detected and starting\n */\nexport interface ToolCallStartEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_START;\n  item_id: string;\n  tool_call_id: string;\n  tool_name: string;\n}\n\n/**\n * Tool call arguments delta - incremental JSON\n */\nexport interface ToolCallArgumentsDeltaEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_ARGUMENTS_DELTA;\n  item_id: string;\n  tool_call_id: string;\n  tool_name: string;\n  delta: string; // JSON chunk\n  sequence_number: number;\n}\n\n/**\n * Tool call arguments complete\n */\nexport interface ToolCallArgumentsDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_ARGUMENTS_DONE;\n  tool_call_id: string;\n  tool_name: string;\n  arguments: string; // Complete JSON string\n  incomplete?: boolean; // True if truncated by max_tokens\n}\n\n/**\n * Tool execution starting\n */\nexport interface ToolExecutionStartEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_EXECUTION_START;\n  tool_call_id: string;\n  tool_name: string;\n  arguments: any; // Parsed arguments\n}\n\n/**\n * Tool execution complete\n */\nexport interface ToolExecutionDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_EXECUTION_DONE;\n  tool_call_id: string;\n  tool_name: string;\n  result: any;\n  execution_time_ms: number;\n  error?: string; // If tool failed\n}\n\n/**\n * Iteration complete - end of agentic loop iteration\n */\nexport interface IterationCompleteEvent extends BaseStreamEvent {\n  type: StreamEventType.ITERATION_COMPLETE;\n  iteration: number;\n  tool_calls_count: number;\n  has_more_iterations: boolean;\n}\n\n/**\n * Response complete - final event\n */\nexport interface ResponseCompleteEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_COMPLETE;\n  status: 'completed' | 'incomplete' | 'failed';\n  usage: TokenUsage;\n  iterations: number;\n  duration_ms?: number;\n}\n\n/**\n * Error event\n */\nexport interface ErrorEvent extends BaseStreamEvent {\n  type: StreamEventType.ERROR;\n  error: {\n    type: string;\n    message: string;\n    code?: string;\n  };\n  recoverable: boolean;\n}\n\n/**\n * Union type of all stream events\n * Discriminated by 'type' field for type narrowing\n */\nexport type StreamEvent =\n  | ResponseCreatedEvent\n  | ResponseInProgressEvent\n  | OutputTextDeltaEvent\n  | OutputTextDoneEvent\n  | ToolCallStartEvent\n  | ToolCallArgumentsDeltaEvent\n  | ToolCallArgumentsDoneEvent\n  | ToolExecutionStartEvent\n  | ToolExecutionDoneEvent\n  | IterationCompleteEvent\n  | ResponseCompleteEvent\n  | ErrorEvent;\n\n/**\n * Type guard to check if event is a specific type\n */\nexport function isStreamEvent<T extends StreamEvent>(\n  event: StreamEvent,\n  type: StreamEventType\n): event is T {\n  return event.type === type;\n}\n\n/**\n * Type guards for specific events\n */\nexport function isOutputTextDelta(event: StreamEvent): event is OutputTextDeltaEvent {\n  return event.type === StreamEventType.OUTPUT_TEXT_DELTA;\n}\n\nexport function isToolCallArgumentsDelta(\n  event: StreamEvent\n): event is ToolCallArgumentsDeltaEvent {\n  return event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DELTA;\n}\n\nexport function isToolCallArgumentsDone(\n  event: StreamEvent\n): event is ToolCallArgumentsDoneEvent {\n  return event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DONE;\n}\n\nexport function isResponseComplete(event: StreamEvent): event is ResponseCompleteEvent {\n  return event.type === StreamEventType.RESPONSE_COMPLETE;\n}\n\nexport function isErrorEvent(event: StreamEvent): event is ErrorEvent {\n  return event.type === StreamEventType.ERROR;\n}\n","/**\n * StreamState - Accumulates streaming events to reconstruct complete response\n */\n\nimport { TokenUsage } from './Response.js';\nimport { ToolCall } from './Tool.js';\n\n/**\n * Buffer for accumulating tool call arguments\n */\nexport interface ToolCallBuffer {\n  toolName: string;\n  argumentChunks: string[];\n  isComplete: boolean;\n  startTime: Date;\n}\n\n/**\n * StreamState tracks all accumulated data during streaming\n */\nexport class StreamState {\n  // Core identifiers\n  public responseId: string;\n  public model: string;\n  public createdAt: number;\n\n  // Text accumulation: item_id -> text chunks\n  private textBuffers: Map<string, string[]>;\n\n  // Tool call accumulation: tool_call_id -> buffer\n  private toolCallBuffers: Map<string, ToolCallBuffer>;\n\n  // Completed tool calls\n  private completedToolCalls: ToolCall[];\n\n  // Tool execution results\n  private toolResults: Map<string, any>;\n\n  // Metadata\n  public currentIteration: number;\n  public usage: TokenUsage;\n  public status: 'in_progress' | 'completed' | 'incomplete' | 'failed';\n  public startTime: Date;\n  public endTime?: Date;\n\n  // Statistics\n  public totalChunks: number;\n  public totalTextDeltas: number;\n  public totalToolCalls: number;\n\n  constructor(responseId: string, model: string, createdAt?: number) {\n    this.responseId = responseId;\n    this.model = model;\n    this.createdAt = createdAt || Date.now();\n\n    this.textBuffers = new Map();\n    this.toolCallBuffers = new Map();\n    this.completedToolCalls = [];\n    this.toolResults = new Map();\n\n    this.currentIteration = 0;\n    this.usage = {\n      input_tokens: 0,\n      output_tokens: 0,\n      total_tokens: 0,\n    };\n    this.status = 'in_progress';\n    this.startTime = new Date();\n\n    this.totalChunks = 0;\n    this.totalTextDeltas = 0;\n    this.totalToolCalls = 0;\n  }\n\n  /**\n   * Accumulate text delta for a specific item\n   */\n  accumulateTextDelta(itemId: string, delta: string): void {\n    if (!this.textBuffers.has(itemId)) {\n      this.textBuffers.set(itemId, []);\n    }\n    this.textBuffers.get(itemId)!.push(delta);\n    this.totalTextDeltas++;\n    this.totalChunks++;\n  }\n\n  /**\n   * Get complete accumulated text for an item\n   */\n  getCompleteText(itemId: string): string {\n    const chunks = this.textBuffers.get(itemId);\n    return chunks ? chunks.join('') : '';\n  }\n\n  /**\n   * Get all accumulated text (all items concatenated)\n   */\n  getAllText(): string {\n    const allText: string[] = [];\n    for (const chunks of this.textBuffers.values()) {\n      allText.push(chunks.join(''));\n    }\n    return allText.join('');\n  }\n\n  /**\n   * Start accumulating tool call arguments\n   */\n  startToolCall(toolCallId: string, toolName: string): void {\n    this.toolCallBuffers.set(toolCallId, {\n      toolName,\n      argumentChunks: [],\n      isComplete: false,\n      startTime: new Date(),\n    });\n  }\n\n  /**\n   * Accumulate tool argument delta\n   */\n  accumulateToolArguments(toolCallId: string, delta: string): void {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    buffer.argumentChunks.push(delta);\n    this.totalChunks++;\n  }\n\n  /**\n   * Mark tool call arguments as complete\n   */\n  completeToolCall(toolCallId: string): void {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    buffer.isComplete = true;\n    this.totalToolCalls++;\n  }\n\n  /**\n   * Get complete tool arguments (joined chunks)\n   */\n  getCompleteToolArguments(toolCallId: string): string {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    return buffer.argumentChunks.join('');\n  }\n\n  /**\n   * Check if tool call is complete\n   */\n  isToolCallComplete(toolCallId: string): boolean {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    return buffer ? buffer.isComplete : false;\n  }\n\n  /**\n   * Get tool name for a tool call\n   */\n  getToolName(toolCallId: string): string | undefined {\n    return this.toolCallBuffers.get(toolCallId)?.toolName;\n  }\n\n  /**\n   * Add completed tool call\n   */\n  addCompletedToolCall(toolCall: ToolCall): void {\n    this.completedToolCalls.push(toolCall);\n  }\n\n  /**\n   * Get all completed tool calls\n   */\n  getCompletedToolCalls(): ToolCall[] {\n    return [...this.completedToolCalls];\n  }\n\n  /**\n   * Store tool execution result\n   */\n  setToolResult(toolCallId: string, result: any): void {\n    this.toolResults.set(toolCallId, result);\n  }\n\n  /**\n   * Get tool execution result\n   */\n  getToolResult(toolCallId: string): any {\n    return this.toolResults.get(toolCallId);\n  }\n\n  /**\n   * Update token usage (replaces values, doesn't accumulate)\n   */\n  updateUsage(usage: Partial<TokenUsage>): void {\n    if (usage.input_tokens !== undefined) {\n      this.usage.input_tokens = usage.input_tokens;\n    }\n    if (usage.output_tokens !== undefined) {\n      this.usage.output_tokens = usage.output_tokens;\n    }\n    if (usage.total_tokens !== undefined) {\n      this.usage.total_tokens = usage.total_tokens;\n    } else {\n      // Calculate total if not provided\n      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;\n    }\n  }\n\n  /**\n   * Accumulate token usage (adds to existing values)\n   */\n  accumulateUsage(usage: Partial<TokenUsage>): void {\n    if (usage.input_tokens !== undefined) {\n      this.usage.input_tokens += usage.input_tokens;\n    }\n    if (usage.output_tokens !== undefined) {\n      this.usage.output_tokens += usage.output_tokens;\n    }\n    if (usage.total_tokens !== undefined) {\n      this.usage.total_tokens += usage.total_tokens;\n    } else {\n      // Recalculate total\n      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;\n    }\n  }\n\n  /**\n   * Mark stream as complete\n   */\n  markComplete(status: 'completed' | 'incomplete' | 'failed' = 'completed'): void {\n    this.status = status;\n    this.endTime = new Date();\n  }\n\n  /**\n   * Get duration in milliseconds\n   */\n  getDuration(): number {\n    const end = this.endTime || new Date();\n    return end.getTime() - this.startTime.getTime();\n  }\n\n  /**\n   * Increment iteration counter\n   */\n  incrementIteration(): void {\n    this.currentIteration++;\n  }\n\n  /**\n   * Get summary statistics\n   */\n  getStatistics() {\n    return {\n      responseId: this.responseId,\n      model: this.model,\n      status: this.status,\n      iterations: this.currentIteration,\n      totalChunks: this.totalChunks,\n      totalTextDeltas: this.totalTextDeltas,\n      totalToolCalls: this.totalToolCalls,\n      textItemsCount: this.textBuffers.size,\n      toolCallBuffersCount: this.toolCallBuffers.size,\n      completedToolCallsCount: this.completedToolCalls.length,\n      durationMs: this.getDuration(),\n      usage: { ...this.usage },\n    };\n  }\n\n  /**\n   * Check if stream has any accumulated text\n   */\n  hasText(): boolean {\n    return this.textBuffers.size > 0;\n  }\n\n  /**\n   * Check if stream has any tool calls\n   */\n  hasToolCalls(): boolean {\n    return this.toolCallBuffers.size > 0;\n  }\n\n  /**\n   * Clear all buffers (for memory management)\n   */\n  clear(): void {\n    this.textBuffers.clear();\n    this.toolCallBuffers.clear();\n    this.completedToolCalls = [];\n    this.toolResults.clear();\n  }\n\n  /**\n   * Create a snapshot for checkpointing (error recovery)\n   */\n  createSnapshot() {\n    return {\n      responseId: this.responseId,\n      model: this.model,\n      createdAt: this.createdAt,\n      textBuffers: new Map(this.textBuffers),\n      toolCallBuffers: new Map(this.toolCallBuffers),\n      completedToolCalls: [...this.completedToolCalls],\n      toolResults: new Map(this.toolResults),\n      currentIteration: this.currentIteration,\n      usage: { ...this.usage },\n      status: this.status,\n      startTime: this.startTime,\n      endTime: this.endTime,\n    };\n  }\n}\n","/**\n * Agentic loop - handles tool calling and multi-turn conversations\n * Now with events, hooks, pause/resume, and enterprise features\n */\n\nimport { randomUUID } from 'crypto';\nimport { EventEmitter } from 'eventemitter3';\nimport { ITextProvider, TextGenerateOptions } from '../../domain/interfaces/ITextProvider.js';\nimport { IToolExecutor } from '../../domain/interfaces/IToolExecutor.js';\nimport { AgentResponse } from '../../domain/entities/Response.js';\nimport { InputItem, MessageRole, OutputItem } from '../../domain/entities/Message.js';\nimport { Tool, ToolCall, ToolCallState, ToolResult } from '../../domain/entities/Tool.js';\nimport { ContentType, ToolResultContent } from '../../domain/entities/Content.js';\nimport { ToolTimeoutError } from '../../domain/errors/AIErrors.js';\nimport { ExecutionContext, HistoryMode } from './ExecutionContext.js';\nimport { HookManager } from './HookManager.js';\nimport { HookConfig } from './types/HookTypes.js';\nimport { AgenticLoopEvents } from './types/EventTypes.js';\nimport { StreamEvent, StreamEventType, isToolCallArgumentsDone } from '../../domain/entities/StreamEvent.js';\nimport { StreamState } from '../../domain/entities/StreamState.js';\n\nexport interface AgenticLoopConfig {\n  model: string;\n  input: string | InputItem[];\n  instructions?: string;\n  tools: Tool[];\n  temperature?: number;\n  maxIterations: number;\n\n  // NEW: Enterprise configuration\n  hooks?: HookConfig;\n  historyMode?: HistoryMode;\n  limits?: {\n    maxExecutionTime?: number;\n    maxToolCalls?: number;\n    maxContextSize?: number;\n    /** Maximum input messages to keep (prevents unbounded growth). Default: 50 */\n    maxInputMessages?: number;\n  };\n  errorHandling?: {\n    hookFailureMode?: 'fail' | 'warn' | 'ignore';\n    /**\n     * Tool failure handling mode:\n     * - 'fail': Stop execution on first tool failure (throw error)\n     * - 'continue': Execute all tools even if some fail, return all results including errors\n     * @default 'continue'\n     */\n    toolFailureMode?: 'fail' | 'continue';\n    maxConsecutiveErrors?: number;\n  };\n\n  /**\n   * Tool execution timeout in milliseconds\n   * @default 30000 (30 seconds)\n   */\n  toolTimeout?: number;\n}\n\nexport class AgenticLoop extends EventEmitter<AgenticLoopEvents> {\n  private hookManager: HookManager;\n  private context: ExecutionContext | null = null;\n\n  // Pause/resume state\n  private paused: boolean = false;\n  private pausePromise: Promise<void> | null = null;\n  private resumeCallback: (() => void) | null = null;\n  private cancelled: boolean = false;\n  // Mutex to prevent race conditions in pause/resume\n  private pauseResumeMutex: Promise<void> = Promise.resolve();\n\n  constructor(\n    private provider: ITextProvider,\n    private toolExecutor: IToolExecutor,\n    hookConfig?: HookConfig,\n    errorHandling?: { maxConsecutiveErrors?: number }\n  ) {\n    super();\n    this.hookManager = new HookManager(\n      hookConfig || {},\n      this,\n      errorHandling\n    );\n  }\n\n  /**\n   * Execute agentic loop with tool calling\n   */\n  async execute(config: AgenticLoopConfig): Promise<AgentResponse> {\n    // Generate execution ID\n    const executionId = `exec_${randomUUID()}`;\n\n    // Create execution context\n    this.context = new ExecutionContext(executionId, {\n      maxHistorySize: 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: 1000,\n    });\n\n    // Reset state\n    this.paused = false;\n    this.cancelled = false;\n\n    // Emit execution start\n    this.emit('execution:start', {\n      executionId,\n      config,\n      timestamp: new Date(),\n    });\n\n    // Execute before:execution hook\n    await this.hookManager.executeHooks('before:execution', {\n      executionId,\n      config,\n      timestamp: new Date(),\n    }, undefined as any);\n\n    let currentInput = config.input;\n    let iteration = 0;\n    let finalResponse: AgentResponse;\n\n    try {\n      while (iteration < config.maxIterations) {\n        // Check pause\n        await this.checkPause();\n\n        // Check if cancelled\n        if (this.cancelled) {\n          throw new Error('Execution cancelled');\n        }\n\n        // Check resource limits\n        this.context.checkLimits(config.limits);\n\n        // Check pause hook\n        const pauseCheck = await this.hookManager.executeHooks('pause:check', {\n          executionId,\n          iteration,\n          context: this.context,\n          timestamp: new Date(),\n        }, { shouldPause: false });\n\n        if (pauseCheck.shouldPause) {\n          this.pause(pauseCheck.reason || 'Hook requested pause');\n          await this.checkPause();\n        }\n\n        // Update iteration\n        this.context.iteration = iteration;\n\n        // Emit iteration start\n        this.emit('iteration:start', {\n          executionId,\n          iteration,\n          timestamp: new Date(),\n        });\n\n        const iterationStartTime = Date.now();\n\n        // Generate LLM response\n        const response = await this.generateWithHooks(config, currentInput, iteration, executionId);\n\n        // Extract tool calls\n        const toolCalls = this.extractToolCalls(response.output, config.tools);\n\n        // Emit tool detection\n        if (toolCalls.length > 0) {\n          this.emit('tool:detected', {\n            executionId,\n            iteration,\n            toolCalls,\n            timestamp: new Date(),\n          });\n        }\n\n        // If no tool calls, we're done\n        if (toolCalls.length === 0) {\n          // Emit iteration complete\n          this.emit('iteration:complete', {\n            executionId,\n            iteration,\n            response,\n            timestamp: new Date(),\n            duration: Date.now() - iterationStartTime,\n          });\n\n          finalResponse = response;\n          break;\n        }\n\n        // Execute tools with hooks\n        const toolResults = await this.executeToolsWithHooks(toolCalls, iteration, executionId, config);\n\n        // Store iteration record\n        this.context.addIteration({\n          iteration,\n          request: {\n            model: config.model,\n            input: currentInput,\n            instructions: config.instructions,\n            tools: config.tools,\n            temperature: config.temperature,\n          },\n          response,\n          toolCalls,\n          toolResults,\n          startTime: new Date(iterationStartTime),\n          endTime: new Date(),\n        });\n\n        // Update metrics\n        this.context.updateMetrics({\n          iterationCount: iteration + 1,\n          inputTokens: this.context.metrics.inputTokens + (response.usage?.input_tokens || 0),\n          outputTokens: this.context.metrics.outputTokens + (response.usage?.output_tokens || 0),\n          totalTokens: this.context.metrics.totalTokens + (response.usage?.total_tokens || 0),\n        });\n\n        // Emit iteration complete\n        this.emit('iteration:complete', {\n          executionId,\n          iteration,\n          response,\n          timestamp: new Date(),\n          duration: Date.now() - iterationStartTime,\n        });\n\n        // Build next input - append to existing context (preserve history)\n        const newMessages = this.buildNewMessages(response.output, toolResults);\n        currentInput = this.appendToContext(currentInput, newMessages);\n\n        // Apply sliding window to prevent unbounded input growth\n        const maxInputMessages = config.limits?.maxInputMessages ?? 50;\n        currentInput = this.applySlidingWindow(currentInput, maxInputMessages);\n\n        iteration++;\n      }\n\n      // Check if we exited normally or hit max iterations\n      if (iteration >= config.maxIterations) {\n        throw new Error(`Max iterations (${config.maxIterations}) reached without completion`);\n      }\n\n      // Calculate total duration\n      const totalDuration = Date.now() - this.context.startTime.getTime();\n      this.context.updateMetrics({ totalDuration });\n\n      // Execute after:execution hook\n      await this.hookManager.executeHooks('after:execution', {\n        executionId,\n        response: finalResponse!,\n        context: this.context,\n        timestamp: new Date(),\n        duration: totalDuration,\n      }, undefined as any);\n\n      // Emit execution complete\n      this.emit('execution:complete', {\n        executionId,\n        response: finalResponse!,\n        timestamp: new Date(),\n        duration: totalDuration,\n      });\n\n      return finalResponse!;\n    } catch (error) {\n      // Emit execution error\n      this.emit('execution:error', {\n        executionId,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      // Record error in metrics\n      this.context?.metrics.errors.push({\n        type: 'execution_error',\n        message: (error as Error).message,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    } finally {\n      // Always cleanup resources\n      this.context?.cleanup();\n      this.hookManager.clear();\n    }\n  }\n\n  /**\n   * Execute agentic loop with streaming and tool calling\n   */\n  async *executeStreaming(config: AgenticLoopConfig): AsyncIterableIterator<StreamEvent> {\n    // Generate execution ID\n    const executionId = `exec_${randomUUID()}`;\n\n    // Create execution context\n    this.context = new ExecutionContext(executionId, {\n      maxHistorySize: 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: 1000,\n    });\n\n    // Reset state\n    this.paused = false;\n    this.cancelled = false;\n    this.pausePromise = null;\n    this.resumeCallback = null;\n\n    const startTime = Date.now();\n    let iteration = 0;\n    let currentInput: string | InputItem[] = config.input;\n\n    // Create a single StreamState for the entire execution (tracks usage across iterations)\n    const globalStreamState = new StreamState(executionId, config.model);\n\n    try {\n      // Emit execution start event\n      this.emit('execution:start', {\n        executionId,\n        model: config.model,\n        timestamp: new Date(),\n      });\n\n      // Execute before:execution hook\n      await this.hookManager.executeHooks('before:execution', {\n        executionId,\n        config,\n        timestamp: new Date(),\n      }, undefined as any);\n\n      // Main agentic loop\n      while (iteration < config.maxIterations) {\n        iteration++;\n\n        // Check pause state\n        await this.checkPause();\n\n        // Check if cancelled\n        if (this.cancelled) {\n          this.emit('execution:cancelled', { executionId, iteration, timestamp: new Date() });\n          break;\n        }\n\n        // Check resource limits\n        if (this.context) {\n          this.context.checkLimits(config.limits);\n        }\n\n        // Execute pause:check hook (allows dynamic pause decisions)\n        const pauseCheck = await this.hookManager.executeHooks('pause:check', {\n          executionId,\n          iteration,\n          context: this.context!,\n          timestamp: new Date(),\n        }, { shouldPause: false });\n\n        if (pauseCheck.shouldPause) {\n          this.pause();\n        }\n\n        // Emit iteration start\n        this.emit('iteration:start', {\n          executionId,\n          iteration,\n          timestamp: new Date(),\n        });\n\n        // Stream LLM response and accumulate state (per-iteration state)\n        const iterationStreamState = new StreamState(executionId, config.model);\n        const toolCallsMap = new Map<string, { name: string; args: string }>();\n\n        // Stream from provider with hooks\n        yield* this.streamGenerateWithHooks(config, currentInput, iteration, executionId, iterationStreamState, toolCallsMap);\n\n        // Accumulate usage from this iteration into global state\n        globalStreamState.accumulateUsage(iterationStreamState.usage);\n\n        // Check if any tool calls were detected\n        const toolCalls: ToolCall[] = [];\n        for (const [toolCallId, buffer] of toolCallsMap) {\n          toolCalls.push({\n            id: toolCallId,\n            type: 'function',\n            function: {\n              name: buffer.name,\n              arguments: buffer.args,\n            },\n            blocking: true,\n            state: ToolCallState.PENDING,\n          });\n        }\n\n        // No tool calls? We're done\n        if (toolCalls.length === 0) {\n          // Yield iteration complete\n          yield {\n            type: StreamEventType.ITERATION_COMPLETE,\n            response_id: executionId,\n            iteration,\n            tool_calls_count: 0,\n            has_more_iterations: false,\n          };\n\n          // Final response complete with accumulated usage from all iterations\n          yield {\n            type: StreamEventType.RESPONSE_COMPLETE,\n            response_id: executionId,\n            status: 'completed',\n            usage: globalStreamState.usage,\n            iterations: iteration,\n            duration_ms: Date.now() - startTime,\n          };\n\n          break;\n        }\n\n        // Execute tools and yield execution events\n        const toolResults: ToolResult[] = [];\n\n        for (const toolCall of toolCalls) {\n          // Parse and validate arguments\n          let parsedArgs: any;\n          try {\n            parsedArgs = JSON.parse(toolCall.function.arguments);\n          } catch (error) {\n            // Invalid JSON - skip this tool\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: null,\n              execution_time_ms: 0,\n              error: `Invalid tool arguments JSON: ${(error as Error).message}`,\n            };\n            continue;\n          }\n\n          // Emit tool execution start\n          yield {\n            type: StreamEventType.TOOL_EXECUTION_START,\n            response_id: executionId,\n            tool_call_id: toolCall.id,\n            tool_name: toolCall.function.name,\n            arguments: parsedArgs,\n          };\n\n          const toolStartTime = Date.now();\n\n          try {\n            // Execute tool with hooks\n            const result = await this.executeToolWithHooks(toolCall, iteration, executionId, config);\n            toolResults.push(result);\n\n            // Emit tool execution done\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: result.content,\n              execution_time_ms: Date.now() - toolStartTime,\n            };\n          } catch (error) {\n            // Emit tool execution error\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: null,\n              execution_time_ms: Date.now() - toolStartTime,\n              error: (error as Error).message,\n            };\n\n            // Check tool failure mode - unified with execute() behavior\n            const failureMode = config.errorHandling?.toolFailureMode || 'continue';\n            if (failureMode === 'fail') {\n              throw error; // Fail-fast mode: stop execution on first tool failure\n            }\n\n            // Continue mode (default): Add error result and continue with remaining tools\n            toolResults.push({\n              tool_use_id: toolCall.id,\n              content: '',\n              error: (error as Error).message,\n              state: ToolCallState.FAILED,\n            });\n          }\n        }\n\n        // Build next input with tool results (streaming constructs messages from StreamState)\n        const assistantMessage: InputItem = {\n          type: 'message',\n          role: MessageRole.ASSISTANT,\n          content: [\n            {\n              type: ContentType.OUTPUT_TEXT,\n              text: iterationStreamState.getAllText(),\n            },\n            ...toolCalls.map((tc) => ({\n              type: ContentType.TOOL_USE as const,\n              id: tc.id,\n              name: tc.function.name,\n              arguments: tc.function.arguments,\n            })),\n          ],\n        };\n\n        const toolResultsMessage: InputItem = {\n          type: 'message',\n          role: MessageRole.USER,\n          content: toolResults.map((tr) => ({\n            type: ContentType.TOOL_RESULT as const,\n            tool_use_id: tr.tool_use_id,\n            content: tr.content,\n            error: tr.error,\n          })),\n        };\n\n        // Update current input for next iteration using shared methods\n        const newMessages: InputItem[] = [assistantMessage, toolResultsMessage];\n        currentInput = this.appendToContext(currentInput, newMessages);\n\n        // Apply sliding window to prevent unbounded input growth\n        const maxInputMessages = config.limits?.maxInputMessages ?? 50;\n        currentInput = this.applySlidingWindow(currentInput, maxInputMessages);\n\n        // Yield iteration complete\n        yield {\n          type: StreamEventType.ITERATION_COMPLETE,\n          response_id: executionId,\n          iteration,\n          tool_calls_count: toolCalls.length,\n          has_more_iterations: true,\n        };\n\n        // Store iteration in context\n        if (this.context) {\n          globalStreamState.incrementIteration();\n        }\n\n        // Clear per-iteration resources to prevent memory accumulation\n        iterationStreamState.clear();\n        toolCallsMap.clear();\n      }\n\n      // If loop ended due to max iterations (not early break), emit final completion\n      if (iteration >= config.maxIterations) {\n        yield {\n          type: StreamEventType.RESPONSE_COMPLETE,\n          response_id: executionId,\n          status: 'incomplete', // Incomplete because we hit max iterations\n          usage: globalStreamState.usage,\n          iterations: iteration,\n          duration_ms: Date.now() - startTime,\n        };\n      }\n\n      // Execute after:execution hook\n      await this.hookManager.executeHooks('after:execution', {\n        executionId,\n        response: null as any, // We don't have a complete response in streaming\n        context: this.context,\n        timestamp: new Date(),\n        duration: Date.now() - startTime,\n      }, undefined as any);\n\n      // Emit execution complete\n      this.emit('execution:complete', {\n        executionId,\n        iterations: iteration,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      // Emit execution error\n      this.emit('execution:error', {\n        executionId,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      // Yield error event\n      yield {\n        type: StreamEventType.ERROR,\n        response_id: executionId,\n        error: {\n          type: 'execution_error',\n          message: (error as Error).message,\n        },\n        recoverable: false,\n      };\n\n      throw error;\n    } finally {\n      // Always cleanup resources\n      globalStreamState.clear();\n      this.context?.cleanup();\n      this.hookManager.clear();\n    }\n  }\n\n  /**\n   * Stream LLM response with hooks\n   * @private\n   */\n  private async *streamGenerateWithHooks(\n    config: AgenticLoopConfig,\n    input: string | InputItem[],\n    iteration: number,\n    executionId: string,\n    streamState: StreamState,\n    toolCallsMap: Map<string, { name: string; args: string }>\n  ): AsyncIterableIterator<StreamEvent> {\n    const llmStartTime = Date.now();\n\n    // Prepare options\n    let generateOptions: TextGenerateOptions = {\n      model: config.model,\n      input,\n      instructions: config.instructions,\n      tools: config.tools,\n      tool_choice: 'auto',\n      temperature: config.temperature,\n    };\n\n    // Execute before:llm hook\n    await this.hookManager.executeHooks('before:llm', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // Emit LLM request event\n    this.emit('llm:request', {\n      executionId,\n      iteration,\n      model: config.model,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Stream from provider\n      for await (const event of this.provider.streamGenerate(generateOptions)) {\n        // Update stream state based on event\n        if (event.type === StreamEventType.OUTPUT_TEXT_DELTA) {\n          streamState.accumulateTextDelta(event.item_id, event.delta);\n        } else if (event.type === StreamEventType.TOOL_CALL_START) {\n          streamState.startToolCall(event.tool_call_id, event.tool_name);\n          toolCallsMap.set(event.tool_call_id, { name: event.tool_name, args: '' });\n        } else if (event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DELTA) {\n          streamState.accumulateToolArguments(event.tool_call_id, event.delta);\n          const buffer = toolCallsMap.get(event.tool_call_id);\n          if (buffer) {\n            buffer.args += event.delta;\n          }\n        } else if (isToolCallArgumentsDone(event)) {\n          streamState.completeToolCall(event.tool_call_id);\n          const buffer = toolCallsMap.get(event.tool_call_id);\n          if (buffer) {\n            buffer.args = event.arguments;\n          }\n        } else if (event.type === StreamEventType.RESPONSE_COMPLETE) {\n          streamState.updateUsage(event.usage);\n\n          if (process.env.DEBUG_STREAMING) {\n            console.error('[DEBUG] Captured usage from provider:', event.usage);\n            console.error('[DEBUG] StreamState usage after update:', streamState.usage);\n          }\n\n          // Don't yield provider's RESPONSE_COMPLETE - we'll emit our own at the end\n          continue;\n        }\n\n        // Yield event to caller (except RESPONSE_COMPLETE which we handle ourselves)\n        yield event;\n      }\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.llmDuration += Date.now() - llmStartTime;\n        this.context.metrics.inputTokens += streamState.usage.input_tokens;\n        this.context.metrics.outputTokens += streamState.usage.output_tokens;\n        this.context.metrics.totalTokens += streamState.usage.total_tokens;\n      }\n\n      if (process.env.DEBUG_STREAMING) {\n        console.error('[DEBUG] Stream iteration complete, usage:', streamState.usage);\n      }\n\n      // Execute after:llm hook\n      await this.hookManager.executeHooks('after:llm', {\n        executionId,\n        iteration,\n        response: null as any, // Streaming doesn't have complete response yet\n        context: this.context!,\n        timestamp: new Date(),\n        duration: Date.now() - llmStartTime,\n      }, {});\n\n      // Emit LLM response event\n      this.emit('llm:response', {\n        executionId,\n        iteration,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      this.emit('llm:error', {\n        executionId,\n        iteration,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute single tool with hooks\n   * @private\n   */\n  private async executeToolWithHooks(\n    toolCall: ToolCall,\n    iteration: number,\n    executionId: string,\n    config: AgenticLoopConfig\n  ): Promise<ToolResult> {\n    const toolStartTime = Date.now();\n\n    toolCall.state = ToolCallState.EXECUTING;\n    toolCall.startTime = new Date();\n\n    // Execute before:tool hook\n    await this.hookManager.executeHooks('before:tool', {\n      executionId,\n      iteration,\n      toolCall,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // Execute approve:tool hook if registered\n    if (this.hookManager.hasHooks('approve:tool')) {\n      const approval = await this.hookManager.executeHooks('approve:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        context: this.context!,\n        timestamp: new Date(),\n      }, { approved: true });\n\n      if (!approval.approved) {\n        throw new Error(`Tool execution rejected: ${approval.reason || 'No reason provided'}`);\n      }\n    }\n\n    // Emit tool start\n    this.emit('tool:start', {\n      executionId,\n      iteration,\n      toolCall,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Execute tool with timeout (configurable)\n      const args = JSON.parse(toolCall.function.arguments);\n      const result = await this.executeWithTimeout(\n        () => this.toolExecutor.execute(toolCall.function.name, args),\n        config.toolTimeout ?? 30000\n      );\n\n      // Create tool result\n      const toolResult: ToolResult = {\n        tool_use_id: toolCall.id,\n        content: result,\n        executionTime: Date.now() - toolStartTime,\n        state: ToolCallState.COMPLETED,\n      };\n\n      toolCall.state = ToolCallState.COMPLETED;\n      toolCall.endTime = new Date();\n\n      // Execute after:tool hook\n      await this.hookManager.executeHooks('after:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        result: toolResult,\n        context: this.context!,\n        timestamp: new Date(),\n      }, {});\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.toolCallCount++;\n        this.context.metrics.toolSuccessCount++;\n        this.context.metrics.toolDuration += toolResult.executionTime || 0;\n      }\n\n      // Emit tool complete\n      this.emit('tool:complete', {\n        executionId,\n        iteration,\n        toolCall,\n        result: toolResult,\n        timestamp: new Date(),\n      });\n\n      return toolResult;\n    } catch (error) {\n      toolCall.state = ToolCallState.FAILED;\n      toolCall.endTime = new Date();\n      toolCall.error = (error as Error).message;\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.toolFailureCount++;\n      }\n\n      // Emit tool error\n      this.emit('tool:error', {\n        executionId,\n        iteration,\n        toolCall,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Generate LLM response with hooks\n   */\n  private async generateWithHooks(\n    config: AgenticLoopConfig,\n    input: string | InputItem[],\n    iteration: number,\n    executionId: string\n  ): Promise<AgentResponse> {\n    const llmStartTime = Date.now();\n\n    // Prepare options\n    let generateOptions: TextGenerateOptions = {\n      model: config.model,\n      input,\n      instructions: config.instructions,\n      tools: config.tools,\n      tool_choice: 'auto',\n      temperature: config.temperature,\n    };\n\n    // Execute before:llm hook\n    const beforeLLM = await this.hookManager.executeHooks('before:llm', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // Apply modifications\n    if (beforeLLM.modified) {\n      generateOptions = { ...generateOptions, ...beforeLLM.modified };\n    }\n\n    // Skip if requested\n    if (beforeLLM.skip) {\n      throw new Error('LLM call skipped by hook');\n    }\n\n    // Emit LLM request\n    this.emit('llm:request', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Call provider\n      const response = await this.provider.generate(generateOptions);\n\n      const llmDuration = Date.now() - llmStartTime;\n\n      // Update metrics\n      this.context?.updateMetrics({\n        llmDuration: (this.context.metrics.llmDuration || 0) + llmDuration,\n      });\n\n      // Emit LLM response\n      this.emit('llm:response', {\n        executionId,\n        iteration,\n        response,\n        timestamp: new Date(),\n        duration: llmDuration,\n      });\n\n      // Execute after:llm hook\n      await this.hookManager.executeHooks('after:llm', {\n        executionId,\n        iteration,\n        response,\n        context: this.context!,\n        timestamp: new Date(),\n        duration: llmDuration,\n      }, {});\n\n      return response;\n    } catch (error) {\n      // Emit LLM error\n      this.emit('llm:error', {\n        executionId,\n        iteration,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute tools with hooks\n   */\n  private async executeToolsWithHooks(\n    toolCalls: ToolCall[],\n    iteration: number,\n    executionId: string,\n    config: AgenticLoopConfig\n  ): Promise<ToolResult[]> {\n    const results: ToolResult[] = [];\n\n    for (const toolCall of toolCalls) {\n      // Add to context\n      this.context?.addToolCall(toolCall);\n\n      // Check pause before each tool\n      await this.checkPause();\n\n      // Execute before:tool hook\n      const beforeTool = await this.hookManager.executeHooks('before:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        context: this.context!,\n        timestamp: new Date(),\n      }, {});\n\n      // Check if tool should be skipped\n      if (beforeTool.skip) {\n        this.context?.audit('tool_skipped', { toolCall }, undefined, toolCall.function.name);\n\n        const mockResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: beforeTool.mockResult || '',\n          state: ToolCallState.COMPLETED,\n          executionTime: 0,\n        };\n\n        results.push(mockResult);\n        this.context?.addToolResult(mockResult);\n        continue;\n      }\n\n      // Apply modifications if any\n      if (beforeTool.modified) {\n        Object.assign(toolCall, beforeTool.modified);\n        this.context?.audit('tool_modified', { modifications: beforeTool.modified }, undefined, toolCall.function.name);\n      }\n\n      // Execute approve:tool hook (if exists)\n      if (this.hookManager.hasHooks('approve:tool')) {\n        const approval = await this.hookManager.executeHooks('approve:tool', {\n          executionId,\n          iteration,\n          toolCall,\n          context: this.context!,\n          timestamp: new Date(),\n        }, { approved: true });\n\n        if (!approval.approved) {\n          this.context?.audit('tool_rejected', { reason: approval.reason }, undefined, toolCall.function.name);\n\n          const rejectedResult: ToolResult = {\n            tool_use_id: toolCall.id,\n            content: '',\n            error: `Tool rejected: ${approval.reason || 'Not approved'}`,\n            state: ToolCallState.FAILED,\n          };\n\n          results.push(rejectedResult);\n          this.context?.addToolResult(rejectedResult);\n          continue;\n        }\n\n        this.context?.audit('tool_approved', { reason: approval.reason }, undefined, toolCall.function.name);\n      }\n\n      // Execute tool\n      toolCall.state = ToolCallState.EXECUTING;\n      toolCall.startTime = new Date();\n\n      // Emit tool start\n      this.emit('tool:start', {\n        executionId,\n        iteration,\n        toolCall,\n        timestamp: new Date(),\n      });\n\n      const toolStartTime = Date.now();\n\n      try {\n        // Execute with timeout (configurable)\n        const timeout = config.toolTimeout ?? 30000;\n        const result = await this.executeWithTimeout(\n          () => this.toolExecutor.execute(\n            toolCall.function.name,\n            JSON.parse(toolCall.function.arguments)\n          ),\n          timeout\n        );\n\n        toolCall.state = ToolCallState.COMPLETED;\n        toolCall.endTime = new Date();\n\n        let toolResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: result,\n          state: ToolCallState.COMPLETED,\n          executionTime: Date.now() - toolStartTime,\n        };\n\n        // Execute after:tool hook\n        const afterTool = await this.hookManager.executeHooks('after:tool', {\n          executionId,\n          iteration,\n          toolCall,\n          result: toolResult,\n          context: this.context!,\n          timestamp: new Date(),\n        }, {});\n\n        // Apply result modifications\n        if (afterTool.modified) {\n          toolResult = { ...toolResult, ...afterTool.modified };\n        }\n\n        results.push(toolResult);\n        this.context?.addToolResult(toolResult);\n\n        // Update metrics\n        this.context?.updateMetrics({\n          toolDuration: (this.context.metrics.toolDuration || 0) + toolResult.executionTime!,\n        });\n\n        // Emit tool complete\n        this.emit('tool:complete', {\n          executionId,\n          iteration,\n          toolCall,\n          result: toolResult,\n          timestamp: new Date(),\n        });\n      } catch (error) {\n        toolCall.state = ToolCallState.FAILED;\n        toolCall.endTime = new Date();\n        toolCall.error = (error as Error).message;\n\n        const toolResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: '',\n          error: (error as Error).message,\n          state: ToolCallState.FAILED,\n        };\n\n        results.push(toolResult);\n        this.context?.addToolResult(toolResult);\n\n        // Record error\n        this.context?.metrics.errors.push({\n          type: 'tool_error',\n          message: (error as Error).message,\n          timestamp: new Date(),\n        });\n\n        // Emit tool error or timeout\n        if (error instanceof ToolTimeoutError) {\n          this.emit('tool:timeout', {\n            executionId,\n            iteration,\n            toolCall,\n            timeout: config.toolTimeout ?? 30000,\n            timestamp: new Date(),\n          });\n        } else {\n          this.emit('tool:error', {\n            executionId,\n            iteration,\n            toolCall,\n            error: error as Error,\n            timestamp: new Date(),\n          });\n        }\n\n        // Check tool failure mode\n        const failureMode = config.errorHandling?.toolFailureMode || 'continue';\n        if (failureMode === 'fail') {\n          // Fail-fast mode: stop execution on first tool failure\n          throw error;\n        }\n\n        // Continue mode (default): Continue executing remaining tools\n        // Error already added to results above\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Extract tool calls from response output\n   */\n  private extractToolCalls(output: OutputItem[], toolDefinitions: Tool[]): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n\n    // Create tool map for quick lookup\n    const toolMap = new Map<string, Tool>();\n    for (const tool of toolDefinitions) {\n      if (tool.type === 'function') {\n        toolMap.set(tool.function.name, tool);\n      }\n    }\n\n    // Extract tool calls from output\n    for (const item of output) {\n      if (item.type === 'message' && item.role === MessageRole.ASSISTANT) {\n        for (const content of item.content) {\n          if (content.type === ContentType.TOOL_USE) {\n            const toolDef = toolMap.get(content.name);\n            const isBlocking = toolDef?.blocking !== false;\n\n            const toolCall: ToolCall = {\n              id: content.id,\n              type: 'function',\n              function: {\n                name: content.name,\n                arguments: content.arguments,\n              },\n              blocking: isBlocking,\n              state: ToolCallState.PENDING,\n            };\n\n            toolCalls.push(toolCall);\n          }\n        }\n      }\n    }\n\n    return toolCalls;\n  }\n\n  /**\n   * Execute function with timeout\n   */\n  private async executeWithTimeout<T>(fn: () => Promise<T>, timeoutMs: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new ToolTimeoutError('tool', timeoutMs));\n      }, timeoutMs);\n\n      fn()\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((error) => {\n          clearTimeout(timer);\n          reject(error);\n        });\n    });\n  }\n\n  // ============ Shared Helper Methods ============\n  // These methods provide unified logic for both execute() and executeStreaming()\n\n  /**\n   * Build new messages from tool results (assistant response + tool results)\n   */\n  private buildNewMessages(\n    previousOutput: OutputItem[],\n    toolResults: ToolResult[]\n  ): InputItem[] {\n    const messages: InputItem[] = [];\n\n    // Add assistant's previous response as input\n    for (const item of previousOutput) {\n      if (item.type === 'message') {\n        messages.push(item);\n      }\n    }\n\n    // Add tool results as user message\n    const toolResultContents: ToolResultContent[] = toolResults.map((result) => ({\n      type: ContentType.TOOL_RESULT,\n      tool_use_id: result.tool_use_id,\n      content: result.content,\n      error: result.error,\n    }));\n\n    if (toolResultContents.length > 0) {\n      messages.push({\n        type: 'message',\n        role: MessageRole.USER,\n        content: toolResultContents,\n      });\n    }\n\n    return messages;\n  }\n\n  /**\n   * Append new messages to current context, preserving history\n   * Unified logic for both execute() and executeStreaming()\n   */\n  private appendToContext(\n    currentInput: string | InputItem[],\n    newMessages: InputItem[]\n  ): InputItem[] {\n    if (Array.isArray(currentInput)) {\n      return [...currentInput, ...newMessages];\n    }\n\n    // First iteration - convert string input to array format\n    return [\n      {\n        type: 'message' as const,\n        role: MessageRole.USER,\n        content: [{ type: ContentType.INPUT_TEXT, text: currentInput }],\n      },\n      ...newMessages,\n    ];\n  }\n\n  /**\n   * Apply sliding window to prevent unbounded input growth\n   * Preserves system/developer message at the start if present\n   * IMPORTANT: Ensures tool_use and tool_result pairs are never broken\n   */\n  private applySlidingWindow(\n    input: InputItem[],\n    maxMessages: number = 50\n  ): InputItem[] {\n    if (input.length <= maxMessages) {\n      return input;\n    }\n\n    // Check if first message is a developer/system message\n    const firstMessage = input[0];\n    const isSystemMessage = firstMessage?.type === 'message' &&\n      firstMessage.role === MessageRole.DEVELOPER;\n\n    // Calculate how many messages we can keep (excluding system message if present)\n    const maxToKeep = isSystemMessage ? maxMessages - 1 : maxMessages;\n\n    // Find a safe cut point that doesn't break tool call/result pairs\n    const safeCutIndex = this.findSafeToolBoundary(input, input.length - maxToKeep);\n\n    // Slice from safe cut point to end\n    const recentMessages = input.slice(safeCutIndex);\n\n    if (isSystemMessage) {\n      return [firstMessage, ...recentMessages];\n    }\n\n    return recentMessages;\n  }\n\n  /**\n   * Find a safe index to cut the message array without breaking tool call/result pairs\n   * A safe boundary is one where all tool_use IDs have matching tool_result IDs\n   */\n  private findSafeToolBoundary(input: InputItem[], targetIndex: number): number {\n    // Ensure we don't go below 0 or above the array length\n    let cutIndex = Math.max(0, Math.min(targetIndex, input.length - 1));\n\n    // Start from targetIndex and search forward for a safe boundary\n    // A safe boundary is where we don't have orphaned tool calls or results\n    while (cutIndex < input.length - 1) {\n      if (this.isToolBoundarySafe(input, cutIndex)) {\n        return cutIndex;\n      }\n      cutIndex++;\n    }\n\n    // If no safe boundary found going forward, try going backward\n    cutIndex = Math.max(0, targetIndex);\n    while (cutIndex > 0) {\n      if (this.isToolBoundarySafe(input, cutIndex)) {\n        return cutIndex;\n      }\n      cutIndex--;\n    }\n\n    // Fallback: return original target (may cause issues but better than infinite loop)\n    return Math.max(0, targetIndex);\n  }\n\n  /**\n   * Check if cutting at this index would leave tool calls/results balanced\n   * Returns true if all tool_use IDs in the slice have matching tool_result IDs\n   */\n  private isToolBoundarySafe(input: InputItem[], startIndex: number): boolean {\n    const slicedMessages = input.slice(startIndex);\n\n    // Collect all tool_use IDs and tool_result IDs in the slice\n    const toolUseIds = new Set<string>();\n    const toolResultIds = new Set<string>();\n\n    for (const item of slicedMessages) {\n      if (item.type !== 'message') continue;\n\n      for (const content of item.content) {\n        if (content.type === ContentType.TOOL_USE) {\n          toolUseIds.add(content.id);\n        } else if (content.type === ContentType.TOOL_RESULT) {\n          toolResultIds.add(content.tool_use_id);\n        }\n      }\n    }\n\n    // Check 1: Every tool_result must have a matching tool_use\n    // (tool_result without tool_use = API error)\n    for (const resultId of toolResultIds) {\n      if (!toolUseIds.has(resultId)) {\n        return false;\n      }\n    }\n\n    // Check 2: Every tool_use should have a matching tool_result\n    // (tool_use without tool_result = incomplete, but less critical for some APIs)\n    // However, for safety, we enforce this too\n    for (const useId of toolUseIds) {\n      if (!toolResultIds.has(useId)) {\n        // Exception: the LAST assistant message may have tool_use without result yet\n        // This is only safe if it's the very last message (current iteration)\n        const lastMessage = slicedMessages[slicedMessages.length - 1];\n        const isLastMessageWithThisToolUse =\n          lastMessage?.type === 'message' &&\n          lastMessage.role === MessageRole.ASSISTANT &&\n          lastMessage.content.some(\n            (c: any) => c.type === ContentType.TOOL_USE && c.id === useId\n          );\n\n        if (!isLastMessageWithThisToolUse) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Pause execution (thread-safe with mutex)\n   */\n  pause(reason?: string): void {\n    // Chain onto the mutex to ensure serialized access\n    this.pauseResumeMutex = this.pauseResumeMutex.then(() => {\n      this._doPause(reason);\n    });\n  }\n\n  /**\n   * Internal pause implementation\n   */\n  private _doPause(reason?: string): void {\n    if (this.paused) return;\n\n    this.paused = true;\n    this.pausePromise = new Promise((resolve) => {\n      this.resumeCallback = resolve;\n    });\n\n    if (this.context) {\n      this.context.paused = true;\n      this.context.pauseReason = reason;\n      this.context.audit('execution_paused', { reason });\n    }\n\n    this.emit('execution:paused', {\n      executionId: this.context?.executionId || 'unknown',\n      reason: reason || 'Manual pause',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Resume execution (thread-safe with mutex)\n   */\n  resume(): void {\n    // Chain onto the mutex to ensure serialized access\n    this.pauseResumeMutex = this.pauseResumeMutex.then(() => {\n      this._doResume();\n    });\n  }\n\n  /**\n   * Internal resume implementation\n   */\n  private _doResume(): void {\n    if (!this.paused) return;\n\n    this.paused = false;\n\n    if (this.context) {\n      this.context.paused = false;\n      this.context.pauseReason = undefined;\n      this.context.audit('execution_resumed', {});\n    }\n\n    if (this.resumeCallback) {\n      this.resumeCallback();\n      this.resumeCallback = null;\n    }\n\n    this.pausePromise = null;\n\n    this.emit('execution:resumed', {\n      executionId: this.context?.executionId || 'unknown',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Cancel execution\n   */\n  cancel(reason?: string): void {\n    this.cancelled = true;\n\n    if (this.context) {\n      this.context.cancelled = true;\n      this.context.cancelReason = reason;\n    }\n\n    // Resume if paused (to allow cancellation to proceed)\n    // Use internal method directly to bypass mutex for immediate cancellation\n    if (this.paused) {\n      this._doResume();\n    }\n\n    this.emit('execution:cancelled', {\n      executionId: this.context?.executionId || 'unknown',\n      reason: reason || 'Manual cancellation',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Check if paused and wait\n   */\n  private async checkPause(): Promise<void> {\n    if (this.paused && this.pausePromise) {\n      await this.pausePromise;\n    }\n  }\n\n  /**\n   * Get current execution context\n   */\n  getContext(): ExecutionContext | null {\n    return this.context;\n  }\n\n  /**\n   * Check if currently executing\n   */\n  isRunning(): boolean {\n    return this.context !== null && !this.cancelled;\n  }\n\n  /**\n   * Check if paused\n   */\n  isPaused(): boolean {\n    return this.paused;\n  }\n\n  /**\n   * Check if cancelled\n   */\n  isCancelled(): boolean {\n    return this.cancelled;\n  }\n}\n"]}