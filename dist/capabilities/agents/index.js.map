{"version":3,"sources":["../../../src/domain/errors/AIErrors.ts","../../../src/capabilities/agents/ExecutionContext.ts","../../../src/capabilities/agents/HookManager.ts","../../../src/domain/entities/StreamEvent.ts","../../../src/domain/entities/StreamState.ts","../../../src/capabilities/agents/AgenticLoop.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Custom error classes for the AI library\n */\n\nexport class AIError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly statusCode?: number,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'AIError';\n    Object.setPrototypeOf(this, AIError.prototype);\n  }\n}\n\nexport class ProviderNotFoundError extends AIError {\n  constructor(providerName: string) {\n    super(\n      `Provider '${providerName}' not found. Did you configure it in OneRingAI constructor?`,\n      'PROVIDER_NOT_FOUND',\n      404\n    );\n    this.name = 'ProviderNotFoundError';\n    Object.setPrototypeOf(this, ProviderNotFoundError.prototype);\n  }\n}\n\nexport class ProviderAuthError extends AIError {\n  constructor(providerName: string, message: string = 'Authentication failed') {\n    super(\n      `${providerName}: ${message}`,\n      'PROVIDER_AUTH_ERROR',\n      401\n    );\n    this.name = 'ProviderAuthError';\n    Object.setPrototypeOf(this, ProviderAuthError.prototype);\n  }\n}\n\nexport class ProviderRateLimitError extends AIError {\n  constructor(\n    providerName: string,\n    public readonly retryAfter?: number\n  ) {\n    super(\n      `${providerName}: Rate limit exceeded${retryAfter ? `. Retry after ${retryAfter}ms` : ''}`,\n      'PROVIDER_RATE_LIMIT',\n      429\n    );\n    this.name = 'ProviderRateLimitError';\n    Object.setPrototypeOf(this, ProviderRateLimitError.prototype);\n  }\n}\n\nexport class ProviderContextLengthError extends AIError {\n  constructor(\n    providerName: string,\n    public readonly maxTokens: number,\n    public readonly requestedTokens?: number\n  ) {\n    super(\n      `${providerName}: Context length exceeded. Max: ${maxTokens}${requestedTokens ? `, Requested: ${requestedTokens}` : ''}`,\n      'PROVIDER_CONTEXT_LENGTH_EXCEEDED',\n      413\n    );\n    this.name = 'ProviderContextLengthError';\n    Object.setPrototypeOf(this, ProviderContextLengthError.prototype);\n  }\n}\n\nexport class ToolExecutionError extends AIError {\n  constructor(\n    toolName: string,\n    message: string,\n    public readonly originalError?: Error\n  ) {\n    super(\n      `Tool '${toolName}' execution failed: ${message}`,\n      'TOOL_EXECUTION_ERROR',\n      500,\n      originalError\n    );\n    this.name = 'ToolExecutionError';\n    Object.setPrototypeOf(this, ToolExecutionError.prototype);\n  }\n}\n\nexport class ToolTimeoutError extends AIError {\n  constructor(\n    toolName: string,\n    public readonly timeoutMs: number\n  ) {\n    super(\n      `Tool '${toolName}' execution timed out after ${timeoutMs}ms`,\n      'TOOL_TIMEOUT',\n      408\n    );\n    this.name = 'ToolTimeoutError';\n    Object.setPrototypeOf(this, ToolTimeoutError.prototype);\n  }\n}\n\nexport class ToolNotFoundError extends AIError {\n  constructor(toolName: string) {\n    super(\n      `Tool '${toolName}' not found. Did you register it with the agent?`,\n      'TOOL_NOT_FOUND',\n      404\n    );\n    this.name = 'ToolNotFoundError';\n    Object.setPrototypeOf(this, ToolNotFoundError.prototype);\n  }\n}\n\nexport class ModelNotSupportedError extends AIError {\n  constructor(providerName: string, model: string, capability: string) {\n    super(\n      `Model '${model}' from ${providerName} does not support ${capability}`,\n      'MODEL_NOT_SUPPORTED',\n      400\n    );\n    this.name = 'ModelNotSupportedError';\n    Object.setPrototypeOf(this, ModelNotSupportedError.prototype);\n  }\n}\n\nexport class InvalidConfigError extends AIError {\n  constructor(message: string) {\n    super(message, 'INVALID_CONFIG', 400);\n    this.name = 'InvalidConfigError';\n    Object.setPrototypeOf(this, InvalidConfigError.prototype);\n  }\n}\n\nexport class InvalidToolArgumentsError extends AIError {\n  constructor(\n    toolName: string,\n    public readonly rawArguments: string,\n    public readonly parseError?: Error\n  ) {\n    super(\n      `Invalid arguments for tool '${toolName}': ${parseError?.message || 'Failed to parse JSON'}`,\n      'INVALID_TOOL_ARGUMENTS',\n      400,\n      parseError\n    );\n    this.name = 'InvalidToolArgumentsError';\n    Object.setPrototypeOf(this, InvalidToolArgumentsError.prototype);\n  }\n}\n\nexport class ProviderError extends AIError {\n  constructor(\n    public readonly providerName: string,\n    message: string,\n    statusCode?: number,\n    originalError?: Error\n  ) {\n    super(\n      `${providerName}: ${message}`,\n      'PROVIDER_ERROR',\n      statusCode,\n      originalError\n    );\n    this.name = 'ProviderError';\n    Object.setPrototypeOf(this, ProviderError.prototype);\n  }\n}\n\n// ============ TaskAgent Errors ============\n\n/**\n * Error thrown when a dependency cycle is detected in a plan\n */\nexport class DependencyCycleError extends AIError {\n  constructor(\n    /** Task IDs forming the cycle (e.g., ['A', 'B', 'C', 'A']) */\n    public readonly cycle: string[],\n    /** Plan ID where the cycle was detected */\n    public readonly planId?: string\n  ) {\n    super(\n      `Dependency cycle detected: ${cycle.join(' -> ')}`,\n      'DEPENDENCY_CYCLE',\n      400\n    );\n    this.name = 'DependencyCycleError';\n    Object.setPrototypeOf(this, DependencyCycleError.prototype);\n  }\n}\n\n/**\n * Error thrown when a task execution times out\n */\nexport class TaskTimeoutError extends AIError {\n  constructor(\n    public readonly taskId: string,\n    public readonly taskName: string,\n    public readonly timeoutMs: number\n  ) {\n    super(\n      `Task '${taskName}' (${taskId}) timed out after ${timeoutMs}ms`,\n      'TASK_TIMEOUT',\n      408\n    );\n    this.name = 'TaskTimeoutError';\n    Object.setPrototypeOf(this, TaskTimeoutError.prototype);\n  }\n}\n\n/**\n * Error thrown when task completion validation fails\n */\nexport class TaskValidationError extends AIError {\n  constructor(\n    public readonly taskId: string,\n    public readonly taskName: string,\n    public readonly reason: string\n  ) {\n    super(\n      `Task '${taskName}' (${taskId}) validation failed: ${reason}`,\n      'TASK_VALIDATION_ERROR',\n      422\n    );\n    this.name = 'TaskValidationError';\n    Object.setPrototypeOf(this, TaskValidationError.prototype);\n  }\n}\n\n/**\n * Task failure info for parallel execution\n */\nexport interface TaskFailure {\n  taskId: string;\n  taskName: string;\n  error: Error;\n}\n\n/**\n * Error thrown when multiple tasks fail in parallel execution (fail-all mode)\n */\nexport class ParallelTasksError extends AIError {\n  constructor(\n    /** Array of task failures */\n    public readonly failures: TaskFailure[]\n  ) {\n    const names = failures.map((f) => f.taskName).join(', ');\n    super(\n      `Multiple tasks failed in parallel execution: ${names}`,\n      'PARALLEL_TASKS_ERROR',\n      500\n    );\n    this.name = 'ParallelTasksError';\n    Object.setPrototypeOf(this, ParallelTasksError.prototype);\n  }\n\n  /**\n   * Get all failure errors\n   */\n  getErrors(): Error[] {\n    return this.failures.map((f) => f.error);\n  }\n\n  /**\n   * Get failed task IDs\n   */\n  getFailedTaskIds(): string[] {\n    return this.failures.map((f) => f.taskId);\n  }\n}\n","/**\n * Execution context - tracks state, metrics, and history for agent execution\n * Includes memory safety (circular buffers) and resource limits\n */\n\nimport { AgentResponse } from '../../domain/entities/Response.js';\nimport { TextGenerateOptions } from '../../domain/interfaces/ITextProvider.js';\nimport { ToolCall, ToolResult, ToolCallState } from '../../domain/entities/Tool.js';\n\nexport type HistoryMode = 'none' | 'summary' | 'full';\n\nexport interface ExecutionContextConfig {\n  maxHistorySize?: number; // Max iterations to store (default: 10)\n  historyMode?: HistoryMode; // What to store (default: 'summary')\n  maxAuditTrailSize?: number; // Max audit entries (default: 1000)\n}\n\nexport interface IterationRecord {\n  iteration: number;\n  request: TextGenerateOptions;\n  response: AgentResponse;\n  toolCalls: ToolCall[];\n  toolResults: ToolResult[];\n  startTime: Date;\n  endTime: Date;\n}\n\nexport interface IterationSummary {\n  iteration: number;\n  tokens: number;\n  toolCount: number;\n  duration: number;\n  timestamp: Date;\n}\n\nexport interface ExecutionMetrics {\n  // Timing\n  totalDuration: number;\n  llmDuration: number;\n  toolDuration: number;\n  hookDuration: number;\n\n  // Counts\n  iterationCount: number;\n  toolCallCount: number;\n  toolSuccessCount: number;\n  toolFailureCount: number;\n  toolTimeoutCount: number;\n\n  // Tokens\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n\n  // Errors\n  errors: Array<{ type: string; message: string; timestamp: Date }>;\n}\n\nexport interface AuditEntry {\n  timestamp: Date;\n  type:\n    | 'hook_executed'\n    | 'tool_modified'\n    | 'tool_skipped'\n    | 'execution_paused'\n    | 'execution_resumed'\n    | 'tool_approved'\n    | 'tool_rejected'\n    | 'tool_blocked'\n    | 'tool_permission_approved';\n  hookName?: string;\n  toolName?: string;\n  details: any;\n}\n\nexport class ExecutionContext {\n  // Execution metadata\n  readonly executionId: string;\n  readonly startTime: Date;\n  iteration: number = 0;\n\n  // Tool tracking\n  readonly toolCalls: Map<string, ToolCall> = new Map();\n  readonly toolResults: Map<string, ToolResult> = new Map();\n\n  // Control state\n  paused: boolean = false;\n  pauseReason?: string;\n  cancelled: boolean = false;\n  cancelReason?: string;\n\n  // User data (for hooks to share state)\n  readonly metadata: Map<string, any> = new Map();\n\n  // History storage (memory-safe)\n  private readonly config: ExecutionContextConfig;\n  private readonly iterations: IterationRecord[] = [];\n  private readonly iterationSummaries: IterationSummary[] = [];\n\n  // Metrics\n  readonly metrics: ExecutionMetrics = {\n    totalDuration: 0,\n    llmDuration: 0,\n    toolDuration: 0,\n    hookDuration: 0,\n    iterationCount: 0,\n    toolCallCount: 0,\n    toolSuccessCount: 0,\n    toolFailureCount: 0,\n    toolTimeoutCount: 0,\n    inputTokens: 0,\n    outputTokens: 0,\n    totalTokens: 0,\n    errors: [],\n  };\n\n  // Audit trail\n  private readonly auditTrail: AuditEntry[] = [];\n\n  constructor(\n    executionId: string,\n    config: ExecutionContextConfig = {}\n  ) {\n    this.executionId = executionId;\n    this.startTime = new Date();\n    this.config = {\n      maxHistorySize: config.maxHistorySize || 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: config.maxAuditTrailSize || 1000,\n    };\n  }\n\n  /**\n   * Add iteration to history (memory-safe)\n   */\n  addIteration(record: IterationRecord): void {\n    switch (this.config.historyMode) {\n      case 'none':\n        // Don't store anything\n        break;\n\n      case 'summary':\n        // Store lightweight summary only\n        this.iterationSummaries.push({\n          iteration: record.iteration,\n          tokens: record.response.usage.total_tokens,\n          toolCount: record.toolCalls.length,\n          duration: record.endTime.getTime() - record.startTime.getTime(),\n          timestamp: record.startTime,\n        });\n\n        // Keep circular buffer\n        if (this.iterationSummaries.length > this.config.maxHistorySize!) {\n          this.iterationSummaries.shift();\n        }\n        break;\n\n      case 'full':\n        // Store full iteration data\n        this.iterations.push(record);\n\n        // Keep circular buffer\n        if (this.iterations.length > this.config.maxHistorySize!) {\n          this.iterations.shift();\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get iteration history\n   */\n  getHistory(): IterationRecord[] | IterationSummary[] {\n    return this.config.historyMode === 'full' ? this.iterations : this.iterationSummaries;\n  }\n\n  /**\n   * Add audit entry\n   */\n  audit(type: AuditEntry['type'], details: any, hookName?: string, toolName?: string): void {\n    this.auditTrail.push({\n      timestamp: new Date(),\n      type,\n      hookName,\n      toolName,\n      details,\n    });\n\n    // Keep circular buffer\n    if (this.auditTrail.length > this.config.maxAuditTrailSize!) {\n      this.auditTrail.shift();\n    }\n  }\n\n  /**\n   * Get audit trail\n   */\n  getAuditTrail(): readonly AuditEntry[] {\n    return this.auditTrail;\n  }\n\n  /**\n   * Update metrics\n   */\n  updateMetrics(update: Partial<ExecutionMetrics>): void {\n    Object.assign(this.metrics, update);\n  }\n\n  /**\n   * Add tool call to tracking\n   */\n  addToolCall(toolCall: ToolCall): void {\n    this.toolCalls.set(toolCall.id, toolCall);\n    this.metrics.toolCallCount++;\n  }\n\n  /**\n   * Add tool result to tracking\n   */\n  addToolResult(result: ToolResult): void {\n    this.toolResults.set(result.tool_use_id, result);\n\n    // Update metrics\n    if (result.state === ToolCallState.COMPLETED) {\n      this.metrics.toolSuccessCount++;\n    } else if (result.state === ToolCallState.FAILED) {\n      this.metrics.toolFailureCount++;\n    } else if (result.state === ToolCallState.TIMEOUT) {\n      this.metrics.toolTimeoutCount++;\n    }\n  }\n\n  /**\n   * Check resource limits\n   */\n  checkLimits(limits?: {\n    maxExecutionTime?: number;\n    maxToolCalls?: number;\n    maxContextSize?: number;\n  }): void {\n    if (!limits) return;\n\n    // Check execution time\n    if (limits.maxExecutionTime) {\n      const elapsed = Date.now() - this.startTime.getTime();\n      if (elapsed > limits.maxExecutionTime) {\n        throw new Error(\n          `Execution time limit exceeded: ${elapsed}ms > ${limits.maxExecutionTime}ms`\n        );\n      }\n    }\n\n    // Check tool call count\n    if (limits.maxToolCalls && this.toolCalls.size > limits.maxToolCalls) {\n      throw new Error(\n        `Tool call limit exceeded: ${this.toolCalls.size} > ${limits.maxToolCalls}`\n      );\n    }\n\n    // Check context size\n    if (limits.maxContextSize) {\n      const size = this.estimateSize();\n      if (size > limits.maxContextSize) {\n        throw new Error(\n          `Context size limit exceeded: ${size} bytes > ${limits.maxContextSize} bytes`\n        );\n      }\n    }\n  }\n\n  /**\n   * Estimate memory usage (rough approximation)\n   */\n  private estimateSize(): number {\n    try {\n      const data = {\n        toolCalls: Array.from(this.toolCalls.values()),\n        toolResults: Array.from(this.toolResults.values()),\n        iterations: this.config.historyMode === 'full' ? this.iterations : this.iterationSummaries,\n        auditTrail: this.auditTrail,\n      };\n      return JSON.stringify(data).length;\n    } catch {\n      return 0; // Error estimating, return 0\n    }\n  }\n\n  /**\n   * Cleanup resources and release memory\n   * Clears all internal arrays and maps to allow garbage collection\n   */\n  cleanup(): void {\n    // Store execution summary before clearing\n    const summary = {\n      executionId: this.executionId,\n      totalIterations: this.iteration,\n      totalToolCalls: this.metrics.toolCallCount,\n      totalDuration: Date.now() - this.startTime.getTime(),\n      success: !this.cancelled && this.metrics.errors.length === 0,\n    };\n\n    // Clear all maps\n    this.toolCalls.clear();\n    this.toolResults.clear();\n    this.metadata.clear();\n\n    // Clear all arrays (modify length to allow GC of items)\n    this.iterations.length = 0;\n    this.iterationSummaries.length = 0;\n    this.auditTrail.length = 0;\n    this.metrics.errors.length = 0;\n\n    // Store summary after clearing (for final access if needed)\n    this.metadata.set('execution_summary', summary);\n  }\n\n  /**\n   * Get execution summary\n   */\n  getSummary() {\n    return {\n      executionId: this.executionId,\n      startTime: this.startTime,\n      currentIteration: this.iteration,\n      paused: this.paused,\n      cancelled: this.cancelled,\n      metrics: { ...this.metrics },\n      totalDuration: Date.now() - this.startTime.getTime(),\n    };\n  }\n}\n","/**\n * Hook manager - handles hook registration and execution\n * Includes error isolation, timeouts, and optional parallel execution\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport {\n  Hook,\n  HookConfig,\n  HookName,\n  HookSignatures,\n} from './types/HookTypes.js';\n\nexport class HookManager {\n  private hooks: Map<HookName, Hook<any, any>[]> = new Map();\n  private timeout: number;\n  private parallel: boolean;\n  // Per-hook error tracking: hookKey -> consecutive error count\n  private hookErrorCounts: Map<string, number> = new Map();\n  // Disabled hooks that exceeded error threshold\n  private disabledHooks: Set<string> = new Set();\n  private maxConsecutiveErrors: number = 3;\n  private emitter: EventEmitter;\n\n  constructor(\n    config: HookConfig = {},\n    emitter: EventEmitter,\n    errorHandling?: { maxConsecutiveErrors?: number }\n  ) {\n    this.timeout = config.hookTimeout || 5000; // 5 second default\n    this.parallel = config.parallelHooks || false;\n    this.emitter = emitter;\n    this.maxConsecutiveErrors = errorHandling?.maxConsecutiveErrors || 3;\n\n    // Register hooks from config\n    this.registerFromConfig(config);\n  }\n\n  /**\n   * Register hooks from configuration\n   */\n  private registerFromConfig(config: HookConfig): void {\n    const hookNames: HookName[] = [\n      'before:execution',\n      'after:execution',\n      'before:llm',\n      'after:llm',\n      'before:tool',\n      'after:tool',\n      'approve:tool',\n      'pause:check',\n    ];\n\n    for (const name of hookNames) {\n      const hook = config[name];\n      if (hook) {\n        this.register(name, hook);\n      }\n    }\n  }\n\n  /**\n   * Register a hook\n   */\n  register(name: HookName, hook: Hook<any, any>): void {\n    // Validate hook is a function\n    if (typeof hook !== 'function') {\n      throw new Error(`Hook must be a function, got: ${typeof hook}`);\n    }\n\n    // Get or create hooks array\n    if (!this.hooks.has(name)) {\n      this.hooks.set(name, []);\n    }\n\n    const existing = this.hooks.get(name)!;\n\n    // Limit number of hooks per name\n    if (existing.length >= 10) {\n      throw new Error(`Too many hooks for ${name} (max: 10)`);\n    }\n\n    existing.push(hook);\n  }\n\n  /**\n   * Execute hooks for a given name\n   */\n  async executeHooks<K extends HookName>(\n    name: K,\n    context: HookSignatures[K]['context'],\n    defaultResult: HookSignatures[K]['result']\n  ): Promise<HookSignatures[K]['result']> {\n    const hooks = this.hooks.get(name);\n\n    if (!hooks || hooks.length === 0) {\n      return defaultResult;\n    }\n\n    // Parallel execution (for independent hooks)\n    if (this.parallel && hooks.length > 1) {\n      return this.executeHooksParallel(hooks, context, defaultResult);\n    }\n\n    // Sequential execution (default)\n    return this.executeHooksSequential(hooks, context, defaultResult);\n  }\n\n  /**\n   * Execute hooks sequentially\n   */\n  private async executeHooksSequential<T>(\n    hooks: Hook<any, any>[],\n    context: any,\n    defaultResult: T\n  ): Promise<T> {\n    let result = defaultResult;\n\n    for (let i = 0; i < hooks.length; i++) {\n      const hook = hooks[i]!;\n      const hookKey = this.getHookKey(hook, i);\n      const hookResult = await this.executeHookSafely(hook, context, hookKey);\n\n      // Skip failed hooks\n      if (hookResult === null) {\n        continue;\n      }\n\n      // Merge hook result\n      result = { ...result, ...hookResult };\n\n      // Check for early exit\n      if ((hookResult as any).skip === true) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute hooks in parallel\n   */\n  private async executeHooksParallel<T>(\n    hooks: Hook<any, any>[],\n    context: any,\n    defaultResult: T\n  ): Promise<T> {\n    // Execute all hooks concurrently with unique keys\n    const results = await Promise.all(\n      hooks.map((hook, i) => {\n        const hookKey = this.getHookKey(hook, i);\n        return this.executeHookSafely(hook, context, hookKey);\n      })\n    );\n\n    // Filter out failures and merge results\n    const validResults = results.filter((r) => r !== null);\n\n    return validResults.reduce(\n      (acc, hookResult) => ({ ...acc, ...hookResult }),\n      defaultResult\n    );\n  }\n\n  /**\n   * Generate unique key for a hook\n   */\n  private getHookKey(hook: Hook<any, any>, index: number): string {\n    return `${hook.name || 'anonymous'}_${index}`;\n  }\n\n  /**\n   * Execute single hook with error isolation and timeout (with per-hook error tracking)\n   */\n  private async executeHookSafely<T>(\n    hook: Hook<any, any>,\n    context: any,\n    hookKey?: string\n  ): Promise<T | null> {\n    const key = hookKey || hook.name || 'anonymous';\n\n    // Skip disabled hooks\n    if (this.disabledHooks.has(key)) {\n      return null;\n    }\n\n    const startTime = Date.now();\n\n    try {\n      // Execute with timeout\n      const result = await Promise.race([\n        hook(context),\n        new Promise<never>((_, reject) =>\n          setTimeout(() => reject(new Error('Hook timeout')), this.timeout)\n        ),\n      ]);\n\n      // Reset error counter for this hook on success\n      this.hookErrorCounts.delete(key);\n\n      // Track timing\n      const duration = Date.now() - startTime;\n      if (context.context?.updateMetrics) {\n        context.context.updateMetrics({\n          hookDuration: (context.context.metrics.hookDuration || 0) + duration,\n        });\n      }\n\n      return result as T;\n    } catch (error) {\n      // Increment error counter for this specific hook\n      const errorCount = (this.hookErrorCounts.get(key) || 0) + 1;\n      this.hookErrorCounts.set(key, errorCount);\n\n      // Emit error event\n      this.emitter.emit('hook:error', {\n        executionId: context.executionId,\n        hookName: hook.name || 'anonymous',\n        error: error as Error,\n        consecutiveErrors: errorCount,\n        timestamp: new Date(),\n      });\n\n      // Check consecutive error threshold for this hook\n      if (errorCount >= this.maxConsecutiveErrors) {\n        // Disable this specific hook, not all hooks\n        this.disabledHooks.add(key);\n        console.warn(\n          `Hook \"${key}\" disabled after ${errorCount} consecutive failures. Last error: ${(error as Error).message}`\n        );\n      } else {\n        // Log warning but continue (degraded mode)\n        console.warn(\n          `Hook execution failed (${key}): ${(error as Error).message} (${errorCount}/${this.maxConsecutiveErrors} errors)`\n        );\n      }\n\n      return null; // Hook failed, skip its result\n    }\n  }\n\n  /**\n   * Check if there are any hooks registered\n   */\n  hasHooks(name: HookName): boolean {\n    const hooks = this.hooks.get(name);\n    return !!hooks && hooks.length > 0;\n  }\n\n  /**\n   * Get hook count\n   */\n  getHookCount(name?: HookName): number {\n    if (name) {\n      return this.hooks.get(name)?.length || 0;\n    }\n    // Total across all hooks\n    return Array.from(this.hooks.values()).reduce((sum, arr) => sum + arr.length, 0);\n  }\n\n  /**\n   * Clear all hooks and reset error tracking\n   */\n  clear(): void {\n    this.hooks.clear();\n    this.hookErrorCounts.clear();\n    this.disabledHooks.clear();\n  }\n\n  /**\n   * Re-enable a disabled hook\n   */\n  enableHook(hookKey: string): void {\n    this.disabledHooks.delete(hookKey);\n    this.hookErrorCounts.delete(hookKey);\n  }\n\n  /**\n   * Get list of disabled hooks\n   */\n  getDisabledHooks(): string[] {\n    return Array.from(this.disabledHooks);\n  }\n}\n","/**\n * Streaming event types for real-time LLM responses\n * Based on OpenAI Responses API event format as the internal standard\n */\n\nimport { TokenUsage } from './Response.js';\n\n/**\n * Stream event type enum\n */\nexport enum StreamEventType {\n  RESPONSE_CREATED = 'response.created',\n  RESPONSE_IN_PROGRESS = 'response.in_progress',\n  OUTPUT_TEXT_DELTA = 'response.output_text.delta',\n  OUTPUT_TEXT_DONE = 'response.output_text.done',\n  TOOL_CALL_START = 'response.tool_call.start',\n  TOOL_CALL_ARGUMENTS_DELTA = 'response.tool_call_arguments.delta',\n  TOOL_CALL_ARGUMENTS_DONE = 'response.tool_call_arguments.done',\n  TOOL_EXECUTION_START = 'response.tool_execution.start',\n  TOOL_EXECUTION_DONE = 'response.tool_execution.done',\n  ITERATION_COMPLETE = 'response.iteration.complete',\n  RESPONSE_COMPLETE = 'response.complete',\n  ERROR = 'response.error',\n}\n\n/**\n * Base interface for all stream events\n */\ninterface BaseStreamEvent {\n  type: StreamEventType;\n  response_id: string;\n}\n\n/**\n * Response created - first event in stream\n */\nexport interface ResponseCreatedEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_CREATED;\n  model: string;\n  created_at: number;\n}\n\n/**\n * Response in progress\n */\nexport interface ResponseInProgressEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_IN_PROGRESS;\n}\n\n/**\n * Text delta - incremental text output\n */\nexport interface OutputTextDeltaEvent extends BaseStreamEvent {\n  type: StreamEventType.OUTPUT_TEXT_DELTA;\n  item_id: string;\n  output_index: number;\n  content_index: number;\n  delta: string;\n  sequence_number: number;\n}\n\n/**\n * Text output complete for this item\n */\nexport interface OutputTextDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.OUTPUT_TEXT_DONE;\n  item_id: string;\n  output_index: number;\n  text: string; // Complete accumulated text\n}\n\n/**\n * Tool call detected and starting\n */\nexport interface ToolCallStartEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_START;\n  item_id: string;\n  tool_call_id: string;\n  tool_name: string;\n}\n\n/**\n * Tool call arguments delta - incremental JSON\n */\nexport interface ToolCallArgumentsDeltaEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_ARGUMENTS_DELTA;\n  item_id: string;\n  tool_call_id: string;\n  tool_name: string;\n  delta: string; // JSON chunk\n  sequence_number: number;\n}\n\n/**\n * Tool call arguments complete\n */\nexport interface ToolCallArgumentsDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_CALL_ARGUMENTS_DONE;\n  tool_call_id: string;\n  tool_name: string;\n  arguments: string; // Complete JSON string\n  incomplete?: boolean; // True if truncated by max_tokens\n}\n\n/**\n * Tool execution starting\n */\nexport interface ToolExecutionStartEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_EXECUTION_START;\n  tool_call_id: string;\n  tool_name: string;\n  arguments: any; // Parsed arguments\n}\n\n/**\n * Tool execution complete\n */\nexport interface ToolExecutionDoneEvent extends BaseStreamEvent {\n  type: StreamEventType.TOOL_EXECUTION_DONE;\n  tool_call_id: string;\n  tool_name: string;\n  result: any;\n  execution_time_ms: number;\n  error?: string; // If tool failed\n}\n\n/**\n * Iteration complete - end of agentic loop iteration\n */\nexport interface IterationCompleteEvent extends BaseStreamEvent {\n  type: StreamEventType.ITERATION_COMPLETE;\n  iteration: number;\n  tool_calls_count: number;\n  has_more_iterations: boolean;\n}\n\n/**\n * Response complete - final event\n */\nexport interface ResponseCompleteEvent extends BaseStreamEvent {\n  type: StreamEventType.RESPONSE_COMPLETE;\n  status: 'completed' | 'incomplete' | 'failed';\n  usage: TokenUsage;\n  iterations: number;\n  duration_ms?: number;\n}\n\n/**\n * Error event\n */\nexport interface ErrorEvent extends BaseStreamEvent {\n  type: StreamEventType.ERROR;\n  error: {\n    type: string;\n    message: string;\n    code?: string;\n  };\n  recoverable: boolean;\n}\n\n/**\n * Union type of all stream events\n * Discriminated by 'type' field for type narrowing\n */\nexport type StreamEvent =\n  | ResponseCreatedEvent\n  | ResponseInProgressEvent\n  | OutputTextDeltaEvent\n  | OutputTextDoneEvent\n  | ToolCallStartEvent\n  | ToolCallArgumentsDeltaEvent\n  | ToolCallArgumentsDoneEvent\n  | ToolExecutionStartEvent\n  | ToolExecutionDoneEvent\n  | IterationCompleteEvent\n  | ResponseCompleteEvent\n  | ErrorEvent;\n\n/**\n * Type guard to check if event is a specific type\n */\nexport function isStreamEvent<T extends StreamEvent>(\n  event: StreamEvent,\n  type: StreamEventType\n): event is T {\n  return event.type === type;\n}\n\n/**\n * Type guards for specific events\n */\nexport function isOutputTextDelta(event: StreamEvent): event is OutputTextDeltaEvent {\n  return event.type === StreamEventType.OUTPUT_TEXT_DELTA;\n}\n\nexport function isToolCallStart(event: StreamEvent): event is ToolCallStartEvent {\n  return event.type === StreamEventType.TOOL_CALL_START;\n}\n\nexport function isToolCallArgumentsDelta(\n  event: StreamEvent\n): event is ToolCallArgumentsDeltaEvent {\n  return event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DELTA;\n}\n\nexport function isToolCallArgumentsDone(\n  event: StreamEvent\n): event is ToolCallArgumentsDoneEvent {\n  return event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DONE;\n}\n\nexport function isResponseComplete(event: StreamEvent): event is ResponseCompleteEvent {\n  return event.type === StreamEventType.RESPONSE_COMPLETE;\n}\n\nexport function isErrorEvent(event: StreamEvent): event is ErrorEvent {\n  return event.type === StreamEventType.ERROR;\n}\n","/**\n * StreamState - Accumulates streaming events to reconstruct complete response\n */\n\nimport { TokenUsage } from './Response.js';\nimport { ToolCall } from './Tool.js';\n\n/**\n * Buffer for accumulating tool call arguments\n */\nexport interface ToolCallBuffer {\n  toolName: string;\n  argumentChunks: string[];\n  isComplete: boolean;\n  startTime: Date;\n}\n\n/**\n * StreamState tracks all accumulated data during streaming\n */\nexport class StreamState {\n  // Core identifiers\n  public responseId: string;\n  public model: string;\n  public createdAt: number;\n\n  // Text accumulation: item_id -> text chunks\n  private textBuffers: Map<string, string[]>;\n\n  // Tool call accumulation: tool_call_id -> buffer\n  private toolCallBuffers: Map<string, ToolCallBuffer>;\n\n  // Completed tool calls\n  private completedToolCalls: ToolCall[];\n\n  // Tool execution results\n  private toolResults: Map<string, any>;\n\n  // Metadata\n  public currentIteration: number;\n  public usage: TokenUsage;\n  public status: 'in_progress' | 'completed' | 'incomplete' | 'failed';\n  public startTime: Date;\n  public endTime?: Date;\n\n  // Statistics\n  public totalChunks: number;\n  public totalTextDeltas: number;\n  public totalToolCalls: number;\n\n  constructor(responseId: string, model: string, createdAt?: number) {\n    this.responseId = responseId;\n    this.model = model;\n    this.createdAt = createdAt || Date.now();\n\n    this.textBuffers = new Map();\n    this.toolCallBuffers = new Map();\n    this.completedToolCalls = [];\n    this.toolResults = new Map();\n\n    this.currentIteration = 0;\n    this.usage = {\n      input_tokens: 0,\n      output_tokens: 0,\n      total_tokens: 0,\n    };\n    this.status = 'in_progress';\n    this.startTime = new Date();\n\n    this.totalChunks = 0;\n    this.totalTextDeltas = 0;\n    this.totalToolCalls = 0;\n  }\n\n  /**\n   * Accumulate text delta for a specific item\n   */\n  accumulateTextDelta(itemId: string, delta: string): void {\n    if (!this.textBuffers.has(itemId)) {\n      this.textBuffers.set(itemId, []);\n    }\n    this.textBuffers.get(itemId)!.push(delta);\n    this.totalTextDeltas++;\n    this.totalChunks++;\n  }\n\n  /**\n   * Get complete accumulated text for an item\n   */\n  getCompleteText(itemId: string): string {\n    const chunks = this.textBuffers.get(itemId);\n    return chunks ? chunks.join('') : '';\n  }\n\n  /**\n   * Get all accumulated text (all items concatenated)\n   */\n  getAllText(): string {\n    const allText: string[] = [];\n    for (const chunks of this.textBuffers.values()) {\n      allText.push(chunks.join(''));\n    }\n    return allText.join('');\n  }\n\n  /**\n   * Start accumulating tool call arguments\n   */\n  startToolCall(toolCallId: string, toolName: string): void {\n    this.toolCallBuffers.set(toolCallId, {\n      toolName,\n      argumentChunks: [],\n      isComplete: false,\n      startTime: new Date(),\n    });\n  }\n\n  /**\n   * Accumulate tool argument delta\n   */\n  accumulateToolArguments(toolCallId: string, delta: string): void {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    buffer.argumentChunks.push(delta);\n    this.totalChunks++;\n  }\n\n  /**\n   * Mark tool call arguments as complete\n   */\n  completeToolCall(toolCallId: string): void {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    buffer.isComplete = true;\n    this.totalToolCalls++;\n  }\n\n  /**\n   * Get complete tool arguments (joined chunks)\n   */\n  getCompleteToolArguments(toolCallId: string): string {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    if (!buffer) {\n      throw new Error(`Tool call buffer not found for id: ${toolCallId}`);\n    }\n    return buffer.argumentChunks.join('');\n  }\n\n  /**\n   * Check if tool call is complete\n   */\n  isToolCallComplete(toolCallId: string): boolean {\n    const buffer = this.toolCallBuffers.get(toolCallId);\n    return buffer ? buffer.isComplete : false;\n  }\n\n  /**\n   * Get tool name for a tool call\n   */\n  getToolName(toolCallId: string): string | undefined {\n    return this.toolCallBuffers.get(toolCallId)?.toolName;\n  }\n\n  /**\n   * Add completed tool call\n   */\n  addCompletedToolCall(toolCall: ToolCall): void {\n    this.completedToolCalls.push(toolCall);\n  }\n\n  /**\n   * Get all completed tool calls\n   */\n  getCompletedToolCalls(): ToolCall[] {\n    return [...this.completedToolCalls];\n  }\n\n  /**\n   * Store tool execution result\n   */\n  setToolResult(toolCallId: string, result: any): void {\n    this.toolResults.set(toolCallId, result);\n  }\n\n  /**\n   * Get tool execution result\n   */\n  getToolResult(toolCallId: string): any {\n    return this.toolResults.get(toolCallId);\n  }\n\n  /**\n   * Update token usage (replaces values, doesn't accumulate)\n   */\n  updateUsage(usage: Partial<TokenUsage>): void {\n    if (usage.input_tokens !== undefined) {\n      this.usage.input_tokens = usage.input_tokens;\n    }\n    if (usage.output_tokens !== undefined) {\n      this.usage.output_tokens = usage.output_tokens;\n    }\n    if (usage.total_tokens !== undefined) {\n      this.usage.total_tokens = usage.total_tokens;\n    } else {\n      // Calculate total if not provided\n      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;\n    }\n  }\n\n  /**\n   * Accumulate token usage (adds to existing values)\n   */\n  accumulateUsage(usage: Partial<TokenUsage>): void {\n    if (usage.input_tokens !== undefined) {\n      this.usage.input_tokens += usage.input_tokens;\n    }\n    if (usage.output_tokens !== undefined) {\n      this.usage.output_tokens += usage.output_tokens;\n    }\n    if (usage.total_tokens !== undefined) {\n      this.usage.total_tokens += usage.total_tokens;\n    } else {\n      // Recalculate total\n      this.usage.total_tokens = this.usage.input_tokens + this.usage.output_tokens;\n    }\n  }\n\n  /**\n   * Mark stream as complete\n   */\n  markComplete(status: 'completed' | 'incomplete' | 'failed' = 'completed'): void {\n    this.status = status;\n    this.endTime = new Date();\n  }\n\n  /**\n   * Get duration in milliseconds\n   */\n  getDuration(): number {\n    const end = this.endTime || new Date();\n    return end.getTime() - this.startTime.getTime();\n  }\n\n  /**\n   * Increment iteration counter\n   */\n  incrementIteration(): void {\n    this.currentIteration++;\n  }\n\n  /**\n   * Get summary statistics\n   */\n  getStatistics() {\n    return {\n      responseId: this.responseId,\n      model: this.model,\n      status: this.status,\n      iterations: this.currentIteration,\n      totalChunks: this.totalChunks,\n      totalTextDeltas: this.totalTextDeltas,\n      totalToolCalls: this.totalToolCalls,\n      textItemsCount: this.textBuffers.size,\n      toolCallBuffersCount: this.toolCallBuffers.size,\n      completedToolCallsCount: this.completedToolCalls.length,\n      durationMs: this.getDuration(),\n      usage: { ...this.usage },\n    };\n  }\n\n  /**\n   * Check if stream has any accumulated text\n   */\n  hasText(): boolean {\n    return this.textBuffers.size > 0;\n  }\n\n  /**\n   * Check if stream has any tool calls\n   */\n  hasToolCalls(): boolean {\n    return this.toolCallBuffers.size > 0;\n  }\n\n  /**\n   * Clear all buffers (for memory management)\n   */\n  clear(): void {\n    this.textBuffers.clear();\n    this.toolCallBuffers.clear();\n    this.completedToolCalls = [];\n    this.toolResults.clear();\n  }\n\n  /**\n   * Create a snapshot for checkpointing (error recovery)\n   */\n  createSnapshot() {\n    return {\n      responseId: this.responseId,\n      model: this.model,\n      createdAt: this.createdAt,\n      textBuffers: new Map(this.textBuffers),\n      toolCallBuffers: new Map(this.toolCallBuffers),\n      completedToolCalls: [...this.completedToolCalls],\n      toolResults: new Map(this.toolResults),\n      currentIteration: this.currentIteration,\n      usage: { ...this.usage },\n      status: this.status,\n      startTime: this.startTime,\n      endTime: this.endTime,\n    };\n  }\n}\n","/**\n * Agentic loop - handles tool calling and multi-turn conversations\n * Now with events, hooks, pause/resume, and enterprise features\n */\n\nimport { randomUUID } from 'crypto';\nimport { EventEmitter } from 'eventemitter3';\nimport { ITextProvider, TextGenerateOptions } from '../../domain/interfaces/ITextProvider.js';\nimport { IToolExecutor } from '../../domain/interfaces/IToolExecutor.js';\nimport { AgentResponse } from '../../domain/entities/Response.js';\nimport { InputItem, MessageRole, OutputItem } from '../../domain/entities/Message.js';\nimport { Tool, ToolCall, ToolCallState, ToolResult } from '../../domain/entities/Tool.js';\nimport { ContentType, ToolResultContent } from '../../domain/entities/Content.js';\nimport { ToolTimeoutError } from '../../domain/errors/AIErrors.js';\nimport { ExecutionContext, HistoryMode } from './ExecutionContext.js';\nimport { HookManager } from './HookManager.js';\nimport { HookConfig } from './types/HookTypes.js';\nimport { AgenticLoopEvents } from './types/EventTypes.js';\nimport { StreamEvent, StreamEventType, isToolCallArgumentsDone } from '../../domain/entities/StreamEvent.js';\nimport { StreamState } from '../../domain/entities/StreamState.js';\nimport type { ToolPermissionManager } from '../../core/permissions/ToolPermissionManager.js';\nimport type { PermissionCheckContext } from '../../core/permissions/types.js';\nimport type { AgentContext } from '../../core/AgentContext.js';\n\nexport interface AgenticLoopConfig {\n  model: string;\n  input: string | InputItem[];\n  instructions?: string;\n  tools: Tool[];\n  temperature?: number;\n  maxIterations: number;\n  /** Vendor-specific options (e.g., Google's thinkingLevel) */\n  vendorOptions?: Record<string, any>;\n\n  // NEW: Enterprise configuration\n  hooks?: HookConfig;\n  historyMode?: HistoryMode;\n  limits?: {\n    maxExecutionTime?: number;\n    maxToolCalls?: number;\n    maxContextSize?: number;\n    /** Maximum input messages to keep (prevents unbounded growth). Default: 50 */\n    maxInputMessages?: number;\n  };\n  errorHandling?: {\n    hookFailureMode?: 'fail' | 'warn' | 'ignore';\n    /**\n     * Tool failure handling mode:\n     * - 'fail': Stop execution on first tool failure (throw error)\n     * - 'continue': Execute all tools even if some fail, return all results including errors\n     * @default 'continue'\n     */\n    toolFailureMode?: 'fail' | 'continue';\n    maxConsecutiveErrors?: number;\n  };\n\n  /**\n   * Tool execution timeout in milliseconds\n   * @default 30000 (30 seconds)\n   */\n  toolTimeout?: number;\n\n  /**\n   * Permission manager for tool approval/blocking.\n   * If provided, permission checks run BEFORE approve:tool hooks.\n   */\n  permissionManager?: ToolPermissionManager;\n\n  /**\n   * Agent type for permission context (used by TaskAgent/UniversalAgent).\n   * @default 'agent'\n   */\n  agentType?: 'agent' | 'task-agent' | 'universal-agent';\n\n  /**\n   * Current task name (used for TaskAgent/UniversalAgent context).\n   */\n  taskName?: string;\n\n  /**\n   * AgentContext for unified context management.\n   * When provided, AgenticLoop delegates ALL context management to AgentContext:\n   * - Uses prepareConversation() before each LLM call\n   * - Uses addAssistantResponse() and addToolResults() after each iteration\n   * - Skips internal sliding window (AgentContext handles compaction)\n   */\n  agentContext?: AgentContext;\n}\n\nexport class AgenticLoop extends EventEmitter<AgenticLoopEvents> {\n  private hookManager: HookManager;\n  private context: ExecutionContext | null = null;\n\n  // Pause/resume state\n  private paused: boolean = false;\n  private pausePromise: Promise<void> | null = null;\n  private resumeCallback: (() => void) | null = null;\n  private cancelled: boolean = false;\n  // Mutex to prevent race conditions in pause/resume\n  private pauseResumeMutex: Promise<void> = Promise.resolve();\n\n  constructor(\n    private provider: ITextProvider,\n    private toolExecutor: IToolExecutor,\n    hookConfig?: HookConfig,\n    errorHandling?: { maxConsecutiveErrors?: number }\n  ) {\n    super();\n    this.hookManager = new HookManager(\n      hookConfig || {},\n      this,\n      errorHandling\n    );\n  }\n\n  /**\n   * Execute agentic loop with tool calling\n   */\n  async execute(config: AgenticLoopConfig): Promise<AgentResponse> {\n    // Generate execution ID\n    const executionId = `exec_${randomUUID()}`;\n\n    // Create execution context\n    this.context = new ExecutionContext(executionId, {\n      maxHistorySize: 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: 1000,\n    });\n\n    // Reset state\n    this.paused = false;\n    this.cancelled = false;\n\n    // Determine if we're using AgentContext for context management\n    const useAgentContext = !!config.agentContext;\n    const agentContext = config.agentContext;\n\n    // If using AgentContext, add initial user message\n    if (useAgentContext && agentContext) {\n      if (typeof config.input === 'string') {\n        agentContext.addUserMessage(config.input);\n      } else if (Array.isArray(config.input)) {\n        agentContext.addInputItems(config.input);\n      }\n    }\n\n    // Emit execution start\n    this.emit('execution:start', {\n      executionId,\n      config,\n      timestamp: new Date(),\n    });\n\n    // Execute before:execution hook\n    await this.hookManager.executeHooks('before:execution', {\n      executionId,\n      config,\n      timestamp: new Date(),\n    }, undefined as any);\n\n    // Internal input tracking (only used when AgentContext is not provided)\n    let currentInput = config.input;\n    let iteration = 0;\n    let finalResponse: AgentResponse;\n\n    try {\n      while (iteration < config.maxIterations) {\n        // Check pause\n        await this.checkPause();\n\n        // Check if cancelled\n        if (this.cancelled) {\n          throw new Error('Execution cancelled');\n        }\n\n        // Check resource limits\n        this.context.checkLimits(config.limits);\n\n        // Check pause hook\n        const pauseCheck = await this.hookManager.executeHooks('pause:check', {\n          executionId,\n          iteration,\n          context: this.context,\n          timestamp: new Date(),\n        }, { shouldPause: false });\n\n        if (pauseCheck.shouldPause) {\n          this.pause(pauseCheck.reason || 'Hook requested pause');\n          await this.checkPause();\n        }\n\n        // Update iteration\n        this.context.iteration = iteration;\n\n        // Emit iteration start\n        this.emit('iteration:start', {\n          executionId,\n          iteration,\n          timestamp: new Date(),\n        });\n\n        const iterationStartTime = Date.now();\n\n        // Get input for LLM call\n        let llmInput: string | InputItem[];\n        if (useAgentContext && agentContext) {\n          // Use AgentContext for context management\n          const prepared = await agentContext.prepareConversation({\n            instructionOverride: config.instructions,\n          });\n          llmInput = prepared.input;\n        } else {\n          // Use internal context management\n          llmInput = currentInput;\n        }\n\n        // Generate LLM response\n        const response = await this.generateWithHooks(config, llmInput, iteration, executionId);\n\n        // Extract tool calls\n        const toolCalls = this.extractToolCalls(response.output, config.tools);\n\n        // Add assistant response to AgentContext\n        if (useAgentContext && agentContext) {\n          agentContext.addAssistantResponse(response.output);\n        }\n\n        // Emit tool detection\n        if (toolCalls.length > 0) {\n          this.emit('tool:detected', {\n            executionId,\n            iteration,\n            toolCalls,\n            timestamp: new Date(),\n          });\n        }\n\n        // If no tool calls, we're done\n        if (toolCalls.length === 0) {\n          // Emit iteration complete\n          this.emit('iteration:complete', {\n            executionId,\n            iteration,\n            response,\n            timestamp: new Date(),\n            duration: Date.now() - iterationStartTime,\n          });\n\n          finalResponse = response;\n          break;\n        }\n\n        // Execute tools with hooks\n        const toolResults = await this.executeToolsWithHooks(toolCalls, iteration, executionId, config);\n\n        // Add tool results to AgentContext\n        if (useAgentContext && agentContext) {\n          agentContext.addToolResults(toolResults);\n        }\n\n        // Store iteration record\n        this.context.addIteration({\n          iteration,\n          request: {\n            model: config.model,\n            input: useAgentContext ? llmInput : currentInput,\n            instructions: config.instructions,\n            tools: config.tools,\n            temperature: config.temperature,\n          },\n          response,\n          toolCalls,\n          toolResults,\n          startTime: new Date(iterationStartTime),\n          endTime: new Date(),\n        });\n\n        // Update metrics\n        this.context.updateMetrics({\n          iterationCount: iteration + 1,\n          inputTokens: this.context.metrics.inputTokens + (response.usage?.input_tokens || 0),\n          outputTokens: this.context.metrics.outputTokens + (response.usage?.output_tokens || 0),\n          totalTokens: this.context.metrics.totalTokens + (response.usage?.total_tokens || 0),\n        });\n\n        // Emit iteration complete\n        this.emit('iteration:complete', {\n          executionId,\n          iteration,\n          response,\n          timestamp: new Date(),\n          duration: Date.now() - iterationStartTime,\n        });\n\n        // Update input for next iteration (only if not using AgentContext)\n        if (!useAgentContext) {\n          // Build next input - append to existing context (preserve history)\n          const newMessages = this.buildNewMessages(response.output, toolResults);\n          currentInput = this.appendToContext(currentInput, newMessages);\n\n          // Apply sliding window to prevent unbounded input growth\n          const maxInputMessages = config.limits?.maxInputMessages ?? 50;\n          currentInput = this.applySlidingWindow(currentInput, maxInputMessages);\n        }\n\n        iteration++;\n      }\n\n      // Check if we exited normally or hit max iterations\n      if (iteration >= config.maxIterations) {\n        throw new Error(`Max iterations (${config.maxIterations}) reached without completion`);\n      }\n\n      // Calculate total duration\n      const totalDuration = Date.now() - this.context.startTime.getTime();\n      this.context.updateMetrics({ totalDuration });\n\n      // Execute after:execution hook\n      await this.hookManager.executeHooks('after:execution', {\n        executionId,\n        response: finalResponse!,\n        context: this.context,\n        timestamp: new Date(),\n        duration: totalDuration,\n      }, undefined as any);\n\n      // Emit execution complete\n      this.emit('execution:complete', {\n        executionId,\n        response: finalResponse!,\n        timestamp: new Date(),\n        duration: totalDuration,\n      });\n\n      return finalResponse!;\n    } catch (error) {\n      // Emit execution error\n      this.emit('execution:error', {\n        executionId,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      // Record error in metrics\n      this.context?.metrics.errors.push({\n        type: 'execution_error',\n        message: (error as Error).message,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    } finally {\n      // Always cleanup resources\n      this.context?.cleanup();\n      this.hookManager.clear();\n    }\n  }\n\n  /**\n   * Execute agentic loop with streaming and tool calling\n   */\n  async *executeStreaming(config: AgenticLoopConfig): AsyncIterableIterator<StreamEvent> {\n    // Generate execution ID\n    const executionId = `exec_${randomUUID()}`;\n\n    // Create execution context\n    this.context = new ExecutionContext(executionId, {\n      maxHistorySize: 10,\n      historyMode: config.historyMode || 'summary',\n      maxAuditTrailSize: 1000,\n    });\n\n    // Reset state\n    this.paused = false;\n    this.cancelled = false;\n    this.pausePromise = null;\n    this.resumeCallback = null;\n\n    // Determine if we're using AgentContext for context management\n    const useAgentContext = !!config.agentContext;\n    const agentContext = config.agentContext;\n\n    // If using AgentContext, add initial user message\n    if (useAgentContext && agentContext) {\n      if (typeof config.input === 'string') {\n        agentContext.addUserMessage(config.input);\n      } else if (Array.isArray(config.input)) {\n        agentContext.addInputItems(config.input);\n      }\n    }\n\n    const startTime = Date.now();\n    let iteration = 0;\n    let currentInput: string | InputItem[] = config.input;\n\n    // Create a single StreamState for the entire execution (tracks usage across iterations)\n    const globalStreamState = new StreamState(executionId, config.model);\n\n    try {\n      // Emit execution start event\n      this.emit('execution:start', {\n        executionId,\n        model: config.model,\n        timestamp: new Date(),\n      });\n\n      // Execute before:execution hook\n      await this.hookManager.executeHooks('before:execution', {\n        executionId,\n        config,\n        timestamp: new Date(),\n      }, undefined as any);\n\n      // Main agentic loop\n      while (iteration < config.maxIterations) {\n        iteration++;\n\n        // Check pause state\n        await this.checkPause();\n\n        // Check if cancelled\n        if (this.cancelled) {\n          this.emit('execution:cancelled', { executionId, iteration, timestamp: new Date() });\n          break;\n        }\n\n        // Check resource limits\n        if (this.context) {\n          this.context.checkLimits(config.limits);\n        }\n\n        // Execute pause:check hook (allows dynamic pause decisions)\n        const pauseCheck = await this.hookManager.executeHooks('pause:check', {\n          executionId,\n          iteration,\n          context: this.context!,\n          timestamp: new Date(),\n        }, { shouldPause: false });\n\n        if (pauseCheck.shouldPause) {\n          this.pause();\n        }\n\n        // Emit iteration start\n        this.emit('iteration:start', {\n          executionId,\n          iteration,\n          timestamp: new Date(),\n        });\n\n        // Get input for LLM call\n        let llmInput: string | InputItem[];\n        if (useAgentContext && agentContext) {\n          // Use AgentContext for context management\n          const prepared = await agentContext.prepareConversation({\n            instructionOverride: config.instructions,\n          });\n          llmInput = prepared.input;\n        } else {\n          // Use internal context management\n          llmInput = currentInput;\n        }\n\n        // Stream LLM response and accumulate state (per-iteration state)\n        const iterationStreamState = new StreamState(executionId, config.model);\n        const toolCallsMap = new Map<string, { name: string; args: string }>();\n\n        // Stream from provider with hooks\n        yield* this.streamGenerateWithHooks(config, llmInput, iteration, executionId, iterationStreamState, toolCallsMap);\n\n        // Accumulate usage from this iteration into global state\n        globalStreamState.accumulateUsage(iterationStreamState.usage);\n\n        // Check if any tool calls were detected\n        const toolCalls: ToolCall[] = [];\n        for (const [toolCallId, buffer] of toolCallsMap) {\n          toolCalls.push({\n            id: toolCallId,\n            type: 'function',\n            function: {\n              name: buffer.name,\n              arguments: buffer.args,\n            },\n            blocking: true,\n            state: ToolCallState.PENDING,\n          });\n        }\n\n        // No tool calls? We're done\n        if (toolCalls.length === 0) {\n          // Yield iteration complete\n          yield {\n            type: StreamEventType.ITERATION_COMPLETE,\n            response_id: executionId,\n            iteration,\n            tool_calls_count: 0,\n            has_more_iterations: false,\n          };\n\n          // Final response complete with accumulated usage from all iterations\n          yield {\n            type: StreamEventType.RESPONSE_COMPLETE,\n            response_id: executionId,\n            status: 'completed',\n            usage: globalStreamState.usage,\n            iterations: iteration,\n            duration_ms: Date.now() - startTime,\n          };\n\n          break;\n        }\n\n        // Execute tools and yield execution events\n        const toolResults: ToolResult[] = [];\n\n        for (const toolCall of toolCalls) {\n          // Parse and validate arguments\n          let parsedArgs: any;\n          try {\n            parsedArgs = JSON.parse(toolCall.function.arguments);\n          } catch (error) {\n            // Invalid JSON - skip this tool\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: null,\n              execution_time_ms: 0,\n              error: `Invalid tool arguments JSON: ${(error as Error).message}`,\n            };\n            continue;\n          }\n\n          // Emit tool execution start\n          yield {\n            type: StreamEventType.TOOL_EXECUTION_START,\n            response_id: executionId,\n            tool_call_id: toolCall.id,\n            tool_name: toolCall.function.name,\n            arguments: parsedArgs,\n          };\n\n          const toolStartTime = Date.now();\n\n          try {\n            // Execute tool with hooks\n            const result = await this.executeToolWithHooks(toolCall, iteration, executionId, config);\n            toolResults.push(result);\n\n            // Emit tool execution done\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: result.content,\n              execution_time_ms: Date.now() - toolStartTime,\n            };\n          } catch (error) {\n            // Emit tool execution error\n            yield {\n              type: StreamEventType.TOOL_EXECUTION_DONE,\n              response_id: executionId,\n              tool_call_id: toolCall.id,\n              tool_name: toolCall.function.name,\n              result: null,\n              execution_time_ms: Date.now() - toolStartTime,\n              error: (error as Error).message,\n            };\n\n            // Check tool failure mode - unified with execute() behavior\n            const failureMode = config.errorHandling?.toolFailureMode || 'continue';\n            if (failureMode === 'fail') {\n              throw error; // Fail-fast mode: stop execution on first tool failure\n            }\n\n            // Continue mode (default): Add error result and continue with remaining tools\n            toolResults.push({\n              tool_use_id: toolCall.id,\n              content: '',\n              error: (error as Error).message,\n              state: ToolCallState.FAILED,\n            });\n          }\n        }\n\n        // Build next input with tool results (streaming constructs messages from StreamState)\n        const assistantMessage: InputItem = {\n          type: 'message',\n          role: MessageRole.ASSISTANT,\n          content: [\n            {\n              type: ContentType.OUTPUT_TEXT,\n              text: iterationStreamState.getAllText(),\n            },\n            ...toolCalls.map((tc) => ({\n              type: ContentType.TOOL_USE as const,\n              id: tc.id,\n              name: tc.function.name,\n              arguments: tc.function.arguments,\n            })),\n          ],\n        };\n\n        const toolResultsMessage: InputItem = {\n          type: 'message',\n          role: MessageRole.USER,\n          content: toolResults.map((tr) => ({\n            type: ContentType.TOOL_RESULT as const,\n            tool_use_id: tr.tool_use_id,\n            content: tr.content,\n            error: tr.error,\n          })),\n        };\n\n        // Update context for next iteration\n        if (useAgentContext && agentContext) {\n          // Add assistant response to AgentContext\n          agentContext.addInputItems([assistantMessage]);\n          // Add tool results to AgentContext\n          agentContext.addToolResults(toolResults);\n        } else {\n          // Use internal context management\n          const newMessages: InputItem[] = [assistantMessage, toolResultsMessage];\n          currentInput = this.appendToContext(currentInput, newMessages);\n\n          // Apply sliding window to prevent unbounded input growth\n          const maxInputMessages = config.limits?.maxInputMessages ?? 50;\n          currentInput = this.applySlidingWindow(currentInput, maxInputMessages);\n        }\n\n        // Yield iteration complete\n        yield {\n          type: StreamEventType.ITERATION_COMPLETE,\n          response_id: executionId,\n          iteration,\n          tool_calls_count: toolCalls.length,\n          has_more_iterations: true,\n        };\n\n        // Store iteration in context\n        if (this.context) {\n          globalStreamState.incrementIteration();\n        }\n\n        // Clear per-iteration resources to prevent memory accumulation\n        iterationStreamState.clear();\n        toolCallsMap.clear();\n      }\n\n      // If loop ended due to max iterations (not early break), emit final completion\n      if (iteration >= config.maxIterations) {\n        yield {\n          type: StreamEventType.RESPONSE_COMPLETE,\n          response_id: executionId,\n          status: 'incomplete', // Incomplete because we hit max iterations\n          usage: globalStreamState.usage,\n          iterations: iteration,\n          duration_ms: Date.now() - startTime,\n        };\n      }\n\n      // Execute after:execution hook\n      await this.hookManager.executeHooks('after:execution', {\n        executionId,\n        response: null as any, // We don't have a complete response in streaming\n        context: this.context,\n        timestamp: new Date(),\n        duration: Date.now() - startTime,\n      }, undefined as any);\n\n      // Emit execution complete\n      this.emit('execution:complete', {\n        executionId,\n        iterations: iteration,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      // Emit execution error\n      this.emit('execution:error', {\n        executionId,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      // Yield error event\n      yield {\n        type: StreamEventType.ERROR,\n        response_id: executionId,\n        error: {\n          type: 'execution_error',\n          message: (error as Error).message,\n        },\n        recoverable: false,\n      };\n\n      throw error;\n    } finally {\n      // Always cleanup resources\n      globalStreamState.clear();\n      this.context?.cleanup();\n      this.hookManager.clear();\n    }\n  }\n\n  /**\n   * Stream LLM response with hooks\n   * @private\n   */\n  private async *streamGenerateWithHooks(\n    config: AgenticLoopConfig,\n    input: string | InputItem[],\n    iteration: number,\n    executionId: string,\n    streamState: StreamState,\n    toolCallsMap: Map<string, { name: string; args: string }>\n  ): AsyncIterableIterator<StreamEvent> {\n    const llmStartTime = Date.now();\n\n    // Prepare options\n    let generateOptions: TextGenerateOptions = {\n      model: config.model,\n      input,\n      instructions: config.instructions,\n      tools: config.tools,\n      tool_choice: 'auto',\n      temperature: config.temperature,\n      vendorOptions: config.vendorOptions,\n    };\n\n    // Execute before:llm hook\n    await this.hookManager.executeHooks('before:llm', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // Emit LLM request event\n    this.emit('llm:request', {\n      executionId,\n      iteration,\n      model: config.model,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Stream from provider\n      for await (const event of this.provider.streamGenerate(generateOptions)) {\n        // Update stream state based on event\n        if (event.type === StreamEventType.OUTPUT_TEXT_DELTA) {\n          streamState.accumulateTextDelta(event.item_id, event.delta);\n        } else if (event.type === StreamEventType.TOOL_CALL_START) {\n          streamState.startToolCall(event.tool_call_id, event.tool_name);\n          toolCallsMap.set(event.tool_call_id, { name: event.tool_name, args: '' });\n        } else if (event.type === StreamEventType.TOOL_CALL_ARGUMENTS_DELTA) {\n          streamState.accumulateToolArguments(event.tool_call_id, event.delta);\n          const buffer = toolCallsMap.get(event.tool_call_id);\n          if (buffer) {\n            buffer.args += event.delta;\n          }\n        } else if (isToolCallArgumentsDone(event)) {\n          streamState.completeToolCall(event.tool_call_id);\n          const buffer = toolCallsMap.get(event.tool_call_id);\n          if (buffer) {\n            buffer.args = event.arguments;\n          }\n        } else if (event.type === StreamEventType.RESPONSE_COMPLETE) {\n          streamState.updateUsage(event.usage);\n\n          if (process.env.DEBUG_STREAMING) {\n            console.error('[DEBUG] Captured usage from provider:', event.usage);\n            console.error('[DEBUG] StreamState usage after update:', streamState.usage);\n          }\n\n          // Don't yield provider's RESPONSE_COMPLETE - we'll emit our own at the end\n          continue;\n        }\n\n        // Yield event to caller (except RESPONSE_COMPLETE which we handle ourselves)\n        yield event;\n      }\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.llmDuration += Date.now() - llmStartTime;\n        this.context.metrics.inputTokens += streamState.usage.input_tokens;\n        this.context.metrics.outputTokens += streamState.usage.output_tokens;\n        this.context.metrics.totalTokens += streamState.usage.total_tokens;\n      }\n\n      if (process.env.DEBUG_STREAMING) {\n        console.error('[DEBUG] Stream iteration complete, usage:', streamState.usage);\n      }\n\n      // Execute after:llm hook\n      await this.hookManager.executeHooks('after:llm', {\n        executionId,\n        iteration,\n        response: null as any, // Streaming doesn't have complete response yet\n        context: this.context!,\n        timestamp: new Date(),\n        duration: Date.now() - llmStartTime,\n      }, {});\n\n      // Emit LLM response event\n      this.emit('llm:response', {\n        executionId,\n        iteration,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      this.emit('llm:error', {\n        executionId,\n        iteration,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check tool permission before execution\n   * Returns true if approved, throws if blocked/rejected\n   * @private\n   */\n  private async checkToolPermission(\n    toolCall: ToolCall,\n    iteration: number,\n    executionId: string,\n    config: AgenticLoopConfig\n  ): Promise<boolean> {\n    const permissionManager = config.permissionManager;\n    if (!permissionManager) {\n      // No permission manager - skip permission checks (backward compatible)\n      return true;\n    }\n\n    const toolName = toolCall.function.name;\n\n    // Check if blocked first\n    if (permissionManager.isBlocked(toolName)) {\n      this.context?.audit('tool_blocked', { reason: 'Tool is blocklisted' }, undefined, toolName);\n      throw new Error(`Tool \"${toolName}\" is blocked and cannot be executed`);\n    }\n\n    // Check if already approved (allowlisted or session-approved)\n    if (permissionManager.isApproved(toolName)) {\n      return true;\n    }\n\n    // Check if needs approval\n    const checkResult = permissionManager.checkPermission(toolName);\n    if (!checkResult.needsApproval) {\n      // Allowed without approval\n      return true;\n    }\n\n    // Parse arguments for context\n    let parsedArgs: Record<string, unknown> = {};\n    try {\n      parsedArgs = JSON.parse(toolCall.function.arguments);\n    } catch {\n      // Use empty args if parsing fails\n    }\n\n    // Build permission context\n    const context: PermissionCheckContext = {\n      toolCall,\n      parsedArgs,\n      config: checkResult.config || {},\n      executionId,\n      iteration,\n      agentType: config.agentType || 'agent',\n      taskName: config.taskName,\n    };\n\n    // Request approval via permission manager's callback\n    const decision = await permissionManager.requestApproval(context);\n\n    if (decision.approved) {\n      this.context?.audit('tool_permission_approved', {\n        scope: decision.scope,\n        approvedBy: decision.approvedBy,\n      }, undefined, toolName);\n      return true;\n    }\n\n    // Not approved - but might need external approval via hooks\n    // Return false to indicate hooks should be used\n    return false;\n  }\n\n  /**\n   * Execute single tool with hooks\n   * @private\n   */\n  private async executeToolWithHooks(\n    toolCall: ToolCall,\n    iteration: number,\n    executionId: string,\n    config: AgenticLoopConfig\n  ): Promise<ToolResult> {\n    const toolStartTime = Date.now();\n\n    toolCall.state = ToolCallState.EXECUTING;\n    toolCall.startTime = new Date();\n\n    // Execute before:tool hook\n    await this.hookManager.executeHooks('before:tool', {\n      executionId,\n      iteration,\n      toolCall,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // === NEW: Permission check (runs BEFORE approve:tool hooks) ===\n    // If permission manager exists and has an approval callback, use it first\n    const permissionApproved = await this.checkToolPermission(toolCall, iteration, executionId, config);\n\n    // Execute approve:tool hook if registered AND permission check didn't auto-approve\n    // (hooks provide additional approval logic beyond the permission system)\n    if (!permissionApproved || this.hookManager.hasHooks('approve:tool')) {\n      const approval = await this.hookManager.executeHooks('approve:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        context: this.context!,\n        timestamp: new Date(),\n      }, { approved: permissionApproved }); // Default to permission result\n\n      if (!approval.approved) {\n        throw new Error(`Tool execution rejected: ${approval.reason || 'No reason provided'}`);\n      }\n    }\n\n    // Emit tool start\n    this.emit('tool:start', {\n      executionId,\n      iteration,\n      toolCall,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Execute tool with timeout (configurable)\n      const args = JSON.parse(toolCall.function.arguments);\n      const result = await this.executeWithTimeout(\n        () => this.toolExecutor.execute(toolCall.function.name, args),\n        config.toolTimeout ?? 30000\n      );\n\n      // Create tool result\n      const toolResult: ToolResult = {\n        tool_use_id: toolCall.id,\n        content: result,\n        executionTime: Date.now() - toolStartTime,\n        state: ToolCallState.COMPLETED,\n      };\n\n      toolCall.state = ToolCallState.COMPLETED;\n      toolCall.endTime = new Date();\n\n      // Execute after:tool hook\n      await this.hookManager.executeHooks('after:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        result: toolResult,\n        context: this.context!,\n        timestamp: new Date(),\n      }, {});\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.toolCallCount++;\n        this.context.metrics.toolSuccessCount++;\n        this.context.metrics.toolDuration += toolResult.executionTime || 0;\n      }\n\n      // Emit tool complete\n      this.emit('tool:complete', {\n        executionId,\n        iteration,\n        toolCall,\n        result: toolResult,\n        timestamp: new Date(),\n      });\n\n      return toolResult;\n    } catch (error) {\n      toolCall.state = ToolCallState.FAILED;\n      toolCall.endTime = new Date();\n      toolCall.error = (error as Error).message;\n\n      // Update metrics\n      if (this.context) {\n        this.context.metrics.toolFailureCount++;\n      }\n\n      // Emit tool error\n      this.emit('tool:error', {\n        executionId,\n        iteration,\n        toolCall,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Generate LLM response with hooks\n   */\n  private async generateWithHooks(\n    config: AgenticLoopConfig,\n    input: string | InputItem[],\n    iteration: number,\n    executionId: string\n  ): Promise<AgentResponse> {\n    const llmStartTime = Date.now();\n\n    // Prepare options\n    let generateOptions: TextGenerateOptions = {\n      model: config.model,\n      input,\n      instructions: config.instructions,\n      tools: config.tools,\n      tool_choice: 'auto',\n      temperature: config.temperature,\n      vendorOptions: config.vendorOptions,\n    };\n\n    // Execute before:llm hook\n    const beforeLLM = await this.hookManager.executeHooks('before:llm', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      context: this.context!,\n      timestamp: new Date(),\n    }, {});\n\n    // Apply modifications\n    if (beforeLLM.modified) {\n      generateOptions = { ...generateOptions, ...beforeLLM.modified };\n    }\n\n    // Skip if requested\n    if (beforeLLM.skip) {\n      throw new Error('LLM call skipped by hook');\n    }\n\n    // Emit LLM request\n    this.emit('llm:request', {\n      executionId,\n      iteration,\n      options: generateOptions,\n      timestamp: new Date(),\n    });\n\n    try {\n      // Call provider\n      const response = await this.provider.generate(generateOptions);\n\n      const llmDuration = Date.now() - llmStartTime;\n\n      // Update metrics\n      this.context?.updateMetrics({\n        llmDuration: (this.context.metrics.llmDuration || 0) + llmDuration,\n      });\n\n      // Emit LLM response\n      this.emit('llm:response', {\n        executionId,\n        iteration,\n        response,\n        timestamp: new Date(),\n        duration: llmDuration,\n      });\n\n      // Execute after:llm hook\n      await this.hookManager.executeHooks('after:llm', {\n        executionId,\n        iteration,\n        response,\n        context: this.context!,\n        timestamp: new Date(),\n        duration: llmDuration,\n      }, {});\n\n      return response;\n    } catch (error) {\n      // Emit LLM error\n      this.emit('llm:error', {\n        executionId,\n        iteration,\n        error: error as Error,\n        timestamp: new Date(),\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute tools with hooks\n   */\n  private async executeToolsWithHooks(\n    toolCalls: ToolCall[],\n    iteration: number,\n    executionId: string,\n    config: AgenticLoopConfig\n  ): Promise<ToolResult[]> {\n    const results: ToolResult[] = [];\n\n    for (const toolCall of toolCalls) {\n      // Add to context\n      this.context?.addToolCall(toolCall);\n\n      // Check pause before each tool\n      await this.checkPause();\n\n      // Execute before:tool hook\n      const beforeTool = await this.hookManager.executeHooks('before:tool', {\n        executionId,\n        iteration,\n        toolCall,\n        context: this.context!,\n        timestamp: new Date(),\n      }, {});\n\n      // Check if tool should be skipped\n      if (beforeTool.skip) {\n        this.context?.audit('tool_skipped', { toolCall }, undefined, toolCall.function.name);\n\n        const mockResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: beforeTool.mockResult || '',\n          state: ToolCallState.COMPLETED,\n          executionTime: 0,\n        };\n\n        results.push(mockResult);\n        this.context?.addToolResult(mockResult);\n        continue;\n      }\n\n      // Apply modifications if any\n      if (beforeTool.modified) {\n        Object.assign(toolCall, beforeTool.modified);\n        this.context?.audit('tool_modified', { modifications: beforeTool.modified }, undefined, toolCall.function.name);\n      }\n\n      // === NEW: Permission check (runs BEFORE approve:tool hooks) ===\n      let permissionApproved = true;\n      try {\n        permissionApproved = await this.checkToolPermission(toolCall, iteration, executionId, config);\n      } catch (error) {\n        // Tool is blocked\n        this.context?.audit('tool_blocked', { reason: (error as Error).message }, undefined, toolCall.function.name);\n\n        const blockedResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: '',\n          error: (error as Error).message,\n          state: ToolCallState.FAILED,\n        };\n\n        results.push(blockedResult);\n        this.context?.addToolResult(blockedResult);\n        continue;\n      }\n\n      // Execute approve:tool hook (if exists AND permission check didn't auto-approve)\n      if (!permissionApproved || this.hookManager.hasHooks('approve:tool')) {\n        const approval = await this.hookManager.executeHooks('approve:tool', {\n          executionId,\n          iteration,\n          toolCall,\n          context: this.context!,\n          timestamp: new Date(),\n        }, { approved: permissionApproved }); // Default to permission result\n\n        if (!approval.approved) {\n          this.context?.audit('tool_rejected', { reason: approval.reason }, undefined, toolCall.function.name);\n\n          const rejectedResult: ToolResult = {\n            tool_use_id: toolCall.id,\n            content: '',\n            error: `Tool rejected: ${approval.reason || 'Not approved'}`,\n            state: ToolCallState.FAILED,\n          };\n\n          results.push(rejectedResult);\n          this.context?.addToolResult(rejectedResult);\n          continue;\n        }\n\n        this.context?.audit('tool_approved', { reason: approval.reason }, undefined, toolCall.function.name);\n      }\n\n      // Execute tool\n      toolCall.state = ToolCallState.EXECUTING;\n      toolCall.startTime = new Date();\n\n      // Emit tool start\n      this.emit('tool:start', {\n        executionId,\n        iteration,\n        toolCall,\n        timestamp: new Date(),\n      });\n\n      const toolStartTime = Date.now();\n\n      try {\n        // Execute with timeout (configurable)\n        const timeout = config.toolTimeout ?? 30000;\n        const result = await this.executeWithTimeout(\n          () => this.toolExecutor.execute(\n            toolCall.function.name,\n            JSON.parse(toolCall.function.arguments)\n          ),\n          timeout\n        );\n\n        toolCall.state = ToolCallState.COMPLETED;\n        toolCall.endTime = new Date();\n\n        let toolResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: result,\n          state: ToolCallState.COMPLETED,\n          executionTime: Date.now() - toolStartTime,\n        };\n\n        // Execute after:tool hook\n        const afterTool = await this.hookManager.executeHooks('after:tool', {\n          executionId,\n          iteration,\n          toolCall,\n          result: toolResult,\n          context: this.context!,\n          timestamp: new Date(),\n        }, {});\n\n        // Apply result modifications\n        if (afterTool.modified) {\n          toolResult = { ...toolResult, ...afterTool.modified };\n        }\n\n        results.push(toolResult);\n        this.context?.addToolResult(toolResult);\n\n        // Update metrics\n        this.context?.updateMetrics({\n          toolDuration: (this.context.metrics.toolDuration || 0) + toolResult.executionTime!,\n        });\n\n        // Emit tool complete\n        this.emit('tool:complete', {\n          executionId,\n          iteration,\n          toolCall,\n          result: toolResult,\n          timestamp: new Date(),\n        });\n      } catch (error) {\n        toolCall.state = ToolCallState.FAILED;\n        toolCall.endTime = new Date();\n        toolCall.error = (error as Error).message;\n\n        const toolResult: ToolResult = {\n          tool_use_id: toolCall.id,\n          content: '',\n          error: (error as Error).message,\n          state: ToolCallState.FAILED,\n        };\n\n        results.push(toolResult);\n        this.context?.addToolResult(toolResult);\n\n        // Record error\n        this.context?.metrics.errors.push({\n          type: 'tool_error',\n          message: (error as Error).message,\n          timestamp: new Date(),\n        });\n\n        // Emit tool error or timeout\n        if (error instanceof ToolTimeoutError) {\n          this.emit('tool:timeout', {\n            executionId,\n            iteration,\n            toolCall,\n            timeout: config.toolTimeout ?? 30000,\n            timestamp: new Date(),\n          });\n        } else {\n          this.emit('tool:error', {\n            executionId,\n            iteration,\n            toolCall,\n            error: error as Error,\n            timestamp: new Date(),\n          });\n        }\n\n        // Check tool failure mode\n        const failureMode = config.errorHandling?.toolFailureMode || 'continue';\n        if (failureMode === 'fail') {\n          // Fail-fast mode: stop execution on first tool failure\n          throw error;\n        }\n\n        // Continue mode (default): Continue executing remaining tools\n        // Error already added to results above\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Extract tool calls from response output\n   */\n  private extractToolCalls(output: OutputItem[], toolDefinitions: Tool[]): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n\n    // Create tool map for quick lookup\n    const toolMap = new Map<string, Tool>();\n    for (const tool of toolDefinitions) {\n      if (tool.type === 'function') {\n        toolMap.set(tool.function.name, tool);\n      }\n    }\n\n    // Extract tool calls from output\n    for (const item of output) {\n      if (item.type === 'message' && item.role === MessageRole.ASSISTANT) {\n        for (const content of item.content) {\n          if (content.type === ContentType.TOOL_USE) {\n            const toolDef = toolMap.get(content.name);\n            const isBlocking = toolDef?.blocking !== false;\n\n            const toolCall: ToolCall = {\n              id: content.id,\n              type: 'function',\n              function: {\n                name: content.name,\n                arguments: content.arguments,\n              },\n              blocking: isBlocking,\n              state: ToolCallState.PENDING,\n            };\n\n            toolCalls.push(toolCall);\n          }\n        }\n      }\n    }\n\n    return toolCalls;\n  }\n\n  /**\n   * Execute function with timeout\n   */\n  private async executeWithTimeout<T>(fn: () => Promise<T>, timeoutMs: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new ToolTimeoutError('tool', timeoutMs));\n      }, timeoutMs);\n\n      fn()\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((error) => {\n          clearTimeout(timer);\n          reject(error);\n        });\n    });\n  }\n\n  // ============ Shared Helper Methods ============\n  // These methods provide unified logic for both execute() and executeStreaming()\n\n  /**\n   * Build new messages from tool results (assistant response + tool results)\n   */\n  private buildNewMessages(\n    previousOutput: OutputItem[],\n    toolResults: ToolResult[]\n  ): InputItem[] {\n    const messages: InputItem[] = [];\n\n    // Add assistant's previous response as input\n    for (const item of previousOutput) {\n      if (item.type === 'message') {\n        messages.push(item);\n      }\n    }\n\n    // Add tool results as user message\n    const toolResultContents: ToolResultContent[] = toolResults.map((result) => ({\n      type: ContentType.TOOL_RESULT,\n      tool_use_id: result.tool_use_id,\n      content: result.content,\n      error: result.error,\n    }));\n\n    if (toolResultContents.length > 0) {\n      messages.push({\n        type: 'message',\n        role: MessageRole.USER,\n        content: toolResultContents,\n      });\n    }\n\n    return messages;\n  }\n\n  /**\n   * Append new messages to current context, preserving history\n   * Unified logic for both execute() and executeStreaming()\n   */\n  private appendToContext(\n    currentInput: string | InputItem[],\n    newMessages: InputItem[]\n  ): InputItem[] {\n    if (Array.isArray(currentInput)) {\n      return [...currentInput, ...newMessages];\n    }\n\n    // First iteration - convert string input to array format\n    return [\n      {\n        type: 'message' as const,\n        role: MessageRole.USER,\n        content: [{ type: ContentType.INPUT_TEXT, text: currentInput }],\n      },\n      ...newMessages,\n    ];\n  }\n\n  /**\n   * Apply sliding window to prevent unbounded input growth\n   * Preserves system/developer message at the start if present\n   * IMPORTANT: Ensures tool_use and tool_result pairs are never broken\n   */\n  private applySlidingWindow(\n    input: InputItem[],\n    maxMessages: number = 50\n  ): InputItem[] {\n    if (input.length <= maxMessages) {\n      return input;\n    }\n\n    // Check if first message is a developer/system message\n    const firstMessage = input[0];\n    const isSystemMessage = firstMessage?.type === 'message' &&\n      firstMessage.role === MessageRole.DEVELOPER;\n\n    // Calculate how many messages we can keep (excluding system message if present)\n    const maxToKeep = isSystemMessage ? maxMessages - 1 : maxMessages;\n\n    // Find a safe cut point that doesn't break tool call/result pairs\n    const safeCutIndex = this.findSafeToolBoundary(input, input.length - maxToKeep);\n\n    // Slice from safe cut point to end\n    const recentMessages = input.slice(safeCutIndex);\n\n    if (isSystemMessage) {\n      return [firstMessage, ...recentMessages];\n    }\n\n    return recentMessages;\n  }\n\n  /**\n   * Find a safe index to cut the message array without breaking tool call/result pairs\n   * A safe boundary is one where all tool_use IDs have matching tool_result IDs\n   */\n  private findSafeToolBoundary(input: InputItem[], targetIndex: number): number {\n    // Ensure we don't go below 0 or above the array length\n    let cutIndex = Math.max(0, Math.min(targetIndex, input.length - 1));\n\n    // Start from targetIndex and search forward for a safe boundary\n    // A safe boundary is where we don't have orphaned tool calls or results\n    while (cutIndex < input.length - 1) {\n      if (this.isToolBoundarySafe(input, cutIndex)) {\n        return cutIndex;\n      }\n      cutIndex++;\n    }\n\n    // If no safe boundary found going forward, try going backward\n    cutIndex = Math.max(0, targetIndex);\n    while (cutIndex > 0) {\n      if (this.isToolBoundarySafe(input, cutIndex)) {\n        return cutIndex;\n      }\n      cutIndex--;\n    }\n\n    // Fallback: return original target (may cause issues but better than infinite loop)\n    return Math.max(0, targetIndex);\n  }\n\n  /**\n   * Check if cutting at this index would leave tool calls/results balanced\n   * Returns true if all tool_use IDs in the slice have matching tool_result IDs\n   */\n  private isToolBoundarySafe(input: InputItem[], startIndex: number): boolean {\n    const slicedMessages = input.slice(startIndex);\n\n    // Collect all tool_use IDs and tool_result IDs in the slice\n    const toolUseIds = new Set<string>();\n    const toolResultIds = new Set<string>();\n\n    for (const item of slicedMessages) {\n      if (item.type !== 'message') continue;\n\n      for (const content of item.content) {\n        if (content.type === ContentType.TOOL_USE) {\n          toolUseIds.add(content.id);\n        } else if (content.type === ContentType.TOOL_RESULT) {\n          toolResultIds.add(content.tool_use_id);\n        }\n      }\n    }\n\n    // Check 1: Every tool_result must have a matching tool_use\n    // (tool_result without tool_use = API error)\n    for (const resultId of toolResultIds) {\n      if (!toolUseIds.has(resultId)) {\n        return false;\n      }\n    }\n\n    // Check 2: Every tool_use should have a matching tool_result\n    // (tool_use without tool_result = incomplete, but less critical for some APIs)\n    // However, for safety, we enforce this too\n    for (const useId of toolUseIds) {\n      if (!toolResultIds.has(useId)) {\n        // Exception: the LAST assistant message may have tool_use without result yet\n        // This is only safe if it's the very last message (current iteration)\n        const lastMessage = slicedMessages[slicedMessages.length - 1];\n        const isLastMessageWithThisToolUse =\n          lastMessage?.type === 'message' &&\n          lastMessage.role === MessageRole.ASSISTANT &&\n          lastMessage.content.some(\n            (c: any) => c.type === ContentType.TOOL_USE && c.id === useId\n          );\n\n        if (!isLastMessageWithThisToolUse) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Pause execution (thread-safe with mutex)\n   */\n  pause(reason?: string): void {\n    // Chain onto the mutex to ensure serialized access\n    this.pauseResumeMutex = this.pauseResumeMutex.then(() => {\n      this._doPause(reason);\n    });\n  }\n\n  /**\n   * Internal pause implementation\n   */\n  private _doPause(reason?: string): void {\n    if (this.paused) return;\n\n    this.paused = true;\n    this.pausePromise = new Promise((resolve) => {\n      this.resumeCallback = resolve;\n    });\n\n    if (this.context) {\n      this.context.paused = true;\n      this.context.pauseReason = reason;\n      this.context.audit('execution_paused', { reason });\n    }\n\n    this.emit('execution:paused', {\n      executionId: this.context?.executionId || 'unknown',\n      reason: reason || 'Manual pause',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Resume execution (thread-safe with mutex)\n   */\n  resume(): void {\n    // Chain onto the mutex to ensure serialized access\n    this.pauseResumeMutex = this.pauseResumeMutex.then(() => {\n      this._doResume();\n    });\n  }\n\n  /**\n   * Internal resume implementation\n   */\n  private _doResume(): void {\n    if (!this.paused) return;\n\n    this.paused = false;\n\n    if (this.context) {\n      this.context.paused = false;\n      this.context.pauseReason = undefined;\n      this.context.audit('execution_resumed', {});\n    }\n\n    if (this.resumeCallback) {\n      this.resumeCallback();\n      this.resumeCallback = null;\n    }\n\n    this.pausePromise = null;\n\n    this.emit('execution:resumed', {\n      executionId: this.context?.executionId || 'unknown',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Cancel execution\n   */\n  cancel(reason?: string): void {\n    this.cancelled = true;\n\n    if (this.context) {\n      this.context.cancelled = true;\n      this.context.cancelReason = reason;\n    }\n\n    // Resume if paused (to allow cancellation to proceed)\n    // Use internal method directly to bypass mutex for immediate cancellation\n    if (this.paused) {\n      this._doResume();\n    }\n\n    this.emit('execution:cancelled', {\n      executionId: this.context?.executionId || 'unknown',\n      reason: reason || 'Manual cancellation',\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Check if paused and wait\n   */\n  private async checkPause(): Promise<void> {\n    if (this.paused && this.pausePromise) {\n      await this.pausePromise;\n    }\n  }\n\n  /**\n   * Get current execution context\n   */\n  getContext(): ExecutionContext | null {\n    return this.context;\n  }\n\n  /**\n   * Check if currently executing\n   */\n  isRunning(): boolean {\n    return this.context !== null && !this.cancelled;\n  }\n\n  /**\n   * Check if paused\n   */\n  isPaused(): boolean {\n    return this.paused;\n  }\n\n  /**\n   * Check if cancelled\n   */\n  isCancelled(): boolean {\n    return this.cancelled;\n  }\n}\n"]}