{"version":3,"sources":["../../../src/domain/interfaces/IDisposable.ts","../../../src/capabilities/images/ImageManager.ts"],"names":[],"mappings":";AAiDO,SAAS,kBAAA,CAAmB,KAAqC,SAAA,EAAyB;AAC/F,EAAA,IAAI,IAAI,WAAA,EAAa;AACnB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,SAAS,CAAA,6BAAA,CAA+B,CAAA;AAAA,EACpE;AACF;;;ACtCO,IAAM,eAAN,MAA0C;AAAA,EAO/C,YAAoB,QAAA,EAA4B;AAA5B,IAAA,IAAA,CAAA,QAAA,GAAA,QAAA;AAAA,EAA6B;AAAA,EANzC,YAAA,GAAe,KAAA;AAAA,EAEvB,IAAI,WAAA,GAAuB;AACzB,IAAA,OAAO,IAAA,CAAK,YAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS,OAAA,EAAuD;AACpE,IAAA,kBAAA,CAAmB,MAAM,gBAAgB,CAAA;AAEzC,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,QAAA,CAAS,gBAAA,CAAiB,OAAA,CAAQ,KAAA,CAAM,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,QAAQ,CAAA;AAC7F,IAAA,OAAO,QAAA,CAAS,cAAc,OAAO,CAAA;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,OAAA,EAAmD;AAC5D,IAAA,kBAAA,CAAmB,MAAM,YAAY,CAAA;AAErC,IAAA,MAAM,eAAe,OAAA,CAAQ,KAAA,CAAM,MAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,QAAA;AACpD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,QAAA,CAAS,iBAAiB,YAAY,CAAA;AAElE,IAAA,IAAI,CAAC,SAAS,SAAA,EAAW;AACvB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,SAAA,EAAY,YAAY,CAAA,+BAAA,CAAiC,CAAA;AAAA,IAC3E;AAEA,IAAA,OAAO,QAAA,CAAS,UAAU,OAAO,CAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,OAAA,EAAwD;AAC5E,IAAA,kBAAA,CAAmB,MAAM,wBAAwB,CAAA;AAEjD,IAAA,MAAM,eAAe,OAAA,CAAQ,KAAA,CAAM,MAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,QAAA;AACpD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,QAAA,CAAS,iBAAiB,YAAY,CAAA;AAElE,IAAA,IAAI,CAAC,SAAS,eAAA,EAAiB;AAC7B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,SAAA,EAAY,YAAY,CAAA,kCAAA,CAAoC,CAAA;AAAA,IAC9E;AAEA,IAAA,OAAO,QAAA,CAAS,gBAAgB,OAAO,CAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAA,GAAgB;AACd,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA;AAAA,IACF;AACA,IAAA,IAAA,CAAK,YAAA,GAAe,IAAA;AAAA,EAGtB;AACF","file":"index.js","sourcesContent":["/**\n * Interface for objects that manage resources and need explicit cleanup.\n *\n * Implementing classes should release all resources (event listeners, timers,\n * connections, etc.) when destroy() is called. After destruction, the instance\n * should not be used.\n */\n\nexport interface IDisposable {\n  /**\n   * Releases all resources held by this instance.\n   *\n   * After calling destroy():\n   * - All event listeners should be removed\n   * - All timers/intervals should be cleared\n   * - All internal state should be cleaned up\n   * - The instance should not be reused\n   *\n   * Multiple calls to destroy() should be safe (idempotent).\n   */\n  destroy(): void;\n\n  /**\n   * Returns true if destroy() has been called.\n   * Methods should check this before performing operations.\n   */\n  readonly isDestroyed: boolean;\n}\n\n/**\n * Async version of IDisposable for resources requiring async cleanup.\n */\nexport interface IAsyncDisposable {\n  /**\n   * Asynchronously releases all resources held by this instance.\n   */\n  destroy(): Promise<void>;\n\n  /**\n   * Returns true if destroy() has been called.\n   */\n  readonly isDestroyed: boolean;\n}\n\n/**\n * Helper to check if an object is destroyed and throw if so.\n * @param obj - The disposable object to check\n * @param operation - Name of the operation being attempted\n */\nexport function assertNotDestroyed(obj: IDisposable | IAsyncDisposable, operation: string): void {\n  if (obj.isDestroyed) {\n    throw new Error(`Cannot ${operation}: instance has been destroyed`);\n  }\n}\n","/**\n * Image generation manager\n *\n * Implements IDisposable for proper resource cleanup\n */\n\nimport { ProviderRegistry } from '../../client/ProviderRegistry.js';\nimport { IDisposable, assertNotDestroyed } from '../../domain/interfaces/IDisposable.js';\nimport {\n  ImageGenerateOptions,\n  ImageEditOptions,\n  ImageVariationOptions,\n  ImageResponse,\n} from '../../domain/interfaces/IImageProvider.js';\n\nexport class ImageManager implements IDisposable {\n  private _isDestroyed = false;\n\n  get isDestroyed(): boolean {\n    return this._isDestroyed;\n  }\n\n  constructor(private registry: ProviderRegistry) {}\n\n  /**\n   * Generate images from text prompt\n   */\n  async generate(options: ImageGenerateOptions): Promise<ImageResponse> {\n    assertNotDestroyed(this, 'generate image');\n\n    const provider = await this.registry.getImageProvider(options.model.split('/')[0] || 'openai');\n    return provider.generateImage(options);\n  }\n\n  /**\n   * Edit an existing image\n   */\n  async edit(options: ImageEditOptions): Promise<ImageResponse> {\n    assertNotDestroyed(this, 'edit image');\n\n    const providerName = options.model.split('/')[0] || 'openai';\n    const provider = await this.registry.getImageProvider(providerName);\n\n    if (!provider.editImage) {\n      throw new Error(`Provider ${providerName} does not support image editing`);\n    }\n\n    return provider.editImage(options);\n  }\n\n  /**\n   * Create variations of an image\n   */\n  async createVariation(options: ImageVariationOptions): Promise<ImageResponse> {\n    assertNotDestroyed(this, 'create image variation');\n\n    const providerName = options.model.split('/')[0] || 'openai';\n    const provider = await this.registry.getImageProvider(providerName);\n\n    if (!provider.createVariation) {\n      throw new Error(`Provider ${providerName} does not support image variations`);\n    }\n\n    return provider.createVariation(options);\n  }\n\n  /**\n   * Destroy the manager and release resources\n   * Safe to call multiple times (idempotent)\n   */\n  destroy(): void {\n    if (this._isDestroyed) {\n      return;\n    }\n    this._isDestroyed = true;\n    // ImageManager has no internal resources to clean up\n    // but follows the IDisposable pattern for consistency\n  }\n}\n"]}